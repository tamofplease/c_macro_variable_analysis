<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/timescaledb/src/chunk.c"><comment type="block">/*
 * This file and its contents are licensed under the Apache License 2.0.
 * Please see the included NOTICE for copyright information and
 * LICENSE-APACHE for a copy of the license.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postgres.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/htup.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/htup_details.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/reloptions.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/tupdesc.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/xact.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/indexing.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/namespace.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_class.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_inherits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_trigger.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_type.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/toasting.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;commands/defrem.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;commands/tablecmds.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;commands/trigger.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;executor/executor.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fmgr.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;funcapi.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;miscadmin.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/execnodes.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/makefuncs.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;storage/lmgr.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;tcop/tcopprot.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/acl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/builtins.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/datum.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/hsearch.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/lsyscache.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/syscache.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/timestamp.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"chunk.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"bgw_policy/chunk_stats.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"chunk_index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"chunk_scan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compat/compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cross_module_fn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"debug_point.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dimension.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dimension_slice.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dimension_vector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"errors.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"export.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"extension.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hypercube.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hypertable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hypertable_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"partitioning.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"process_utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"scan_iterator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"scanner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"time_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ts_catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ts_catalog/chunk_data_node.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ts_catalog/compression_chunk_size.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ts_catalog/continuous_agg.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ts_catalog/hypertable_data_node.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils.h"</cpp:file></cpp:include>

<expr_stmt><expr><call><name>TS_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>ts_chunk_show_chunks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TS_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>ts_chunk_drop_chunks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TS_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>ts_chunk_drop_single_chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TS_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>ts_chunk_attach_osm_table_chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TS_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>ts_chunks_in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TS_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>ts_chunk_id_from_relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TS_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>ts_chunk_show</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TS_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>ts_chunk_create</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TS_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>ts_chunk_status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ts_chunk_add_status</name><parameter_list>(<parameter><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>status</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_GE</name></expr></cpp:if>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ts_chunk_clear_status</name><parameter_list>(<parameter><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>status</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>DatumGetNameString</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>datum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Name</name></type> <name>name</name> <init>= <expr><call><name>DatumGetName</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Used when processing scanned chunks */</comment>
<typedef>typedef <type><enum>enum <name>ChunkResult</name>
<block>{
	<decl><name>CHUNK_DONE</name></decl>,
	<decl><name>CHUNK_IGNORED</name></decl>,
	<decl><name>CHUNK_PROCESSED</name></decl>
}</block></enum></type> <name>ChunkResult</name>;</typedef>

<comment type="block">/*
 * Context for scanning and building a chunk from a stub.
 *
 * If found, the chunk will be created and the chunk pointer member is set in
 * the result. Optionally, a caller can pre-allocate the chunk member's memory,
 * which is useful if one, e.g., wants to fill in an memory-aligned array of
 * chunks.
 *
 * If the chunk is a tombstone (dropped flag set), then the Chunk will not be
 * created and instead is_dropped will be TRUE.
 */</comment>
<typedef>typedef <type><struct>struct <name>ChunkStubScanCtx</name>
<block>{
	<decl_stmt><decl><type><name>ChunkStub</name> <modifier>*</modifier></type><name>stub</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>is_dropped</name></decl>;</decl_stmt>
}</block></struct></type> <name>ChunkStubScanCtx</name>;</typedef>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>chunk_stub_is_valid</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ChunkStub</name> <modifier>*</modifier></type><name>stub</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>expected_slices</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>stub</name> <operator>&amp;&amp;</operator> <name><name>stub</name><operator>-&gt;</operator><name>id</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>stub</name><operator>-&gt;</operator><name>constraints</name></name> <operator>&amp;&amp;</operator> <name>expected_slices</name> <operator>==</operator> <name><name>stub</name><operator>-&gt;</operator><name>cube</name><operator>-&gt;</operator><name>num_slices</name></name> <operator>&amp;&amp;</operator>
		   <name><name>stub</name><operator>-&gt;</operator><name>cube</name><operator>-&gt;</operator><name>num_slices</name></name> <operator>==</operator> <name><name>stub</name><operator>-&gt;</operator><name>constraints</name><operator>-&gt;</operator><name>num_dimension_constraints</name></name></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <function_decl><type><name>ChunkResult</name></type> (<modifier>*</modifier><name>on_chunk_stub_func</name>)<parameter_list>(<parameter><decl><type><name>ChunkScanCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>ChunkStub</name> <modifier>*</modifier></type><name>stub</name></decl></parameter>)</parameter_list>;</function_decl></typedef>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>chunk_scan_ctx_init</name><parameter_list>(<parameter><decl><type><name>ChunkScanCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Hyperspace</name> <modifier>*</modifier></type><name>hs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Point</name> <modifier>*</modifier></type><name>point</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>chunk_scan_ctx_destroy</name><parameter_list>(<parameter><decl><type><name>ChunkScanCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>chunk_collision_scan</name><parameter_list>(<parameter><decl><type><name>ChunkScanCtx</name> <modifier>*</modifier></type><name>scanctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Hypercube</name> <modifier>*</modifier></type><name>cube</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>chunk_scan_ctx_foreach_chunk_stub</name><parameter_list>(<parameter><decl><type><name>ChunkScanCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>on_chunk_stub_func</name></type> <name>on_chunk</name></decl></parameter>,
											 <parameter><decl><type><name>uint16</name></type> <name>limit</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>chunks_return_srf</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>chunk_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>ch1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>ch2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>chunk_point_find_chunk_id</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Point</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>init_scan_by_qualified_table_name</name><parameter_list>(<parameter><decl><type><name>ScanIterator</name> <modifier>*</modifier></type><name>iterator</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>schema_name</name></decl></parameter>,
											  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>table_name</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Hypertable</name> <modifier>*</modifier></type><name>find_hypertable_from_table_or_cagg</name><parameter_list>(<parameter><decl><type><name>Cache</name> <modifier>*</modifier></type><name>hcache</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>allow_matht</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Chunk</name> <modifier>*</modifier></type><name>get_chunks_in_time_range</name><parameter_list>(<parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>older_than</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>newer_than</name></decl></parameter>,
									   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>caller_name</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>mctx</name></decl></parameter>,
									   <parameter><decl><type><name>uint64</name> <modifier>*</modifier></type><name>num_chunks_returned</name></decl></parameter>, <parameter><decl><type><name>ScanTupLock</name> <modifier>*</modifier></type><name>tuplock</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Chunk</name> <modifier>*</modifier></type><name>chunk_resurrect</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>chunk_id</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * The chunk status field values are persisted in the database and must never be changed.
 * Those values are used as flags and must always be powers of 2 to allow bitwise operations.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHUNK_STATUS_DEFAULT</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<comment type="block">/*
 * Setting a Data-Node chunk as CHUNK_STATUS_COMPRESSED means that the corresponding
 * compressed_chunk_id field points to a chunk that holds the compressed data. Otherwise,
 * the corresponding compressed_chunk_id is NULL.
 *
 * However, for Access-Nodes compressed_chunk_id is always NULL. CHUNK_STATUS_COMPRESSED being set
 * means that a remote compress_chunk() operation has taken place for this distributed
 * meta-chunk. On the other hand, if CHUNK_STATUS_COMPRESSED is cleared, then it is probable
 * that a remote compress_chunk() has not taken place, but not certain.
 *
 * For the above reason, this flag should not be assumed to be consistent (when it is cleared)
 * for Access-Nodes. When used in distributed hypertables one should take advantage of the
 * idempotent properties of remote compress_chunk() and distributed compression policy to
 * make progress.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHUNK_STATUS_COMPRESSED</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<comment type="block">/*
 * When inserting into a compressed chunk the configured compress_orderby is not retained.
 * Any such chunks need an explicit Sort step to produce ordered output until the chunk
 * ordering has been restored by recompress_chunk. This flag can only exist on compressed
 * chunks.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHUNK_STATUS_COMPRESSED_UNORDERED</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<comment type="block">/*
 * A chunk is in frozen state (i.e no inserts/updates/deletes into this chunk are
 * permitted. Other chunk level operations like dropping chunk etc. are also blocked.
 *
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHUNK_STATUS_FROZEN</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>
<comment type="block">/*
 * A chunk is in this state when it is compressed but also has uncompressed tuples
 * in the uncompressed chunk.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHUNK_STATUS_COMPRESSED_PARTIAL</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>HeapTuple</name></type>
<name>chunk_formdata_make_tuple</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FormData_chunk</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>desc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type> <name><name>values</name><index>[<expr><name>Natts_chunk</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name><name>nulls</name><index>[<expr><name>Natts_chunk</name></expr>]</index></name> <init>= <expr><block>{ <expr><name>false</name></expr> }</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>Natts_chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_chunk_id</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>fd</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_chunk_hypertable_id</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>fd</name><operator>-&gt;</operator><name>hypertable_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_chunk_schema_name</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <call><name>NameGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fd</name><operator>-&gt;</operator><name>schema_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_chunk_table_name</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <call><name>NameGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fd</name><operator>-&gt;</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*when we insert a chunk the compressed chunk id is always NULL */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fd</name><operator>-&gt;</operator><name>compressed_chunk_id</name></name> <operator>==</operator> <name>INVALID_CHUNK_ID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_chunk_compressed_chunk_id</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_chunk_compressed_chunk_id</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
			<call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>fd</name><operator>-&gt;</operator><name>compressed_chunk_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_chunk_dropped</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>fd</name><operator>-&gt;</operator><name>dropped</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_chunk_status</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>fd</name><operator>-&gt;</operator><name>status</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_chunk_osm_chunk</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>fd</name><operator>-&gt;</operator><name>osm_chunk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ts_chunk_formdata_fill</name><parameter_list>(<parameter><decl><type><name>FormData_chunk</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>should_free</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name> <init>= <expr><call><name>ts_scanner_fetch_heap_tuple</name><argument_list>(<argument><expr><name>ti</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>should_free</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name><name>nulls</name><index>[<expr><name>Natts_chunk</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name><name>values</name><index>[<expr><name>Natts_chunk</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FormData_chunk</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><call><name>ts_scanner_get_tupledesc</name><argument_list>(<argument><expr><name>ti</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>nulls</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_chunk_id</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>nulls</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_chunk_hypertable_id</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>nulls</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_chunk_schema_name</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>nulls</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_chunk_table_name</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>nulls</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_chunk_dropped</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>nulls</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_chunk_status</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>nulls</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_chunk_osm_chunk</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_chunk_id</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>hypertable_id</name></name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_chunk_hypertable_id</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fd</name><operator>-&gt;</operator><name>schema_name</name></name></expr></argument>,
		   <argument><expr><call><name>DatumGetName</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_chunk_schema_name</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fd</name><operator>-&gt;</operator><name>table_name</name></name></expr></argument>,
		   <argument><expr><call><name>DatumGetName</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_chunk_table_name</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>nulls</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_chunk_compressed_chunk_id</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>compressed_chunk_id</name></name> <operator>=</operator> <name>INVALID_CHUNK_ID</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>compressed_chunk_id</name></name> <operator>=</operator>
			<call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_chunk_compressed_chunk_id</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>dropped</name></name> <operator>=</operator> <call><name>DatumGetBool</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_chunk_dropped</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_chunk_status</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>osm_chunk</name></name> <operator>=</operator> <call><name>DatumGetBool</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_chunk_osm_chunk</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>should_free</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>int64</name></type>
<name>ts_chunk_primary_dimension_start</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>chunk</name><operator>-&gt;</operator><name>cube</name><operator>-&gt;</operator><name>slices</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>fd</name><operator>.</operator><name>range_start</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int64</name></type>
<name>ts_chunk_primary_dimension_end</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>chunk</name><operator>-&gt;</operator><name>cube</name><operator>-&gt;</operator><name>slices</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>fd</name><operator>.</operator><name>range_end</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>chunk_insert_relation</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>new_tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CatalogSecurityContext</name></type> <name>sec_ctx</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>new_tuple</name> <operator>=</operator> <call><name>chunk_formdata_make_tuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>chunk</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ts_catalog_database_info_become_owner</name><argument_list>(<argument><expr><call><name>ts_catalog_database_info_get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_catalog_insert</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>new_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_catalog_restore_user</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>new_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ts_chunk_insert_lock</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Catalog</name> <modifier>*</modifier></type><name>catalog</name> <init>= <expr><call><name>ts_catalog_get</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><call><name>catalog_get_table_id</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>CHUNK</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>chunk_insert_relation</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <name>CollisionInfo</name>
<block>{
	<decl_stmt><decl><type><name>Hypercube</name> <modifier>*</modifier></type><name>cube</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ChunkStub</name> <modifier>*</modifier></type><name>colliding_chunk</name></decl>;</decl_stmt>
}</block></struct></type> <name>CollisionInfo</name>;</typedef>

<comment type="block">/*-
 * Align a chunk's hypercube in 'aligned' dimensions.
 *
 * Alignment ensures that chunks line up in a particular dimension, i.e., their
 * ranges should either be identical or not overlap at all.
 *
 * Non-aligned:
 *
 * ' [---------]      &lt;- existing slice
 * '      [---------] &lt;- calculated (new) slice
 *
 * To align the slices above there are two cases depending on where the
 * insertion point happens:
 *
 * Case 1 (reuse slice):
 *
 * ' [---------]
 * '      [--x------]
 *
 * The insertion point x falls within the range of the existing slice. We should
 * reuse the existing slice rather than creating a new one.
 *
 * Case 2 (cut to align):
 *
 * ' [---------]
 * '      [-------x-]
 *
 * The insertion point falls outside the range of the existing slice and we need
 * to cut the new slice to line up.
 *
 * ' [---------]
 * '        cut [---]
 * '
 *
 * Note that slice reuse (case 1) happens already when calculating the tentative
 * hypercube for the chunk, and is thus already performed once reaching this
 * function. Thus, we deal only with case 2 here. Also note that a new slice
 * might overlap in complicated ways, requiring multiple cuts. For instance,
 * consider the following situation:
 *
 * ' [------]   [-] [---]
 * '      [---x-------]  &lt;- calculated slice
 *
 * This should but cut-to-align as follows:
 *
 * ' [------]   [-] [---]
 * '         [x]
 *
 * After a chunk collision scan, this function is called for each chunk in the
 * chunk scan context. Chunks in the scan context may have only a partial set of
 * slices if they only overlap in some, but not all, dimensions (see
 * illustrations below). Still, partial chunks may still be of interest for
 * alignment in a particular dimension. Thus, if a chunk has an overlapping
 * slice in an aligned dimension, we cut to not overlap with that slice.
 */</comment>
<function><type><specifier>static</specifier> <name>ChunkResult</name></type>
<name>do_dimension_alignment</name><parameter_list>(<parameter><decl><type><name>ChunkScanCtx</name> <modifier>*</modifier></type><name>scanctx</name></decl></parameter>, <parameter><decl><type><name>ChunkStub</name> <modifier>*</modifier></type><name>stub</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CollisionInfo</name> <modifier>*</modifier></type><name>info</name> <init>= <expr><name><name>scanctx</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Hypercube</name> <modifier>*</modifier></type><name>cube</name> <init>= <expr><name><name>info</name><operator>-&gt;</operator><name>cube</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>Hyperspace</name> <modifier>*</modifier></type><name>space</name> <init>= <expr><name><name>scanctx</name><operator>-&gt;</operator><name>space</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ChunkResult</name></type> <name>res</name> <init>= <expr><name>CHUNK_IGNORED</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>space</name><operator>-&gt;</operator><name>num_dimensions</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type><name>dim</name> <init>= <expr><operator>&amp;</operator><name><name>space</name><operator>-&gt;</operator><name>dimensions</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>DimensionSlice</name> <modifier>*</modifier></type><name>chunk_slice</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DimensionSlice</name> <modifier>*</modifier></type><name>cube_slice</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int64</name></type> <name>coord</name> <init>= <expr><name><name>scanctx</name><operator>-&gt;</operator><name>point</name><operator>-&gt;</operator><name>coordinates</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>aligned</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * The stub might not have a slice for each dimension, so we cannot
		 * use array indexing. Fetch slice by dimension ID instead.
		 */</comment>
		<expr_stmt><expr><name>chunk_slice</name> <operator>=</operator> <call><name>ts_hypercube_get_slice_by_dimension_id</name><argument_list>(<argument><expr><name><name>stub</name><operator>-&gt;</operator><name>cube</name></name></expr></argument>, <argument><expr><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>chunk_slice</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>cube_slice</name> <operator>=</operator> <name><name>cube</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Only cut-to-align if the slices collide and are not identical
		 * (i.e., if we are reusing an existing slice we should not cut it)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ts_dimension_slices_equal</name><argument_list>(<argument><expr><name>cube_slice</name></expr></argument>, <argument><expr><name>chunk_slice</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>ts_dimension_slices_collide</name><argument_list>(<argument><expr><name>cube_slice</name></expr></argument>, <argument><expr><name>chunk_slice</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ts_dimension_slice_cut</name><argument_list>(<argument><expr><name>cube_slice</name></expr></argument>, <argument><expr><name>chunk_slice</name></expr></argument>, <argument><expr><name>coord</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <name>CHUNK_PROCESSED</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Calculate, and potentially set, a new chunk interval for an open dimension.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>calculate_and_set_new_chunk_interval</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Point</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Hyperspace</name> <modifier>*</modifier></type><name>hs</name> <init>= <expr><name><name>ht</name><operator>-&gt;</operator><name>space</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Dimension</name> <modifier>*</modifier></type><name>dim</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>datum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>chunk_interval</name></decl>, <decl><type ref="prev"/><name>coord</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>chunk_sizing_func</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>chunk_target_size</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Find first open dimension */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>hs</name><operator>-&gt;</operator><name>num_dimensions</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>dim</name> <operator>=</operator> <operator>&amp;</operator><name><name>hs</name><operator>-&gt;</operator><name>dimensions</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IS_OPEN_DIMENSION</name><argument_list>(<argument><expr><name>dim</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>dim</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Nothing to do if no open dimension */</comment>
	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>dim</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
			 <argument><expr><literal type="string">"adaptive chunking enabled on hypertable \"%s\" without an open (time) dimension"</literal></expr></argument>,
			 <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>coord</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>coordinates</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>OidFunctionCall3</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>chunk_sizing_func</name></name></expr></argument>,
							 <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>coord</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>chunk_target_size</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>chunk_interval</name> <operator>=</operator> <call><name>DatumGetInt64</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check if the function didn't set and interval or nothing changed */</comment>
	<if_stmt><if>if <condition>(<expr><name>chunk_interval</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>chunk_interval</name> <operator>==</operator> <name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>interval_length</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Update the dimension */</comment>
	<expr_stmt><expr><call><name>ts_dimension_set_chunk_interval</name><argument_list>(<argument><expr><name>dim</name></expr></argument>, <argument><expr><name>chunk_interval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Resolve chunk collisions.
 *
 * After a chunk collision scan, this function is called for each chunk in the
 * chunk scan context. We only care about chunks that have a full set of
 * slices/constraints that overlap with our tentative hypercube, i.e., they
 * fully collide. We resolve those collisions by cutting the hypercube.
 */</comment>
<function><type><specifier>static</specifier> <name>ChunkResult</name></type>
<name>do_collision_resolution</name><parameter_list>(<parameter><decl><type><name>ChunkScanCtx</name> <modifier>*</modifier></type><name>scanctx</name></decl></parameter>, <parameter><decl><type><name>ChunkStub</name> <modifier>*</modifier></type><name>stub</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CollisionInfo</name> <modifier>*</modifier></type><name>info</name> <init>= <expr><name><name>scanctx</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Hypercube</name> <modifier>*</modifier></type><name>cube</name> <init>= <expr><name><name>info</name><operator>-&gt;</operator><name>cube</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>Hyperspace</name> <modifier>*</modifier></type><name>space</name> <init>= <expr><name><name>scanctx</name><operator>-&gt;</operator><name>space</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ChunkResult</name></type> <name>res</name> <init>= <expr><name>CHUNK_IGNORED</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stub</name><operator>-&gt;</operator><name>cube</name><operator>-&gt;</operator><name>num_slices</name></name> <operator>!=</operator> <name><name>space</name><operator>-&gt;</operator><name>num_dimensions</name></name> <operator>||</operator> <operator>!</operator><call><name>ts_hypercubes_collide</name><argument_list>(<argument><expr><name>cube</name></expr></argument>, <argument><expr><name><name>stub</name><operator>-&gt;</operator><name>cube</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>CHUNK_IGNORED</name></expr>;</return></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>space</name><operator>-&gt;</operator><name>num_dimensions</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DimensionSlice</name> <modifier>*</modifier></type><name>cube_slice</name> <init>= <expr><name><name>cube</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DimensionSlice</name> <modifier>*</modifier></type><name>chunk_slice</name> <init>= <expr><name><name>stub</name><operator>-&gt;</operator><name>cube</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int64</name></type> <name>coord</name> <init>= <expr><name><name>scanctx</name><operator>-&gt;</operator><name>point</name><operator>-&gt;</operator><name>coordinates</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Only cut if we aren't reusing an existing slice and there is a
		 * collision
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ts_dimension_slices_equal</name><argument_list>(<argument><expr><name>cube_slice</name></expr></argument>, <argument><expr><name>chunk_slice</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>ts_dimension_slices_collide</name><argument_list>(<argument><expr><name>cube_slice</name></expr></argument>, <argument><expr><name>chunk_slice</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ts_dimension_slice_cut</name><argument_list>(<argument><expr><name>cube_slice</name></expr></argument>, <argument><expr><name>chunk_slice</name></expr></argument>, <argument><expr><name>coord</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <name>CHUNK_PROCESSED</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Redo the collision check after each cut since cutting in one
			 * dimension might have resolved the collision in another
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ts_hypercubes_collide</name><argument_list>(<argument><expr><name>cube</name></expr></argument>, <argument><expr><name><name>stub</name><operator>-&gt;</operator><name>cube</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ts_hypercubes_collide</name><argument_list>(<argument><expr><name>cube</name></expr></argument>, <argument><expr><name><name>stub</name><operator>-&gt;</operator><name>cube</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ChunkResult</name></type>
<name>check_for_collisions</name><parameter_list>(<parameter><decl><type><name>ChunkScanCtx</name> <modifier>*</modifier></type><name>scanctx</name></decl></parameter>, <parameter><decl><type><name>ChunkStub</name> <modifier>*</modifier></type><name>stub</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CollisionInfo</name> <modifier>*</modifier></type><name>info</name> <init>= <expr><name><name>scanctx</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Hypercube</name> <modifier>*</modifier></type><name>cube</name> <init>= <expr><name><name>info</name><operator>-&gt;</operator><name>cube</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>Hyperspace</name> <modifier>*</modifier></type><name>space</name> <init>= <expr><name><name>scanctx</name><operator>-&gt;</operator><name>space</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Check if this chunk collides with our hypercube */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stub</name><operator>-&gt;</operator><name>cube</name><operator>-&gt;</operator><name>num_slices</name></name> <operator>==</operator> <name><name>space</name><operator>-&gt;</operator><name>num_dimensions</name></name> <operator>&amp;&amp;</operator> <call><name>ts_hypercubes_collide</name><argument_list>(<argument><expr><name>cube</name></expr></argument>, <argument><expr><name><name>stub</name><operator>-&gt;</operator><name>cube</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>colliding_chunk</name></name> <operator>=</operator> <name>stub</name></expr>;</expr_stmt>
		<return>return <expr><name>CHUNK_DONE</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>CHUNK_IGNORED</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check if a (tentative) chunk collides with existing chunks.
 *
 * Return the colliding chunk. Note that the chunk is a stub and not a full
 * chunk.
 */</comment>
<function><type><specifier>static</specifier> <name>ChunkStub</name> <modifier>*</modifier></type>
<name>chunk_collides</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Hypercube</name> <modifier>*</modifier></type><name>hc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ChunkScanCtx</name></type> <name>scanctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CollisionInfo</name></type> <name>info</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>cube</name> <operator>=</operator> <operator>(</operator><name>Hypercube</name> <operator>*</operator><operator>)</operator> <name>hc</name></expr>,
		<expr><operator>.</operator><name>colliding_chunk</name> <operator>=</operator> <name>NULL</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>chunk_scan_ctx_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scanctx</name></expr></argument>, <argument><expr><name><name>ht</name><operator>-&gt;</operator><name>space</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Scan for all chunks that collide with the hypercube of the new chunk */</comment>
	<expr_stmt><expr><call><name>chunk_collision_scan</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scanctx</name></expr></argument>, <argument><expr><name>hc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanctx</name><operator>.</operator><name>data</name></name> <operator>=</operator> <operator>&amp;</operator><name>info</name></expr>;</expr_stmt>

	<comment type="block">/* Find chunks that collide */</comment>
	<expr_stmt><expr><call><name>chunk_scan_ctx_foreach_chunk_stub</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scanctx</name></expr></argument>, <argument><expr><name>check_for_collisions</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>chunk_scan_ctx_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scanctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>info</name><operator>.</operator><name>colliding_chunk</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*-
 * Resolve collisions and perform alignmment.
 *
 * Chunks collide only if their hypercubes overlap in all dimensions. For
 * instance, the 2D chunks below collide because they overlap in both the X and
 * Y dimensions:
 *
 * ' _____
 * ' |    |
 * ' | ___|__
 * ' |_|__|  |
 * '   |     |
 * '   |_____|
 *
 * While the following chunks do not collide, although they still overlap in the
 * X dimension:
 *
 * ' _____
 * ' |    |
 * ' |    |
 * ' |____|
 * '   ______
 * '   |     |
 * '   |    *|
 * '   |_____|
 *
 * For the collision case above we obviously want to cut our hypercube to no
 * longer collide with existing chunks. However, the second case might still be
 * of interest for alignment in case X is an 'aligned' dimension. If '*' is the
 * insertion point, then we still want to cut the hypercube to ensure that the
 * dimension remains aligned, like so:
 *
 * ' _____
 * ' |    |
 * ' |    |
 * ' |____|
 * '       ___
 * '       | |
 * '       |*|
 * '       |_|
 *
 *
 * We perform alignment first as that might actually resolve chunk
 * collisions. After alignment we check for any remaining collisions.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>chunk_collision_resolve</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>Hypercube</name> <modifier>*</modifier></type><name>cube</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Point</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ChunkScanCtx</name></type> <name>scanctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CollisionInfo</name></type> <name>info</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>cube</name> <operator>=</operator> <name>cube</name></expr>,
		<expr><operator>.</operator><name>colliding_chunk</name> <operator>=</operator> <name>NULL</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>chunk_scan_ctx_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scanctx</name></expr></argument>, <argument><expr><name><name>ht</name><operator>-&gt;</operator><name>space</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Scan for all chunks that collide with the hypercube of the new chunk */</comment>
	<expr_stmt><expr><call><name>chunk_collision_scan</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scanctx</name></expr></argument>, <argument><expr><name>cube</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanctx</name><operator>.</operator><name>data</name></name> <operator>=</operator> <operator>&amp;</operator><name>info</name></expr>;</expr_stmt>

	<comment type="block">/* Cut the hypercube in any aligned dimensions */</comment>
	<expr_stmt><expr><call><name>chunk_scan_ctx_foreach_chunk_stub</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scanctx</name></expr></argument>, <argument><expr><name>do_dimension_alignment</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If there are any remaining collisions with chunks, then cut-to-fit to
	 * resolve those collisions
	 */</comment>
	<expr_stmt><expr><call><name>chunk_scan_ctx_foreach_chunk_stub</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scanctx</name></expr></argument>, <argument><expr><name>do_collision_resolution</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>chunk_scan_ctx_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scanctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>chunk_add_constraints</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>num_added</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>num_added</name> <operator>=</operator> <call><name>ts_chunk_constraints_add_dimension_constraints</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>constraints</name></name></expr></argument>,
															   <argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>,
															   <argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>cube</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>num_added</name> <operator>+=</operator> <call><name>ts_chunk_constraints_add_inheritable_constraints</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>constraints</name></name></expr></argument>,
																  <argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>,
																  <argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>relkind</name></name></expr></argument>,
																  <argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>hypertable_relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>num_added</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* applies the attributes and statistics target for columns on the hypertable
   to columns on the chunk */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_attoptions</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>ht_rel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>chunk_oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>ht_rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>natts</name> <init>= <expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>attno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>alter_cmds</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>attno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>attno</name> <operator>&lt;=</operator> <name>natts</name></expr>;</condition> <incr><expr><name>attno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attribute</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>attno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>attributeName</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type> <name>options</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>isnull</name></decl>;</decl_stmt>

		<comment type="block">/* Ignore dropped */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>attribute</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheAttName</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>ht_rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attributeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tuple</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Pass down the attribute options (ALTER TABLE ALTER COLUMN SET
		 * attribute_option)
		 */</comment>
		<expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>ATTNAME</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pg_attribute_attoptions</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>AlterTableCmd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>=</operator> <name>AT_SetOptions</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>attributeName</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>untransformRelOptions</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>alter_cmds</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>alter_cmds</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Pass down the attribute options (ALTER TABLE ALTER COLUMN SET
		 * STATISTICS)
		 */</comment>
		<expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>ATTNAME</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pg_attribute_attstattarget</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int32</name></type> <name>target</name> <init>= <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* Don't do anything if it's set to the default */</comment>
			<if_stmt><if>if <condition>(<expr><name>target</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>AlterTableCmd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>=</operator> <name>AT_SetStatistics</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>attributeName</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeInteger</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>alter_cmds</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>alter_cmds</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>alter_cmds</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ts_alter_table_with_event_trigger</name><argument_list>(<argument><expr><name>chunk_oid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>alter_cmds</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>list_free_deep</name><argument_list>(<argument><expr><name>alter_cmds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>create_toast_table</name><parameter_list>(<parameter><decl><type><name>CreateStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>chunk_oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* similar to tcop/utility.c */</comment>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name><name>validnsps</name><index>[]</index></name> <init>= <expr><name>HEAP_RELOPT_NAMESPACES</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>toast_options</name> <init>=
		<expr><call><name>transformRelOptions</name><argument_list>(<argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>, <argument><expr><literal type="string">"toast"</literal></expr></argument>, <argument><expr><name>validnsps</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>heap_reloptions</name><argument_list>(<argument><expr><name>RELKIND_TOASTVALUE</name></expr></argument>, <argument><expr><name>toast_options</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>NewRelationCreateToastTable</name><argument_list>(<argument><expr><name>chunk_oid</name></expr></argument>, <argument><expr><name>toast_options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get the access method name for a relation.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_am_name_for_rel</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>cform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>amoid</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>cform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>amoid</name> <operator>=</operator> <name><name>cform</name><operator>-&gt;</operator><name>relam</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>get_am_name</name><argument_list>(<argument><expr><name>amoid</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>copy_hypertable_acl_to_relid</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Oid</name></type> <name>owner_id</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ts_copy_relation_acl</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>, <argument><expr><name>relid</name></expr></argument>, <argument><expr><name>owner_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Create a chunk's table.
 *
 * A chunk inherits from the main hypertable and will have the same owner. Since
 * chunks can be created either in the TimescaleDB internal schema or in a
 * user-specified schema, some care has to be taken to use the right
 * permissions, depending on the case:
 *
 * 1. if the chunk is created in the internal schema, we create it as the
 * catalog/schema owner (i.e., anyone can create chunks there via inserting into
 * a hypertable, but can not do it via CREATE TABLE).
 *
 * 2. if the chunk is created in a user-specified "associated schema", then we
 * shouldn't use the catalog owner to create the table since that typically
 * implies super-user permissions. If we would allow that, anyone can specify
 * someone else's schema in create_hypertable() and create chunks in it without
 * having the proper permissions to do so. With this logic, the hypertable owner
 * must have permissions to create tables in the associated schema, or else
 * table creation will fail. If the schema doesn't yet exist, the table owner
 * instead needs the proper permissions on the database to create the schema.
 */</comment>
<function><type><name>Oid</name></type>
<name>ts_chunk_create_table</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tablespacename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>objaddr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>sec_ctx</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * The CreateForeignTableStmt embeds a regular CreateStmt, so we can use
	 * it to create both regular and foreign tables
	 */</comment>
	<decl_stmt><decl><type><name>CreateForeignTableStmt</name></type> <name>stmt</name> <init>= <expr><block>{
		<expr><operator>.</operator><name><name>base</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>T_CreateStmt</name></expr>,
		<expr><operator>.</operator><name><name>base</name><operator>.</operator><name>relation</name></name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>schema_name</name></name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name><name>base</name><operator>.</operator><name>inhRelations</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeRangeVar</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>schema_name</name></name></expr></argument>)</argument_list></call></expr></argument>,
													 <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr></argument>,
													 <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name><name>base</name><operator>.</operator><name>tablespacename</name></name> <operator>=</operator> <name>tablespacename</name> <operator>?</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>tablespacename</name> <operator>:</operator> <name>NULL</name></expr>,
		<comment type="block">/* Propagate storage options of the main table to a regular chunk
		 * table, but avoid using it for a foreign chunk table. */</comment>
		<expr><operator>.</operator><name><name>base</name><operator>.</operator><name>options</name></name> <operator>=</operator>
			<operator>(</operator><name><name>chunk</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name><operator>)</operator> <operator>?</operator> <call><name>ts_get_reloptions</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>)</argument_list></call> <operator>:</operator> <name>NIL</name></expr>,
		<expr><operator>.</operator><name><name>base</name><operator>.</operator><name>accessMethod</name></name> <operator>=</operator> <operator>(</operator><name><name>chunk</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name><operator>)</operator> <operator>?</operator>
								 <call><name>get_am_name_for_rel</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>hypertable_relid</name></name></expr></argument>)</argument_list></call> <operator>:</operator>
								 <name>NULL</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>uid</name></decl>, <decl><type ref="prev"/><name>saved_uid</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>hypertable_relid</name></name> <operator>==</operator> <name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the chunk is created in the internal schema, become the catalog
	 * owner, otherwise become the hypertable owner
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>namestrcmp</name><argument_list>(<argument><expr><operator>(</operator><name>Name</name><operator>)</operator> <operator>&amp;</operator><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>schema_name</name></name></expr></argument>, <argument><expr><name>INTERNAL_SCHEMA_NAME</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>uid</name> <operator>=</operator> <call><name>ts_catalog_database_info_get</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>owner_uid</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>uid</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relowner</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>GetUserIdAndSecContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>saved_uid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>uid</name> <operator>!=</operator> <name>saved_uid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SetUserIdAndSecContext</name><argument_list>(<argument><expr><name>uid</name></expr></argument>, <argument><expr><name>sec_ctx</name> <operator>|</operator> <name>SECURITY_LOCAL_USERID_CHANGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>objaddr</name> <operator>=</operator> <call><name>DefineRelation</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>stmt</name><operator>.</operator><name>base</name></name></expr></argument>, <argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>relkind</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relowner</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make the newly defined relation visible so that we can update the
	 * ACL. */</comment>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Copy acl from hypertable to chunk relation record */</comment>
	<expr_stmt><expr><call><name>copy_hypertable_acl_to_relid</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relowner</name></name></expr></argument>, <argument><expr><name><name>objaddr</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>chunk</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * need to create a toast table explicitly for some of the option
		 * setting to work
		 */</comment>
		<expr_stmt><expr><call><name>create_toast_table</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>stmt</name><operator>.</operator><name>base</name></name></expr></argument>, <argument><expr><name><name>objaddr</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Some options require being table owner to set for example statistics
		 * so we have to set them before restoring security context
		 */</comment>
		<expr_stmt><expr><call><name>set_attoptions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>objaddr</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>uid</name> <operator>!=</operator> <name>saved_uid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>SetUserIdAndSecContext</name><argument_list>(<argument><expr><name>saved_uid</name></expr></argument>, <argument><expr><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>chunk</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ChunkDataNode</name> <modifier>*</modifier></type><name>cdn</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>data_nodes</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TS_INSUFFICIENT_NUM_DATA_NODES</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no data nodes associated with chunk \"%s\""</literal></expr></argument>,
							 <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>table_id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Use the first chunk data node as the "primary" to put in the foreign
		 * table
		 */</comment>
		<expr_stmt><expr><name>cdn</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>data_nodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stmt</name><operator>.</operator><name>base</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>T_CreateForeignServerStmt</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stmt</name><operator>.</operator><name>servername</name></name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>cdn</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>node_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Create the foreign table catalog information */</comment>
		<expr_stmt><expr><call><name>CreateForeignTable</name><argument_list>(<argument><expr><operator>&amp;</operator><name>stmt</name></expr></argument>, <argument><expr><name><name>objaddr</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Some options require being table owner to set for example statistics
		 * so we have to set them before restoring security context
		 */</comment>
		<expr_stmt><expr><call><name>set_attoptions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>objaddr</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Need to restore security context to execute remote commands as the
		 * original user
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>uid</name> <operator>!=</operator> <name>saved_uid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>SetUserIdAndSecContext</name><argument_list>(<argument><expr><name>saved_uid</name></expr></argument>, <argument><expr><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Create the corresponding chunk replicas on the remote data nodes */</comment>
		<expr_stmt><expr><call><name><name>ts_cm_functions</name><operator>-&gt;</operator><name>create_chunk_on_data_nodes</name></name><argument_list>(<argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>ht</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Record the remote data node chunk ID mappings */</comment>
		<expr_stmt><expr><call><name>ts_chunk_data_node_insert_multi</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>data_nodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid relkind \"%c\" when creating chunk"</literal></expr></argument>, <argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>relkind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>objaddr</name><operator>.</operator><name>objectId</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>chunk_assign_data_nodes</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>htnodes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>chunk_data_nodes</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>chunk</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ht</name><operator>-&gt;</operator><name>data_nodes</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TS_INSUFFICIENT_NUM_DATA_NODES</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no data nodes associated with hypertable \"%s\""</literal></expr></argument>,
						 <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>cube</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>htnodes</name> <operator>=</operator> <call><name>ts_hypertable_assign_chunk_data_nodes</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>cube</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>htnodes</name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>htnodes</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dn</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ForeignServer</name> <modifier>*</modifier></type><name>foreign_server</name> <init>= <expr><call><name>GetForeignServerByName</name><argument_list>(<argument><expr><name>dn</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ChunkDataNode</name> <modifier>*</modifier></type><name>chunk_data_node</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ChunkDataNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Create a stub data node (partially filled in entry). This will be
		 * fully filled in and persisted to metadata tables once we create the
		 * remote tables during insert
		 */</comment>
		<expr_stmt><expr><name><name>chunk_data_node</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>chunk_id</name></name> <operator>=</operator> <name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>chunk_data_node</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>node_chunk_id</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>chunk_data_node</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>node_name</name></name></expr></argument>, <argument><expr><name><name>foreign_server</name><operator>-&gt;</operator><name>servername</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>chunk_data_node</name><operator>-&gt;</operator><name>foreign_server_oid</name></name> <operator>=</operator> <name><name>foreign_server</name><operator>-&gt;</operator><name>serverid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>chunk_data_nodes</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>chunk_data_nodes</name></expr></argument>, <argument><expr><name>chunk_data_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>chunk_data_nodes</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>List</name> <modifier>*</modifier></type>
<name>ts_chunk_get_data_node_name_list</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>datanodes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>chunk-&gt;data_nodes</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ChunkDataNode</name> <modifier>*</modifier></type><name>cdn</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>datanodes</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>datanodes</name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>cdn</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>node_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>datanodes</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ts_chunk_has_data_node</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>node_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ChunkDataNode</name> <modifier>*</modifier></type><name>cdn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>chunk</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>node_name</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* check that the chunk is indeed present on the specified data node */</comment>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>chunk-&gt;data_nodes</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>cdn</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>namestrcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cdn</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>node_name</name></name></expr></argument>, <argument><expr><name>node_name</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>found</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32</name></type>
<name>get_next_chunk_id</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type> <name>chunk_id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CatalogSecurityContext</name></type> <name>sec_ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>Catalog</name> <modifier>*</modifier></type><name>catalog</name> <init>= <expr><call><name>ts_catalog_get</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ts_catalog_database_info_become_owner</name><argument_list>(<argument><expr><call><name>ts_catalog_database_info_get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>chunk_id</name> <operator>=</operator> <call><name>ts_catalog_table_next_seq_id</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>CHUNK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_catalog_restore_user</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>chunk_id</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Create a chunk object from the dimensional constraints in the given hypercube.
 *
 * The chunk object is then used to create the actual chunk table and update the
 * metadata separately.
 *
 * The table name for the chunk can be given explicitly, or generated if
 * table_name is NULL. If the table name is generated, it will use the given
 * prefix or, if NULL, use the hypertable's associated table prefix. Similarly,
 * if schema_name is NULL it will use the hypertable's associated schema for
 * the chunk.
 */</comment>
<function><type><specifier>static</specifier> <name>Chunk</name> <modifier>*</modifier></type>
<name>chunk_create_object</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>Hypercube</name> <modifier>*</modifier></type><name>cube</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>schema_name</name></decl></parameter>,
					<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>table_name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>chunk_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>Hyperspace</name> <modifier>*</modifier></type><name>hs</name> <init>= <expr><name><name>ht</name><operator>-&gt;</operator><name>space</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name>relkind</name> <init>= <expr><call><name>hypertable_chunk_relkind</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>schema_name</name> <operator>||</operator> <name><name>schema_name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>schema_name</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>associated_schema_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Create a new chunk based on the hypercube */</comment>
	<expr_stmt><expr><name>chunk</name> <operator>=</operator> <call><name>ts_chunk_create_base</name><argument_list>(<argument><expr><name>chunk_id</name></expr></argument>, <argument><expr><name><name>hs</name><operator>-&gt;</operator><name>num_dimensions</name></name></expr></argument>, <argument><expr><name>relkind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>hypertable_id</name></name> <operator>=</operator> <name><name>hs</name><operator>-&gt;</operator><name>hypertable_id</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>chunk</name><operator>-&gt;</operator><name>cube</name></name> <operator>=</operator> <name>cube</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>chunk</name><operator>-&gt;</operator><name>hypertable_relid</name></name> <operator>=</operator> <name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>schema_name</name></name></expr></argument>, <argument><expr><name>schema_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>table_name</name> <operator>||</operator> <name><name>table_name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>prefix</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>prefix</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>associated_table_prefix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>table_name</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>, <argument><expr><literal type="string">"%s_%d_chunk"</literal></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;=</operator> <name>NAMEDATALEN</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"chunk table name too long"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>table_name</name></name></expr></argument>, <argument><expr><name>table_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>chunk</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>chunk</name><operator>-&gt;</operator><name>data_nodes</name></name> <operator>=</operator> <call><name>chunk_assign_data_nodes</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>chunk</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>chunk_insert_into_metadata_after_lock</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Insert chunk */</comment>
	<expr_stmt><expr><call><name>ts_chunk_insert_lock</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Add metadata for dimensional and inheritable constraints */</comment>
	<expr_stmt><expr><call><name>ts_chunk_constraints_insert_metadata</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>constraints</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>chunk_create_table_constraints</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Create the chunk's constraints, triggers, and indexes */</comment>
	<expr_stmt><expr><call><name>ts_chunk_constraints_create</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>constraints</name></name></expr></argument>,
								<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>table_id</name></name></expr></argument>,
								<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>,
								<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>hypertable_relid</name></name></expr></argument>,
								<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>hypertable_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>chunk</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IS_OSM_CHUNK</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ts_trigger_create_all_on_chunk</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ts_chunk_index_create_all</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>hypertable_id</name></name></expr></argument>,
								  <argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>hypertable_relid</name></name></expr></argument>,
								  <argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>,
								  <argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>table_id</name></name></expr></argument>,
								  <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>chunk_create_table</name><parameter_list>(<parameter><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Create the actual table relation for the chunk */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tablespace</name> <init>= <expr><call><name>ts_hypertable_select_tablespace_name</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>chunk</name><operator>-&gt;</operator><name>table_id</name></name> <operator>=</operator> <call><name>ts_chunk_create_table</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>ht</name></expr></argument>, <argument><expr><name>tablespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>table_id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>chunk</name><operator>-&gt;</operator><name>table_id</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Creates only a table for a chunk.
 * Either table name or chunk id needs to be provided.
 */</comment>
<function><type><specifier>static</specifier> <name>Chunk</name> <modifier>*</modifier></type>
<name>chunk_create_only_table_after_lock</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>Hypercube</name> <modifier>*</modifier></type><name>cube</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>schema_name</name></decl></parameter>,
								   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>table_name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>chunk_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>table_name</name> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <name>chunk_id</name> <operator>!=</operator> <name>INVALID_CHUNK_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>chunk</name> <operator>=</operator> <call><name>chunk_create_object</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>cube</name></expr></argument>, <argument><expr><name>schema_name</name></expr></argument>, <argument><expr><name>table_name</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>chunk_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>chunk</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>chunk_create_table</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>chunk</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>chunk_table_drop_inherit</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>, <parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlterTableCmd</name></type> <name>drop_inh_cmd</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>T_AlterTableCmd</name></expr>,
		<expr><operator>.</operator><name>subtype</name> <operator>=</operator> <name>AT_DropInherit</name></expr>,
		<expr><operator>.</operator><name>def</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>schema_name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>missing_ok</name> <operator>=</operator> <name>false</name></expr>
	}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ts_alter_table_with_event_trigger</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>table_id</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><operator>&amp;</operator><name>drop_inh_cmd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Checks that given hypercube does not collide with existing chunks and
 * creates an empty table for a chunk without any metadata modifications.
 */</comment>
<function><type><name>Chunk</name> <modifier>*</modifier></type>
<name>ts_chunk_create_only_table</name><parameter_list>(<parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>Hypercube</name> <modifier>*</modifier></type><name>cube</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>schema_name</name></decl></parameter>,
						   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>table_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ChunkStub</name> <modifier>*</modifier></type><name>stub</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanTupLock</name></type> <name>tuplock</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>lockmode</name> <operator>=</operator> <name>LockTupleKeyShare</name></expr>,
		<expr><operator>.</operator><name>waitpolicy</name> <operator>=</operator> <name>LockWaitBlock</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Chunk table can be created if no chunk collides with the dimension slices.
	 */</comment>
	<expr_stmt><expr><name>stub</name> <operator>=</operator> <call><name>chunk_collides</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>cube</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>stub</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TS_CHUNK_COLLISION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"chunk table creation failed due to dimension slice collision"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Serialize chunk creation around a lock on the "main table" to avoid
	 * multiple processes trying to create the same chunk. We use a
	 * ShareUpdateExclusiveLock, which is the weakest lock possible that
	 * conflicts with itself. The lock needs to be held until transaction end.
	 */</comment>
	<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ts_hypercube_find_existing_slices</name><argument_list>(<argument><expr><name>cube</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tuplock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>chunk</name> <operator>=</operator> <call><name>chunk_create_only_table_after_lock</name><argument_list>(<argument><expr><name>ht</name></expr></argument>,
											   <argument><expr><name>cube</name></expr></argument>,
											   <argument><expr><name>schema_name</name></expr></argument>,
											   <argument><expr><name>table_name</name></expr></argument>,
											   <argument><expr><name>NULL</name></expr></argument>,
											   <argument><expr><name>INVALID_CHUNK_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>chunk_table_drop_inherit</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>chunk</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_GE</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OSM_CHUNK_INSERT_CHECK_HOOK</name></cpp:macro> <cpp:value>"osm_chunk_insert_check_hook"</cpp:value></cpp:define>
<typedef>typedef <function_decl><type><name>int</name></type> (<modifier>*</modifier><name>ts_osm_chunk_insert_hook_type</name>)<parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>ht_oid</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>range_start</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>range_end</name></decl></parameter>)</parameter_list>;</function_decl></typedef>
<function><type><specifier>static</specifier> <name>ts_osm_chunk_insert_hook_type</name></type>
<name>get_osm_chunk_insert_hook</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ts_osm_chunk_insert_hook_type</name> <modifier>*</modifier></type><name>func_ptr</name> <init>=
		<expr><operator>(</operator><name>ts_osm_chunk_insert_hook_type</name> <operator>*</operator><operator>)</operator> <call><name>find_rendezvous_variable</name><argument_list>(<argument><expr><name>OSM_CHUNK_INSERT_CHECK_HOOK</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><operator>*</operator><name>func_ptr</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>Chunk</name> <modifier>*</modifier></type>
<name>chunk_create_from_hypercube_after_lock</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>Hypercube</name> <modifier>*</modifier></type><name>cube</name></decl></parameter>,
									   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>schema_name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>table_name</name></decl></parameter>,
									   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_GE</name></expr></cpp:if>
	<decl_stmt><decl><type><name>ts_osm_chunk_insert_hook_type</name></type> <name>insert_func_ptr</name> <init>= <expr><call><name>get_osm_chunk_insert_hook</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>insert_func_ptr</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* OSM only uses first dimension . doesn't work with multinode tables yet*/</comment>
		<decl_stmt><decl><type><name>Dimension</name> <modifier>*</modifier></type><name>dim</name> <init>= <expr><operator>&amp;</operator><name><name>ht</name><operator>-&gt;</operator><name>space</name><operator>-&gt;</operator><name>dimensions</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<comment type="block">/* convert to PG timestamp from timescaledb internal format */</comment>
		<decl_stmt><decl><type><name>int64</name></type> <name>range_start</name> <init>=
			<expr><call><name>ts_internal_to_time_int64</name><argument_list>(<argument><expr><name><name>cube</name><operator>-&gt;</operator><name>slices</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>fd</name><operator>.</operator><name>range_start</name></name></expr></argument>, <argument><expr><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>column_type</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int64</name></type> <name>range_end</name> <init>=
			<expr><call><name>ts_internal_to_time_int64</name><argument_list>(<argument><expr><name><name>cube</name><operator>-&gt;</operator><name>slices</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>fd</name><operator>.</operator><name>range_end</name></name></expr></argument>, <argument><expr><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>column_type</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>chunk_exists</name> <init>= <expr><call><name>insert_func_ptr</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>, <argument><expr><name>range_start</name></expr></argument>, <argument><expr><name>range_end</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>chunk_exists</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type> <name>outfuncid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type> <name>isvarlena</name></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>Datum</name></type> <name>start_ts</name> <init>=
				<expr><call><name>ts_internal_to_time_value</name><argument_list>(<argument><expr><name><name>cube</name><operator>-&gt;</operator><name>slices</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>fd</name><operator>.</operator><name>range_start</name></name></expr></argument>, <argument><expr><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>column_type</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type> <name>end_ts</name> <init>=
				<expr><call><name>ts_internal_to_time_value</name><argument_list>(<argument><expr><name><name>cube</name><operator>-&gt;</operator><name>slices</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>fd</name><operator>.</operator><name>range_end</name></name></expr></argument>, <argument><expr><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>column_type</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>column_type</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>outfuncid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isvarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isvarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"distributed hypertable member cannot create chunk on its own"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Cannot insert into tiered chunk range of %s.%s - attempt to create "</literal>
							<literal type="string">"new chunk "</literal>
							<literal type="string">"with range  [%s %s] failed"</literal></expr></argument>,
							<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>schema_name</name></name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>OidFunctionCall1</name><argument_list>(<argument><expr><name>outfuncid</name></expr></argument>, <argument><expr><name>start_ts</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>OidFunctionCall1</name><argument_list>(<argument><expr><name>outfuncid</name></expr></argument>, <argument><expr><name>end_ts</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(
						 <argument><expr><literal type="string">"Hypertable has tiered data with time range that overlaps the insert"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<comment type="block">/* Insert any new dimension slices into metadata */</comment>
	<expr_stmt><expr><call><name>ts_dimension_slice_insert_multi</name><argument_list>(<argument><expr><name><name>cube</name><operator>-&gt;</operator><name>slices</name></name></expr></argument>, <argument><expr><name><name>cube</name><operator>-&gt;</operator><name>num_slices</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name> <init>= <expr><call><name>chunk_create_only_table_after_lock</name><argument_list>(<argument><expr><name>ht</name></expr></argument>,
													  <argument><expr><name>cube</name></expr></argument>,
													  <argument><expr><name>schema_name</name></expr></argument>,
													  <argument><expr><name>table_name</name></expr></argument>,
													  <argument><expr><name>prefix</name></expr></argument>,
													  <argument><expr><call><name>get_next_chunk_id</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>chunk_add_constraints</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>chunk_insert_into_metadata_after_lock</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>chunk_create_table_constraints</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>chunk</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Make a chunk table inherit a hypertable.
 *
 * Execution happens via high-level ALTER TABLE statement. This includes
 * numerous checks to ensure that the chunk table has all the prerequisites to
 * properly inherit the hypertable.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>chunk_add_inheritance</name><parameter_list>(<parameter><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlterTableCmd</name></type> <name>altercmd</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>T_AlterTableCmd</name></expr>,
		<expr><operator>.</operator><name>subtype</name> <operator>=</operator> <name>AT_AddInherit</name></expr>,
		<expr><operator>.</operator><name>def</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>schema_name</name></name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>missing_ok</name> <operator>=</operator> <name>false</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AlterTableStmt</name></type> <name>alterstmt</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>T_AlterTableStmt</name></expr>,
		<expr><operator>.</operator><name>cmds</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><operator>&amp;</operator><name>altercmd</name></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>missing_ok</name> <operator>=</operator> <name>false</name></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_GE</name></expr></cpp:if>
		<expr><operator>.</operator><name>objtype</name> <operator>=</operator> <name>OBJECT_TABLE</name></expr>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr><operator>.</operator><name>relkind</name> <operator>=</operator> <name>OBJECT_TABLE</name></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr><operator>.</operator><name>relation</name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>schema_name</name></name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
	}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKMODE</name></type> <name>lockmode</name> <init>= <expr><call><name>AlterTableGetLockLevel</name><argument_list>(<argument><expr><name><name>alterstmt</name><operator>.</operator><name>cmds</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG13_GE</name></expr></cpp:if>
	<decl_stmt><decl><type><name>AlterTableUtilityContext</name></type> <name>atcontext</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>relid</name> <operator>=</operator> <call><name>AlterTableLookupRelation</name><argument_list>(<argument><expr><operator>&amp;</operator><name>alterstmt</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AlterTable</name><argument_list>(<argument><expr><operator>&amp;</operator><name>alterstmt</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>atcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>AlterTable</name><argument_list>(<argument><expr><call><name>AlterTableLookupRelation</name><argument_list>(<argument><expr><operator>&amp;</operator><name>alterstmt</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>alterstmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Chunk</name> <modifier>*</modifier></type>
<name>chunk_create_from_hypercube_and_table_after_lock</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>Hypercube</name> <modifier>*</modifier></type><name>cube</name></decl></parameter>,
												 <parameter><decl><type><name>Oid</name></type> <name>chunk_table_relid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>schema_name</name></decl></parameter>,
												 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>table_name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>current_chunk_schemaid</name> <init>= <expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name>chunk_table_relid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>new_chunk_schemaid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>chunk_table_relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>current_chunk_schemaid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Insert any new dimension slices into metadata */</comment>
	<expr_stmt><expr><call><name>ts_dimension_slice_insert_multi</name><argument_list>(<argument><expr><name><name>cube</name><operator>-&gt;</operator><name>slices</name></name></expr></argument>, <argument><expr><name><name>cube</name><operator>-&gt;</operator><name>num_slices</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>chunk</name> <operator>=</operator> <call><name>chunk_create_object</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>cube</name></expr></argument>, <argument><expr><name>schema_name</name></expr></argument>, <argument><expr><name>table_name</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><call><name>get_next_chunk_id</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>chunk</name><operator>-&gt;</operator><name>table_id</name></name> <operator>=</operator> <name>chunk_table_relid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>chunk</name><operator>-&gt;</operator><name>hypertable_relid</name></name> <operator>=</operator> <name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>new_chunk_schemaid</name> <operator>=</operator> <call><name>get_namespace_oid</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>schema_name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>current_chunk_schemaid</name> <operator>!=</operator> <name>new_chunk_schemaid</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type> <name>chunk_rel</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>chunk_table_relid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>objects</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CheckSetNamespace</name><argument_list>(<argument><expr><name>current_chunk_schemaid</name></expr></argument>, <argument><expr><name>new_chunk_schemaid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>objects</name> <operator>=</operator> <call><name>new_object_addresses</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AlterTableNamespaceInternal</name><argument_list>(<argument><expr><name>chunk_rel</name></expr></argument>, <argument><expr><name>current_chunk_schemaid</name></expr></argument>, <argument><expr><name>new_chunk_schemaid</name></expr></argument>, <argument><expr><name>objects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free_object_addresses</name><argument_list>(<argument><expr><name>objects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>chunk_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Make changes visible */</comment>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>namestrcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>table_name</name></name></expr></argument>, <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>chunk_table_relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Renaming will acquire and keep an AccessExclusivelock on the chunk
		 * table */</comment>
		<expr_stmt><expr><call><name>RenameRelationInternal</name><argument_list>(<argument><expr><name>chunk_table_relid</name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Make changes visible */</comment>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Note that we do not automatically add constrains and triggers to the
	 * chunk table when the chunk is created from an existing table. However,
	 * PostgreSQL currently validates that CHECK constraints exists, but no
	 * validation is done for other objects, including triggers, UNIQUE,
	 * PRIMARY KEY, and FOREIGN KEY constraints. We might want to either
	 * enforce that these constraints exist prior to creating the chunk from a
	 * table, or we ensure that they are automatically added when the chunk is
	 * created. However, for the latter case, we risk duplicating constraints
	 * and triggers if some of them already exist on the chunk table prior to
	 * creating the chunk from it. */</comment>
	<expr_stmt><expr><call><name>chunk_add_constraints</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>chunk_insert_into_metadata_after_lock</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>chunk_add_inheritance</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>chunk_create_table_constraints</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>chunk</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Chunk</name> <modifier>*</modifier></type>
<name>chunk_create_from_point_after_lock</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Point</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>schema_name</name></decl></parameter>,
								   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>table_name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Hyperspace</name> <modifier>*</modifier></type><name>hs</name> <init>= <expr><name><name>ht</name><operator>-&gt;</operator><name>space</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Hypercube</name> <modifier>*</modifier></type><name>cube</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanTupLock</name></type> <name>tuplock</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>lockmode</name> <operator>=</operator> <name>LockTupleKeyShare</name></expr>,
		<expr><operator>.</operator><name>waitpolicy</name> <operator>=</operator> <name>LockWaitBlock</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the user has enabled adaptive chunking, call the function to
	 * calculate and set the new chunk time interval.
	 */</comment>
	<expr_stmt><expr><call><name>calculate_and_set_new_chunk_interval</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Calculate the hypercube for a new chunk that covers the tuple's point.
	 *
	 * We lock the tuple in KEY SHARE mode since we are concerned with
	 * ensuring that it is not deleted (or the key value changed) while we are
	 * adding chunk constraints (in `ts_chunk_constraints_insert_metadata`
	 * called in `chunk_create_metadata_after_lock`). The range of a dimension
	 * slice does not change, but we should use the weakest lock possible to
	 * not unnecessarily block other operations. */</comment>
	<expr_stmt><expr><name>cube</name> <operator>=</operator> <call><name>ts_hypercube_calculate_from_point</name><argument_list>(<argument><expr><name>hs</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tuplock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Resolve collisions with other chunks by cutting the new hypercube */</comment>
	<expr_stmt><expr><call><name>chunk_collision_resolve</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>cube</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>chunk_create_from_hypercube_after_lock</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>cube</name></expr></argument>, <argument><expr><name>schema_name</name></expr></argument>, <argument><expr><name>table_name</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Chunk</name> <modifier>*</modifier></type>
<name>ts_chunk_find_or_create_without_cuts</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>Hypercube</name> <modifier>*</modifier></type><name>hc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>schema_name</name></decl></parameter>,
									 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>table_name</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>chunk_table_relid</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>created</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ChunkStub</name> <modifier>*</modifier></type><name>stub</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>DEBUG_WAITPOINT</name><argument_list>(<argument><expr><literal type="string">"find_or_create_chunk_start"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>stub</name> <operator>=</operator> <call><name>chunk_collides</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>hc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>stub</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Serialize chunk creation around the root hypertable */</comment>
		<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Check again after lock */</comment>
		<expr_stmt><expr><name>stub</name> <operator>=</operator> <call><name>chunk_collides</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>hc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>stub</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ScanTupLock</name></type> <name>tuplock</name> <init>= <expr><block>{
				<expr><operator>.</operator><name>lockmode</name> <operator>=</operator> <name>LockTupleKeyShare</name></expr>,
				<expr><operator>.</operator><name>waitpolicy</name> <operator>=</operator> <name>LockWaitBlock</name></expr>,
			}</block></expr></init></decl>;</decl_stmt>

			<comment type="block">/* Lock all slices that already exist to ensure they remain when we
			 * commit since we won't create those slices ourselves. */</comment>
			<expr_stmt><expr><call><name>ts_hypercube_find_existing_slices</name><argument_list>(<argument><expr><name>hc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tuplock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>chunk_table_relid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>chunk</name> <operator>=</operator> <call><name>chunk_create_from_hypercube_and_table_after_lock</name><argument_list>(<argument><expr><name>ht</name></expr></argument>,
																		 <argument><expr><name>hc</name></expr></argument>,
																		 <argument><expr><name>chunk_table_relid</name></expr></argument>,
																		 <argument><expr><name>schema_name</name></expr></argument>,
																		 <argument><expr><name>table_name</name></expr></argument>,
																		 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>chunk</name> <operator>=</operator>
					<call><name>chunk_create_from_hypercube_after_lock</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>hc</name></expr></argument>, <argument><expr><name>schema_name</name></expr></argument>, <argument><expr><name>table_name</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>created</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>created</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>ASSERT_IS_VALID_CHUNK</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>DEBUG_WAITPOINT</name><argument_list>(<argument><expr><literal type="string">"find_or_create_chunk_created"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<return>return <expr><name>chunk</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* We didn't need the lock, so release it */</comment>
		<expr_stmt><expr><call><name>UnlockRelationOid</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>stub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We can only use an existing chunk if it has identical dimensional
	 * constraints. Otherwise, throw an error */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ts_hypercube_equal</name><argument_list>(<argument><expr><name><name>stub</name><operator>-&gt;</operator><name>cube</name></name></expr></argument>, <argument><expr><name>hc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TS_CHUNK_COLLISION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"chunk creation failed due to collision"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* chunk_collides only returned a stub, so we need to lookup the full
	 * chunk. */</comment>
	<expr_stmt><expr><name>chunk</name> <operator>=</operator> <call><name>ts_chunk_get_by_id</name><argument_list>(<argument><expr><name><name>stub</name><operator>-&gt;</operator><name>id</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>created</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>created</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>DEBUG_WAITPOINT</name><argument_list>(<argument><expr><literal type="string">"find_or_create_chunk_found"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ASSERT_IS_VALID_CHUNK</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>chunk</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Find the chunk containing the given point, locking all its dimension slices
 * for share. NULL if not found.
 */</comment>
<function><type><name>Chunk</name> <modifier>*</modifier></type>
<name>ts_chunk_find_for_point</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Point</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>chunk_id</name> <init>= <expr><call><name>chunk_point_find_chunk_id</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>chunk_id</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* The chunk might be dropped, so we don't fail if we haven't found it. */</comment>
	<return>return <expr><call><name>ts_chunk_get_by_id</name><argument_list>(<argument><expr><name>chunk_id</name></expr></argument>, <comment type="block">/* fail_if_not_found = */</comment> <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Create a chunk through insertion of a tuple at a given point.
 */</comment>
<function><type><name>Chunk</name> <modifier>*</modifier></type>
<name>ts_chunk_create_for_point</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Point</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>found</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>schema</name></decl></parameter>,
						  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We're going to have to resurrect or create the chunk.
	 * Serialize chunk creation around a lock on the "main table" to avoid
	 * multiple processes trying to create the same chunk. We use a
	 * ShareUpdateExclusiveLock, which is the weakest lock possible that
	 * conflicts with itself. The lock needs to be held until transaction end.
	 */</comment>
	<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>DEBUG_WAITPOINT</name><argument_list>(<argument><expr><literal type="string">"chunk_create_for_point"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Recheck if someone else created the chunk before we got the table
	 * lock. The returned chunk will have all slices locked so that they
	 * aren't removed.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>chunk_id</name> <init>= <expr><call><name>chunk_point_find_chunk_id</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>chunk_id</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* The chunk might be dropped, so we don't fail if we haven't found it. */</comment>
		<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name> <init>= <expr><call><name>ts_chunk_get_by_id</name><argument_list>(<argument><expr><name>chunk_id</name></expr></argument>, <comment type="block">/* fail_if_not_found = */</comment> <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>chunk</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Chunk was not created by us but by someone else, so we can
			 * release the lock early.
			 */</comment>
			<expr_stmt><expr><call><name>UnlockRelationOid</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<return>return <expr><name>chunk</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If we managed to find some metadata for the chunk (chunk_id != 0),
		 * but it is marked as dropped, try to resurrect it.
		 * Not sure if this ever worked for distributed hypertables.
		 */</comment>
		<expr_stmt><expr><name>chunk</name> <operator>=</operator> <call><name>chunk_resurrect</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>chunk_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>chunk</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<return>return <expr><name>chunk</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Create the chunk normally. */</comment>
	<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>found</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>hypertable_is_distributed_member</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TS_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"distributed hypertable member cannot create chunk on its own"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Chunk creation should only happen through an access node."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name> <init>= <expr><call><name>chunk_create_from_point_after_lock</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>schema</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ASSERT_IS_VALID_CHUNK</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>chunk</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Find the chunks that belong to the subspace identified by the given dimension
 * vectors. We might be restricting only some dimensions, so this subspace is
 * not a hypercube, but a hyperplane of some order.
 * Returns a list of matching chunk ids.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>ts_chunk_id_find_in_subspace</name><parameter_list>(<parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>dimension_vecs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>chunk_ids</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ChunkScanCtx</name></type> <name>ctx</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>chunk_scan_ctx_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>, <argument><expr><name><name>ht</name><operator>-&gt;</operator><name>space</name></name></expr></argument>, <comment type="block">/* point = */</comment> <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ScanIterator</name></type> <name>iterator</name> <init>= <expr><call><name>ts_chunk_constraint_scan_iterator_create</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>dimension_vecs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>DimensionVec</name> <modifier>*</modifier></type><name>vec</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="block">/*
		 * We shouldn't see a dimension with zero matching dimension slices.
		 * That would mean that no chunks match at all, this should have been
		 * handled earlier by gather_restriction_dimension_vectors().
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>vec</name><operator>-&gt;</operator><name>num_slices</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>vec</name><operator>-&gt;</operator><name>num_slices</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>DimensionSlice</name> <modifier>*</modifier></type><name>slice</name> <init>= <expr><name><name>vec</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>ts_chunk_constraint_scan_iterator_set_slice_id</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>, <argument><expr><name><name>slice</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ts_scan_iterator_start_or_restart_scan</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<while>while <condition>(<expr><call><name>ts_scan_iterator_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name> <init>= <expr><call><name>ts_scan_iterator_tuple_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name> <name>PG_USED_FOR_ASSERTS_ONLY</name></type> <name>isnull</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Datum</name></type> <name>datum</name> <init>= <expr><call><name>slot_getattr</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>slot</name></name></expr></argument>, <argument><expr><name>Anum_chunk_constraint_chunk_id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<decl_stmt><decl><type><name>int32</name></type> <name>current_chunk_id</name> <init>= <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>current_chunk_id</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ChunkScanEntry</name> <modifier>*</modifier></type><name>entry</name> <init>=
					<expr><call><name>hash_search</name><argument_list>(<argument><expr><name><name>ctx</name><operator>.</operator><name>htab</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>current_chunk_id</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>stub</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>num_dimension_constraints</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * We have only the dimension constraints here, because we're searching
				 * by dimension slice id.
				 */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>slot_attisnull</name><argument_list>(<argument><expr><call><name>ts_scan_iterator_slot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><name>Anum_chunk_constraint_dimension_slice_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>num_dimension_constraints</name></name><operator>++</operator></expr>;</expr_stmt>

				<comment type="block">/*
				 * A chunk is complete when we've found slices for all required dimensions,
				 * i.e., a complete subspace.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>num_dimension_constraints</name></name> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>dimension_vecs</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>chunk_ids</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>chunk_ids</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>chunk_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></while>
		</block_content>}</block></for>
	</block_content>}</block>

	<expr_stmt><expr><call><name>ts_scan_iterator_close</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>chunk_scan_ctx_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>chunk_ids</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>ChunkStub</name> <modifier>*</modifier></type>
<name>ts_chunk_stub_create</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>num_constraints</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ChunkStub</name> <modifier>*</modifier></type><name>stub</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>stub</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>stub</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stub</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <name>id</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>num_constraints</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>stub</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <call><name>ts_chunk_constraints_alloc</name><argument_list>(<argument><expr><name>num_constraints</name></expr></argument>, <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>stub</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Chunk</name> <modifier>*</modifier></type>
<name>ts_chunk_create_base</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>num_constraints</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name></type> <name>relkind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>chunk</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Chunk</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name> <operator>=</operator> <name>id</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>compressed_chunk_id</name></name> <operator>=</operator> <name>INVALID_CHUNK_ID</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>chunk</name><operator>-&gt;</operator><name>relkind</name></name> <operator>=</operator> <name>relkind</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>num_constraints</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>chunk</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <call><name>ts_chunk_constraints_alloc</name><argument_list>(<argument><expr><name>num_constraints</name></expr></argument>, <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>chunk</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Build a chunk from a chunk tuple and a stub.
 *
 * The stub allows the chunk to be constructed more efficiently. But if the stub
 * is not "valid", dimension slices and constraints are fully
 * rescanned/recreated.
 */</comment>
<function><type><name>Chunk</name> <modifier>*</modifier></type>
<name>ts_chunk_build_from_tuple_and_stub</name><parameter_list>(<parameter><decl><type><name>Chunk</name> <modifier>*</modifier><modifier>*</modifier></type><name>chunkptr</name></decl></parameter>, <parameter><decl><type><name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ChunkStub</name> <modifier>*</modifier></type><name>stub</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>num_constraints_hint</name> <init>= <expr><ternary><condition><expr><name>stub</name></expr> ?</condition><then> <expr><name><name>stub</name><operator>-&gt;</operator><name>constraints</name><operator>-&gt;</operator><name>num_constraints</name></name></expr> </then><else>: <expr><literal type="number">2</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>chunkptr</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>chunkptr</name> <operator>=</operator> <operator>&amp;</operator><name>chunk</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <operator>*</operator><name>chunkptr</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>chunkptr</name> <operator>=</operator> <call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>mctx</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Chunk</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>chunk</name> <operator>=</operator> <operator>*</operator><name>chunkptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_chunk_formdata_fill</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>chunk</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>ti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * When searching for the chunk stub matching the dimensional point, we
	 * only scanned for dimensional constraints. We now need to rescan the
	 * constraints to also get the inherited constraints.
	 */</comment>
	<expr_stmt><expr><name><name>chunk</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator>
		<call><name>ts_chunk_constraint_scan_by_chunk_id</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>, <argument><expr><name>num_constraints_hint</name></expr></argument>, <argument><expr><name><name>ti</name><operator>-&gt;</operator><name>mctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If a stub is provided then reuse its hypercube. Note that stubs that
	 * are results of a point or range scan might be incomplete (in terms of
	 * number of slices and constraints). Only a chunk stub that matches in
	 * all dimensions will have a complete hypercube. Thus, we need to check
	 * the validity of the stub before we can reuse it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>chunk_stub_is_valid</name><argument_list>(<argument><expr><name>stub</name></expr></argument>, <argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>constraints</name><operator>-&gt;</operator><name>num_dimension_constraints</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldctx</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>mctx</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>chunk</name><operator>-&gt;</operator><name>cube</name></name> <operator>=</operator> <call><name>ts_hypercube_copy</name><argument_list>(<argument><expr><name><name>stub</name><operator>-&gt;</operator><name>cube</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * The hypercube slices were filled in during the scan. Now we need to
		 * sort them in dimension order.
		 */</comment>
		<expr_stmt><expr><call><name>ts_hypercube_slice_sort</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>cube</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>ScanIterator</name></type> <name>it</name> <init>= <expr><call><name>ts_dimension_slice_scan_iterator_create</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>ti</name><operator>-&gt;</operator><name>mctx</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>chunk</name><operator>-&gt;</operator><name>cube</name></name> <operator>=</operator> <call><name>ts_hypercube_from_constraints</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>constraints</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ts_scan_iterator_close</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>chunk</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ScanFilterResult</name></type>
<name>chunk_tuple_dropped_filter</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ChunkStubScanCtx</name> <modifier>*</modifier></type><name>stubctx</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>dropped</name> <init>= <expr><call><name>slot_getattr</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>slot</name></name></expr></argument>, <argument><expr><name>Anum_chunk_dropped</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stubctx</name><operator>-&gt;</operator><name>is_dropped</name></name> <operator>=</operator> <call><name>DatumGetBool</name><argument_list>(<argument><expr><name>dropped</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><ternary><condition><expr><name><name>stubctx</name><operator>-&gt;</operator><name>is_dropped</name></name></expr> ?</condition><then> <expr><name>SCAN_EXCLUDE</name></expr> </then><else>: <expr><name>SCAN_INCLUDE</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* This is a modified version of chunk_tuple_dropped_filter that does
 * not use ChunkStubScanCtx as the arg, it just ignores the passed in
 * argument.
 * We need a variant as the ScannerCtx assumes that the the filter function
 * and tuple_found function share the argument.
 */</comment>
<function><type><specifier>static</specifier> <name>ScanFilterResult</name></type>
<name>chunk_check_ignorearg_dropped_filter</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>dropped</name> <init>= <expr><call><name>slot_getattr</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>slot</name></name></expr></argument>, <argument><expr><name>Anum_chunk_dropped</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>is_dropped</name> <init>= <expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><name>dropped</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><ternary><condition><expr><name>is_dropped</name></expr> ?</condition><then> <expr><name>SCAN_EXCLUDE</name></expr> </then><else>: <expr><name>SCAN_INCLUDE</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ScanTupleResult</name></type>
<name>chunk_tuple_found</name><parameter_list>(<parameter><decl><type><name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ChunkStubScanCtx</name> <modifier>*</modifier></type><name>stubctx</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>chunk</name> <operator>=</operator> <call><name>ts_chunk_build_from_tuple_and_stub</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>stubctx</name><operator>-&gt;</operator><name>chunk</name></name></expr></argument>, <argument><expr><name>ti</name></expr></argument>, <argument><expr><name><name>stubctx</name><operator>-&gt;</operator><name>stub</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>dropped</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Fill in table relids. Note that we cannot do this in
	 * ts_chunk_build_from_tuple_and_stub() since chunk_resurrect() also uses
	 * that function and, in that case, the chunk object is needed to create
	 * the data table and related objects. */</comment>
	<expr_stmt><expr><name><name>chunk</name><operator>-&gt;</operator><name>table_id</name></name> <operator>=</operator> <call><name>get_relname_relid</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>table_name</name><operator>.</operator><name>data</name></name></expr></argument>,
										<argument><expr><call><name>get_namespace_oid</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>schema_name</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>chunk</name><operator>-&gt;</operator><name>hypertable_relid</name></name> <operator>=</operator> <call><name>ts_hypertable_id_to_relid</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>hypertable_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>chunk</name><operator>-&gt;</operator><name>relkind</name></name> <operator>=</operator> <call><name>get_rel_relkind</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>table_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>chunk</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IS_OSM_CHUNK</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>chunk</name><operator>-&gt;</operator><name>data_nodes</name></name> <operator>=</operator> <call><name>ts_chunk_data_node_scan_by_chunk_id</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>, <argument><expr><name><name>ti</name><operator>-&gt;</operator><name>mctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>SCAN_DONE</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Create a chunk by scanning on chunk ID. A stub must be provided as input. */</comment>
<function><type><specifier>static</specifier> <name>Chunk</name> <modifier>*</modifier></type>
<name>chunk_create_from_stub</name><parameter_list>(<parameter><decl><type><name>ChunkStubScanCtx</name> <modifier>*</modifier></type><name>stubctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scankey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Catalog</name> <modifier>*</modifier></type><name>catalog</name> <init>= <expr><call><name>ts_catalog_get</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>num_found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScannerCtx</name></type> <name>scanctx</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>table</name> <operator>=</operator> <call><name>catalog_get_table_id</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>CHUNK</name></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>index</name> <operator>=</operator> <call><name>catalog_get_index</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>CHUNK</name></expr></argument>, <argument><expr><name>CHUNK_ID_INDEX</name></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>nkeys</name> <operator>=</operator> <literal type="number">1</literal></expr>,
		<expr><operator>.</operator><name>scankey</name> <operator>=</operator> <name>scankey</name></expr>,
		<expr><operator>.</operator><name>data</name> <operator>=</operator> <name>stubctx</name></expr>,
		<expr><operator>.</operator><name>filter</name> <operator>=</operator> <name>chunk_tuple_dropped_filter</name></expr>,
		<expr><operator>.</operator><name>tuple_found</name> <operator>=</operator> <name>chunk_tuple_found</name></expr>,
		<expr><operator>.</operator><name>lockmode</name> <operator>=</operator> <name>AccessShareLock</name></expr>,
		<expr><operator>.</operator><name>scandirection</name> <operator>=</operator> <name>ForwardScanDirection</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Perform an index scan on chunk ID.
	 */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scankey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_chunk_idx_id</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
				<argument><expr><name>F_INT4EQ</name></expr></argument>,
				<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>stubctx</name><operator>-&gt;</operator><name>stub</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>num_found</name> <operator>=</operator> <call><name>ts_scanner_scan</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scanctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>num_found</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>num_found</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stubctx</name><operator>-&gt;</operator><name>is_dropped</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>num_found</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>num_found</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"no chunk found with ID %d"</literal></expr></argument>, <argument><expr><name><name>stubctx</name><operator>-&gt;</operator><name>stub</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name><name>stubctx</name><operator>-&gt;</operator><name>chunk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>stubctx</name><operator>-&gt;</operator><name>chunk</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize a chunk scan context.
 *
 * A chunk scan context is used to join chunk-related information from metadata
 * tables during scans.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>chunk_scan_ctx_init</name><parameter_list>(<parameter><decl><type><name>ChunkScanCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Hyperspace</name> <modifier>*</modifier></type><name>hs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Point</name> <modifier>*</modifier></type><name>point</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>HASHCTL</name></name></type> <name>hctl</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>keysize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr>,
		<expr><operator>.</operator><name>entrysize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ChunkScanEntry</name></expr></argument>)</argument_list></sizeof></expr>,
		<expr><operator>.</operator><name>hcxt</name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>ctx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>htab</name></name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"chunk-scan-context"</literal></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>hctl</name></expr></argument>, <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_CONTEXT</name> <operator>|</operator> <name>HASH_BLOBS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>space</name></name> <operator>=</operator> <name>hs</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>point</name></name> <operator>=</operator> <name>point</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>lockmode</name></name> <operator>=</operator> <name>NoLock</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Destroy the chunk scan context.
 *
 * This will free the hash table in the context, but not the chunks within since
 * they are not allocated on the hash tables memory context.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>chunk_scan_ctx_destroy</name><parameter_list>(<parameter><decl><type><name>ChunkScanCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>htab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>dimension_slice_and_chunk_constraint_join</name><parameter_list>(<parameter><decl><type><name>ChunkScanCtx</name> <modifier>*</modifier></type><name>scanctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DimensionVec</name> <modifier>*</modifier></type><name>vec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>vec</name><operator>-&gt;</operator><name>num_slices</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * For each dimension slice, find matching constraints. These will be
		 * saved in the scan context
		 */</comment>
		<expr_stmt><expr><call><name>ts_chunk_constraint_scan_by_dimension_slice</name><argument_list>(<argument><expr><name><name>vec</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>scanctx</name></expr></argument>, <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Scan for chunks that collide with the given hypercube.
 *
 * Collisions are determined using axis-aligned bounding box collision detection
 * generalized to N dimensions. Slices are collected in the scan context's hash
 * table according to the chunk IDs they are associated with. A slice might
 * represent the dimensional bound of multiple chunks, and thus is added to all
 * the hash table slots of those chunks. At the end of the scan, those chunks
 * that have a full set of slices are the ones that actually collide with the
 * given hypercube.
 *
 * Chunks in the scan context that do not collide (do not have a full set of
 * slices), might still be important for ensuring alignment in those dimensions
 * that require alignment.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>chunk_collision_scan</name><parameter_list>(<parameter><decl><type><name>ChunkScanCtx</name> <modifier>*</modifier></type><name>scanctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Hypercube</name> <modifier>*</modifier></type><name>cube</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Scan all dimensions for colliding slices */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>scanctx</name><operator>-&gt;</operator><name>space</name><operator>-&gt;</operator><name>num_dimensions</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DimensionVec</name> <modifier>*</modifier></type><name>vec</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DimensionSlice</name> <modifier>*</modifier></type><name>slice</name> <init>= <expr><name><name>cube</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>vec</name> <operator>=</operator> <call><name>dimension_slice_collision_scan</name><argument_list>(<argument><expr><name><name>slice</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>dimension_id</name></name></expr></argument>,
											 <argument><expr><name><name>slice</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>range_start</name></name></expr></argument>,
											 <argument><expr><name><name>slice</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>range_end</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Add the slices to all the chunks they are associated with */</comment>
		<expr_stmt><expr><call><name>dimension_slice_and_chunk_constraint_join</name><argument_list>(<argument><expr><name>scanctx</name></expr></argument>, <argument><expr><name>vec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Apply a function to each stub in the scan context's hash table. If the limit
 * is greater than zero only a limited number of chunks will be processed.
 *
 * The chunk handler function (on_chunk_func) should return CHUNK_PROCESSED if
 * the chunk should be considered processed and count towards the given
 * limit. CHUNK_IGNORE can be returned to have a chunk NOT count towards the
 * limit. CHUNK_DONE counts the chunk but aborts processing irrespective of
 * whether the limit is reached or not.
 *
 * Returns the number of processed chunks.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>chunk_scan_ctx_foreach_chunk_stub</name><parameter_list>(<parameter><decl><type><name>ChunkScanCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>on_chunk_stub_func</name></type> <name>on_chunk</name></decl></parameter>, <parameter><decl><type><name>uint16</name></type> <name>limit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ChunkScanEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>num_processed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>htab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>entry</name> <operator>=</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>entry</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>entry</name> <operator>=</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr></incr>)</control>
	<block>{<block_content>
		<switch>switch <condition>(<expr><call><name>on_chunk</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>stub</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>CHUNK_DONE</name></expr>:</case>
				<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>num_processed</name></name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>hash_seq_term</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name><name>ctx</name><operator>-&gt;</operator><name>num_processed</name></name></expr>;</return>
			<case>case <expr><name>CHUNK_PROCESSED</name></expr>:</case>
				<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>num_processed</name></name><operator>++</operator></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>limit</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>num_processed</name></name> <operator>==</operator> <name>limit</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>hash_seq_term</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name><name>ctx</name><operator>-&gt;</operator><name>num_processed</name></name></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><name>CHUNK_IGNORED</name></expr>:</case>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></for>

	<return>return <expr><name><name>ctx</name><operator>-&gt;</operator><name>num_processed</name></name></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <name>ChunkScanCtxAddChunkData</name>
<block>{
	<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>max_chunks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>num_chunks</name></decl>;</decl_stmt>
}</block></struct></type> <name>ChunkScanCtxAddChunkData</name>;</typedef>

<function><type><specifier>static</specifier> <name>ChunkResult</name></type>
<name>chunk_scan_context_add_chunk</name><parameter_list>(<parameter><decl><type><name>ChunkScanCtx</name> <modifier>*</modifier></type><name>scanctx</name></decl></parameter>, <parameter><decl><type><name>ChunkStub</name> <modifier>*</modifier></type><name>stub</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ChunkScanCtxAddChunkData</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><name><name>scanctx</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ChunkStubScanCtx</name></type> <name>stubctx</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>chunk</name> <operator>=</operator> <operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>chunks</name><index>[<expr><name><name>data</name><operator>-&gt;</operator><name>num_chunks</name></name></expr>]</index></name></expr>,
		<expr><operator>.</operator><name>stub</name> <operator>=</operator> <name>stub</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>num_chunks</name></name> <operator>&lt;</operator> <name><name>data</name><operator>-&gt;</operator><name>max_chunks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>chunk_create_from_stub</name><argument_list>(<argument><expr><operator>&amp;</operator><name>stubctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stubctx</name><operator>.</operator><name>is_dropped</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>CHUNK_IGNORED</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>num_chunks</name></name><operator>++</operator></expr>;</expr_stmt>

	<return>return <expr><name>CHUNK_PROCESSED</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Resurrect a chunk from a tombstone.
 *
 * A chunk can be dropped while retaining its metadata as a tombstone. Such a
 * chunk is marked with dropped=true.
 *
 * This function resurrects such a dropped chunk based on the original metadata,
 * including recreating the table and related objects.
 */</comment>
<function><type><specifier>static</specifier> <name>Chunk</name> <modifier>*</modifier></type>
<name>chunk_resurrect</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>chunk_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScanIterator</name></type> <name>iterator</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PG_USED_FOR_ASSERTS_ONLY</name> <name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>chunk_id</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>iterator</name> <operator>=</operator> <call><name>ts_scan_iterator_create</name><argument_list>(<argument><expr><name>CHUNK</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>, <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_chunk_scan_iterator_set_chunk_id</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>, <argument><expr><name>chunk_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>ts_scanner_foreach</name><argument_list>(<argument>&amp;iterator</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name> <init>= <expr><call><name>ts_scan_iterator_tuple_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type> <name>new_tuple</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>count</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>chunk</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>chunk</name> <operator>=</operator> <call><name>ts_chunk_build_from_tuple_and_stub</name><argument_list>(<comment type="block">/* chunkptr = */</comment> <argument><expr><name>NULL</name></expr></argument>,
												   <argument><expr><name>ti</name></expr></argument>,
												   <comment type="block">/* stub = */</comment> <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>dropped</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Create data table and related objects */</comment>
		<expr_stmt><expr><name><name>chunk</name><operator>-&gt;</operator><name>hypertable_relid</name></name> <operator>=</operator> <name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>chunk</name><operator>-&gt;</operator><name>relkind</name></name> <operator>=</operator> <call><name>hypertable_chunk_relkind</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>chunk</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>chunk</name><operator>-&gt;</operator><name>data_nodes</name></name> <operator>=</operator> <call><name>ts_chunk_data_node_scan_by_chunk_id</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>, <argument><expr><name><name>ti</name><operator>-&gt;</operator><name>mctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* If the Data-Node replica list information has been deleted reassign them */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>chunk</name><operator>-&gt;</operator><name>data_nodes</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>chunk</name><operator>-&gt;</operator><name>data_nodes</name></name> <operator>=</operator> <call><name>chunk_assign_data_nodes</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>chunk</name><operator>-&gt;</operator><name>table_id</name></name> <operator>=</operator> <call><name>chunk_create_table</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>chunk_create_table_constraints</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Finally, update the chunk tuple to no longer be a tombstone */</comment>
		<expr_stmt><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>dropped</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>new_tuple</name> <operator>=</operator> <call><name>chunk_formdata_make_tuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>chunk</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><call><name>ts_scan_iterator_tupledesc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ts_catalog_update_tid</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>scanrel</name></name></expr></argument>, <argument><expr><call><name>ts_scanner_get_tuple_tid</name><argument_list>(<argument><expr><name>ti</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>new_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>new_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/* Assume there's only one match. (We break early to avoid scanning
		 * also the updated tuple.) */</comment>
		<break>break;</break>
	</block_content>}</block>

	<expr_stmt><expr><call><name>ts_scan_iterator_close</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>count</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>count</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If count == 0 and chunk is NULL here, the tombstone (metadata) must
	 * have been removed before we had a chance to resurrect the chunk */</comment>
	<return>return <expr><name>chunk</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Scan for the chunk that encloses the given point.
 *
 * In each dimension there can be one or more slices that match the point's
 * coordinate in that dimension. Slices are collected in the scan context's hash
 * table according to the chunk IDs they are associated with. A slice might
 * represent the dimensional bound of multiple chunks, and thus is added to all
 * the hash table slots of those chunks. At the end of the scan there will be at
 * most one chunk that has a complete set of slices, since a point cannot belong
 * to two chunks.
 *
 * This involves:
 *
 * 1) For each dimension:
 *	  - Find all dimension slices that match the dimension
 * 2) For each dimension slice:
 *	  - Find all chunk constraints matching the dimension slice
 * 3) For each matching chunk constraint
 *	  - Insert a chunk stub into a hash table and add the constraint to the chunk
 *	  - If chunk already exists in hash table, add the constraint to the chunk
 * 4) At the end of the scan, only one chunk in the hash table should have
 *	  N number of constraints. This is the matching chunk.
 *
 * NOTE: this function allocates transient data, e.g., dimension slice,
 * constraints and chunks, that in the end are not part of the returned
 * chunk. Therefore, this scan should be executed on a transient memory
 * context. The returned chunk needs to be copied into another memory context in
 * case it needs to live beyond the lifetime of the other data.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>chunk_point_find_chunk_id</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Point</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>matching_chunk_id</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* The scan context will keep the state accumulated during the scan */</comment>
	<decl_stmt><decl><type><name>ChunkScanCtx</name></type> <name>ctx</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>chunk_scan_ctx_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>, <argument><expr><name><name>ht</name><operator>-&gt;</operator><name>space</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Scan all dimensions for slices enclosing the point */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>all_slices</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>dimension_index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>dimension_index</name> <operator>&lt;</operator> <name><name>ctx</name><operator>.</operator><name>space</name><operator>-&gt;</operator><name>num_dimensions</name></name></expr>;</condition> <incr><expr><name>dimension_index</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ts_dimension_slice_scan_list</name><argument_list>(<argument><expr><name><name>ctx</name><operator>.</operator><name>space</name><operator>-&gt;</operator><name>dimensions</name><index>[<expr><name>dimension_index</name></expr>]</index></name><operator>.</operator><name><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>,
									 <argument><expr><name><name>p</name><operator>-&gt;</operator><name>coordinates</name><index>[<expr><name>dimension_index</name></expr>]</index></name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>all_slices</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Find constraints matching dimension slices. */</comment>
	<decl_stmt><decl><type><name>ScanIterator</name></type> <name>iterator</name> <init>= <expr><call><name>ts_chunk_constraint_scan_iterator_create</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>all_slices</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DimensionSlice</name> <modifier>*</modifier></type><name>slice</name> <init>= <expr><operator>(</operator><name>DimensionSlice</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ts_chunk_constraint_scan_iterator_set_slice_id</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>, <argument><expr><name><name>slice</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ts_scan_iterator_start_or_restart_scan</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<while>while <condition>(<expr><call><name>ts_scan_iterator_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name> <init>= <expr><call><name>ts_scan_iterator_tuple_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name> <name>PG_USED_FOR_ASSERTS_ONLY</name></type> <name>isnull</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type> <name>datum</name> <init>= <expr><call><name>slot_getattr</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>slot</name></name></expr></argument>, <argument><expr><name>Anum_chunk_constraint_chunk_id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<decl_stmt><decl><type><name>int32</name></type> <name>current_chunk_id</name> <init>= <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>current_chunk_id</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ChunkScanEntry</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><call><name>hash_search</name><argument_list>(<argument><expr><name><name>ctx</name><operator>.</operator><name>htab</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>current_chunk_id</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>stub</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>num_dimension_constraints</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * We have only the dimension constraints here, because we're searching
			 * by dimension slice id.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>slot_attisnull</name><argument_list>(<argument><expr><call><name>ts_scan_iterator_slot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name>Anum_chunk_constraint_dimension_slice_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>num_dimension_constraints</name></name><operator>++</operator></expr>;</expr_stmt>

			<comment type="block">/*
			 * A chunk is complete when we've found slices for all its dimensions,
			 * i.e., a complete hypercube. Only one chunk matches a given hyperspace
			 * point, so we can stop early.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>num_dimension_constraints</name></name> <operator>==</operator> <name><name>ctx</name><operator>.</operator><name>space</name><operator>-&gt;</operator><name>num_dimensions</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>matching_chunk_id</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>chunk_id</name></name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></while>

		<if_stmt><if>if <condition>(<expr><name>matching_chunk_id</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>ts_scan_iterator_close</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>chunk_scan_ctx_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>matching_chunk_id</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Find all the chunks in hyperspace that include elements (dimension slices)
 * calculated by given range constraints and return the corresponding
 * ChunkScanCxt. It is the caller's responsibility to destroy this context after
 * usage.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>chunks_find_all_in_range_limit</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type><name>time_dim</name></decl></parameter>,
							   <parameter><decl><type><name>StrategyNumber</name></type> <name>start_strategy</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>start_value</name></decl></parameter>,
							   <parameter><decl><type><name>StrategyNumber</name></type> <name>end_strategy</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>end_value</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>limit</name></decl></parameter>,
							   <parameter><decl><type><name>uint64</name> <modifier>*</modifier></type><name>num_found</name></decl></parameter>, <parameter><decl><type><name>ScanTupLock</name> <modifier>*</modifier></type><name>tuplock</name></decl></parameter>, <parameter><decl><type><name>ChunkScanCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DimensionVec</name> <modifier>*</modifier></type><name>slices</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ht</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* must have been checked earlier that this is the case */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>time_dim</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>slices</name> <operator>=</operator> <call><name>ts_dimension_slice_scan_range_limit</name><argument_list>(<argument><expr><name><name>time_dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>,
												 <argument><expr><name>start_strategy</name></expr></argument>,
												 <argument><expr><name>start_value</name></expr></argument>,
												 <argument><expr><name>end_strategy</name></expr></argument>,
												 <argument><expr><name>end_value</name></expr></argument>,
												 <argument><expr><name>limit</name></expr></argument>,
												 <argument><expr><name>tuplock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* The scan context will keep the state accumulated during the scan */</comment>
	<expr_stmt><expr><call><name>chunk_scan_ctx_init</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>ht</name><operator>-&gt;</operator><name>space</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* No abort when the first chunk is found */</comment>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>early_abort</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* Scan for chunks that are in range */</comment>
	<expr_stmt><expr><call><name>dimension_slice_and_chunk_constraint_join</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>slices</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>num_found</name> <operator>+=</operator> <call><name>hash_get_num_entries</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>htab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* show_chunks SQL function handler */</comment>
<function><type><name>Datum</name></type>
<name>ts_chunk_show_chunks</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * chunks_return_srf is called even when it is not the first call but only
	 * after doing some computation first
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>SRF_IS_FIRSTCALL</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FuncCallContext</name> <modifier>*</modifier></type><name>funcctx</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>relid</name> <init>= <expr><ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>InvalidOid</name></expr> </then><else>: <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type><name>time_dim</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Cache</name> <modifier>*</modifier></type><name>hcache</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int64</name></type> <name>older_than</name> <init>= <expr><name>PG_INT64_MAX</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int64</name></type> <name>newer_than</name> <init>= <expr><name>PG_INT64_MIN</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>time_type</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>hcache</name> <operator>=</operator> <call><name>ts_hypertable_cache_pin</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ht</name> <operator>=</operator> <call><name>find_hypertable_from_table_or_cagg</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ht</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>time_dim</name> <operator>=</operator> <call><name>hyperspace_get_open_dimension</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>space</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>time_dim</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>time_type</name> <operator>=</operator> <call><name>ts_dimension_get_partition_type</name><argument_list>(<argument><expr><name>time_dim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>time_type</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>older_than</name> <operator>=</operator> <call><name>ts_time_value_from_arg</name><argument_list>(<argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
												<argument><expr><call><name>get_fn_expr_argtype</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
												<argument><expr><name>time_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>newer_than</name> <operator>=</operator> <call><name>ts_time_value_from_arg</name><argument_list>(<argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>,
												<argument><expr><call><name>get_fn_expr_argtype</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>,
												<argument><expr><name>time_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_FIRSTCALL_INIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name> <operator>=</operator> <call><name>get_chunks_in_time_range</name><argument_list>(<argument><expr><name>ht</name></expr></argument>,
													  <argument><expr><name>older_than</name></expr></argument>,
													  <argument><expr><name>newer_than</name></expr></argument>,
													  <argument><expr><literal type="string">"show_chunks"</literal></expr></argument>,
													  <argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>multi_call_memory_ctx</name></name></expr></argument>,
													  <argument><expr><operator>&amp;</operator><name><name>funcctx</name><operator>-&gt;</operator><name>max_calls</name></name></expr></argument>,
													  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>chunks_return_srf</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Chunk</name> <modifier>*</modifier></type>
<name>get_chunks_in_time_range</name><parameter_list>(<parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>older_than</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>newer_than</name></decl></parameter>,
						 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>caller_name</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>mctx</name></decl></parameter>, <parameter><decl><type><name>uint64</name> <modifier>*</modifier></type><name>num_chunks_returned</name></decl></parameter>,
						 <parameter><decl><type><name>ScanTupLock</name> <modifier>*</modifier></type><name>tuplock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ChunkScanCtx</name></type> <name>chunk_scan_ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ChunkScanCtxAddChunkData</name></type> <name>data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type><name>time_dim</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StrategyNumber</name></type> <name>start_strategy</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StrategyNumber</name></type> <name>end_strategy</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>num_chunks</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>older_than</name> <operator>&lt;=</operator> <name>newer_than</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid time range"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"The start of the time range must be before the end."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TS_HYPERTABLE_IS_INTERNAL_COMPRESSION_TABLE</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid operation on compressed hypertable"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>start_strategy</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>newer_than</name> <operator>==</operator> <name>PG_INT64_MIN</name><operator>)</operator></expr> ?</condition><then> <expr><name>InvalidStrategy</name></expr> </then><else>: <expr><name>BTGreaterEqualStrategyNumber</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name>end_strategy</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>older_than</name> <operator>==</operator> <name>PG_INT64_MAX</name><operator>)</operator></expr> ?</condition><then> <expr><name>InvalidStrategy</name></expr> </then><else>: <expr><name>BTLessStrategyNumber</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name>time_dim</name> <operator>=</operator> <call><name>hyperspace_get_open_dimension</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>space</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>mctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>chunks_find_all_in_range_limit</name><argument_list>(<argument><expr><name>ht</name></expr></argument>,
								   <argument><expr><name>time_dim</name></expr></argument>,
								   <argument><expr><name>start_strategy</name></expr></argument>,
								   <argument><expr><name>newer_than</name></expr></argument>,
								   <argument><expr><name>end_strategy</name></expr></argument>,
								   <argument><expr><name>older_than</name></expr></argument>,
								   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>num_chunks</name></expr></argument>,
								   <argument><expr><name>tuplock</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>chunk_scan_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>chunks</name> <operator>=</operator> <call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>mctx</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Chunk</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>num_chunks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>data</name> <operator>=</operator> <operator>(</operator><name>ChunkScanCtxAddChunkData</name><operator>)</operator><block>{
		<expr><operator>.</operator><name>chunks</name> <operator>=</operator> <name>chunks</name></expr>,
		<expr><operator>.</operator><name>max_chunks</name> <operator>=</operator> <name>num_chunks</name></expr>,
		<expr><operator>.</operator><name>num_chunks</name> <operator>=</operator> <literal type="number">0</literal></expr>,
	}</block></expr>;</expr_stmt>

	<comment type="block">/* Get all the chunks from the context */</comment>
	<expr_stmt><expr><name><name>chunk_scan_ctx</name><operator>.</operator><name>data</name></name> <operator>=</operator> <operator>&amp;</operator><name>data</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>chunk_scan_ctx_foreach_chunk_stub</name><argument_list>(<argument><expr><operator>&amp;</operator><name>chunk_scan_ctx</name></expr></argument>, <argument><expr><name>chunk_scan_context_add_chunk</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*
	 * only affects ctx.htab Got all the chunk already so can now safely
	 * destroy the context
	 */</comment>
	<expr_stmt><expr><call><name>chunk_scan_ctx_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>chunk_scan_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>num_chunks_returned</name> <operator>=</operator> <name><name>data</name><operator>.</operator><name>num_chunks</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>chunks</name></expr></argument>, <argument><expr><operator>*</operator><name>num_chunks_returned</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Chunk</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>chunk_cmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
	<do>do
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint64</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<comment type="block">/* Assert that we never return dropped chunks */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>*</operator><name>num_chunks_returned</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ASSERT_IS_VALID_CHUNK</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>chunks</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block> while <condition>(<expr><name>false</name></expr>)</condition>;</do>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><name>chunks</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>List</name> <modifier>*</modifier></type>
<name>ts_chunk_data_nodes_copy</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>lcopy</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>chunk-&gt;data_nodes</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ChunkDataNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ChunkDataNode</name> <modifier>*</modifier></type><name>copy</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ChunkDataNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>copy</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ChunkDataNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>lcopy</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>lcopy</name></expr></argument>, <argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>lcopy</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Chunk</name> <modifier>*</modifier></type>
<name>ts_chunk_copy</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>copy</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ASSERT_IS_VALID_CHUNK</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>copy</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Chunk</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>copy</name></expr></argument>, <argument><expr><name>chunk</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Chunk</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>chunk</name><operator>-&gt;</operator><name>constraints</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>copy</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <call><name>ts_chunk_constraints_copy</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>constraints</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>chunk</name><operator>-&gt;</operator><name>cube</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>copy</name><operator>-&gt;</operator><name>cube</name></name> <operator>=</operator> <call><name>ts_hypercube_copy</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>cube</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>copy</name><operator>-&gt;</operator><name>data_nodes</name></name> <operator>=</operator> <call><name>ts_chunk_data_nodes_copy</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>copy</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>chunk_scan_internal</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>indexid</name></decl></parameter>, <parameter><decl><type><name>ScanKeyData</name></type> <name><name>scankey</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nkeys</name></decl></parameter>, <parameter><decl><type><name>tuple_filter_func</name></type> <name>filter</name></decl></parameter>,
					<parameter><decl><type><name>tuple_found_func</name></type> <name>tuple_found</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>limit</name></decl></parameter>, <parameter><decl><type><name>ScanDirection</name></type> <name>scandir</name></decl></parameter>,
					<parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>mctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Catalog</name> <modifier>*</modifier></type><name>catalog</name> <init>= <expr><call><name>ts_catalog_get</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScannerCtx</name></type> <name>ctx</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>table</name> <operator>=</operator> <call><name>catalog_get_table_id</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>CHUNK</name></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>index</name> <operator>=</operator> <call><name>catalog_get_index</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>CHUNK</name></expr></argument>, <argument><expr><name>indexid</name></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>nkeys</name> <operator>=</operator> <name>nkeys</name></expr>,
		<expr><operator>.</operator><name>data</name> <operator>=</operator> <name>data</name></expr>,
		<expr><operator>.</operator><name>scankey</name> <operator>=</operator> <name>scankey</name></expr>,
		<expr><operator>.</operator><name>filter</name> <operator>=</operator> <name>filter</name></expr>,
		<expr><operator>.</operator><name>tuple_found</name> <operator>=</operator> <name>tuple_found</name></expr>,
		<expr><operator>.</operator><name>limit</name> <operator>=</operator> <name>limit</name></expr>,
		<expr><operator>.</operator><name>lockmode</name> <operator>=</operator> <name>lockmode</name></expr>,
		<expr><operator>.</operator><name>scandirection</name> <operator>=</operator> <name>scandir</name></expr>,
		<expr><operator>.</operator><name>result_mctx</name> <operator>=</operator> <name>mctx</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>ts_scanner_scan</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get a window of chunks that "precedes" the given dimensional point.
 *
 * For instance, if the dimension is "time", then given a point in time the
 * function returns the recent chunks that come before the chunk that includes
 * that point. The count parameter determines the number or slices the window
 * should include in the given dimension. Note, that with multi-dimensional
 * partitioning, there might be multiple chunks in each dimensional slice that
 * all precede the given point. For instance, the example below shows two
 * different situations that each go "back" two slices (count = 2) in the
 * x-dimension, but returns two vs. eight chunks due to different
 * partitioning.
 *
 * '_____________
 * '|   |   | * |
 * '|___|___|___|
 * '
 * '
 * '____ ________
 * '|   |   | * |
 * '|___|___|___|
 * '|   |   |   |
 * '|___|___|___|
 * '|   |   |   |
 * '|___|___|___|
 * '|   |   |   |
 * '|___|___|___|
 *
 * Note that the returned chunks will be allocated on the given memory
 * context, including the list itself. So, beware of not leaking the list if
 * the chunks are later cached somewhere else.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>ts_chunk_get_window</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>dimension_id</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>point</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>mctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>chunks</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DimensionVec</name> <modifier>*</modifier></type><name>dimvec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Scan for "count" slices that precede the point in the given dimension */</comment>
	<expr_stmt><expr><name>dimvec</name> <operator>=</operator> <call><name>ts_dimension_slice_scan_by_dimension_before_point</name><argument_list>(<argument><expr><name>dimension_id</name></expr></argument>,
															   <argument><expr><name>point</name></expr></argument>,
															   <argument><expr><name>count</name></expr></argument>,
															   <argument><expr><name>BackwardScanDirection</name></expr></argument>,
															   <argument><expr><name>mctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * For each slice, join with any constraints that reference the slice.
	 * There might be multiple constraints for each slice in case of
	 * multi-dimensional partitioning.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>dimvec</name><operator>-&gt;</operator><name>num_slices</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DimensionSlice</name> <modifier>*</modifier></type><name>slice</name> <init>= <expr><name><name>dimvec</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ChunkConstraints</name> <modifier>*</modifier></type><name>ccs</name> <init>= <expr><call><name>ts_chunk_constraints_alloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>mctx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ts_chunk_constraint_scan_by_dimension_slice_id</name><argument_list>(<argument><expr><name><name>slice</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>, <argument><expr><name>ccs</name></expr></argument>, <argument><expr><name>mctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* For each constraint, find the corresponding chunk */</comment>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>ccs</name><operator>-&gt;</operator><name>num_constraints</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ChunkConstraint</name> <modifier>*</modifier></type><name>cc</name> <init>= <expr><operator>&amp;</operator><name><name>ccs</name><operator>-&gt;</operator><name>constraints</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name> <init>= <expr><call><name>ts_chunk_get_by_id</name><argument_list>(<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>chunk_id</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ScanIterator</name></type> <name>it</name></decl>;</decl_stmt>

			<comment type="block">/* Dropped chunks do not contain valid data and must not be returned */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>chunk</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>chunk</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <call><name>ts_chunk_constraint_scan_by_chunk_id</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>mctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>it</name> <operator>=</operator> <call><name>ts_dimension_slice_scan_iterator_create</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>mctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>chunk</name><operator>-&gt;</operator><name>cube</name></name> <operator>=</operator> <call><name>ts_hypercube_from_constraints</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>constraints</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ts_scan_iterator_close</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Allocate the list on the same memory context as the chunks */</comment>
			<expr_stmt><expr><name>old</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>mctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>chunks</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>chunks</name></expr></argument>, <argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
	<comment type="block">/* Assert that we never return dropped chunks */</comment>
	<do>do
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>chunks</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>ASSERT_IS_VALID_CHUNK</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block> while <condition>(<expr><name>false</name></expr>)</condition>;</do>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><name>chunks</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Chunk</name> <modifier>*</modifier></type>
<name>chunk_scan_find</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>indexid</name></decl></parameter>, <parameter><decl><type><name>ScanKeyData</name></type> <name><name>scankey</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nkeys</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>mctx</name></decl></parameter>,
				<parameter><decl><type><name>bool</name></type> <name>fail_if_not_found</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DisplayKeyData</name></type> <name><name>displaykey</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ChunkStubScanCtx</name></type> <name>stubctx</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>num_found</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>num_found</name> <operator>=</operator> <call><name>chunk_scan_internal</name><argument_list>(<argument><expr><name>indexid</name></expr></argument>,
									<argument><expr><name>scankey</name></expr></argument>,
									<argument><expr><name>nkeys</name></expr></argument>,
									<argument><expr><name>chunk_tuple_dropped_filter</name></expr></argument>,
									<argument><expr><name>chunk_tuple_found</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>stubctx</name></expr></argument>,
									<argument><expr><literal type="number">1</literal></expr></argument>,
									<argument><expr><name>ForwardScanDirection</name></expr></argument>,
									<argument><expr><name>AccessShareLock</name></expr></argument>,
									<argument><expr><name>mctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>num_found</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>num_found</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>stubctx</name><operator>.</operator><name>is_dropped</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>chunk</name> <operator>=</operator> <name><name>stubctx</name><operator>.</operator><name>chunk</name></name></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name>num_found</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><literal type="number">0</literal></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>fail_if_not_found</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>StringInfo</name></type> <name>info</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
				<while>while <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>nkeys</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>info</name></expr></argument>,
									 <argument><expr><literal type="string">"%s: %s"</literal></expr></argument>,
									 <argument><expr><name><name>displaykey</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>,
									 <argument><expr><name><name>displaykey</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>as_string</name><argument_list>(<argument><expr><name><name>scankey</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sk_argument</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>++</operator><name>i</name> <operator>&lt;</operator> <name>nkeys</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>info</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></while>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"chunk not found"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>info</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><literal type="number">1</literal></expr>:</case>
			<expr_stmt><expr><call><name>ASSERT_IS_VALID_CHUNK</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"expected a single chunk, found %d"</literal></expr></argument>, <argument><expr><name>num_found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<return>return <expr><name>chunk</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Chunk</name> <modifier>*</modifier></type>
<name>ts_chunk_get_by_name_with_memory_context</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>schema_name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>table_name</name></decl></parameter>,
										 <parameter><decl><type><name>MemoryContext</name></type> <name>mctx</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>fail_if_not_found</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NameData</name></type> <name>schema</name></decl>, <decl><type ref="prev"/><name>table</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scankey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>DisplayKeyData</name></type> <name><name>displaykey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{
		<expr><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>=</operator> <block>{ <expr><operator>.</operator><name>name</name> <operator>=</operator> <literal type="string">"schema_name"</literal></expr>, <expr><operator>.</operator><name>as_string</name> <operator>=</operator> <name>DatumGetNameString</name></expr> }</block></expr>,
		<expr><index>[<expr><literal type="number">1</literal></expr>]</index> <operator>=</operator> <block>{ <expr><operator>.</operator><name>name</name> <operator>=</operator> <literal type="string">"table_name"</literal></expr>, <expr><operator>.</operator><name>as_string</name> <operator>=</operator> <name>DatumGetNameString</name></expr> }</block></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Early check for rogue input */</comment>
	<if_stmt><if>if <condition>(<expr><name>schema_name</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>table_name</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>fail_if_not_found</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"chunk not found"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"schema_name: %s, table_name: %s"</literal></expr></argument>,
							   <argument><expr><ternary><condition><expr><name>schema_name</name></expr> ?</condition><then> <expr><name>schema_name</name></expr> </then><else>: <expr><literal type="string">"&lt;null&gt;"</literal></expr></else></ternary></expr></argument>,
							   <argument><expr><ternary><condition><expr><name>table_name</name></expr> ?</condition><then> <expr><name>table_name</name></expr> </then><else>: <expr><literal type="string">"&lt;null&gt;"</literal></expr></else></ternary></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>schema</name></expr></argument>, <argument><expr><name>schema_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>table</name></expr></argument>, <argument><expr><name>table_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Perform an index scan on chunk name.
	 */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scankey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_chunk_schema_name_idx_schema_name</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
				<argument><expr><name>F_NAMEEQ</name></expr></argument>,
				<argument><expr><call><name>NameGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>schema</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scankey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_chunk_schema_name_idx_table_name</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
				<argument><expr><name>F_NAMEEQ</name></expr></argument>,
				<argument><expr><call><name>NameGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>table</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>chunk_scan_find</name><argument_list>(<argument><expr><name>CHUNK_SCHEMA_NAME_INDEX</name></expr></argument>,
						   <argument><expr><name>scankey</name></expr></argument>,
						   <argument><expr><literal type="number">2</literal></expr></argument>,
						   <argument><expr><name>mctx</name></expr></argument>,
						   <argument><expr><name>fail_if_not_found</name></expr></argument>,
						   <argument><expr><name>displaykey</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Chunk</name> <modifier>*</modifier></type>
<name>ts_chunk_get_by_relid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>fail_if_not_found</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>schema</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>table</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>fail_if_not_found</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid Oid"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>schema</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>table</name> <operator>=</operator> <call><name>get_rel_name</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>chunk_get_by_name</name><argument_list>(<argument><expr><name>schema</name></expr></argument>, <argument><expr><name>table</name></expr></argument>, <argument><expr><name>fail_if_not_found</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ts_chunk_free</name><parameter_list>(<parameter><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>chunk</name><operator>-&gt;</operator><name>cube</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ts_hypercube_free</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>cube</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>chunk</name><operator>-&gt;</operator><name>constraints</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ChunkConstraints</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><name><name>chunk</name><operator>-&gt;</operator><name>constraints</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>constraints</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>data_nodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>DatumGetInt32AsString</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>datum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="block">/* sign, 10 digits, '\0' */</comment>
	<expr_stmt><expr><call><name>pg_ltoa</name><argument_list>(<argument><expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Chunk</name> <modifier>*</modifier></type>
<name>ts_chunk_get_by_id</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>fail_if_not_found</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scankey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>DisplayKeyData</name></type> <name><name>displaykey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{
		<expr><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>=</operator> <block>{ <expr><operator>.</operator><name>name</name> <operator>=</operator> <literal type="string">"id"</literal></expr>, <expr><operator>.</operator><name>as_string</name> <operator>=</operator> <name>DatumGetInt32AsString</name></expr> }</block></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Perform an index scan on chunk id.
	 */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scankey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_chunk_idx_id</name></expr></argument>, <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_INT4EQ</name></expr></argument>, <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>chunk_scan_find</name><argument_list>(<argument><expr><name>CHUNK_ID_INDEX</name></expr></argument>,
						   <argument><expr><name>scankey</name></expr></argument>,
						   <argument><expr><literal type="number">1</literal></expr></argument>,
						   <argument><expr><name>CurrentMemoryContext</name></expr></argument>,
						   <argument><expr><name>fail_if_not_found</name></expr></argument>,
						   <argument><expr><name>displaykey</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Number of chunks created after given chunk.
 * If chunk2.id &gt; chunk1.id then chunk2 is created after chunk1
 */</comment>
<function><type><name>int</name></type>
<name>ts_chunk_num_of_chunks_created_after</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scankey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Try to find chunks with a greater Id then a given chunk
	 */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scankey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_chunk_idx_id</name></expr></argument>,
				<argument><expr><name>BTGreaterStrategyNumber</name></expr></argument>,
				<argument><expr><name>F_INT4GT</name></expr></argument>,
				<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>chunk_scan_internal</name><argument_list>(<argument><expr><name>CHUNK_ID_INDEX</name></expr></argument>,
							   <argument><expr><name>scankey</name></expr></argument>,
							   <argument><expr><literal type="number">1</literal></expr></argument>,
							   <argument><expr><name>NULL</name></expr></argument>,
							   <argument><expr><name>NULL</name></expr></argument>,
							   <argument><expr><name>NULL</name></expr></argument>,
							   <argument><expr><literal type="number">0</literal></expr></argument>,
							   <argument><expr><name>ForwardScanDirection</name></expr></argument>,
							   <argument><expr><name>AccessShareLock</name></expr></argument>,
							   <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Simple scans provide lightweight ways to access chunk information without the
 * overhead of getting a full chunk (i.e., no extra metadata, like constraints,
 * are joined in). This function forms the basis of a number of lookup functions
 * that, e.g., translates a chunk relid to a chunk_id, or vice versa.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>chunk_simple_scan</name><parameter_list>(<parameter><decl><type><name>ScanIterator</name> <modifier>*</modifier></type><name>iterator</name></decl></parameter>, <parameter><decl><type><name>FormData_chunk</name> <modifier>*</modifier></type><name>form</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>,
				  <parameter><decl><type><specifier>const</specifier> <name>DisplayKeyData</name></type> <name><name>displaykey</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<macro><name>ts_scanner_foreach</name><argument_list>(<argument>iterator</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name> <init>= <expr><call><name>ts_scan_iterator_tuple_info</name><argument_list>(<argument><expr><name>iterator</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ts_chunk_formdata_fill</name><argument_list>(<argument><expr><name>form</name></expr></argument>, <argument><expr><name>ti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>form</name><operator>-&gt;</operator><name>dropped</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>count</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>count</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>missing_ok</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StringInfo</name></type> <name>info</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<while>while <condition>(<expr><name>i</name> <operator>&lt;</operator> <name><name>iterator</name><operator>-&gt;</operator><name>ctx</name><operator>.</operator><name>nkeys</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>info</name></expr></argument>,
							 <argument><expr><literal type="string">"%s: %s"</literal></expr></argument>,
							 <argument><expr><name><name>displaykey</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>,
							 <argument><expr><name><name>displaykey</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>as_string</name><argument_list>(<argument><expr><name><name>iterator</name><operator>-&gt;</operator><name>ctx</name><operator>.</operator><name>scankey</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sk_argument</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>++</operator><name>i</name> <operator>&lt;</operator> <name><name>iterator</name><operator>-&gt;</operator><name>ctx</name><operator>.</operator><name>nkeys</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>info</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></while>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"chunk not found"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>count</name> <operator>==</operator> <literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>chunk_simple_scan_by_name</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>schema</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>table</name></decl></parameter>, <parameter><decl><type><name>FormData_chunk</name> <modifier>*</modifier></type><name>form</name></decl></parameter>,
						  <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScanIterator</name></type> <name>iterator</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>DisplayKeyData</name></type> <name><name>displaykey</name><index>[]</index></name> <init>= <expr><block>{
		<expr><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>=</operator> <block>{ <expr><operator>.</operator><name>name</name> <operator>=</operator> <literal type="string">"schema_name"</literal></expr>, <expr><operator>.</operator><name>as_string</name> <operator>=</operator> <name>DatumGetNameString</name></expr> }</block></expr>,
		<expr><index>[<expr><literal type="number">1</literal></expr>]</index> <operator>=</operator> <block>{ <expr><operator>.</operator><name>name</name> <operator>=</operator> <literal type="string">"table_name"</literal></expr>, <expr><operator>.</operator><name>as_string</name> <operator>=</operator> <name>DatumGetNameString</name></expr> }</block></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>schema</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>table</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>iterator</name> <operator>=</operator> <call><name>ts_scan_iterator_create</name><argument_list>(<argument><expr><name>CHUNK</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>, <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>init_scan_by_qualified_table_name</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>, <argument><expr><name>schema</name></expr></argument>, <argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>chunk_simple_scan</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>, <argument><expr><name>form</name></expr></argument>, <argument><expr><name>missing_ok</name></expr></argument>, <argument><expr><name>displaykey</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>chunk_simple_scan_by_relid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>FormData_chunk</name> <modifier>*</modifier></type><name>form</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>table</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>table</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type> <name>nspid</name> <init>= <expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>schema</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>nspid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>found</name> <operator>=</operator> <call><name>chunk_simple_scan_by_name</name><argument_list>(<argument><expr><name>schema</name></expr></argument>, <argument><expr><name>table</name></expr></argument>, <argument><expr><name>form</name></expr></argument>, <argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>missing_ok</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"chunk with relid %u not found"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>found</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>chunk_simple_scan_by_id</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>chunk_id</name></decl></parameter>, <parameter><decl><type><name>FormData_chunk</name> <modifier>*</modifier></type><name>form</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScanIterator</name></type> <name>iterator</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>DisplayKeyData</name></type> <name><name>displaykey</name><index>[]</index></name> <init>= <expr><block>{
		<expr><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>=</operator> <block>{ <expr><operator>.</operator><name>name</name> <operator>=</operator> <literal type="string">"id"</literal></expr>, <expr><operator>.</operator><name>as_string</name> <operator>=</operator> <name>DatumGetInt32AsString</name></expr> }</block></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>iterator</name> <operator>=</operator> <call><name>ts_scan_iterator_create</name><argument_list>(<argument><expr><name>CHUNK</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>, <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_chunk_scan_iterator_set_chunk_id</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>, <argument><expr><name>chunk_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>chunk_simple_scan</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>, <argument><expr><name>form</name></expr></argument>, <argument><expr><name>missing_ok</name></expr></argument>, <argument><expr><name>displaykey</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Lookup a Chunk ID from a chunk's relid.
 */</comment>
<function><type><name>Datum</name></type>
<name>ts_chunk_id_from_relid</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>Oid</name></type> <name>last_relid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>int32</name></type> <name>last_id</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FormData_chunk</name></type> <name>form</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>last_relid</name> <operator>==</operator> <name>relid</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>last_id</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>chunk_simple_scan_by_relid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>form</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>last_relid</name> <operator>=</operator> <name>relid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>last_id</name> <operator>=</operator> <name><name>form</name><operator>.</operator><name>id</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><name>last_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int32</name></type>
<name>ts_chunk_get_id_by_relid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FormData_chunk</name></type> <name>form</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>chunk_simple_scan_by_relid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>form</name></expr></argument>, <comment type="block">/* missing_ok = */</comment> <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>form</name><operator>.</operator><name>id</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ts_chunk_exists_relid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FormData_chunk</name></type> <name>form</name></decl>;</decl_stmt>

	<return>return <expr><call><name>chunk_simple_scan_by_relid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>form</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Returns 0 if there is no chunk with such reloid.
 */</comment>
<function><type><name>int32</name></type>
<name>ts_chunk_get_hypertable_id_by_relid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FormData_chunk</name></type> <name>form</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>chunk_simple_scan_by_relid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>form</name></expr></argument>, <comment type="block">/* missing_ok = */</comment> <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name><name>form</name><operator>.</operator><name>hypertable_id</name></name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Returns the compressed chunk id. The original chunk must exist.
 */</comment>
<function><type><name>int32</name></type>
<name>ts_chunk_get_compressed_chunk_id</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>chunk_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FormData_chunk</name></type> <name>form</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PG_USED_FOR_ASSERTS_ONLY</name> <name>bool</name></type> <name>result</name> <init>=
		<expr><call><name>chunk_simple_scan_by_id</name><argument_list>(<argument><expr><name>chunk_id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>form</name></expr></argument>, <comment type="block">/* missing_ok = */</comment> <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>form</name><operator>.</operator><name>compressed_chunk_id</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Returns false if there is no chunk with such reloid.
 */</comment>
<function><type><name>bool</name></type>
<name>ts_chunk_get_hypertable_id_and_status_by_relid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>hypertable_id</name></decl></parameter>, <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>chunk_status</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FormData_chunk</name></type> <name>form</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>hypertable_id</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>chunk_status</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>chunk_simple_scan_by_relid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>form</name></expr></argument>, <comment type="block">/* missing_ok = */</comment> <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>hypertable_id</name> <operator>=</operator> <name><name>form</name><operator>.</operator><name>hypertable_id</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>chunk_status</name> <operator>=</operator> <name><name>form</name><operator>.</operator><name>status</name></name></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get the relid of a chunk given its ID.
 */</comment>
<function><type><name>Oid</name></type>
<name>ts_chunk_get_relid</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>chunk_id</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FormData_chunk</name></type> <name>form</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>chunk_simple_scan_by_id</name><argument_list>(<argument><expr><name>chunk_id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>form</name></expr></argument>, <argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>schemaid</name> <init>= <expr><call><name>get_namespace_oid</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>form</name><operator>.</operator><name>schema_name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>schemaid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>get_relname_relid</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>form</name><operator>.</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>schemaid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>missing_ok</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_SCHEMA</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"chunk with id %d not found"</literal></expr></argument>, <argument><expr><name>chunk_id</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>relid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get the schema (namespace) of a chunk given its ID.
 *
 * This is a lightweight way to get the schema of a chunk without creating a
 * full Chunk object that joins in constraints, etc.
 */</comment>
<function><type><name>Oid</name></type>
<name>ts_chunk_get_schema_id</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>chunk_id</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FormData_chunk</name></type> <name>form</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>chunk_simple_scan_by_id</name><argument_list>(<argument><expr><name>chunk_id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>form</name></expr></argument>, <argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><call><name>get_namespace_oid</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>form</name><operator>.</operator><name>schema_name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ts_chunk_get_id</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>schema</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>table</name></decl></parameter>, <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>chunk_id</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FormData_chunk</name></type> <name>form</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>chunk_simple_scan_by_name</name><argument_list>(<argument><expr><name>schema</name></expr></argument>, <argument><expr><name>table</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>form</name></expr></argument>, <argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>chunk_id</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>chunk_id</name> <operator>=</operator> <name><name>form</name><operator>.</operator><name>id</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Results of deleting a chunk.
 *
 * A chunk can be deleted in two ways: (1) full delete of data and metadata,
 * (2) delete data but preserve metadata (marked with dropped=true). The
 * deletion mode (preserve or not) combined with the current state of the
 * "dropped" flag on a chunk metadata row leads to a cross-product resulting
 * in the following outcomes:
 */</comment>
<typedef>typedef <type><enum>enum <name>ChunkDeleteResult</name>
<block>{
	<comment type="block">/* Deleted a live chunk */</comment>
	<decl><name>CHUNK_DELETED</name></decl>,
	<comment type="block">/* Deleted a chunk previously marked "dropped" */</comment>
	<decl><name>CHUNK_DELETED_DROPPED</name></decl>,
	<comment type="block">/* Marked a chunk as dropped instead of deleting */</comment>
	<decl><name>CHUNK_MARKED_DROPPED</name></decl>,
	<comment type="block">/* Tried to mark a chunk as dropped when it was already marked */</comment>
	<decl><name>CHUNK_ALREADY_MARKED_DROPPED</name></decl>,
}</block></enum></type> <name>ChunkDeleteResult</name>;</typedef>

<comment type="block">/* Delete the chunk tuple.
 *
 * preserve_chunk_catalog_row - instead of deleting the row, mark it as dropped.
 * this is used when we need to preserve catalog information about the chunk
 * after dropping it. Currently only used when preserving continuous aggregates
 * on the chunk after the raw data was dropped. Otherwise, we'd have dangling
 * chunk ids left over in the materialization table. Preserve the space dimension
 * info about these chunks too.
 *
 * When chunk rows are preserved, the rows need to be updated to set the
 * 'dropped' flag to TRUE. But since this produces a new tuple into the
 * metadata table we will process also the new tuple in the same loop, which
 * is not only inefficient but could also lead to bugs. For now, we just ignore
 * those tuples (the CHUNK_ALREADY_MARKED_DROPPED case), but ideally we
 * shouldn't scan the updated tuples at all since it means double the number
 * of tuples to process.
 */</comment>
<function><type><specifier>static</specifier> <name>ChunkDeleteResult</name></type>
<name>chunk_tuple_delete</name><parameter_list>(<parameter><decl><type><name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name></decl></parameter>, <parameter><decl><type><name>DropBehavior</name></type> <name>behavior</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>preserve_chunk_catalog_row</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FormData_chunk</name></type> <name>form</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CatalogSecurityContext</name></type> <name>sec_ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ChunkConstraints</name> <modifier>*</modifier></type><name>ccs</name> <init>= <expr><call><name>ts_chunk_constraints_alloc</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>ti</name><operator>-&gt;</operator><name>mctx</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ChunkDeleteResult</name></type> <name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ts_chunk_formdata_fill</name><argument_list>(<argument><expr><operator>&amp;</operator><name>form</name></expr></argument>, <argument><expr><name>ti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>preserve_chunk_catalog_row</name> <operator>&amp;&amp;</operator> <name><name>form</name><operator>.</operator><name>dropped</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>CHUNK_ALREADY_MARKED_DROPPED</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* if only marking as deleted, keep the constraints and dimension info */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>preserve_chunk_catalog_row</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ts_chunk_constraint_delete_by_chunk_id</name><argument_list>(<argument><expr><name><name>form</name><operator>.</operator><name>id</name></name></expr></argument>, <argument><expr><name>ccs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Check for dimension slices that are orphaned by the chunk deletion */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ccs</name><operator>-&gt;</operator><name>num_constraints</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ChunkConstraint</name> <modifier>*</modifier></type><name>cc</name> <init>= <expr><operator>&amp;</operator><name><name>ccs</name><operator>-&gt;</operator><name>constraints</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Delete the dimension slice if there are no remaining constraints
			 * referencing it
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>is_dimension_constraint</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Dimension slices are shared between chunk constraints and
				 * subsequently between chunks as well. Since different chunks
				 * can reference the same dimension slice (through the chunk
				 * constraint), we must lock the dimension slice in FOR UPDATE
				 * mode *prior* to scanning the chunk constraints table. If we
				 * do not do that, we can have the following scenario:
				 *
				 * - T1: Prepares to create a chunk that uses an existing dimension slice X
				 * - T2: Deletes a chunk and dimension slice X because it is not
				 *   references by a chunk constraint.
				 * - T1: Adds a chunk constraint referencing dimension
				 *   slice X (which is about to be deleted by T2).
				 */</comment>
				<decl_stmt><decl><type><name>ScanTupLock</name></type> <name>tuplock</name> <init>= <expr><block>{
					<expr><operator>.</operator><name>lockmode</name> <operator>=</operator> <name>LockTupleExclusive</name></expr>,
					<expr><operator>.</operator><name>waitpolicy</name> <operator>=</operator> <name>LockWaitBlock</name></expr>,
				}</block></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>DimensionSlice</name> <modifier>*</modifier></type><name>slice</name> <init>=
					<expr><call><name>ts_dimension_slice_scan_by_id_and_lock</name><argument_list>(<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>dimension_slice_id</name></name></expr></argument>,
														   <argument><expr><operator>&amp;</operator><name>tuplock</name></expr></argument>,
														   <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<comment type="block">/* If the slice is not found in the scan above, the table is
				 * broken so we do not delete the slice. We proceed
				 * anyway since users need to be able to drop broken tables or
				 * remove broken chunks. */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>slice</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><specifier>const</specifier> <name>Hypertable</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ht</name> <init>= <expr><call><name>ts_hypertable_get_by_id</name><argument_list>(<argument><expr><name><name>form</name><operator>.</operator><name>hypertable_id</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected state for chunk %s.%s, dropping anyway"</literal></expr></argument>,
									<argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>form</name><operator>.</operator><name>schema_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>form</name><operator>.</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The integrity of hypertable %s.%s might be "</literal>
									   <literal type="string">"compromised "</literal>
									   <literal type="string">"since one of its chunks lacked a dimension slice."</literal></expr></argument>,
									   <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>schema_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><call><name>ts_chunk_constraint_scan_by_dimension_slice_id</name><argument_list>(<argument><expr><name><name>slice</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>,
																		<argument><expr><name>NULL</name></expr></argument>,
																		<argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ts_dimension_slice_delete_by_id</name><argument_list>(<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>dimension_slice_id</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ts_chunk_index_delete_by_chunk_id</name><argument_list>(<argument><expr><name><name>form</name><operator>.</operator><name>id</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_compression_chunk_size_delete</name><argument_list>(<argument><expr><name><name>form</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_chunk_data_node_delete_by_chunk_id</name><argument_list>(<argument><expr><name><name>form</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Delete any row in bgw_policy_chunk-stats corresponding to this chunk */</comment>
	<expr_stmt><expr><call><name>ts_bgw_policy_chunk_stats_delete_by_chunk_id</name><argument_list>(<argument><expr><name><name>form</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>form</name><operator>.</operator><name>compressed_chunk_id</name></name> <operator>!=</operator> <name>INVALID_CHUNK_ID</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>compressed_chunk</name> <init>= <expr><call><name>ts_chunk_get_by_id</name><argument_list>(<argument><expr><name><name>form</name><operator>.</operator><name>compressed_chunk_id</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* The chunk may have been delete by a CASCADE */</comment>
		<if_stmt><if>if <condition>(<expr><name>compressed_chunk</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<comment type="block">/* Plain drop without preserving catalog row because this is the compressed
			 * chunk */</comment>
			<expr_stmt><expr><call><name>ts_chunk_drop</name><argument_list>(<argument><expr><name>compressed_chunk</name></expr></argument>, <argument><expr><name>behavior</name></expr></argument>, <argument><expr><name>DEBUG1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ts_catalog_database_info_become_owner</name><argument_list>(<argument><expr><call><name>ts_catalog_database_info_get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>preserve_chunk_catalog_row</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ts_catalog_delete_tid</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>scanrel</name></name></expr></argument>, <argument><expr><call><name>ts_scanner_get_tuple_tid</name><argument_list>(<argument><expr><name>ti</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>form</name><operator>.</operator><name>dropped</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <name>CHUNK_DELETED_DROPPED</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <name>CHUNK_DELETED</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type> <name>new_tuple</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>form</name><operator>.</operator><name>dropped</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>form</name><operator>.</operator><name>compressed_chunk_id</name></name> <operator>=</operator> <name>INVALID_CHUNK_ID</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>form</name><operator>.</operator><name>dropped</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>form</name><operator>.</operator><name>status</name></name> <operator>=</operator> <name>CHUNK_STATUS_DEFAULT</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>new_tuple</name> <operator>=</operator> <call><name>chunk_formdata_make_tuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name>form</name></expr></argument>, <argument><expr><call><name>ts_scanner_get_tupledesc</name><argument_list>(<argument><expr><name>ti</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ts_catalog_update_tid</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>scanrel</name></name></expr></argument>, <argument><expr><call><name>ts_scanner_get_tuple_tid</name><argument_list>(<argument><expr><name>ti</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>new_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>new_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <name>CHUNK_MARKED_DROPPED</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>ts_catalog_restore_user</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>init_scan_by_qualified_table_name</name><parameter_list>(<parameter><decl><type><name>ScanIterator</name> <modifier>*</modifier></type><name>iterator</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>schema_name</name></decl></parameter>,
								  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>table_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>ctx</name><operator>.</operator><name>index</name></name> <operator>=</operator> <call><name>catalog_get_index</name><argument_list>(<argument><expr><call><name>ts_catalog_get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>CHUNK</name></expr></argument>, <argument><expr><name>CHUNK_SCHEMA_NAME_INDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_scan_iterator_scan_key_init</name><argument_list>(<argument><expr><name>iterator</name></expr></argument>,
								   <argument><expr><name>Anum_chunk_schema_name_idx_schema_name</name></expr></argument>,
								   <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
								   <argument><expr><name>F_NAMEEQ</name></expr></argument>,
								   <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>schema_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_scan_iterator_scan_key_init</name><argument_list>(<argument><expr><name>iterator</name></expr></argument>,
								   <argument><expr><name>Anum_chunk_schema_name_idx_table_name</name></expr></argument>,
								   <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
								   <argument><expr><name>F_NAMEEQ</name></expr></argument>,
								   <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>table_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>chunk_delete</name><parameter_list>(<parameter><decl><type><name>ScanIterator</name> <modifier>*</modifier></type><name>iterator</name></decl></parameter>, <parameter><decl><type><name>DropBehavior</name></type> <name>behavior</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>preserve_chunk_catalog_row</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<macro><name>ts_scanner_foreach</name><argument_list>(<argument>iterator</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ChunkDeleteResult</name></type> <name>res</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>chunk_tuple_delete</name><argument_list>(<argument><expr><call><name>ts_scan_iterator_tuple_info</name><argument_list>(<argument><expr><name>iterator</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><name>behavior</name></expr></argument>,
								 <argument><expr><name>preserve_chunk_catalog_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<switch>switch <condition>(<expr><name>res</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>CHUNK_DELETED</name></expr>:</case>
			<case>case <expr><name>CHUNK_MARKED_DROPPED</name></expr>:</case>
				<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>CHUNK_ALREADY_MARKED_DROPPED</name></expr>:</case>
			<case>case <expr><name>CHUNK_DELETED_DROPPED</name></expr>:</case>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block>

	<return>return <expr><name>count</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>ts_chunk_delete_by_name_internal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>schema</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>table</name></decl></parameter>, <parameter><decl><type><name>DropBehavior</name></type> <name>behavior</name></decl></parameter>,
								 <parameter><decl><type><name>bool</name></type> <name>preserve_chunk_catalog_row</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScanIterator</name></type> <name>iterator</name> <init>= <expr><call><name>ts_scan_iterator_create</name><argument_list>(<argument><expr><name>CHUNK</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>, <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>count</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>init_scan_by_qualified_table_name</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>, <argument><expr><name>schema</name></expr></argument>, <argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>count</name> <operator>=</operator> <call><name>chunk_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>, <argument><expr><name>behavior</name></expr></argument>, <argument><expr><name>preserve_chunk_catalog_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* (schema,table) names and (hypertable_id) are unique so should only have
	 * dropped one chunk or none (if not found) */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>count</name> <operator>==</operator> <literal type="number">1</literal> <operator>||</operator> <name>count</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>count</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>ts_chunk_delete_by_name</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>schema</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>table</name></decl></parameter>, <parameter><decl><type><name>DropBehavior</name></type> <name>behavior</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>ts_chunk_delete_by_name_internal</name><argument_list>(<argument><expr><name>schema</name></expr></argument>, <argument><expr><name>table</name></expr></argument>, <argument><expr><name>behavior</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>ts_chunk_delete_by_relid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>DropBehavior</name></type> <name>behavior</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>preserve_chunk_catalog_row</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><call><name>ts_chunk_delete_by_name_internal</name><argument_list>(<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><name>behavior</name></expr></argument>,
											<argument><expr><name>preserve_chunk_catalog_row</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>init_scan_by_hypertable_id</name><parameter_list>(<parameter><decl><type><name>ScanIterator</name> <modifier>*</modifier></type><name>iterator</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>hypertable_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>ctx</name><operator>.</operator><name>index</name></name> <operator>=</operator> <call><name>catalog_get_index</name><argument_list>(<argument><expr><call><name>ts_catalog_get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>CHUNK</name></expr></argument>, <argument><expr><name>CHUNK_HYPERTABLE_ID_INDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_scan_iterator_scan_key_init</name><argument_list>(<argument><expr><name>iterator</name></expr></argument>,
								   <argument><expr><name>Anum_chunk_hypertable_id_idx_hypertable_id</name></expr></argument>,
								   <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
								   <argument><expr><name>F_INT4EQ</name></expr></argument>,
								   <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>hypertable_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>ts_chunk_delete_by_hypertable_id</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>hypertable_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScanIterator</name></type> <name>iterator</name> <init>= <expr><call><name>ts_scan_iterator_create</name><argument_list>(<argument><expr><name>CHUNK</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>, <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>init_scan_by_hypertable_id</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>, <argument><expr><name>hypertable_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>chunk_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>, <argument><expr><name>DROP_RESTRICT</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ts_chunk_exists_with_compression</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>hypertable_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScanIterator</name></type> <name>iterator</name> <init>= <expr><call><name>ts_scan_iterator_create</name><argument_list>(<argument><expr><name>CHUNK</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>, <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>init_scan_by_hypertable_id</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>, <argument><expr><name>hypertable_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>ts_scanner_foreach</name><argument_list>(<argument>&amp;iterator</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>isnull_dropped</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>isnull_chunk_id</name> <init>=
			<expr><call><name>slot_attisnull</name><argument_list>(<argument><expr><call><name>ts_scan_iterator_slot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Anum_chunk_compressed_chunk_id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>dropped</name> <init>= <expr><call><name>DatumGetBool</name><argument_list>(
			<argument><expr><call><name>slot_getattr</name><argument_list>(<argument><expr><call><name>ts_scan_iterator_slot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Anum_chunk_dropped</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull_dropped</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="block">/* dropped is not NULLABLE */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull_dropped</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull_chunk_id</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>dropped</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>ts_scan_iterator_close</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>found</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>init_scan_by_compressed_chunk_id</name><parameter_list>(<parameter><decl><type><name>ScanIterator</name> <modifier>*</modifier></type><name>iterator</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>compressed_chunk_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>ctx</name><operator>.</operator><name>index</name></name> <operator>=</operator>
		<call><name>catalog_get_index</name><argument_list>(<argument><expr><call><name>ts_catalog_get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>CHUNK</name></expr></argument>, <argument><expr><name>CHUNK_COMPRESSED_CHUNK_ID_INDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_scan_iterator_scan_key_init</name><argument_list>(<argument><expr><name>iterator</name></expr></argument>,
								   <argument><expr><name>Anum_chunk_compressed_chunk_id_idx_compressed_chunk_id</name></expr></argument>,
								   <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
								   <argument><expr><name>F_INT4EQ</name></expr></argument>,
								   <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>compressed_chunk_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Chunk</name> <modifier>*</modifier></type>
<name>ts_chunk_get_compressed_chunk_parent</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScanIterator</name></type> <name>iterator</name> <init>= <expr><call><name>ts_scan_iterator_create</name><argument_list>(<argument><expr><name>CHUNK</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>, <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>parent_id</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>init_scan_by_compressed_chunk_id</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>, <argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>ts_scanner_foreach</name><argument_list>(<argument>&amp;iterator</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name> <init>= <expr><call><name>ts_scan_iterator_tuple_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type> <name>datum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>isnull</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>parent_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>slot</name></name></expr></argument>, <argument><expr><name>Anum_chunk_id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>parent_id</name> <operator>=</operator> <call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>parent_id</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>ts_chunk_get_by_id</name><argument_list>(<argument><expr><name>parent_id</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ts_chunk_contains_compressed_data</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>parent_chunk</name> <init>= <expr><call><name>ts_chunk_get_compressed_chunk_parent</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>parent_chunk</name> <operator>!=</operator> <name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>List</name> <modifier>*</modifier></type>
<name>ts_chunk_get_chunk_ids_by_hypertable_id</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>hypertable_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>chunkids</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanIterator</name></type> <name>iterator</name> <init>= <expr><call><name>ts_scan_iterator_create</name><argument_list>(<argument><expr><name>CHUNK</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>, <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>init_scan_by_hypertable_id</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>, <argument><expr><name>hypertable_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>ts_scanner_foreach</name><argument_list>(<argument>&amp;iterator</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>isnull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type> <name>id</name> <init>= <expr><call><name>slot_getattr</name><argument_list>(<argument><expr><call><name>ts_scan_iterator_slot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Anum_chunk_id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>chunkids</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>chunkids</name></expr></argument>, <argument><expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>chunkids</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>List</name> <modifier>*</modifier></type>
<name>ts_chunk_get_all_chunk_ids</name><parameter_list>(<parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>chunkids</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanIterator</name></type> <name>iterator</name> <init>= <expr><call><name>ts_scan_iterator_create</name><argument_list>(<argument><expr><name>CHUNK</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ts_scan_iterator_set_index</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>, <argument><expr><name>CHUNK</name></expr></argument>, <argument><expr><name>CHUNK_ID_INDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_scan_iterator_scan_key_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>,
								   <argument><expr><name>Anum_chunk_idx_id</name></expr></argument>,
								   <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
								   <argument><expr><name>F_INT4GE</name></expr></argument>,
								   <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>ts_scanner_foreach</name><argument_list>(<argument>&amp;iterator</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>isnull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type> <name>id</name> <init>= <expr><call><name>slot_getattr</name><argument_list>(<argument><expr><call><name>ts_scan_iterator_slot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Anum_chunk_id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>chunkids</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>chunkids</name></expr></argument>, <argument><expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>chunkids</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ChunkResult</name></type>
<name>chunk_recreate_constraint</name><parameter_list>(<parameter><decl><type><name>ChunkScanCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>ChunkStub</name> <modifier>*</modifier></type><name>stub</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ChunkConstraints</name> <modifier>*</modifier></type><name>ccs</name> <init>= <expr><name><name>stub</name><operator>-&gt;</operator><name>constraints</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ChunkStubScanCtx</name></type> <name>stubctx</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>stub</name> <operator>=</operator> <name>stub</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>chunk</name> <operator>=</operator> <call><name>chunk_create_from_stub</name><argument_list>(<argument><expr><operator>&amp;</operator><name>stubctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stubctx</name><operator>.</operator><name>is_dropped</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"should not be recreating constraints on dropped chunks"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ccs</name><operator>-&gt;</operator><name>num_constraints</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ts_chunk_constraint_recreate</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ccs</name><operator>-&gt;</operator><name>constraints</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>table_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<return>return <expr><name>CHUNK_PROCESSED</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ts_chunk_recreate_all_constraints_for_dimension</name><parameter_list>(<parameter><decl><type><name>Hyperspace</name> <modifier>*</modifier></type><name>hs</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>dimension_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DimensionVec</name> <modifier>*</modifier></type><name>slices</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ChunkScanCtx</name></type> <name>chunkctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>slices</name> <operator>=</operator> <call><name>ts_dimension_slice_scan_by_dimension</name><argument_list>(<argument><expr><name>dimension_id</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>slices</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>chunk_scan_ctx_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>chunkctx</name></expr></argument>, <argument><expr><name>hs</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>slices</name><operator>-&gt;</operator><name>num_slices</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ts_chunk_constraint_scan_by_dimension_slice</name><argument_list>(<argument><expr><name><name>slices</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
													<argument><expr><operator>&amp;</operator><name>chunkctx</name></expr></argument>,
													<argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>chunk_scan_ctx_foreach_chunk_stub</name><argument_list>(<argument><expr><operator>&amp;</operator><name>chunkctx</name></expr></argument>, <argument><expr><name>chunk_recreate_constraint</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>chunk_scan_ctx_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>chunkctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Drops all FK constraints on a given chunk.
 * Currently it is used only for chunks, which have been compressed and
 * contain no data.
 */</comment>
<function><type><name>void</name></type>
<name>ts_chunk_drop_fks</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Chunk</name> <modifier>*</modifier><specifier>const</specifier></type> <name>chunk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>fks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ASSERT_IS_VALID_CHUNK</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>table_id</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>fks</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><call><name>RelationGetFKeyList</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>fks</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>ForeignKeyCacheInfo</name> <modifier>*</modifier><specifier>const</specifier></type> <name>fk</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>ForeignKeyCacheInfo</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ts_chunk_constraint_delete_by_constraint_name</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>,
													  <argument><expr><call><name>get_constraint_name</name><argument_list>(<argument><expr><name><name>fk</name><operator>-&gt;</operator><name>conoid</name></name></expr></argument>)</argument_list></call></expr></argument>,
													  <argument><expr><name>true</name></expr></argument>,
													  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Recreates all FK constraints on a chunk by using the constraints on the parent hypertable
 * as a template. Currently it is used only during chunk decompression, since FK constraints
 * are dropped during compression.
 */</comment>
<function><type><name>void</name></type>
<name>ts_chunk_create_fks</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Chunk</name> <modifier>*</modifier><specifier>const</specifier></type> <name>chunk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>fks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ASSERT_IS_VALID_CHUNK</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>hypertable_relid</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>fks</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><call><name>RelationGetFKeyList</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>fks</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ForeignKeyCacheInfo</name> <modifier>*</modifier></type><name>fk</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>ForeignKeyCacheInfo</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ts_chunk_constraint_create_on_chunk</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>, <argument><expr><name><name>fk</name><operator>-&gt;</operator><name>conoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ScanTupleResult</name></type>
<name>chunk_tuple_update_schema_and_table</name><parameter_list>(<parameter><decl><type><name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FormData_chunk</name></type> <name>form</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FormData_chunk</name> <modifier>*</modifier></type><name>update</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CatalogSecurityContext</name></type> <name>sec_ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>new_tuple</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ts_chunk_formdata_fill</name><argument_list>(<argument><expr><operator>&amp;</operator><name>form</name></expr></argument>, <argument><expr><name>ti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>form</name><operator>.</operator><name>schema_name</name></name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>update</name><operator>-&gt;</operator><name>schema_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>form</name><operator>.</operator><name>table_name</name></name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>update</name><operator>-&gt;</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>new_tuple</name> <operator>=</operator> <call><name>chunk_formdata_make_tuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name>form</name></expr></argument>, <argument><expr><call><name>ts_scanner_get_tupledesc</name><argument_list>(<argument><expr><name>ti</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ts_catalog_database_info_become_owner</name><argument_list>(<argument><expr><call><name>ts_catalog_database_info_get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_catalog_update_tid</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>scanrel</name></name></expr></argument>, <argument><expr><call><name>ts_scanner_get_tuple_tid</name><argument_list>(<argument><expr><name>ti</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>new_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_catalog_restore_user</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>new_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>SCAN_DONE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ScanTupleResult</name></type>
<name>chunk_tuple_update_status</name><parameter_list>(<parameter><decl><type><name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FormData_chunk</name></type> <name>form</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FormData_chunk</name> <modifier>*</modifier></type><name>update</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CatalogSecurityContext</name></type> <name>sec_ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>new_tuple</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ts_chunk_formdata_fill</name><argument_list>(<argument><expr><operator>&amp;</operator><name>form</name></expr></argument>, <argument><expr><name>ti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>form</name><operator>.</operator><name>status</name></name> <operator>=</operator> <name><name>update</name><operator>-&gt;</operator><name>status</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>new_tuple</name> <operator>=</operator> <call><name>chunk_formdata_make_tuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name>form</name></expr></argument>, <argument><expr><call><name>ts_scanner_get_tupledesc</name><argument_list>(<argument><expr><name>ti</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ts_catalog_database_info_become_owner</name><argument_list>(<argument><expr><call><name>ts_catalog_database_info_get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_catalog_update_tid</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>scanrel</name></name></expr></argument>, <argument><expr><call><name>ts_scanner_get_tuple_tid</name><argument_list>(<argument><expr><name>ti</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>new_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_catalog_restore_user</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>new_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>SCAN_DONE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>chunk_update_form</name><parameter_list>(<parameter><decl><type><name>FormData_chunk</name> <modifier>*</modifier></type><name>form</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scankey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scankey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_chunk_idx_id</name></expr></argument>, <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_INT4EQ</name></expr></argument>, <argument><expr><name><name>form</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>chunk_scan_internal</name><argument_list>(<argument><expr><name>CHUNK_ID_INDEX</name></expr></argument>,
							   <argument><expr><name>scankey</name></expr></argument>,
							   <argument><expr><literal type="number">1</literal></expr></argument>,
							   <argument><expr><name>NULL</name></expr></argument>,
							   <argument><expr><name>chunk_tuple_update_schema_and_table</name></expr></argument>,
							   <argument><expr><name>form</name></expr></argument>,
							   <argument><expr><literal type="number">0</literal></expr></argument>,
							   <argument><expr><name>ForwardScanDirection</name></expr></argument>,
							   <argument><expr><name>RowExclusiveLock</name></expr></argument>,
							   <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* update the status flag for chunk. Should not be called directly
 * Use chunk_update_status instead
 * Acquires RowExclusiveLock
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>chunk_update_status_internal</name><parameter_list>(<parameter><decl><type><name>FormData_chunk</name> <modifier>*</modifier></type><name>form</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scankey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scankey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_chunk_idx_id</name></expr></argument>, <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_INT4EQ</name></expr></argument>, <argument><expr><name><name>form</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>chunk_scan_internal</name><argument_list>(<argument><expr><name>CHUNK_ID_INDEX</name></expr></argument>,
							   <argument><expr><name>scankey</name></expr></argument>,
							   <argument><expr><literal type="number">1</literal></expr></argument>,
							   <argument><expr><name>NULL</name></expr></argument>,
							   <argument><expr><name>chunk_tuple_update_status</name></expr></argument>,
							   <argument><expr><name>form</name></expr></argument>,
							   <argument><expr><literal type="number">0</literal></expr></argument>,
							   <argument><expr><name>ForwardScanDirection</name></expr></argument>,
							   <argument><expr><name>RowExclusiveLock</name></expr></argument>,
							   <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* status update is done in 2 steps.
 * Do the equivalent of SELECT for UPDATE, followed by UPDATE
 * 1. RowShare lock to read the status.
 * 2. if status != proposed new status
 *      update status using RowExclusiveLock
 * All callers who want to update chunk status should call this function so that locks
 * are acquired correctly.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>chunk_update_status</name><parameter_list>(<parameter><decl><type><name>FormData_chunk</name> <modifier>*</modifier></type><name>form</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type> <name>chunk_id</name> <init>= <expr><name><name>form</name><operator>-&gt;</operator><name>id</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>new_status</name> <init>= <expr><name><name>form</name><operator>-&gt;</operator><name>status</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>success</name> <init>= <expr><name>true</name></expr></init></decl>, <decl><type ref="prev"/><name>dropped</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<comment type="block">/* lock the chunk tuple for update. Block till we get exclusivetuplelock */</comment>
	<decl_stmt><decl><type><name>ScanTupLock</name></type> <name>scantuplock</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>waitpolicy</name> <operator>=</operator> <name>LockWaitBlock</name></expr>,
		<expr><operator>.</operator><name>lockmode</name> <operator>=</operator> <name>LockTupleExclusive</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanIterator</name></type> <name>iterator</name> <init>= <expr><call><name>ts_scan_iterator_create</name><argument_list>(<argument><expr><name>CHUNK</name></expr></argument>, <argument><expr><name>RowShareLock</name></expr></argument>, <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>iterator</name><operator>.</operator><name>ctx</name><operator>.</operator><name>index</name></name> <operator>=</operator> <call><name>catalog_get_index</name><argument_list>(<argument><expr><call><name>ts_catalog_get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>CHUNK</name></expr></argument>, <argument><expr><name>CHUNK_ID_INDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>iterator</name><operator>.</operator><name>ctx</name><operator>.</operator><name>tuplock</name></name> <operator>=</operator> <operator>&amp;</operator><name>scantuplock</name></expr>;</expr_stmt>

	<comment type="block">/* see table_tuple_lock for details about flags that are set in TupleExclusive mode */</comment>
	<expr_stmt><expr><name><name>scantuplock</name><operator>.</operator><name>lockflags</name></name> <operator>=</operator> <name>TUPLE_LOCK_FLAG_LOCK_UPDATE_IN_PROGRESS</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsolationUsesXactSnapshot</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* in read committed mode, we follow all updates to this tuple */</comment>
		<expr_stmt><expr><name><name>scantuplock</name><operator>.</operator><name>lockflags</name></name> <operator>|=</operator> <name>TUPLE_LOCK_FLAG_FIND_LAST_VERSION</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ts_scan_iterator_scan_key_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>,
								   <argument><expr><name>Anum_chunk_idx_id</name></expr></argument>,
								   <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
								   <argument><expr><name>F_INT4EQ</name></expr></argument>,
								   <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>chunk_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>ts_scanner_foreach</name><argument_list>(<argument>&amp;iterator</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name> <init>= <expr><call><name>ts_scan_iterator_tuple_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>dropped_isnull</name></decl>, <decl><type ref="prev"/><name>status_isnull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dropped</name> <operator>=</operator> <call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>slot_getattr</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>slot</name></name></expr></argument>, <argument><expr><name>Anum_chunk_dropped</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dropped_isnull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>dropped_isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>slot_getattr</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>slot</name></name></expr></argument>, <argument><expr><name>Anum_chunk_status</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>status_isnull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>status_isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dropped</name> <operator>&amp;&amp;</operator> <name>status</name> <operator>!=</operator> <name>new_status</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>chunk_update_status_internal</name><argument_list>(<argument><expr><name>form</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// get RowExclusiveLock and update here</comment>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>ts_scan_iterator_close</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>dropped</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"attempt to update status(%d) on dropped chunk %d"</literal></expr></argument>, <argument><expr><name>new_status</name></expr></argument>, <argument><expr><name>chunk_id</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>success</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ts_chunk_set_name</name><parameter_list>(<parameter><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>table_name</name></name></expr></argument>, <argument><expr><name>newname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>chunk_update_form</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>chunk</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ts_chunk_set_schema</name><parameter_list>(<parameter><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newschema</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>schema_name</name></name></expr></argument>, <argument><expr><name>newschema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>chunk_update_form</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>chunk</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ts_chunk_set_unordered</name><parameter_list>(<parameter><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ts_chunk_is_compressed</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>ts_chunk_add_status</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>CHUNK_STATUS_COMPRESSED_UNORDERED</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ts_chunk_set_partial</name><parameter_list>(<parameter><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ts_chunk_is_compressed</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>ts_chunk_add_status</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>CHUNK_STATUS_COMPRESSED_PARTIAL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* No inserts, updates, and deletes are permitted on a frozen chunk.
 * Compression policies etc do not run on a frozen chunk.
 * Only valid operation is dropping the chunk
 */</comment>
<function><type><name>bool</name></type>
<name>ts_chunk_set_frozen</name><parameter_list>(<parameter><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_GE</name></expr></cpp:if>
	<return>return <expr><call><name>ts_chunk_add_status</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>CHUNK_STATUS_FROZEN</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"freeze chunk supported only for PG14 or greater"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ts_chunk_unset_frozen</name><parameter_list>(<parameter><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_GE</name></expr></cpp:if>
	<return>return <expr><call><name>ts_chunk_clear_status</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>CHUNK_STATUS_FROZEN</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"freeze chunk supported only for PG14 or greater"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ts_chunk_is_frozen</name><parameter_list>(<parameter><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_GE</name></expr></cpp:if>
	<return>return <expr><call><name>ts_flags_are_set_32</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>status</name></name></expr></argument>, <argument><expr><name>CHUNK_STATUS_FROZEN</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"freeze chunk supported only for PG14 or greater"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_GE</name></expr></cpp:if>
<comment type="block">/* only caller is ts_chunk_unset_frozen. This code is in PG14 block as we run into
 * defined but unsed error in CI/CD builds for PG &lt; 14.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ts_chunk_clear_status</name><parameter_list>(<parameter><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>status</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* only frozen status can be cleared for a frozen chunk */</comment>
	<if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <name>CHUNK_STATUS_FROZEN</name> <operator>&amp;&amp;</operator> <call><name>ts_flags_are_set_32</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>status</name></name></expr></argument>, <argument><expr><name>CHUNK_STATUS_FROZEN</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* chunk in frozen state cannot be modified */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot modify frozen chunk status"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"chunk id = %d attempt to clear status %d , current status %x "</literal></expr></argument>,
						   <argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>,
						   <argument><expr><name>status</name></expr></argument>,
						   <argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>status</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>mstatus</name> <init>= <expr><call><name>ts_clear_flags_32</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>status</name></name></expr></argument>, <argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>status</name></name> <operator>=</operator> <name>mstatus</name></expr>;</expr_stmt>
	<return>return <expr><call><name>chunk_update_status</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>chunk</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ts_chunk_add_status</name><parameter_list>(<parameter><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>status</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>ts_flags_are_set_32</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>status</name></name></expr></argument>, <argument><expr><name>CHUNK_STATUS_FROZEN</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* chunk in frozen state cannot be modified */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot modify frozen chunk status"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"chunk id = %d attempt to set status %d , current status %x "</literal></expr></argument>,
						   <argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>,
						   <argument><expr><name>status</name></expr></argument>,
						   <argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>status</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>mstatus</name> <init>= <expr><call><name>ts_set_flags_32</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>status</name></name></expr></argument>, <argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>status</name></name> <operator>=</operator> <name>mstatus</name></expr>;</expr_stmt>
	<return>return <expr><call><name>chunk_update_status</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>chunk</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Setting (INVALID_CHUNK_ID, true) is valid for an Access Node. It means
 * the data nodes contain the actual compressed chunks, and the meta-chunk is
 * marked as compressed in the Access Node.
 * Setting (is_compressed =&gt; false) means that the chunk is uncompressed.
 */</comment>
<function><type><specifier>static</specifier> <name>ScanTupleResult</name></type>
<name>chunk_change_compressed_status_in_tuple</name><parameter_list>(<parameter><decl><type><name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>compressed_chunk_id</name></decl></parameter>,
										<parameter><decl><type><name>bool</name></type> <name>is_compressed</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FormData_chunk</name></type> <name>form</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>new_tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CatalogSecurityContext</name></type> <name>sec_ctx</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ts_chunk_formdata_fill</name><argument_list>(<argument><expr><operator>&amp;</operator><name>form</name></expr></argument>, <argument><expr><name>ti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>is_compressed</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>form</name><operator>.</operator><name>compressed_chunk_id</name></name> <operator>=</operator> <name>compressed_chunk_id</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>form</name><operator>.</operator><name>status</name></name> <operator>=</operator> <call><name>ts_set_flags_32</name><argument_list>(<argument><expr><name><name>form</name><operator>.</operator><name>status</name></name></expr></argument>, <argument><expr><name>CHUNK_STATUS_COMPRESSED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>form</name><operator>.</operator><name>compressed_chunk_id</name></name> <operator>=</operator> <name>INVALID_CHUNK_ID</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>form</name><operator>.</operator><name>status</name></name> <operator>=</operator>
			<call><name>ts_clear_flags_32</name><argument_list>(<argument><expr><name><name>form</name><operator>.</operator><name>status</name></name></expr></argument>,
							  <argument><expr><name>CHUNK_STATUS_COMPRESSED</name> <operator>|</operator> <name>CHUNK_STATUS_COMPRESSED_UNORDERED</name> <operator>|</operator>
								  <name>CHUNK_STATUS_COMPRESSED_PARTIAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name>new_tuple</name> <operator>=</operator> <call><name>chunk_formdata_make_tuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name>form</name></expr></argument>, <argument><expr><call><name>ts_scanner_get_tupledesc</name><argument_list>(<argument><expr><name>ti</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ts_catalog_database_info_become_owner</name><argument_list>(<argument><expr><call><name>ts_catalog_database_info_get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_catalog_update_tid</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>scanrel</name></name></expr></argument>, <argument><expr><call><name>ts_scanner_get_tuple_tid</name><argument_list>(<argument><expr><name>ti</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>new_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_catalog_restore_user</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>new_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>SCAN_DONE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ScanTupleResult</name></type>
<name>chunk_clear_compressed_status_in_tuple</name><parameter_list>(<parameter><decl><type><name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>chunk_change_compressed_status_in_tuple</name><argument_list>(<argument><expr><name>ti</name></expr></argument>, <argument><expr><name>INVALID_CHUNK_ID</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ScanTupleResult</name></type>
<name>chunk_set_compressed_id_in_tuple</name><parameter_list>(<parameter><decl><type><name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type> <name>compressed_chunk_id</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>int32</name> <operator>*</operator><operator>)</operator> <name>data</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>chunk_change_compressed_status_in_tuple</name><argument_list>(<argument><expr><name>ti</name></expr></argument>, <argument><expr><name>compressed_chunk_id</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*Assume permissions are already checked */</comment>
<function><type><name>bool</name></type>
<name>ts_chunk_set_compressed_chunk</name><parameter_list>(<parameter><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>compressed_chunk_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scankey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scankey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_chunk_idx_id</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
				<argument><expr><name>F_INT4EQ</name></expr></argument>,
				<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>chunk_scan_internal</name><argument_list>(<argument><expr><name>CHUNK_ID_INDEX</name></expr></argument>,
							   <argument><expr><name>scankey</name></expr></argument>,
							   <argument><expr><literal type="number">1</literal></expr></argument>,
							   <argument><expr><name>chunk_check_ignorearg_dropped_filter</name></expr></argument>,
							   <argument><expr><name>chunk_set_compressed_id_in_tuple</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>compressed_chunk_id</name></expr></argument>,
							   <argument><expr><literal type="number">0</literal></expr></argument>,
							   <argument><expr><name>ForwardScanDirection</name></expr></argument>,
							   <argument><expr><name>RowExclusiveLock</name></expr></argument>,
							   <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*Assume permissions are already checked */</comment>
<function><type><name>bool</name></type>
<name>ts_chunk_clear_compressed_chunk</name><parameter_list>(<parameter><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type> <name>compressed_chunk_id</name> <init>= <expr><name>INVALID_CHUNK_ID</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scankey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scankey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_chunk_idx_id</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
				<argument><expr><name>F_INT4EQ</name></expr></argument>,
				<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>chunk_scan_internal</name><argument_list>(<argument><expr><name>CHUNK_ID_INDEX</name></expr></argument>,
							   <argument><expr><name>scankey</name></expr></argument>,
							   <argument><expr><literal type="number">1</literal></expr></argument>,
							   <argument><expr><name>chunk_check_ignorearg_dropped_filter</name></expr></argument>,
							   <argument><expr><name>chunk_clear_compressed_status_in_tuple</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>compressed_chunk_id</name></expr></argument>,
							   <argument><expr><literal type="number">0</literal></expr></argument>,
							   <argument><expr><name>ForwardScanDirection</name></expr></argument>,
							   <argument><expr><name>RowExclusiveLock</name></expr></argument>,
							   <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Used as a tuple found function */</comment>
<function><type><specifier>static</specifier> <name>ScanTupleResult</name></type>
<name>chunk_rename_schema_name</name><parameter_list>(<parameter><decl><type><name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FormData_chunk</name></type> <name>form</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>new_tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CatalogSecurityContext</name></type> <name>sec_ctx</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ts_chunk_formdata_fill</name><argument_list>(<argument><expr><operator>&amp;</operator><name>form</name></expr></argument>, <argument><expr><name>ti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Rename schema name */</comment>
	<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>form</name><operator>.</operator><name>schema_name</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>new_tuple</name> <operator>=</operator> <call><name>chunk_formdata_make_tuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name>form</name></expr></argument>, <argument><expr><call><name>ts_scanner_get_tupledesc</name><argument_list>(<argument><expr><name>ti</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ts_catalog_database_info_become_owner</name><argument_list>(<argument><expr><call><name>ts_catalog_database_info_get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_catalog_update_tid</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>scanrel</name></name></expr></argument>, <argument><expr><call><name>ts_scanner_get_tuple_tid</name><argument_list>(<argument><expr><name>ti</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>new_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_catalog_restore_user</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>new_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>SCAN_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Go through the internal chunk table and rename all matching schemas */</comment>
<function><type><name>void</name></type>
<name>ts_chunks_rename_schema_name</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>old_schema</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>new_schema</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NameData</name></type> <name>old_schema_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scankey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Catalog</name> <modifier>*</modifier></type><name>catalog</name> <init>= <expr><call><name>ts_catalog_get</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScannerCtx</name></type> <name>scanctx</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>table</name> <operator>=</operator> <call><name>catalog_get_table_id</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>CHUNK</name></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>index</name> <operator>=</operator> <call><name>catalog_get_index</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>CHUNK</name></expr></argument>, <argument><expr><name>CHUNK_SCHEMA_NAME_INDEX</name></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>nkeys</name> <operator>=</operator> <literal type="number">1</literal></expr>,
		<expr><operator>.</operator><name>scankey</name> <operator>=</operator> <name>scankey</name></expr>,
		<expr><operator>.</operator><name>tuple_found</name> <operator>=</operator> <name>chunk_rename_schema_name</name></expr>,
		<expr><operator>.</operator><name>data</name> <operator>=</operator> <name>new_schema</name></expr>,
		<expr><operator>.</operator><name>lockmode</name> <operator>=</operator> <name>RowExclusiveLock</name></expr>,
		<expr><operator>.</operator><name>scandirection</name> <operator>=</operator> <name>ForwardScanDirection</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>old_schema_name</name></expr></argument>, <argument><expr><name>old_schema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scankey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_chunk_schema_name_idx_schema_name</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
				<argument><expr><name>F_NAMEEQ</name></expr></argument>,
				<argument><expr><call><name>NameGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>old_schema_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ts_scanner_scan</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scanctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>chunk_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>ch1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>ch2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>Chunk</name> <modifier>*</modifier></type><name>v1</name> <init>= <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>Chunk</name> <operator>*</operator><operator>)</operator> <name>ch1</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>Chunk</name> <modifier>*</modifier></type><name>v2</name> <init>= <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>Chunk</name> <operator>*</operator><operator>)</operator> <name>ch2</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>v1</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>hypertable_id</name></name> <operator>&lt;</operator> <name><name>v2</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>hypertable_id</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>v1</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>hypertable_id</name></name> <operator>&gt;</operator> <name><name>v2</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>hypertable_id</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>v1</name><operator>-&gt;</operator><name>table_id</name></name> <operator>&lt;</operator> <name><name>v2</name><operator>-&gt;</operator><name>table_id</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>v1</name><operator>-&gt;</operator><name>table_id</name></name> <operator>&gt;</operator> <name><name>v2</name><operator>-&gt;</operator><name>table_id</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * This is a helper set returning function (SRF) that takes a set returning function context
 * and as argument and returns oids extracted from funcctx-&gt;user_fctx (which is Chunk*
 * array). Note that the caller needs to be registered as a set returning function for this
 * to work.
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>chunks_return_srf</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FuncCallContext</name> <modifier>*</modifier></type><name>funcctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>call_cntr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>result_set</name></decl>;</decl_stmt>

	<comment type="block">/* stuff done only on the first call of the function */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>SRF_IS_FIRSTCALL</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Build a tuple descriptor for our result type */</comment>
		<comment type="block">/* not quite necessary */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>get_call_result_type</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupdesc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TYPEFUNC_SCALAR</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function returning record called in context "</literal>
							<literal type="string">"that cannot accept type record"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* stuff done on every call of the function */</comment>
	<expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_PERCALL_SETUP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>call_cntr</name> <operator>=</operator> <name><name>funcctx</name><operator>-&gt;</operator><name>call_cntr</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>result_set</name> <operator>=</operator> <operator>(</operator><name>Chunk</name> <operator>*</operator><operator>)</operator> <name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name></expr>;</expr_stmt>

	<comment type="block">/* do when there is more left to send */</comment>
	<if_stmt><if>if <condition>(<expr><name>call_cntr</name> <operator>&lt;</operator> <name><name>funcctx</name><operator>-&gt;</operator><name>max_calls</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SRF_RETURN_NEXT</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>, <argument><expr><name><name>result_set</name><index>[<expr><name>call_cntr</name></expr>]</index></name><operator>.</operator><name>table_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content> <comment type="block">/* do when there is no more left */</comment>
		<expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ts_chunk_drop_internal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>, <parameter><decl><type><name>DropBehavior</name></type> <name>behavior</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>log_level</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>preserve_catalog_row</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>objaddr</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>classId</name> <operator>=</operator> <name>RelationRelationId</name></expr>,
		<expr><operator>.</operator><name>objectId</name> <operator>=</operator> <name><name>chunk</name><operator>-&gt;</operator><name>table_id</name></name></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>log_level</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>log_level</name></expr></argument>,
			 <argument><expr><literal type="string">"dropping chunk %s.%s"</literal></expr></argument>,
			 <argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>schema_name</name><operator>.</operator><name>data</name></name></expr></argument>,
			 <argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>table_name</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Remove the chunk from the chunk table */</comment>
	<expr_stmt><expr><call><name>ts_chunk_delete_by_relid</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>table_id</name></name></expr></argument>, <argument><expr><name>behavior</name></expr></argument>, <argument><expr><name>preserve_catalog_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Drop the table */</comment>
	<expr_stmt><expr><call><name>performDeletion</name><argument_list>(<argument><expr><operator>&amp;</operator><name>objaddr</name></expr></argument>, <argument><expr><name>behavior</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ts_chunk_drop</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>, <parameter><decl><type><name>DropBehavior</name></type> <name>behavior</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>log_level</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ts_chunk_drop_internal</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>behavior</name></expr></argument>, <argument><expr><name>log_level</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ts_chunk_drop_preserve_catalog_row</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>, <parameter><decl><type><name>DropBehavior</name></type> <name>behavior</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>log_level</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ts_chunk_drop_internal</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>behavior</name></expr></argument>, <argument><expr><name>log_level</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>lock_referenced_tables</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>table_relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>fk_relids</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>cachedfkeys</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>table_rel</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>table_relid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* this list is from the relcache and can disappear with a cache flush, so
	 * no further catalog access till we save the fk relids */</comment>
	<expr_stmt><expr><name>cachedfkeys</name> <operator>=</operator> <call><name>RelationGetFKeyList</name><argument_list>(<argument><expr><name>table_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>lf</argument>, <argument>cachedfkeys</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ForeignKeyCacheInfo</name> <modifier>*</modifier></type><name>cachedfk</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>ForeignKeyCacheInfo</name></expr></argument>, <argument><expr><name>lf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* conrelid should always be that of the table we're considering */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cachedfk</name><operator>-&gt;</operator><name>conrelid</name></name> <operator>==</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>table_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>fk_relids</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>fk_relids</name></expr></argument>, <argument><expr><name><name>cachedfk</name><operator>-&gt;</operator><name>confrelid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>table_rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>lf</argument>, <argument>fk_relids</argument>)</argument_list></macro>
		<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>List</name> <modifier>*</modifier></type>
<name>ts_chunk_do_drop_chunks</name><parameter_list>(<parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>older_than</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>newer_than</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>log_level</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>affected_data_nodes</name></decl></parameter>)</parameter_list>

<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type> <name>num_chunks</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>schema_name</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>table_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int32</name></type> <name>hypertable_id</name> <init>= <expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>has_continuous_aggs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><name>CurrentMemoryContext</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanTupLock</name></type> <name>tuplock</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>waitpolicy</name> <operator>=</operator> <name>LockWaitBlock</name></expr>,
		<expr><operator>.</operator><name>lockmode</name> <operator>=</operator> <name>LockTupleExclusive</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ts_hypertable_permissions_check</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We have a FK between hypertable H and PAR. Hypertable H has number of
	 * chunks C1, C2, etc. When we execute "drop table C", PG acquires locks
	 * on C and PAR. If we have a query as "select * from hypertable", this
	 * acquires a lock on C and PAR as well. But the order of the locks is not
	 * the same and results in deadlocks. - github issue #865 We hope to
	 * alleviate the problem by acquiring a lock on PAR before executing the
	 * drop table stmt. This is not fool-proof as we could have multiple
	 * fkrelids and the order of lock acquisition for these could differ as
	 * well. Do not unlock - let the transaction semantics take care of it. */</comment>
	<expr_stmt><expr><call><name>lock_referenced_tables</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><call><name>ts_continuous_agg_hypertable_status</name><argument_list>(<argument><expr><name>hypertable_id</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>HypertableIsMaterialization</name></expr>:</case>
			<expr_stmt><expr><name>has_continuous_aggs</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>HypertableIsMaterializationAndRaw</name></expr>:</case>
			<expr_stmt><expr><name>has_continuous_aggs</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>HypertableIsRawTable</name></expr>:</case>
			<expr_stmt><expr><name>has_continuous_aggs</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><name>has_continuous_aggs</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><name>chunks</name> <operator>=</operator> <call><name>get_chunks_in_time_range</name><argument_list>(<argument><expr><name>ht</name></expr></argument>,
										  <argument><expr><name>older_than</name></expr></argument>,
										  <argument><expr><name>newer_than</name></expr></argument>,
										  <argument><expr><name>DROP_CHUNKS_FUNCNAME</name></expr></argument>,
										  <argument><expr><name>CurrentMemoryContext</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>num_chunks</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>tuplock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ErrorData</name> <modifier>*</modifier></type><name>edata</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>edata</name> <operator>=</operator> <call><name>CopyErrorData</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>sqlerrcode</name></name> <operator>==</operator> <name>ERRCODE_LOCK_NOT_AVAILABLE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>detail</name></name> <operator>=</operator> <name><name>edata</name><operator>-&gt;</operator><name>message</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>message</name></name> <operator>=</operator>
				<call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"some chunks could not be read since they are being concurrently updated"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>ReThrowError</name><argument_list>(<argument><expr><name>edata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>DEBUG_WAITPOINT</name><argument_list>(<argument><expr><literal type="string">"drop_chunks_chunks_found"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>has_continuous_aggs</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Exclusively lock all chunks, and invalidate the continuous
		 * aggregates in the regions covered by the chunks. We do this in two
		 * steps: first lock all the chunks and then invalidate the
		 * regions. Since we are going to drop the chunks, there is no point
		 * in allowing inserts into them.
		 *
		 * Locking prevents further modification of the dropped region during
		 * this transaction, which allows moving the invalidation threshold
		 * without having to worry about new invalidations while
		 * refreshing. */</comment>
		<for>for <control>(<init><decl><type><name>uint64</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_chunks</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name><name>chunks</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>table_id</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>hyperspace_get_open_dimension</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>space</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>fd</name><operator>.</operator><name>id</name></name> <operator>==</operator>
				   <name><name>chunks</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>cube</name><operator>-&gt;</operator><name>slices</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>fd</name><operator>.</operator><name>dimension_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>DEBUG_WAITPOINT</name><argument_list>(<argument><expr><literal type="string">"drop_chunks_locked"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Invalidate the dropped region to indicate that it was modified.
		 *
		 * The invalidation will allow the refresh command on a continuous
		 * aggregate to see that this region was dropped and and will
		 * therefore be able to refresh accordingly.*/</comment>
		<for>for <control>(<init><decl><type><name>uint64</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_chunks</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int64</name></type> <name>start</name> <init>= <expr><call><name>ts_chunk_primary_dimension_start</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>chunks</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int64</name></type> <name>end</name> <init>= <expr><call><name>ts_chunk_primary_dimension_end</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>chunks</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name><name>ts_cm_functions</name><operator>-&gt;</operator><name>continuous_agg_invalidate_raw_ht</name></name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>data_nodes</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>dropped_chunk_names</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<for>for <control>(<init><decl><type><name>uint64</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_chunks</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>chunk_name</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ASSERT_IS_VALID_CHUNK</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>chunks</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* frozen chunks are skipped. Not dropped. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ts_chunk_validate_chunk_status_for_operation</name><argument_list>(<argument><expr><name><name>chunks</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>table_id</name></expr></argument>,
														  <argument><expr><name><name>chunks</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>fd</name><operator>.</operator><name>status</name></name></expr></argument>,
														  <argument><expr><name>CHUNK_DROP</name></expr></argument>,
														  <argument><expr><name>false</name></expr></argument> <comment type="block">/*throw_error */</comment>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* store chunk name for output */</comment>
		<expr_stmt><expr><name>schema_name</name> <operator>=</operator> <call><name>quote_identifier</name><argument_list>(<argument><expr><name><name>chunks</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>fd</name><operator>.</operator><name>schema_name</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>table_name</name> <operator>=</operator> <call><name>quote_identifier</name><argument_list>(<argument><expr><name><name>chunks</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>fd</name><operator>.</operator><name>table_name</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>chunk_name</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s.%s"</literal></expr></argument>, <argument><expr><name>schema_name</name></expr></argument>, <argument><expr><name>table_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>dropped_chunk_names</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>dropped_chunk_names</name></expr></argument>, <argument><expr><name>chunk_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>has_continuous_aggs</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ts_chunk_drop_preserve_catalog_row</name><argument_list>(<argument><expr><name>chunks</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>DROP_RESTRICT</name></expr></argument>, <argument><expr><name>log_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ts_chunk_drop</name><argument_list>(<argument><expr><name>chunks</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>DROP_RESTRICT</name></expr></argument>, <argument><expr><name>log_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* Collect a list of affected data nodes so that we know which data
		 * nodes we need to drop chunks on */</comment>
		<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>chunks[i].data_nodes</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ChunkDataNode</name> <modifier>*</modifier></type><name>cdn</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>data_nodes</name> <operator>=</operator> <call><name>list_append_unique_oid</name><argument_list>(<argument><expr><name>data_nodes</name></expr></argument>, <argument><expr><name><name>cdn</name><operator>-&gt;</operator><name>foreign_server_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>affected_data_nodes</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>affected_data_nodes</name> <operator>=</operator> <name>data_nodes</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>DEBUG_WAITPOINT</name><argument_list>(<argument><expr><literal type="string">"drop_chunks_end"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>dropped_chunk_names</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * This is a helper set returning function (SRF) that takes a set returning function context
 * and as argument and returns cstrings extracted from funcctx-&gt;user_fctx (which is a List).
 * Note that the caller needs to be registered as a set returning function for this to work.
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>list_return_srf</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FuncCallContext</name> <modifier>*</modifier></type><name>funcctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>call_cntr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>result_set</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>retval</name></decl>;</decl_stmt>

	<comment type="block">/* stuff done only on the first call of the function */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>SRF_IS_FIRSTCALL</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Build a tuple descriptor for our result type */</comment>
		<comment type="block">/* not quite necessary */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>get_call_result_type</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupdesc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TYPEFUNC_SCALAR</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function returning record called in context "</literal>
							<literal type="string">"that cannot accept type record"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* stuff done on every call of the function */</comment>
	<expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_PERCALL_SETUP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>call_cntr</name> <operator>=</operator> <name><name>funcctx</name><operator>-&gt;</operator><name>call_cntr</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>result_set</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* do when there is more left to send */</comment>
	<if_stmt><if>if <condition>(<expr><name>call_cntr</name> <operator>&lt;</operator> <name><name>funcctx</name><operator>-&gt;</operator><name>max_calls</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* store return value and increment linked list */</comment>
		<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>result_set</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name>result_set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SRF_RETURN_NEXT</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>, <argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content> <comment type="block">/* do when there is no more left */</comment>
		<expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Find either the hypertable or the materialized hypertable, if the relid is
 * a continuous aggregate, for the relid.
 *
 * If allow_matht is false, relid should be a cagg or a hypertable.
 * If allow_matht is true, materialized hypertable is also permitted as relid
 */</comment>
<function><type><specifier>static</specifier> <name>Hypertable</name> <modifier>*</modifier></type>
<name>find_hypertable_from_table_or_cagg</name><parameter_list>(<parameter><decl><type><name>Cache</name> <modifier>*</modifier></type><name>hcache</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>allow_matht</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>rel_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>rel_name</name> <operator>=</operator> <call><name>get_rel_name</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rel_name</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid hypertable or continuous aggregate"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>ht</name> <operator>=</operator> <call><name>ts_hypertable_cache_get_entry</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>, <argument><expr><name>CACHE_FLAG_MISSING_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>ht</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>ContinuousAggHypertableStatus</name></type> <name>status</name> <init>= <expr><call><name>ts_continuous_agg_hypertable_status</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<switch>switch <condition>(<expr><name>status</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>HypertableIsMaterialization</name></expr>:</case>
			<case>case <expr><name>HypertableIsMaterializationAndRaw</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>allow_matht</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"operation not supported on materialized hypertable"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Try the operation on the continuous aggregate instead."</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Hypertable \"%s\" is a materialized hypertable."</literal></expr></argument>,
									   <argument><expr><name>rel_name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>

			<default>default:</default>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>ContinuousAgg</name> <modifier>*</modifier><specifier>const</specifier></type> <name>cagg</name> <init>= <expr><call><name>ts_continuous_agg_find_by_relid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cagg</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TS_HYPERTABLE_NOT_EXIST</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a hypertable or a continuous aggregate"</literal></expr></argument>, <argument><expr><name>rel_name</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"The operation is only possible on a hypertable or continuous"</literal>
							 <literal type="string">" aggregate."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>ht</name> <operator>=</operator> <call><name>ts_hypertable_get_by_id</name><argument_list>(<argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>mat_hypertable_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ht</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TS_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no materialized table for continuous aggregate"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Continuous aggregate \"%s\" had a materialized hypertable"</literal>
							   <literal type="string">" with id %d but it was not found in the hypertable "</literal>
							   <literal type="string">"catalog."</literal></expr></argument>,
							   <argument><expr><name>rel_name</name></expr></argument>,
							   <argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>mat_hypertable_id</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>ht</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>ts_chunk_drop_single_chunk</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>chunk_relid</name> <init>= <expr><ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>InvalidOid</name></expr> </then><else>: <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>chunk_table_name</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>chunk_relid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>chunk_schema_name</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name>chunk_relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>Chunk</name> <modifier>*</modifier></type><name>ch</name> <init>= <expr><call><name>ts_chunk_get_by_name_with_memory_context</name><argument_list>(<argument><expr><name>chunk_schema_name</name></expr></argument>,
															   <argument><expr><name>chunk_table_name</name></expr></argument>,
															   <argument><expr><name>CurrentMemoryContext</name></expr></argument>,
															   <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ch</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_chunk_validate_chunk_status_for_operation</name><argument_list>(<argument><expr><name>chunk_relid</name></expr></argument>,
												 <argument><expr><name><name>ch</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>status</name></name></expr></argument>,
												 <argument><expr><name>CHUNK_DROP</name></expr></argument>,
												 <argument><expr><name>true</name></expr></argument> <comment type="block">/*throw_error */</comment>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* do not drop any chunk dependencies */</comment>
	<expr_stmt><expr><call><name>ts_chunk_drop</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr><name>DROP_RESTRICT</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>ts_chunk_drop_chunks</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncCallContext</name> <modifier>*</modifier></type><name>funcctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>dc_temp</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>dc_names</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relid</name> <init>= <expr><ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>InvalidOid</name></expr> </then><else>: <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Marked volatile to suppress the -Wclobbered warning. The warning is
	 * actually incorrect because these values are not used after longjmp.
	 */</comment>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>int64</name></type> <name>older_than</name> <init>= <expr><name>PG_INT64_MAX</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>int64</name></type> <name>newer_than</name> <init>= <expr><name>PG_INT64_MIN</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>verbose</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>elevel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>data_node_oids</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cache</name> <modifier>*</modifier></type><name>hcache</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type><name>time_dim</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>time_type</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>TS_PREVENT_FUNC_IF_READ_ONLY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * When past the first call of the SRF, dropping has already been completed,
	 * so we just return the next chunk in the list of dropped chunks.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SRF_IS_FIRSTCALL</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>list_return_srf</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid hypertable or continuous aggregate"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Specify a hypertable or continuous aggregate."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid time range for dropping chunks"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"At least one of older_than and newer_than must be provided."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Find either the hypertable or view, or error out if the relid is
	 * neither.
	 *
	 * We should improve the printout since it can either be a proper relid
	 * that does not refer to a hypertable or a continuous aggregate, or a
	 * relid that does not refer to anything at all. */</comment>
	<expr_stmt><expr><name>hcache</name> <operator>=</operator> <call><name>ts_hypertable_cache_pin</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ht</name> <operator>=</operator> <call><name>find_hypertable_from_table_or_cagg</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ht</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>time_dim</name> <operator>=</operator> <call><name>hyperspace_get_open_dimension</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>space</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>time_dim</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"hypertable has no open partitioning dimension"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>time_type</name> <operator>=</operator> <call><name>ts_dimension_get_partition_type</name><argument_list>(<argument><expr><name>time_dim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>older_than</name> <operator>=</operator> <call><name>ts_time_value_from_arg</name><argument_list>(<argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><call><name>get_fn_expr_argtype</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><name>time_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>newer_than</name> <operator>=</operator> <call><name>ts_time_value_from_arg</name><argument_list>(<argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><call><name>get_fn_expr_argtype</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><name>time_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>verbose</name> <operator>=</operator> <ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>false</name></expr> </then><else>: <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name>elevel</name> <operator>=</operator> <ternary><condition><expr><name>verbose</name></expr> ?</condition><then> <expr><name>INFO</name></expr> </then><else>: <expr><name>DEBUG2</name></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/* Initial multi function call setup */</comment>
	<expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_FIRSTCALL_INIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Drop chunks and store their names for return */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>multi_call_memory_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><name>dc_temp</name> <operator>=</operator> <call><name>ts_chunk_do_drop_chunks</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>older_than</name></expr></argument>, <argument><expr><name>newer_than</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data_node_oids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<comment type="block">/* An error is raised if there are dependent objects, but the original
		 * message is not very helpful in suggesting that you should use
		 * CASCADE (we don't support it), so we replace the hint with a more
		 * accurate hint for our situation. */</comment>
		<decl_stmt><decl><type><name>ErrorData</name> <modifier>*</modifier></type><name>edata</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>edata</name> <operator>=</operator> <call><name>CopyErrorData</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>sqlerrcode</name></name> <operator>==</operator> <name>ERRCODE_DEPENDENT_OBJECTS_STILL_EXIST</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>hint</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">"Use DROP ... to drop the dependent objects."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReThrowError</name><argument_list>(<argument><expr><name>edata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dc_names</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>dc_names</name></expr></argument>, <argument><expr><name>dc_temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>data_node_oids</name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name><name>ts_cm_functions</name><operator>-&gt;</operator><name>func_call_on_data_nodes</name></name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>data_node_oids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* store data for multi function call */</comment>
	<expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>max_calls</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>dc_names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name> <operator>=</operator> <name>dc_names</name></expr>;</expr_stmt>

	<return>return <expr><call><name>list_return_srf</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * This function is used to explicitly specify chunks that are being scanned. It's being
 * processed in the planning phase and removed from the query tree. This means that the
 * actual function implementation will only be executed if something went wrong during
 * explicit chunk exclusion.
 */</comment>
<function><type><name>Datum</name></type>
<name>ts_chunks_in</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>funcname</name> <init>= <expr><call><name>get_func_name</name><argument_list>(<argument><expr><call><name>FC_FN_OID</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"illegal invocation of %s function"</literal></expr></argument>, <argument><expr><name>funcname</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"The %s function must appear in the WHERE clause and can only"</literal>
					 <literal type="string">" be combined with AND operator."</literal></expr></argument>,
					 <argument><expr><name>funcname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_unreachable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Return the compression status for the chunk
 */</comment>
<function><type><name>ChunkCompressionStatus</name></type>
<name>ts_chunk_get_compression_status</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>chunk_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ChunkCompressionStatus</name></type> <name>st</name> <init>= <expr><name>CHUNK_COMPRESS_NONE</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanIterator</name></type> <name>iterator</name> <init>= <expr><call><name>ts_scan_iterator_create</name><argument_list>(<argument><expr><name>CHUNK</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>, <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>iterator</name><operator>.</operator><name>ctx</name><operator>.</operator><name>index</name></name> <operator>=</operator> <call><name>catalog_get_index</name><argument_list>(<argument><expr><call><name>ts_catalog_get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>CHUNK</name></expr></argument>, <argument><expr><name>CHUNK_ID_INDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_scan_iterator_scan_key_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>,
								   <argument><expr><name>Anum_chunk_idx_id</name></expr></argument>,
								   <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
								   <argument><expr><name>F_INT4EQ</name></expr></argument>,
								   <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>chunk_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>ts_scanner_foreach</name><argument_list>(<argument>&amp;iterator</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name> <init>= <expr><call><name>ts_scan_iterator_tuple_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>dropped_isnull</name></decl>, <decl><type ref="prev"/><name>status_isnull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type> <name>status</name></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>bool</name></type> <name>dropped</name> <init>= <expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>slot_getattr</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>slot</name></name></expr></argument>, <argument><expr><name>Anum_chunk_dropped</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dropped_isnull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>dropped_isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>slot</name></name></expr></argument>, <argument><expr><name>Anum_chunk_status</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>status_isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>status_isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Note that dropped attribute takes precedence over everything else.
		 * We should not check status attribute for dropped chunks
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dropped</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type> <name>status_is_compressed</name> <init>=
				<expr><call><name>ts_flags_are_set_32</name><argument_list>(<argument><expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>CHUNK_STATUS_COMPRESSED</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type> <name>status_is_unordered</name> <init>=
				<expr><call><name>ts_flags_are_set_32</name><argument_list>(<argument><expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>CHUNK_STATUS_COMPRESSED_UNORDERED</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>status_is_compressed</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>status_is_unordered</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>st</name> <operator>=</operator> <name>CHUNK_COMPRESS_UNORDERED</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>st</name> <operator>=</operator> <name>CHUNK_COMPRESS_ORDERED</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>status_is_unordered</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>st</name> <operator>=</operator> <name>CHUNK_COMPRESS_NONE</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>st</name> <operator>=</operator> <name>CHUNK_DROPPED</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>ts_scan_iterator_close</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>st</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Note that only a compressed chunk can have unordered flag set */</comment>
<function><type><name>bool</name></type>
<name>ts_chunk_is_unordered</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>ts_flags_are_set_32</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>status</name></name></expr></argument>, <argument><expr><name>CHUNK_STATUS_COMPRESSED_UNORDERED</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ts_chunk_is_compressed</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>ts_flags_are_set_32</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>status</name></name></expr></argument>, <argument><expr><name>CHUNK_STATUS_COMPRESSED</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Note that only a compressed chunk can have partial flag set */</comment>
<function><type><name>bool</name></type>
<name>ts_chunk_is_partial</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>ts_flags_are_set_32</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>status</name></name></expr></argument>, <argument><expr><name>CHUNK_STATUS_COMPRESSED_PARTIAL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_chunk_operation_str</name><parameter_list>(<parameter><decl><type><name>ChunkOperation</name></type> <name>cmd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>cmd</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>CHUNK_INSERT</name></expr>:</case>
			<return>return <expr><literal type="string">"Insert"</literal></expr>;</return>
		<case>case <expr><name>CHUNK_DELETE</name></expr>:</case>
			<return>return <expr><literal type="string">"Delete"</literal></expr>;</return>
		<case>case <expr><name>CHUNK_UPDATE</name></expr>:</case>
			<return>return <expr><literal type="string">"Update"</literal></expr>;</return>
		<case>case <expr><name>CHUNK_COMPRESS</name></expr>:</case>
			<return>return <expr><literal type="string">"compress_chunk"</literal></expr>;</return>
		<case>case <expr><name>CHUNK_DECOMPRESS</name></expr>:</case>
			<return>return <expr><literal type="string">"decompress_chunk"</literal></expr>;</return>
		<case>case <expr><name>CHUNK_DROP</name></expr>:</case>
			<return>return <expr><literal type="string">"drop_chunk"</literal></expr>;</return>
		<default>default:</default>
			<return>return <expr><literal type="string">"Unsupported"</literal></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ts_chunk_validate_chunk_status_for_operation</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>chunk_relid</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>chunk_status</name></decl></parameter>,
											 <parameter><decl><type><name>ChunkOperation</name></type> <name>cmd</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>throw_error</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Handle frozen chunks */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>ts_flags_are_set_32</name><argument_list>(<argument><expr><name>chunk_status</name></expr></argument>, <argument><expr><name>CHUNK_STATUS_FROZEN</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Data modification is not permitted on a frozen chunk */</comment>
		<switch>switch <condition>(<expr><name>cmd</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>CHUNK_INSERT</name></expr>:</case>
			<case>case <expr><name>CHUNK_DELETE</name></expr>:</case>
			<case>case <expr><name>CHUNK_UPDATE</name></expr>:</case>
			<case>case <expr><name>CHUNK_COMPRESS</name></expr>:</case>
			<case>case <expr><name>CHUNK_DECOMPRESS</name></expr>:</case>
			<case>case <expr><name>CHUNK_DROP</name></expr>:</case>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>throw_error</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						 <argument><expr><literal type="string">"%s not permitted on frozen chunk \"%s\" "</literal></expr></argument>,
						 <argument><expr><call><name>get_chunk_operation_str</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>chunk_relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<return>return <expr><name>false</name></expr>;</return>
				<break>break;</break>
			</block_content>}</block>
			<default>default:</default>
				<break>break;</break> <comment type="block">/*supported operations */</comment>
		</block_content>}</block></switch>
	</block_content>}</block></if>
	<comment type="block">/* Handle unfrozen chunks */</comment>
	<else>else
	<block>{<block_content>
		<switch>switch <condition>(<expr><name>cmd</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* supported operations */</comment>
			<case>case <expr><name>CHUNK_INSERT</name></expr>:</case>
			<case>case <expr><name>CHUNK_DELETE</name></expr>:</case>
			<case>case <expr><name>CHUNK_UPDATE</name></expr>:</case>
				<break>break;</break>
			<comment type="block">/* Only uncompressed chunks can be compressed */</comment>
			<case>case <expr><name>CHUNK_COMPRESS</name></expr>:</case>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>ts_flags_are_set_32</name><argument_list>(<argument><expr><name>chunk_status</name></expr></argument>, <argument><expr><name>CHUNK_STATUS_COMPRESSED</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><operator>(</operator><ternary><condition><expr><name>throw_error</name></expr> ?</condition><then> <expr><name>ERROR</name></expr> </then><else>: <expr><name>NOTICE</name></expr></else></ternary><operator>)</operator></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"chunk \"%s\" is already compressed"</literal></expr></argument>,
									<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>chunk_relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block>
			<comment type="block">/* Only compressed chunks can be decompressed */</comment>
			<case>case <expr><name>CHUNK_DECOMPRESS</name></expr>:</case>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ts_flags_are_set_32</name><argument_list>(<argument><expr><name>chunk_status</name></expr></argument>, <argument><expr><name>CHUNK_STATUS_COMPRESSED</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><operator>(</operator><ternary><condition><expr><name>throw_error</name></expr> ?</condition><then> <expr><name>ERROR</name></expr> </then><else>: <expr><name>NOTICE</name></expr></else></ternary><operator>)</operator></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"chunk \"%s\" is already decompressed"</literal></expr></argument>,
									<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>chunk_relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block>
			<default>default:</default>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>ts_chunk_show</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name><name>ts_cm_functions</name><operator>-&gt;</operator><name>show_chunk</name></name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>ts_chunk_create</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name><name>ts_cm_functions</name><operator>-&gt;</operator><name>create_chunk</name></name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Get the chunk status.
 *
 * Values returned are documented above and is a bitwise or of the
 * CHUNK_STATUS_XXX values.
 *
 * @see CHUNK_STATUS_DEFAULT
 * @see CHUNK_STATUS_COMPRESSED
 * @see CHUNK_STATUS_COMPRESSED_UNORDERED
 * @see CHUNK_STATUS_FROZEN
 */</comment>
<function><type><name>Datum</name></type>
<name>ts_chunk_status</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>chunk_relid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name> <init>= <expr><call><name>ts_chunk_get_by_relid</name><argument_list>(<argument><expr><name>chunk_relid</name></expr></argument>, <comment type="block">/* fail_if_not_found */</comment> <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>status</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Lock the chunk if the lockmode demands it.
 *
 * Also check that the chunk relation actually exists after the lock is
 * acquired. Return true if no locking is necessary or the chunk relation
 * exists and the lock was successfully acquired. Otherwise return false.
 */</comment>
<function><type><name>bool</name></type>
<name>ts_chunk_lock_if_exists</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>chunk_oid</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>chunk_lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* No lock is requested, so assume relation exists */</comment>
	<if_stmt><if>if <condition>(<expr><name>chunk_lockmode</name> <operator>!=</operator> <name>NoLock</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Get the lock to synchronize against concurrent drop */</comment>
		<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name>chunk_oid</name></expr></argument>, <argument><expr><name>chunk_lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Now that we have the lock, double-check to see if the relation
		 * really exists or not.  If not, assume it was dropped while we
		 * waited to acquire lock, and ignore it.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SearchSysCacheExists1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>chunk_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Release useless lock */</comment>
			<expr_stmt><expr><call><name>UnlockRelationOid</name><argument_list>(<argument><expr><name>chunk_oid</name></expr></argument>, <argument><expr><name>chunk_lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* And ignore this relation */</comment>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>ts_chunk_oid_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>Chunk</name> <modifier>*</modifier></type><name>c1</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>Chunk</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>p1</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>Chunk</name> <modifier>*</modifier></type><name>c2</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>Chunk</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>p2</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>oid_cmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>c1</name><operator>-&gt;</operator><name>table_id</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>c2</name><operator>-&gt;</operator><name>table_id</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>ScanIterator</name></type>
<name>ts_chunk_scan_iterator_create</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>result_mcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScanIterator</name></type> <name>it</name> <init>= <expr><call><name>ts_scan_iterator_create</name><argument_list>(<argument><expr><name>CHUNK</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>, <argument><expr><name>result_mcxt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>it</name><operator>.</operator><name>ctx</name><operator>.</operator><name>flags</name></name> <operator>|=</operator> <name>SCANNER_F_NOEND_AND_NOCLOSE</name></expr>;</expr_stmt>

	<return>return <expr><name>it</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ts_chunk_scan_iterator_set_chunk_id</name><parameter_list>(<parameter><decl><type><name>ScanIterator</name> <modifier>*</modifier></type><name>it</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>chunk_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>ctx</name><operator>.</operator><name>index</name></name> <operator>=</operator> <call><name>catalog_get_index</name><argument_list>(<argument><expr><call><name>ts_catalog_get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>CHUNK</name></expr></argument>, <argument><expr><name>CHUNK_ID_INDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_scan_iterator_scan_key_reset</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_scan_iterator_scan_key_init</name><argument_list>(<argument><expr><name>it</name></expr></argument>,
								   <argument><expr><name>Anum_chunk_idx_id</name></expr></argument>,
								   <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
								   <argument><expr><name>F_INT4EQ</name></expr></argument>,
								   <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>chunk_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hypercube.h"</cpp:file></cpp:include>
<function><type><specifier>static</specifier> <name>Hypercube</name> <modifier>*</modifier></type>
<name>fill_hypercube_for_foreign_table_chunk</name><parameter_list>(<parameter><decl><type><name>Hyperspace</name> <modifier>*</modifier></type><name>hs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Hypercube</name> <modifier>*</modifier></type><name>cube</name> <init>= <expr><call><name>ts_hypercube_alloc</name><argument_list>(<argument><expr><name><name>hs</name><operator>-&gt;</operator><name>num_dimensions</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>ts_point_create</name><argument_list>(<argument><expr><name><name>hs</name><operator>-&gt;</operator><name>num_dimensions</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>hs</name><operator>-&gt;</operator><name>num_dimensions</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// does not work with partitioned range</comment>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>hs</name><operator>-&gt;</operator><name>num_dimensions</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type><name>dim</name> <init>= <expr><operator>&amp;</operator><name><name>hs</name><operator>-&gt;</operator><name>dimensions</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>dim</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>DIMENSION_TYPE_OPEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>dimtype</name> <init>= <expr><call><name>ts_dimension_get_partition_type</name><argument_list>(<argument><expr><name>dim</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type> <name>val</name> <init>= <expr><call><name>ts_time_datum_get_max</name><argument_list>(<argument><expr><name>dimtype</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>coordinates</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>num_coords</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>ts_time_value_to_internal</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>dimtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cube</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>ts_dimension_calculate_default_slice</name><argument_list>(<argument><expr><name>dim</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>coordinates</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cube</name><operator>-&gt;</operator><name>num_slices</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cube</name><operator>-&gt;</operator><name>num_slices</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>cube</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* adds foreign table as a chunk to the hypertable.
 * creates a dummy chunk constraint for the time dimension.
 * These constraints are recorded in the chunk-dimension slice metadata.
 * They are NOT added as CHECK constraints on the foreign table.
 *
 * Does not add any inheritable constraints or indexes that are already
 * defined on the hypertable.
 *
 * This is used to add an OSM table as a chunk.
 * Set the osm_chunk flag to true.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_foreign_table_as_chunk</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>parent_ht</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Hyperspace</name> <modifier>*</modifier></type><name>hs</name> <init>= <expr><name><name>parent_ht</name><operator>-&gt;</operator><name>space</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Catalog</name> <modifier>*</modifier></type><name>catalog</name> <init>= <expr><call><name>ts_catalog_get</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CatalogSecurityContext</name></type> <name>sec_ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relschema</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relname</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>ht_ownerid</name> <init>= <expr><call><name>ts_rel_get_owner</name><argument_list>(<argument><expr><name><name>parent_ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>has_privs_of_role</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ht_ownerid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must be owner of hypertable \"%s\""</literal></expr></argument>,
						<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>parent_ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>hs</name><operator>-&gt;</operator><name>num_dimensions</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			 <argument><expr><literal type="string">"cannot attach a  foreign table to a hypertable that has more than 1 dimension"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* Create a new chunk based on the hypercube */</comment>
	<expr_stmt><expr><call><name>ts_catalog_database_info_become_owner</name><argument_list>(<argument><expr><call><name>ts_catalog_database_info_get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>chunk</name> <operator>=</operator> <call><name>ts_chunk_create_base</name><argument_list>(<argument><expr><call><name>ts_catalog_table_next_seq_id</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>CHUNK</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><name><name>hs</name><operator>-&gt;</operator><name>num_dimensions</name></name></expr></argument>,
								 <argument><expr><name>RELKIND_RELATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_catalog_restore_user</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* fill in the correct table_name for the chunk*/</comment>
	<expr_stmt><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>hypertable_id</name></name> <operator>=</operator> <name><name>hs</name><operator>-&gt;</operator><name>hypertable_id</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>osm_chunk</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt> <comment type="block">/* this is an OSM chunk */</comment>
	<expr_stmt><expr><name><name>chunk</name><operator>-&gt;</operator><name>cube</name></name> <operator>=</operator> <call><name>fill_hypercube_for_foreign_table_chunk</name><argument_list>(<argument><expr><name>hs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>chunk</name><operator>-&gt;</operator><name>hypertable_relid</name></name> <operator>=</operator> <name><name>parent_ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>chunk</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <call><name>ts_chunk_constraints_alloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>schema_name</name></name></expr></argument>, <argument><expr><name>relschema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>table_name</name></name></expr></argument>, <argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Insert chunk */</comment>
	<expr_stmt><expr><call><name>ts_chunk_insert_lock</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* insert dimension slices if they do not exist.
	 */</comment>
	<expr_stmt><expr><call><name>ts_dimension_slice_insert_multi</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>cube</name><operator>-&gt;</operator><name>slices</name></name></expr></argument>, <argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>cube</name><operator>-&gt;</operator><name>num_slices</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* check constraints are not automatically created for foreign tables.
	 * See: ts_chunk_constraints_add_dimension_constraints.
	 * Collect all the check constraints from the hypertable and add them to the
	 * foreign table. Otherwise, cannot add as child of the hypertable (pg inheritance
	 * code will error. Note that the name of the check constraint on the hypertable
	 * and the foreign table chunk should match.
	 */</comment>
	<expr_stmt><expr><call><name>ts_chunk_constraints_add_inheritable_check_constraints</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>constraints</name></name></expr></argument>,
														   <argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>,
														   <argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>relkind</name></name></expr></argument>,
														   <argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>hypertable_relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>chunk_create_table_constraints</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Add dimension constriants for the chunk */</comment>
	<expr_stmt><expr><call><name>ts_chunk_constraints_add_dimension_constraints</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>constraints</name></name></expr></argument>, <argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>, <argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>cube</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_chunk_constraints_insert_metadata</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>constraints</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>chunk_add_inheritance</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>parent_ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ts_chunk_merge_on_dimension</name><parameter_list>(<parameter><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Chunk</name> <modifier>*</modifier></type><name>merge_chunk</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>dimension_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>DimensionSlice</name> <modifier>*</modifier></type><name>slice</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>merge_slice</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>num_ccs</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>dimension_slice_found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>chunk</name><operator>-&gt;</operator><name>hypertable_relid</name></name> <operator>!=</operator> <name><name>merge_chunk</name><operator>-&gt;</operator><name>hypertable_relid</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot merge chunks from different hypertables"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"chunk 1: \"%s\", chunk 2: \"%s\""</literal></expr></argument>,
						 <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>table_id</name></name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>merge_chunk</name><operator>-&gt;</operator><name>table_id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>chunk</name><operator>-&gt;</operator><name>cube</name><operator>-&gt;</operator><name>num_slices</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>chunk</name><operator>-&gt;</operator><name>cube</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>fd</name><operator>.</operator><name>dimension_id</name></name> <operator>==</operator> <name>dimension_id</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>slice</name> <operator>=</operator> <name><name>chunk</name><operator>-&gt;</operator><name>cube</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>merge_slice</name> <operator>=</operator> <name><name>merge_chunk</name><operator>-&gt;</operator><name>cube</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>dimension_slice_found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>chunk</name><operator>-&gt;</operator><name>cube</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>fd</name><operator>.</operator><name>id</name></name> <operator>!=</operator> <name><name>merge_chunk</name><operator>-&gt;</operator><name>cube</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>fd</name><operator>.</operator><name>id</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* If the slices do not match (except on time dimension), we cannot merge the chunks. */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot merge chunks with different partitioning schemas"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"chunk 1: \"%s\", chunk 2: \"%s\" have different slices on "</literal>
							 <literal type="string">"dimension ID %d"</literal></expr></argument>,
							 <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>table_id</name></name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>merge_chunk</name><operator>-&gt;</operator><name>table_id</name></name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>cube</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>fd</name><operator>.</operator><name>dimension_id</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dimension_slice_found</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot find slice for merging dimension"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"chunk 1: \"%s\", chunk 2: \"%s\", dimension ID %d"</literal></expr></argument>,
						 <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>table_id</name></name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>merge_chunk</name><operator>-&gt;</operator><name>table_id</name></name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name>dimension_id</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>slice</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>range_end</name></name> <operator>!=</operator> <name><name>merge_slice</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>range_start</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot merge non-adjacent chunks over supplied dimension"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"chunk 1: \"%s\", chunk 2: \"%s\", dimension ID %d"</literal></expr></argument>,
						 <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>table_id</name></name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>merge_chunk</name><operator>-&gt;</operator><name>table_id</name></name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name>dimension_id</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>num_ccs</name> <operator>=</operator>
		<call><name>ts_chunk_constraint_scan_by_dimension_slice_id</name><argument_list>(<argument><expr><name><name>slice</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* There should always be an associated chunk constraint to a dimension slice.
	 * This can only occur when the catalog metadata is corrupt.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>num_ccs</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"missing chunk constraint for dimension slice"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"chunk: \"%s\", slice ID %d"</literal></expr></argument>,
						 <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>table_id</name></name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name><name>slice</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>DimensionSlice</name> <modifier>*</modifier></type><name>new_slice</name> <init>=
		<expr><call><name>ts_dimension_slice_create</name><argument_list>(<argument><expr><name>dimension_id</name></expr></argument>, <argument><expr><name><name>slice</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>range_start</name></name></expr></argument>, <argument><expr><name><name>merge_slice</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>range_end</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Only if there is exactly one chunk constraint for the merged dimension slice
	 * we can go ahead and delete it since we are dropping the chunk.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>num_ccs</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ts_dimension_slice_delete_by_id</name><argument_list>(<argument><expr><name><name>slice</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Check for dimension slice already exists, if not create a new one. */</comment>
	<decl_stmt><decl><type><name>ScanTupLock</name></type> <name>tuplock</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>lockmode</name> <operator>=</operator> <name>LockTupleKeyShare</name></expr>,
		<expr><operator>.</operator><name>waitpolicy</name> <operator>=</operator> <name>LockWaitBlock</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ts_dimension_slice_scan_for_existing</name><argument_list>(<argument><expr><name>new_slice</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tuplock</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ts_dimension_slice_insert</name><argument_list>(<argument><expr><name>new_slice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ts_chunk_constraint_update_slice_id</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>, <argument><expr><name><name>slice</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>, <argument><expr><name><name>new_slice</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>ChunkConstraints</name> <modifier>*</modifier></type><name>ccs</name> <init>= <expr><call><name>ts_chunk_constraints_alloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>num_ccs</name> <operator>=</operator>
		<call><name>ts_chunk_constraint_scan_by_dimension_slice_id</name><argument_list>(<argument><expr><name><name>new_slice</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>, <argument><expr><name>ccs</name></expr></argument>, <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>num_ccs</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"missing chunk constraint for merged dimension slice"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"chunk: \"%s\", slice ID %d"</literal></expr></argument>,
						 <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>table_id</name></name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name><name>new_slice</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* We have to recreate the chunk constraints since we are changing
	 * table constraints when updating the slice.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ccs</name><operator>-&gt;</operator><name>capacity</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ChunkConstraint</name></type> <name>cc</name> <init>= <expr><name><name>ccs</name><operator>-&gt;</operator><name>constraints</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>cc</name><operator>.</operator><name>fd</name><operator>.</operator><name>chunk_id</name></name> <operator>==</operator> <name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ts_process_utility_set_expect_chunk_modification</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ts_chunk_constraint_recreate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cc</name></expr></argument>, <argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>table_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ts_process_utility_set_expect_chunk_modification</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>ts_chunk_drop</name><argument_list>(<argument><expr><name>merge_chunk</name></expr></argument>, <argument><expr><name>DROP_RESTRICT</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Internal API used by OSM extension. OSM table is a foreign table that is
 * attached as a chunk of the hypertable. A chunk needs dimension constraints. We
 * add dummy constraints for the OSM chunk and then attach it to the hypertable.
 * OSM extension is responsible for maintaining any constraints on this table.
 */</comment>
<function><type><name>Datum</name></type>
<name>ts_chunk_attach_osm_table_chunk</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>hypertable_relid</name> <init>= <expr><ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>InvalidOid</name></expr> </then><else>: <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>ftable_relid</name> <init>= <expr><ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>InvalidOid</name></expr> </then><else>: <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Cache</name> <modifier>*</modifier></type><name>hcache</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>par_ht</name> <init>=
		<expr><call><name>ts_hypertable_cache_get_cache_and_entry</name><argument_list>(<argument><expr><name>hypertable_relid</name></expr></argument>, <argument><expr><name>CACHE_FLAG_MISSING_OK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hcache</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>par_ht</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"\"%s\" is not a hypertable"</literal></expr></argument>, <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>hypertable_relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>ftable_relid</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>add_foreign_table_as_chunk</name><argument_list>(<argument><expr><name>ftable_relid</name></expr></argument>, <argument><expr><name>par_ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ScanTupleResult</name></type>
<name>chunk_tuple_osm_chunk_found</name><parameter_list>(<parameter><decl><type><name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>osm_chunk</name> <init>= <expr><call><name>slot_getattr</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>slot</name></name></expr></argument>, <argument><expr><name>Anum_chunk_osm_chunk</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>is_osm_chunk</name> <init>= <expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><name>osm_chunk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_osm_chunk</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>SCAN_CONTINUE</name></expr>;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>chunk_id</name> <init>= <expr><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>chunk_id_datum</name> <init>= <expr><call><name>slot_getattr</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>slot</name></name></expr></argument>, <argument><expr><name>Anum_chunk_id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>chunk_id</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>chunk_id_datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>SCAN_DONE</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* get OSM chunk id associated with the hypertable */</comment>
<function><type><name>int</name></type>
<name>ts_chunk_get_osm_chunk_id</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>hypertable_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>chunk_id</name> <init>= <expr><name>INVALID_CHUNK_ID</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scankey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>is_osm_chunk</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Catalog</name> <modifier>*</modifier></type><name>catalog</name> <init>= <expr><call><name>ts_catalog_get</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScannerCtx</name></type> <name>scanctx</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>table</name> <operator>=</operator> <call><name>catalog_get_table_id</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>CHUNK</name></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>index</name> <operator>=</operator> <call><name>catalog_get_index</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>CHUNK</name></expr></argument>, <argument><expr><name>CHUNK_OSM_CHUNK_INDEX</name></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>nkeys</name> <operator>=</operator> <literal type="number">2</literal></expr>,
		<expr><operator>.</operator><name>scankey</name> <operator>=</operator> <name>scankey</name></expr>,
		<expr><operator>.</operator><name>data</name> <operator>=</operator> <operator>&amp;</operator><name>chunk_id</name></expr>,
		<expr><operator>.</operator><name>tuple_found</name> <operator>=</operator> <name>chunk_tuple_osm_chunk_found</name></expr>,
		<expr><operator>.</operator><name>lockmode</name> <operator>=</operator> <name>AccessShareLock</name></expr>,
		<expr><operator>.</operator><name>scandirection</name> <operator>=</operator> <name>ForwardScanDirection</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Perform an index scan on hypertable ID + osm_chunk
	 */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scankey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_chunk_osm_chunk_idx_osm_chunk</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
				<argument><expr><name>F_BOOLEQ</name></expr></argument>,
				<argument><expr><call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>is_osm_chunk</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scankey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_chunk_osm_chunk_idx_hypertable_id</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
				<argument><expr><name>F_INT4EQ</name></expr></argument>,
				<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>hypertable_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>num_found</name> <init>= <expr><call><name>ts_scanner_scan</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scanctx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>num_found</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TS_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"More than 1 OSM chunk found for hypertable (%d)"</literal></expr></argument>, <argument><expr><name>hypertable_id</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>chunk_id</name></expr>;</return>
</block_content>}</block></function>
</unit>
