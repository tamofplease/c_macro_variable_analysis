<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/timescaledb/src/ts_catalog/continuous_agg.c"><comment type="block">/*
 * This file and its contents are licensed under the Apache License 2.0.
 * Please see the included NOTICE for copyright information and
 * LICENSE-APACHE for a copy of the license.
 */</comment>

<comment type="block">/*
 * This file handles commands on continuous aggs that should be allowed in
 * apache only mode. Right now this consists mostly of drop commands
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postgres.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/htup_details.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/xact.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/dependency.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/namespace.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_trigger.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;commands/trigger.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fmgr.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/makefuncs.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;storage/lmgr.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/acl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/builtins.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/date.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/lsyscache.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/timestamp.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;miscadmin.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compat/compat.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"bgw/job.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ts_catalog/continuous_agg.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cross_module_fn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hypercube.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hypertable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hypertable_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"scan_iterator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"time_bucket.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"time_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ts_catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"errors.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BUCKET_FUNCTION_SERIALIZE_VERSION</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_NAME_MATCH</name><parameter_list>(<parameter><type><name>name1</name></type></parameter>, <parameter><type><name>name2</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(namestrcmp(name1, name2) == 0)</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>WithClauseDefinition</name></type> <name><name>continuous_aggregate_with_clause_def</name><index>[]</index></name> <init>= <expr><block>{
		<expr><index>[<expr><name>ContinuousEnabled</name></expr>]</index> <operator>=</operator> <block>{
			<expr><operator>.</operator><name>arg_name</name> <operator>=</operator> <literal type="string">"continuous"</literal></expr>,
			<expr><operator>.</operator><name>type_id</name> <operator>=</operator> <name>BOOLOID</name></expr>,
			<expr><operator>.</operator><name>default_val</name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>,
		}</block></expr>,
		<expr><index>[<expr><name>ContinuousViewOptionCreateGroupIndex</name></expr>]</index> <operator>=</operator> <block>{
			<expr><operator>.</operator><name>arg_name</name> <operator>=</operator> <literal type="string">"create_group_indexes"</literal></expr>,
			<expr><operator>.</operator><name>type_id</name> <operator>=</operator> <name>BOOLOID</name></expr>,
			<expr><operator>.</operator><name>default_val</name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>,
		}</block></expr>,
		<expr><index>[<expr><name>ContinuousViewOptionMaterializedOnly</name></expr>]</index> <operator>=</operator> <block>{
			<expr><operator>.</operator><name>arg_name</name> <operator>=</operator> <literal type="string">"materialized_only"</literal></expr>,
			<expr><operator>.</operator><name>type_id</name> <operator>=</operator> <name>BOOLOID</name></expr>,
			<expr><operator>.</operator><name>default_val</name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>,
		}</block></expr>,
        <expr><index>[<expr><name>ContinuousViewOptionCompress</name></expr>]</index> <operator>=</operator> <block>{
			<expr><operator>.</operator><name>arg_name</name> <operator>=</operator> <literal type="string">"compress"</literal></expr>,
			<expr><operator>.</operator><name>type_id</name> <operator>=</operator> <name>BOOLOID</name></expr>,
		}</block></expr>,
		<expr><index>[<expr><name>ContinuousViewOptionFinalized</name></expr>]</index> <operator>=</operator> <block>{
			<expr><operator>.</operator><name>arg_name</name> <operator>=</operator> <literal type="string">"finalized"</literal></expr>,
			<expr><operator>.</operator><name>type_id</name> <operator>=</operator> <name>BOOLOID</name></expr>,
			<expr><operator>.</operator><name>default_val</name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>,
		}</block></expr>,
}</block></expr></init></decl>;</decl_stmt>

<function><type><name>WithClauseResult</name> <modifier>*</modifier></type>
<name>ts_continuous_agg_with_clause_parse</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>defelems</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>ts_with_clauses_parse</name><argument_list>(<argument><expr><name>defelems</name></expr></argument>,
								 <argument><expr><name>continuous_aggregate_with_clause_def</name></expr></argument>,
								 <argument><expr><call><name>TS_ARRAY_LEN</name><argument_list>(<argument><expr><name>continuous_aggregate_with_clause_def</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>init_scan_by_mat_hypertable_id</name><parameter_list>(<parameter><decl><type><name>ScanIterator</name> <modifier>*</modifier></type><name>iterator</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int32</name></type> <name>mat_hypertable_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>ctx</name><operator>.</operator><name>index</name></name> <operator>=</operator> <call><name>catalog_get_index</name><argument_list>(<argument><expr><call><name>ts_catalog_get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>CONTINUOUS_AGG</name></expr></argument>, <argument><expr><name>CONTINUOUS_AGG_PKEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ts_scan_iterator_scan_key_init</name><argument_list>(<argument><expr><name>iterator</name></expr></argument>,
								   <argument><expr><name>Anum_continuous_agg_pkey_mat_hypertable_id</name></expr></argument>,
								   <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
								   <argument><expr><name>F_INT4EQ</name></expr></argument>,
								   <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>mat_hypertable_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>init_scan_cagg_bucket_function_by_mat_hypertable_id</name><parameter_list>(<parameter><decl><type><name>ScanIterator</name> <modifier>*</modifier></type><name>iterator</name></decl></parameter>,
													<parameter><decl><type><specifier>const</specifier> <name>int32</name></type> <name>mat_hypertable_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>ctx</name><operator>.</operator><name>index</name></name> <operator>=</operator> <call><name>catalog_get_index</name><argument_list>(<argument><expr><call><name>ts_catalog_get</name><argument_list>()</argument_list></call></expr></argument>,
											<argument><expr><name>CONTINUOUS_AGGS_BUCKET_FUNCTION</name></expr></argument>,
											<argument><expr><name>CONTINUOUS_AGGS_BUCKET_FUNCTION_PKEY_IDX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ts_scan_iterator_scan_key_init</name><argument_list>(<argument><expr><name>iterator</name></expr></argument>,
								   <argument><expr><name>Anum_continuous_aggs_bucket_function_pkey_mat_hypertable_id</name></expr></argument>,
								   <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
								   <argument><expr><name>F_INT4EQ</name></expr></argument>,
								   <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>mat_hypertable_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>init_scan_by_raw_hypertable_id</name><parameter_list>(<parameter><decl><type><name>ScanIterator</name> <modifier>*</modifier></type><name>iterator</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int32</name></type> <name>raw_hypertable_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>ctx</name><operator>.</operator><name>index</name></name> <operator>=</operator>
		<call><name>catalog_get_index</name><argument_list>(<argument><expr><call><name>ts_catalog_get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>CONTINUOUS_AGG</name></expr></argument>, <argument><expr><name>CONTINUOUS_AGG_RAW_HYPERTABLE_ID_IDX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ts_scan_iterator_scan_key_init</name><argument_list>(<argument><expr><name>iterator</name></expr></argument>,
								   <argument><expr><name>Anum_continuous_agg_raw_hypertable_id_idx_raw_hypertable_id</name></expr></argument>,
								   <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
								   <argument><expr><name>F_INT4EQ</name></expr></argument>,
								   <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>raw_hypertable_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>init_invalidation_threshold_scan_by_hypertable_id</name><parameter_list>(<parameter><decl><type><name>ScanIterator</name> <modifier>*</modifier></type><name>iterator</name></decl></parameter>,
												  <parameter><decl><type><specifier>const</specifier> <name>int32</name></type> <name>raw_hypertable_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>ctx</name><operator>.</operator><name>index</name></name> <operator>=</operator> <call><name>catalog_get_index</name><argument_list>(<argument><expr><call><name>ts_catalog_get</name><argument_list>()</argument_list></call></expr></argument>,
											<argument><expr><name>CONTINUOUS_AGGS_INVALIDATION_THRESHOLD</name></expr></argument>,
											<argument><expr><name>CONTINUOUS_AGGS_INVALIDATION_THRESHOLD_PKEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ts_scan_iterator_scan_key_init</name><argument_list>(<argument><expr><name>iterator</name></expr></argument>,
								   <argument><expr><name>Anum_continuous_aggs_invalidation_threshold_pkey_hypertable_id</name></expr></argument>,
								   <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
								   <argument><expr><name>F_INT4EQ</name></expr></argument>,
								   <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>raw_hypertable_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>init_hypertable_invalidation_log_scan_by_hypertable_id</name><parameter_list>(<parameter><decl><type><name>ScanIterator</name> <modifier>*</modifier></type><name>iterator</name></decl></parameter>,
													   <parameter><decl><type><specifier>const</specifier> <name>int32</name></type> <name>raw_hypertable_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>ctx</name><operator>.</operator><name>index</name></name> <operator>=</operator> <call><name>catalog_get_index</name><argument_list>(<argument><expr><call><name>ts_catalog_get</name><argument_list>()</argument_list></call></expr></argument>,
											<argument><expr><name>CONTINUOUS_AGGS_HYPERTABLE_INVALIDATION_LOG</name></expr></argument>,
											<argument><expr><name>CONTINUOUS_AGGS_HYPERTABLE_INVALIDATION_LOG_IDX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ts_scan_iterator_scan_key_init</name><argument_list>(
		<argument><expr><name>iterator</name></expr></argument>,
		<argument><expr><name>Anum_continuous_aggs_hypertable_invalidation_log_idx_hypertable_id</name></expr></argument>,
		<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
		<argument><expr><name>F_INT4EQ</name></expr></argument>,
		<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>raw_hypertable_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>init_materialization_invalidation_log_scan_by_materialization_id</name><parameter_list>(<parameter><decl><type><name>ScanIterator</name> <modifier>*</modifier></type><name>iterator</name></decl></parameter>,
																 <parameter><decl><type><specifier>const</specifier> <name>int32</name></type> <name>materialization_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>ctx</name><operator>.</operator><name>index</name></name> <operator>=</operator> <call><name>catalog_get_index</name><argument_list>(<argument><expr><call><name>ts_catalog_get</name><argument_list>()</argument_list></call></expr></argument>,
											<argument><expr><name>CONTINUOUS_AGGS_MATERIALIZATION_INVALIDATION_LOG</name></expr></argument>,
											<argument><expr><name>CONTINUOUS_AGGS_MATERIALIZATION_INVALIDATION_LOG_IDX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ts_scan_iterator_scan_key_init</name><argument_list>(
		<argument><expr><name>iterator</name></expr></argument>,
		<argument><expr><name>Anum_continuous_aggs_materialization_invalidation_log_idx_materialization_id</name></expr></argument>,
		<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
		<argument><expr><name>F_INT4EQ</name></expr></argument>,
		<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>materialization_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32</name></type>
<name>number_of_continuous_aggs_attached</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>raw_hypertable_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScanIterator</name></type> <name>iterator</name> <init>=
		<expr><call><name>ts_scan_iterator_create</name><argument_list>(<argument><expr><name>CONTINUOUS_AGG</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>, <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>init_scan_by_raw_hypertable_id</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>, <argument><expr><name>raw_hypertable_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>ts_scanner_foreach</name><argument_list>(<argument>&amp;iterator</argument>)</argument_list></macro> <block>{<block_content> <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block>
	<return>return <expr><name>count</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>invalidation_threshold_delete</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>raw_hypertable_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScanIterator</name></type> <name>iterator</name> <init>= <expr><call><name>ts_scan_iterator_create</name><argument_list>(<argument><expr><name>CONTINUOUS_AGGS_INVALIDATION_THRESHOLD</name></expr></argument>,
													<argument><expr><name>RowExclusiveLock</name></expr></argument>,
													<argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>init_invalidation_threshold_scan_by_hypertable_id</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>, <argument><expr><name>raw_hypertable_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>ts_scanner_foreach</name><argument_list>(<argument>&amp;iterator</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name> <init>= <expr><call><name>ts_scan_iterator_tuple_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ts_catalog_delete_tid</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>scanrel</name></name></expr></argument>, <argument><expr><call><name>ts_scanner_get_tuple_tid</name><argument_list>(<argument><expr><name>ti</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>cagg_bucket_function_delete</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>mat_hypertable_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScanIterator</name></type> <name>iterator</name> <init>= <expr><call><name>ts_scan_iterator_create</name><argument_list>(<argument><expr><name>CONTINUOUS_AGGS_BUCKET_FUNCTION</name></expr></argument>,
													<argument><expr><name>RowExclusiveLock</name></expr></argument>,
													<argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>init_scan_cagg_bucket_function_by_mat_hypertable_id</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>, <argument><expr><name>mat_hypertable_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>ts_scanner_foreach</name><argument_list>(<argument>&amp;iterator</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name> <init>= <expr><call><name>ts_scan_iterator_tuple_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ts_catalog_delete_tid</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>scanrel</name></name></expr></argument>, <argument><expr><call><name>ts_scanner_get_tuple_tid</name><argument_list>(<argument><expr><name>ti</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>hypertable_invalidation_log_delete</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>raw_hypertable_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScanIterator</name></type> <name>iterator</name> <init>= <expr><call><name>ts_scan_iterator_create</name><argument_list>(<argument><expr><name>CONTINUOUS_AGGS_HYPERTABLE_INVALIDATION_LOG</name></expr></argument>,
													<argument><expr><name>RowExclusiveLock</name></expr></argument>,
													<argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>init_hypertable_invalidation_log_scan_by_hypertable_id</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>, <argument><expr><name>raw_hypertable_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>ts_scanner_foreach</name><argument_list>(<argument>&amp;iterator</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name> <init>= <expr><call><name>ts_scan_iterator_tuple_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ts_catalog_delete_tid</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>scanrel</name></name></expr></argument>, <argument><expr><call><name>ts_scanner_get_tuple_tid</name><argument_list>(<argument><expr><name>ti</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<expr_stmt><expr><call><name>TS_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>ts_hypertable_invalidation_log_delete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block" format="doxygen">/**
 * Delete hypertable invalidation log entries for all the CAGGs that belong to the
 * distributed hypertable with hypertable ID 'raw_hypertable_id' in the Access Node.
 *
 * @param raw_hypertable_id - The hypertable ID of the original distributed hypertable in the
 *                            Access Node.
 */</comment>
<function><type><name>Datum</name></type>
<name>ts_hypertable_invalidation_log_delete</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type> <name>raw_hypertable_id</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"invalidation log delete for hypertable %d"</literal></expr></argument>, <argument><expr><name>raw_hypertable_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>hypertable_invalidation_log_delete</name><argument_list>(<argument><expr><name>raw_hypertable_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ts_materialization_invalidation_log_delete_inner</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>mat_hypertable_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScanIterator</name></type> <name>iterator</name> <init>=
		<expr><call><name>ts_scan_iterator_create</name><argument_list>(<argument><expr><name>CONTINUOUS_AGGS_MATERIALIZATION_INVALIDATION_LOG</name></expr></argument>,
								<argument><expr><name>RowExclusiveLock</name></expr></argument>,
								<argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"materialization log delete for hypertable %d"</literal></expr></argument>, <argument><expr><name>mat_hypertable_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>init_materialization_invalidation_log_scan_by_materialization_id</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>, <argument><expr><name>mat_hypertable_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>ts_scanner_foreach</name><argument_list>(<argument>&amp;iterator</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name> <init>= <expr><call><name>ts_scan_iterator_tuple_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ts_catalog_delete_tid</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>scanrel</name></name></expr></argument>, <argument><expr><call><name>ts_scanner_get_tuple_tid</name><argument_list>(<argument><expr><name>ti</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<expr_stmt><expr><call><name>TS_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>ts_materialization_invalidation_log_delete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block" format="doxygen">/**
 * Delete materialization invalidation log entries for the CAGG that belong to the
 * materialized hypertable with ID 'mat_hypertable_id' in the Access Node.
 *
 * @param mat_hypertable_id The hypertable ID of the CAGG materialized hypertable in the Access
 *                          Node.
 */</comment>
<function><type><name>Datum</name></type>
<name>ts_materialization_invalidation_log_delete</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type> <name>mat_hypertable_id</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ts_materialization_invalidation_log_delete_inner</name><argument_list>(<argument><expr><name>mat_hypertable_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>HeapTuple</name></type>
<name>continuous_agg_formdata_make_tuple</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FormData_continuous_agg</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>desc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type> <name><name>values</name><index>[<expr><name>Natts_continuous_agg</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name><name>nulls</name><index>[<expr><name>Natts_continuous_agg</name></expr>]</index></name> <init>= <expr><block>{ <expr><name>false</name></expr> }</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>Natts_continuous_agg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_continuous_agg_mat_hypertable_id</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
		<call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>fd</name><operator>-&gt;</operator><name>mat_hypertable_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_continuous_agg_raw_hypertable_id</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
		<call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>fd</name><operator>-&gt;</operator><name>raw_hypertable_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fd</name><operator>-&gt;</operator><name>parent_mat_hypertable_id</name></name> <operator>==</operator> <name>INVALID_HYPERTABLE_ID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_continuous_agg_parent_mat_hypertable_id</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_continuous_agg_parent_mat_hypertable_id</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
			<call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>fd</name><operator>-&gt;</operator><name>parent_mat_hypertable_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_continuous_agg_user_view_schema</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
		<call><name>NameGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fd</name><operator>-&gt;</operator><name>user_view_schema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_continuous_agg_user_view_name</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
		<call><name>NameGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fd</name><operator>-&gt;</operator><name>user_view_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_continuous_agg_partial_view_schema</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
		<call><name>NameGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fd</name><operator>-&gt;</operator><name>partial_view_schema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_continuous_agg_partial_view_name</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
		<call><name>NameGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fd</name><operator>-&gt;</operator><name>partial_view_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_continuous_agg_bucket_width</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
		<call><name>Int64GetDatum</name><argument_list>(<argument><expr><name><name>fd</name><operator>-&gt;</operator><name>bucket_width</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_continuous_agg_direct_view_schema</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
		<call><name>NameGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fd</name><operator>-&gt;</operator><name>direct_view_schema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_continuous_agg_direct_view_name</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
		<call><name>NameGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fd</name><operator>-&gt;</operator><name>direct_view_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_continuous_agg_materialize_only</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
		<call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>fd</name><operator>-&gt;</operator><name>materialized_only</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_continuous_agg_finalized</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>fd</name><operator>-&gt;</operator><name>finalized</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>continuous_agg_formdata_fill</name><parameter_list>(<parameter><decl><type><name>FormData_continuous_agg</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>should_free</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name><name>values</name><index>[<expr><name>Natts_continuous_agg</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name><name>nulls</name><index>[<expr><name>Natts_continuous_agg</name></expr>]</index></name> <init>= <expr><block>{ <expr><name>false</name></expr> }</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>ts_scanner_fetch_heap_tuple</name><argument_list>(<argument><expr><name>ti</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>should_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><call><name>ts_scanner_get_tupledesc</name><argument_list>(<argument><expr><name>ti</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>mat_hypertable_id</name></name> <operator>=</operator>
		<call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_continuous_agg_mat_hypertable_id</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>raw_hypertable_id</name></name> <operator>=</operator>
		<call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_continuous_agg_raw_hypertable_id</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>nulls</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_continuous_agg_parent_mat_hypertable_id</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>parent_mat_hypertable_id</name></name> <operator>=</operator> <name>INVALID_HYPERTABLE_ID</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>parent_mat_hypertable_id</name></name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(
			<argument><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_continuous_agg_parent_mat_hypertable_id</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fd</name><operator>-&gt;</operator><name>user_view_schema</name></name></expr></argument>,
		   <argument><expr><call><name>DatumGetName</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_continuous_agg_user_view_schema</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fd</name><operator>-&gt;</operator><name>user_view_name</name></name></expr></argument>,
		   <argument><expr><call><name>DatumGetName</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_continuous_agg_user_view_name</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fd</name><operator>-&gt;</operator><name>partial_view_schema</name></name></expr></argument>,
		   <argument><expr><call><name>DatumGetName</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_continuous_agg_partial_view_schema</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fd</name><operator>-&gt;</operator><name>partial_view_name</name></name></expr></argument>,
		   <argument><expr><call><name>DatumGetName</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_continuous_agg_partial_view_name</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>bucket_width</name></name> <operator>=</operator>
		<call><name>DatumGetInt64</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_continuous_agg_bucket_width</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fd</name><operator>-&gt;</operator><name>direct_view_schema</name></name></expr></argument>,
		   <argument><expr><call><name>DatumGetName</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_continuous_agg_direct_view_schema</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fd</name><operator>-&gt;</operator><name>direct_view_name</name></name></expr></argument>,
		   <argument><expr><call><name>DatumGetName</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_continuous_agg_direct_view_name</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>materialized_only</name></name> <operator>=</operator>
		<call><name>DatumGetBool</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_continuous_agg_materialize_only</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>finalized</name></name> <operator>=</operator> <call><name>DatumGetBool</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_continuous_agg_finalized</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>should_free</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>continuous_agg_fill_bucket_function</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>mat_hypertable_id</name></decl></parameter>, <parameter><decl><type><name>ContinuousAggsBucketFunction</name> <modifier>*</modifier></type><name>bf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScanIterator</name></type> <name>iterator</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>iterator</name> <operator>=</operator> <call><name>ts_scan_iterator_create</name><argument_list>(<argument><expr><name>CONTINUOUS_AGGS_BUCKET_FUNCTION</name></expr></argument>,
									   <argument><expr><name>AccessShareLock</name></expr></argument>,
									   <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>init_scan_cagg_bucket_function_by_mat_hypertable_id</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>, <argument><expr><name>mat_hypertable_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>ts_scanner_foreach</name><argument_list>(<argument>&amp;iterator</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>bucket_width_str</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>origin_str</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type> <name><name>values</name><index>[<expr><name>Natts_continuous_aggs_bucket_function</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name><name>isnull</name><index>[<expr><name>Natts_continuous_aggs_bucket_function</name></expr>]</index></name></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>bool</name></type> <name>should_free</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name> <init>= <expr><call><name>ts_scan_iterator_fetch_heap_tuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>should_free</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Our usual GETSTRUCT() approach doesn't work when TEXT fields are involved,
		 * thus a more robust approach with heap_deform_tuple() is used here.
		 */</comment>
		<expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><call><name>ts_scan_iterator_tupledesc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>isnull</name><index>[<expr><name>Anum_continuous_aggs_bucket_function_experimental</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bf</name><operator>-&gt;</operator><name>experimental</name></name> <operator>=</operator>
			<call><name>DatumGetBool</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>Anum_continuous_aggs_bucket_function_experimental</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>isnull</name><index>[<expr><name>Anum_continuous_aggs_bucket_function_name</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bf</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>Anum_continuous_aggs_bucket_function_name</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * So far bucket_width is stored as TEXT for flexibility, but it's type
		 * most likely is going to change to Interval when the variable-sized
		 * buckets feature will stabilize.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>isnull</name><index>[<expr><name>Anum_continuous_aggs_bucket_function_bucket_width</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bucket_width_str</name> <operator>=</operator>
			<call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>Anum_continuous_aggs_bucket_function_bucket_width</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>bucket_width_str</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bf</name><operator>-&gt;</operator><name>bucket_width</name></name> <operator>=</operator> <call><name>DatumGetIntervalP</name><argument_list>(
			<argument><expr><call><name>DirectFunctionCall3</name><argument_list>(<argument><expr><name>interval_in</name></expr></argument>, <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>bucket_width_str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>isnull</name><index>[<expr><name>Anum_continuous_aggs_bucket_function_origin</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>origin_str</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>Anum_continuous_aggs_bucket_function_origin</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>origin_str</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>TIMESTAMP_NOBEGIN</name><argument_list>(<argument><expr><name><name>bf</name><operator>-&gt;</operator><name>origin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>bf</name><operator>-&gt;</operator><name>origin</name></name> <operator>=</operator> <call><name>DatumGetTimestamp</name><argument_list>(<argument><expr><call><name>DirectFunctionCall3</name><argument_list>(<argument><expr><name>timestamp_in</name></expr></argument>,
															   <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>origin_str</name></expr></argument>)</argument_list></call></expr></argument>,
															   <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr></argument>,
															   <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>isnull</name><index>[<expr><name>Anum_continuous_aggs_bucket_function_timezone</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bf</name><operator>-&gt;</operator><name>timezone</name></name> <operator>=</operator>
			<call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>Anum_continuous_aggs_bucket_function_timezone</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>should_free</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * This function should never be called unless we know that the corresponding
	 * cagg exists and uses a variable-sized bucket. There should be exactly one
	 * entry in .continuous_aggs_bucket_function catalog table for such a cagg.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>count</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid or missing information about the bucketing function for cagg"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>mat_hypertable_id</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>continuous_agg_init</name><parameter_list>(<parameter><decl><type><name>ContinuousAgg</name> <modifier>*</modifier></type><name>cagg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Form_continuous_agg</name></type> <name>fd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>nspid</name> <init>= <expr><call><name>get_namespace_oid</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>fd</name><operator>-&gt;</operator><name>user_view_schema</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>cagg_ht</name> <init>= <expr><call><name>ts_hypertable_get_by_id</name><argument_list>(<argument><expr><name><name>fd</name><operator>-&gt;</operator><name>mat_hypertable_id</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type><name>time_dim</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>cagg_ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>time_dim</name> <operator>=</operator> <call><name>hyperspace_get_open_dimension</name><argument_list>(<argument><expr><name><name>cagg_ht</name><operator>-&gt;</operator><name>space</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>time_dim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cagg</name><operator>-&gt;</operator><name>partition_type</name></name> <operator>=</operator> <call><name>ts_dimension_get_partition_type</name><argument_list>(<argument><expr><name>time_dim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cagg</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <call><name>get_relname_relid</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>fd</name><operator>-&gt;</operator><name>user_view_name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nspid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cagg</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>partition_type</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ts_continuous_agg_bucket_width_variable</name><argument_list>(<argument><expr><name>cagg</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>cagg</name><operator>-&gt;</operator><name>bucket_function</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ContinuousAggsBucketFunction</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>continuous_agg_fill_bucket_function</name><argument_list>(<argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>mat_hypertable_id</name></name></expr></argument>, <argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>bucket_function</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>TSDLLEXPORT</name> <name>CaggsInfo</name></type>
<name>ts_continuous_agg_get_all_caggs_info</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>raw_hypertable_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CaggsInfo</name></type> <name>all_caggs_info</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>caggs</name> <init>= <expr><call><name>ts_continuous_aggs_find_by_raw_table_id</name><argument_list>(<argument><expr><name>raw_hypertable_id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>bucket_width</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>all_caggs_info</name><operator>.</operator><name>bucket_widths</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>all_caggs_info</name><operator>.</operator><name>mat_hypertable_ids</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>all_caggs_info</name><operator>.</operator><name>bucket_functions</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>caggs</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>caggs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ContinuousAgg</name> <modifier>*</modifier></type><name>cagg</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>bucket_width</name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><ternary><condition><expr><call><name>ts_continuous_agg_bucket_width_variable</name><argument_list>(<argument><expr><name>cagg</name></expr></argument>)</argument_list></call></expr> ?</condition><then>
										 <expr><name>BUCKET_WIDTH_VARIABLE</name></expr> </then><else>:
										 <expr><call><name>ts_continuous_agg_bucket_width</name><argument_list>(<argument><expr><name>cagg</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>all_caggs_info</name><operator>.</operator><name>bucket_widths</name></name> <operator>=</operator>
			<call><name>lappend</name><argument_list>(<argument><expr><name><name>all_caggs_info</name><operator>.</operator><name>bucket_widths</name></name></expr></argument>, <argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>bucket_width</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>all_caggs_info</name><operator>.</operator><name>bucket_functions</name></name> <operator>=</operator>
			<call><name>lappend</name><argument_list>(<argument><expr><name><name>all_caggs_info</name><operator>.</operator><name>bucket_functions</name></name></expr></argument>, <argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>bucket_function</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>all_caggs_info</name><operator>.</operator><name>mat_hypertable_ids</name></name> <operator>=</operator>
			<call><name>lappend_int</name><argument_list>(<argument><expr><name><name>all_caggs_info</name><operator>.</operator><name>mat_hypertable_ids</name></name></expr></argument>, <argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>mat_hypertable_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<return>return <expr><name>all_caggs_info</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Serializes ContinuousAggsBucketFunction* into a string like:
 *
 *     ver;bucket_width;origin;timezone;
 *
 * ... where ver is a version of the serialization format. This particular format
 * was chosen because of it's simplicity and good performance. Future versions
 * of the procedure can use other format (like key=value or JSON) and/or add
 * extra fields. NULL pointer is serialized to an empty string.
 *
 * Note that the schema and the name of the function are not serialized. This
 * is intentional since this information is currently not used for anything.
 * We can serialize the name of the function as well when and if this would be
 * necessary.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>bucket_function_serialize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ContinuousAggsBucketFunction</name> <modifier>*</modifier></type><name>bf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>bucket_width_str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>origin_str</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>str</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>bf</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="string">""</literal></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We are pretty sure that user can't place ';' character in this field */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>strstr</name><argument_list>(<argument><expr><name><name>bf</name><operator>-&gt;</operator><name>timezone</name></name></expr></argument>, <argument><expr><literal type="string">";"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>bucket_width_str</name> <operator>=</operator>
		<call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>interval_out</name></expr></argument>, <argument><expr><call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><name><name>bf</name><operator>-&gt;</operator><name>bucket_width</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TIMESTAMP_NOT_FINITE</name><argument_list>(<argument><expr><name><name>bf</name><operator>-&gt;</operator><name>origin</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>origin_str</name> <operator>=</operator>
			<call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>timestamp_out</name></expr></argument>, <argument><expr><call><name>TimestampGetDatum</name><argument_list>(<argument><expr><name><name>bf</name><operator>-&gt;</operator><name>origin</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>,
					 <argument><expr><literal type="string">"%d;%s;%s;%s;"</literal></expr></argument>,
					 <argument><expr><name>BUCKET_FUNCTION_SERIALIZE_VERSION</name></expr></argument>,
					 <argument><expr><name>bucket_width_str</name></expr></argument>,
					 <argument><expr><name>origin_str</name></expr></argument>,
					 <argument><expr><name><name>bf</name><operator>-&gt;</operator><name>timezone</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>str</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Deserielizes a string into a palloc'ated ContinuousAggsBucketFunction*. Note
 * that NULL is also a valid return value.
 *
 * See bucket_function_serialize() for more details.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>ContinuousAggsBucketFunction</name> <modifier>*</modifier></type>
<name>bucket_function_deserialize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>begin</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name><name>strings</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ContinuousAggsBucketFunction</name> <modifier>*</modifier></type><name>bf</name></decl>;</decl_stmt>

	<comment type="block">/* empty string stands for serialized NULL */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>str</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>begin</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>strings</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>end</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>begin</name></expr></argument>, <argument><expr><literal type="string">";"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>end</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"failed to deserialize \"%s\" into a bucketing function"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"separator not found"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><operator>*</operator><name>end</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>strings</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>begin</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>begin</name> <operator>=</operator> <name>end</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* end of string was reached */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>begin</name> <operator>==</operator> <literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>atoi</name><argument_list>(<argument><expr><name><name>strings</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"failed to deserialize \"%s\" into a bucketing function"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"unsupported format version"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>bf</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ContinuousAggsBucketFunction</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bf</name><operator>-&gt;</operator><name>experimental</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bf</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <literal type="string">"time_bucket_ng"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>strings</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bf</name><operator>-&gt;</operator><name>bucket_width</name></name> <operator>=</operator> <call><name>DatumGetIntervalP</name><argument_list>(
		<argument><expr><call><name>DirectFunctionCall3</name><argument_list>(<argument><expr><name>interval_in</name></expr></argument>, <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name><name>strings</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>strings</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>TIMESTAMP_NOBEGIN</name><argument_list>(<argument><expr><name><name>bf</name><operator>-&gt;</operator><name>origin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>bf</name><operator>-&gt;</operator><name>origin</name></name> <operator>=</operator> <call><name>DatumGetTimestamp</name><argument_list>(<argument><expr><call><name>DirectFunctionCall3</name><argument_list>(<argument><expr><name>timestamp_in</name></expr></argument>,
														   <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name><name>strings</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
														   <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr></argument>,
														   <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name><name>bf</name><operator>-&gt;</operator><name>timezone</name></name> <operator>=</operator> <name><name>strings</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
	<return>return <expr><name>bf</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Does not do deep copy of Datums For performance reasons. Make sure the arrays are not deallocated
 * before CaggsInfo.
 */</comment>
<function><type><name>TSDLLEXPORT</name> <name>void</name></type>
<name>ts_populate_caggs_info_from_arrays</name><parameter_list>(<parameter><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>mat_hypertable_ids</name></decl></parameter>, <parameter><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>bucket_widths</name></decl></parameter>,
								   <parameter><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>bucket_functions</name></decl></parameter>, <parameter><decl><type><name>CaggsInfo</name> <modifier>*</modifier></type><name>all_caggs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>all_caggs</name><operator>-&gt;</operator><name>mat_hypertable_ids</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>all_caggs</name><operator>-&gt;</operator><name>bucket_widths</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>all_caggs</name><operator>-&gt;</operator><name>bucket_functions</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>mat_hypertable_ids</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>bucket_widths</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		   <call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>bucket_functions</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>mat_hypertable_ids</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>bucket_widths</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		   <call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>bucket_functions</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>bucket_widths</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ArrayIterator</name></type> <name>it_htids</name></decl>, <decl><type ref="prev"/><name>it_widths</name></decl>, <decl><type ref="prev"/><name>it_bfs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>array_datum1</name></decl>, <decl><type ref="prev"/><name>array_datum2</name></decl>, <decl><type ref="prev"/><name>array_datum3</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>isnull1</name></decl>, <decl><type ref="prev"/><name>isnull2</name></decl>, <decl><type ref="prev"/><name>isnull3</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>it_htids</name> <operator>=</operator> <call><name>array_create_iterator</name><argument_list>(<argument><expr><name>mat_hypertable_ids</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>it_widths</name> <operator>=</operator> <call><name>array_create_iterator</name><argument_list>(<argument><expr><name>bucket_widths</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>it_bfs</name> <operator>=</operator> <call><name>array_create_iterator</name><argument_list>(<argument><expr><name>bucket_functions</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><call><name>array_iterate</name><argument_list>(<argument><expr><name>it_htids</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>array_datum1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull1</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		   <call><name>array_iterate</name><argument_list>(<argument><expr><name>it_widths</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>array_datum2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull2</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		   <call><name>array_iterate</name><argument_list>(<argument><expr><name>it_bfs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>array_datum3</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull3</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull1</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>isnull2</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>isnull3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>int32</name></type> <name>mat_hypertable_id</name> <init>= <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>array_datum1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>all_caggs</name><operator>-&gt;</operator><name>mat_hypertable_ids</name></name> <operator>=</operator>
			<call><name>lappend_int</name><argument_list>(<argument><expr><name><name>all_caggs</name><operator>-&gt;</operator><name>mat_hypertable_ids</name></name></expr></argument>, <argument><expr><name>mat_hypertable_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>Datum</name></type> <name>bucket_width</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>bucket_width</name> <operator>=</operator> <name>array_datum2</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>all_caggs</name><operator>-&gt;</operator><name>bucket_widths</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>all_caggs</name><operator>-&gt;</operator><name>bucket_widths</name></name></expr></argument>, <argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>bucket_width</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><specifier>const</specifier> <name>ContinuousAggsBucketFunction</name> <modifier>*</modifier></type><name>bucket_function</name> <init>=
			<expr><call><name>bucket_function_deserialize</name><argument_list>(<argument><expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>array_datum3</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="block">/* bucket_function is cast to non-const type to make Visual Studio happy */</comment>
		<expr_stmt><expr><name><name>all_caggs</name><operator>-&gt;</operator><name>bucket_functions</name></name> <operator>=</operator>
			<call><name>lappend</name><argument_list>(<argument><expr><name><name>all_caggs</name><operator>-&gt;</operator><name>bucket_functions</name></name></expr></argument>, <argument><expr><operator>(</operator><name>ContinuousAggsBucketFunction</name> <operator>*</operator><operator>)</operator> <name>bucket_function</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>array_free_iterator</name><argument_list>(<argument><expr><name>it_htids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_free_iterator</name><argument_list>(<argument><expr><name>it_widths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_free_iterator</name><argument_list>(<argument><expr><name>it_bfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Does not do deep copy of Datums For performance reasons. Make sure the Caggsinfo is not
 * deallocated before the arrays.
 */</comment>
<function><type><name>TSDLLEXPORT</name> <name>void</name></type>
<name>ts_create_arrays_from_caggs_info</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CaggsInfo</name> <modifier>*</modifier></type><name>all_caggs</name></decl></parameter>, <parameter><decl><type><name>ArrayType</name> <modifier>*</modifier><modifier>*</modifier></type><name>mat_hypertable_ids</name></decl></parameter>,
								 <parameter><decl><type><name>ArrayType</name> <modifier>*</modifier><modifier>*</modifier></type><name>bucket_widths</name></decl></parameter>, <parameter><decl><type><name>ArrayType</name> <modifier>*</modifier><modifier>*</modifier></type><name>bucket_functions</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>lc2</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>lc3</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>matiddatums</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>all_caggs</name><operator>-&gt;</operator><name>mat_hypertable_ids</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>widthdatums</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>all_caggs</name><operator>-&gt;</operator><name>bucket_widths</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>bucketfunctions</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>all_caggs</name><operator>-&gt;</operator><name>bucket_functions</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>forthree</name> <argument_list>(<argument>lc1</argument>,
			  <argument>all_caggs-&gt;mat_hypertable_ids</argument>,
			  <argument>lc2</argument>,
			  <argument>all_caggs-&gt;bucket_widths</argument>,
			  <argument>lc3</argument>,
			  <argument>all_caggs-&gt;bucket_functions</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int32</name></type> <name>cagg_hyper_id</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>matiddatums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>cagg_hyper_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>widthdatums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><specifier>const</specifier> <name>ContinuousAggsBucketFunction</name> <modifier>*</modifier></type><name>bucket_function</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc3</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>bucketfunctions</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><call><name>bucket_function_serialize</name><argument_list>(<argument><expr><name>bucket_function</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><operator>++</operator><name>i</name></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><operator>*</operator><name>mat_hypertable_ids</name> <operator>=</operator> <call><name>construct_array</name><argument_list>(<argument><expr><name>matiddatums</name></expr></argument>,
										  <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>all_caggs</name><operator>-&gt;</operator><name>mat_hypertable_ids</name></name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><name>INT4OID</name></expr></argument>,
										  <argument><expr><literal type="number">4</literal></expr></argument>,
										  <argument><expr><name>true</name></expr></argument>,
										  <argument><expr><name>TYPALIGN_INT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>bucket_widths</name> <operator>=</operator> <call><name>construct_array</name><argument_list>(<argument><expr><name>widthdatums</name></expr></argument>,
									 <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>all_caggs</name><operator>-&gt;</operator><name>bucket_widths</name></name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><name>INT8OID</name></expr></argument>,
									 <argument><expr><literal type="number">8</literal></expr></argument>,
									 <argument><expr><name>FLOAT8PASSBYVAL</name></expr></argument>,
									 <argument><expr><name>TYPALIGN_DOUBLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>bucket_functions</name> <operator>=</operator> <call><name>construct_array</name><argument_list>(<argument><expr><name>bucketfunctions</name></expr></argument>,
										<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>all_caggs</name><operator>-&gt;</operator><name>bucket_functions</name></name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><name>TEXTOID</name></expr></argument>,
										<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
										<argument><expr><name>false</name></expr></argument>,
										<argument><expr><name>TYPALIGN_INT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>TSDLLEXPORT</name> <name>ContinuousAggHypertableStatus</name></type>
<name>ts_continuous_agg_hypertable_status</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>hypertable_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScanIterator</name></type> <name>iterator</name> <init>=
		<expr><call><name>ts_scan_iterator_create</name><argument_list>(<argument><expr><name>CONTINUOUS_AGG</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>, <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ContinuousAggHypertableStatus</name></type> <name>status</name> <init>= <expr><name>HypertableIsNotContinuousAgg</name></expr></init></decl>;</decl_stmt>

	<macro><name>ts_scanner_foreach</name><argument_list>(<argument>&amp;iterator</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FormData_continuous_agg</name></type> <name>data</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name> <init>= <expr><call><name>ts_scan_iterator_tuple_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>continuous_agg_formdata_fill</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><name>ti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>data</name><operator>.</operator><name>raw_hypertable_id</name></name> <operator>==</operator> <name>hypertable_id</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>status</name> <operator>|=</operator> <name>HypertableIsRawTable</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>data</name><operator>.</operator><name>mat_hypertable_id</name></name> <operator>==</operator> <name>hypertable_id</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>status</name> <operator>|=</operator> <name>HypertableIsMaterialization</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>HypertableIsMaterializationAndRaw</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ts_scan_iterator_close</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>status</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>TSDLLEXPORT</name> <name>List</name> <modifier>*</modifier></type>
<name>ts_continuous_aggs_find_by_raw_table_id</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>raw_hypertable_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>continuous_aggs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanIterator</name></type> <name>iterator</name> <init>=
		<expr><call><name>ts_scan_iterator_create</name><argument_list>(<argument><expr><name>CONTINUOUS_AGG</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>, <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>init_scan_by_raw_hypertable_id</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>, <argument><expr><name>raw_hypertable_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>ts_scanner_foreach</name><argument_list>(<argument>&amp;iterator</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ContinuousAgg</name> <modifier>*</modifier></type><name>ca</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>FormData_continuous_agg</name></type> <name>data</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldmctx</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name> <init>= <expr><call><name>ts_scan_iterator_tuple_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>continuous_agg_formdata_fill</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><name>ti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>oldmctx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>ts_scan_iterator_get_result_memory_context</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ca</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>ca</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>continuous_agg_init</name><argument_list>(<argument><expr><name>ca</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>continuous_aggs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>continuous_aggs</name></expr></argument>, <argument><expr><name>ca</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldmctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>continuous_aggs</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Find a continuous aggregate by the materialized hypertable id */</comment>
<function><type><name>ContinuousAgg</name> <modifier>*</modifier></type>
<name>ts_continuous_agg_find_by_mat_hypertable_id</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>mat_hypertable_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ContinuousAgg</name> <modifier>*</modifier></type><name>ca</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanIterator</name></type> <name>iterator</name> <init>=
		<expr><call><name>ts_scan_iterator_create</name><argument_list>(<argument><expr><name>CONTINUOUS_AGG</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>, <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>init_scan_by_mat_hypertable_id</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>, <argument><expr><name>mat_hypertable_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>ts_scanner_foreach</name><argument_list>(<argument>&amp;iterator</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name> <init>= <expr><call><name>ts_scan_iterator_tuple_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>FormData_continuous_agg</name></type> <name>form</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>continuous_agg_formdata_fill</name><argument_list>(<argument><expr><operator>&amp;</operator><name>form</name></expr></argument>, <argument><expr><name>ti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Note that this scan can only match at most once, so we assert on
		 * `ca` here. */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ca</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ca</name> <operator>=</operator> <call><name>ts_scan_iterator_alloc_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>ca</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>continuous_agg_init</name><argument_list>(<argument><expr><name>ca</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>form</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ca</name> <operator>&amp;&amp;</operator> <name><name>ca</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>mat_hypertable_id</name></name> <operator>==</operator> <name>mat_hypertable_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>ts_scan_iterator_close</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ca</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>continuous_agg_find_by_name</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>schema</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>ContinuousAggViewType</name></type> <name>type</name></decl></parameter>,
							<parameter><decl><type><name>FormData_continuous_agg</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScanIterator</name></type> <name>iterator</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type> <name>view_name_attrnum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type> <name>schema_name_attrnum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>schema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name>type</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>ContinuousAggUserView</name></expr>:</case>
			<expr_stmt><expr><name>schema_name_attrnum</name> <operator>=</operator> <name>Anum_continuous_agg_user_view_schema</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>view_name_attrnum</name> <operator>=</operator> <name>Anum_continuous_agg_user_view_name</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>ContinuousAggPartialView</name></expr>:</case>
			<expr_stmt><expr><name>schema_name_attrnum</name> <operator>=</operator> <name>Anum_continuous_agg_partial_view_schema</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>view_name_attrnum</name> <operator>=</operator> <name>Anum_continuous_agg_partial_view_name</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>ContinuousAggDirectView</name></expr>:</case>
			<expr_stmt><expr><name>schema_name_attrnum</name> <operator>=</operator> <name>Anum_continuous_agg_direct_view_schema</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>view_name_attrnum</name> <operator>=</operator> <name>Anum_continuous_agg_direct_view_name</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>ContinuousAggAnyView</name></expr>:</case>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><name>iterator</name> <operator>=</operator> <call><name>ts_scan_iterator_create</name><argument_list>(<argument><expr><name>CONTINUOUS_AGG</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>, <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>ContinuousAggAnyView</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ts_scan_iterator_scan_key_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>,
									   <argument><expr><name>schema_name_attrnum</name></expr></argument>,
									   <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
									   <argument><expr><name>F_NAMEEQ</name></expr></argument>,
									   <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>schema</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ts_scan_iterator_scan_key_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>,
									   <argument><expr><name>view_name_attrnum</name></expr></argument>,
									   <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
									   <argument><expr><name>F_NAMEEQ</name></expr></argument>,
									   <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<macro><name>ts_scanner_foreach</name><argument_list>(<argument>&amp;iterator</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ContinuousAggViewType</name></type> <name>vtype</name> <init>= <expr><name>type</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name> <init>= <expr><call><name>ts_scan_iterator_tuple_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>FormData_continuous_agg</name></type> <name>data</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>continuous_agg_formdata_fill</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><name>ti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>vtype</name> <operator>==</operator> <name>ContinuousAggAnyView</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>vtype</name> <operator>=</operator> <call><name>ts_continuous_agg_view_type</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><name>schema</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>vtype</name> <operator>!=</operator> <name>ContinuousAggAnyView</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>fd</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>count</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>count</name> <operator>==</operator> <literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>ContinuousAgg</name> <modifier>*</modifier></type>
<name>ts_continuous_agg_find_by_view_name</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>schema</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
									<parameter><decl><type><name>ContinuousAggViewType</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FormData_continuous_agg</name></type> <name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ContinuousAgg</name> <modifier>*</modifier></type><name>ca</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>continuous_agg_find_by_name</name><argument_list>(<argument><expr><name>schema</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fd</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>ca</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ContinuousAgg</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>continuous_agg_init</name><argument_list>(<argument><expr><name>ca</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ca</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>ContinuousAgg</name> <modifier>*</modifier></type>
<name>ts_continuous_agg_find_userview_name</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>schema</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>ts_continuous_agg_find_by_view_name</name><argument_list>(<argument><expr><name>schema</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>ContinuousAggUserView</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Find a continuous agg object by the main relid.
 *
 * The relid is the user-facing object ID that represents the continuous
 * aggregate (i.e., the query view's ID).
 */</comment>
<function><type><name>ContinuousAgg</name> <modifier>*</modifier></type>
<name>ts_continuous_agg_find_by_relid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relname</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>schemaname</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>relname</name> <operator>||</operator> <name>NULL</name> <operator>==</operator> <name>schemaname</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><call><name>ts_continuous_agg_find_userview_name</name><argument_list>(<argument><expr><name>schemaname</name></expr></argument>, <argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Find a continuous aggregate by range var.
 */</comment>
<function><type><name>ContinuousAgg</name> <modifier>*</modifier></type>
<name>ts_continuous_agg_find_by_rv</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RangeVar</name> <modifier>*</modifier></type><name>rv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relid</name></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>rv</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><call><name>ts_continuous_agg_find_by_relid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>get_and_lock_rel_by_name</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Name</name></type> <name>schema</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Name</name></type> <name>name</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>addr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>nspid</name> <init>= <expr><call><name>get_namespace_oid</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>schema</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>nspid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>get_relname_relid</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nspid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>addr</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>get_and_lock_rel_by_hypertable_id</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>hypertable_id</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>addr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relid</name> <init>= <expr><call><name>ts_hypertable_id_to_relid</name><argument_list>(<argument><expr><name>hypertable_id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>addr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Drops continuous aggs and all related objects.
 *
 * This function is intended to be run by event trigger during CASCADE,
 * which implies that most of the dependent objects potentially could be
 * dropped including associated schema.
 *
 * These objects are:
 *
 * - user view itself
 * - continuous agg catalog entry
 * - partial view
 * - materialization hypertable
 * - trigger on the raw hypertable (hypertable specified in the user view)
 * - copy of the user view query (AKA the direct view)
 *
 * NOTE: The order in which the objects are dropped should be EXACTLY the
 * same as in materialize.c
 *
 * drop_user_view indicates whether to drop the user view.
 *                (should be false if called as part of the drop-user-view callback)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>drop_continuous_agg</name><parameter_list>(<parameter><decl><type><name>FormData_continuous_agg</name> <modifier>*</modifier></type><name>cadata</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>drop_user_view</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Catalog</name> <modifier>*</modifier></type><name>catalog</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanIterator</name></type> <name>iterator</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>user_view</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>partial_view</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>direct_view</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>raw_hypertable_trig</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>raw_hypertable</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>mat_hypertable</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>raw_hypertable_has_other_caggs</name></decl>;</decl_stmt>

	<comment type="block">/* Delete the job before taking locks as it kills long-running jobs
	 * which we would otherwise wait on */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>jobs</name> <init>= <expr><call><name>ts_bgw_job_find_by_hypertable_id</name><argument_list>(<argument><expr><name><name>cadata</name><operator>-&gt;</operator><name>mat_hypertable_id</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>jobs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BgwJob</name> <modifier>*</modifier></type><name>job</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ts_bgw_job_delete_by_id</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Lock objects.
	 *
	 * Following objects might be already dropped in case of CASCADE
	 * drop including the associated schema object.
	 *
	 * NOTE: the lock order matters, see tsl/src/materialization.c.
	 * Perform all locking upfront.
	 *
	 * AccessExclusiveLock is needed to drop triggers and also prevent
	 * concurrent DML commands.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>drop_user_view</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>user_view</name> <operator>=</operator> <call><name>get_and_lock_rel_by_name</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cadata</name><operator>-&gt;</operator><name>user_view_schema</name></name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name><name>cadata</name><operator>-&gt;</operator><name>user_view_name</name></name></expr></argument>,
											 <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>raw_hypertable</name> <operator>=</operator>
		<call><name>get_and_lock_rel_by_hypertable_id</name><argument_list>(<argument><expr><name><name>cadata</name><operator>-&gt;</operator><name>raw_hypertable_id</name></name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>mat_hypertable</name> <operator>=</operator>
		<call><name>get_and_lock_rel_by_hypertable_id</name><argument_list>(<argument><expr><name><name>cadata</name><operator>-&gt;</operator><name>mat_hypertable_id</name></name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Lock catalogs */</comment>
	<expr_stmt><expr><name>catalog</name> <operator>=</operator> <call><name>ts_catalog_get</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><call><name>catalog_get_table_id</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>BGW_JOB</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><call><name>catalog_get_table_id</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>CONTINUOUS_AGG</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>raw_hypertable_has_other_caggs</name> <operator>=</operator>
		<call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>raw_hypertable</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>number_of_continuous_aggs_attached</name><argument_list>(<argument><expr><name><name>cadata</name><operator>-&gt;</operator><name>raw_hypertable_id</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>raw_hypertable_has_other_caggs</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><call><name>catalog_get_table_id</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>CONTINUOUS_AGGS_HYPERTABLE_INVALIDATION_LOG</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><call><name>catalog_get_table_id</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>CONTINUOUS_AGGS_INVALIDATION_THRESHOLD</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* The trigger will be dropped if the hypertable still exists and no other
		 * caggs attached. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>raw_hypertable</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>raw_hypertable_trig</name></expr></argument>,
							 <argument><expr><name>TriggerRelationId</name></expr></argument>,
							 <argument><expr><call><name>get_trigger_oid</name><argument_list>(<argument><expr><name><name>raw_hypertable</name><operator>.</operator><name>objectId</name></name></expr></argument>,
											 <argument><expr><name>CAGGINVAL_TRIGGER_NAME</name></expr></argument>,
											 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Raw hypertable is locked above */</comment>
			<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name><name>raw_hypertable_trig</name><operator>.</operator><name>objectId</name></name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Following objects might be already dropped in case of CASCADE
	 * drop including the associated schema object.
	 */</comment>
	<expr_stmt><expr><name>partial_view</name> <operator>=</operator> <call><name>get_and_lock_rel_by_name</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cadata</name><operator>-&gt;</operator><name>partial_view_schema</name></name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name><name>cadata</name><operator>-&gt;</operator><name>partial_view_name</name></name></expr></argument>,
											<argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>direct_view</name> <operator>=</operator> <call><name>get_and_lock_rel_by_name</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cadata</name><operator>-&gt;</operator><name>direct_view_schema</name></name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name><name>cadata</name><operator>-&gt;</operator><name>direct_view_name</name></name></expr></argument>,
										   <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Delete catalog entry */</comment>
	<expr_stmt><expr><name>iterator</name> <operator>=</operator> <call><name>ts_scan_iterator_create</name><argument_list>(<argument><expr><name>CONTINUOUS_AGG</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>, <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>init_scan_by_mat_hypertable_id</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>, <argument><expr><name><name>cadata</name><operator>-&gt;</operator><name>mat_hypertable_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>ts_scanner_foreach</name><argument_list>(<argument>&amp;iterator</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name> <init>= <expr><call><name>ts_scan_iterator_tuple_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>FormData_continuous_agg</name></type> <name>form</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>continuous_agg_formdata_fill</name><argument_list>(<argument><expr><operator>&amp;</operator><name>form</name></expr></argument>, <argument><expr><name>ti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ts_catalog_delete_tid</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>scanrel</name></name></expr></argument>, <argument><expr><call><name>ts_scanner_get_tuple_tid</name><argument_list>(<argument><expr><name>ti</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Delete all related rows */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>raw_hypertable_has_other_caggs</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>hypertable_invalidation_log_delete</name><argument_list>(<argument><expr><name><name>form</name><operator>.</operator><name>raw_hypertable_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>ts_cm_functions</name><operator>-&gt;</operator><name>remote_invalidation_log_delete</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name><name>ts_cm_functions</name><operator>-&gt;</operator><name>remote_invalidation_log_delete</name></name><argument_list>(<argument><expr><name><name>form</name><operator>.</operator><name>raw_hypertable_id</name></name></expr></argument>,
																<argument><expr><name>HypertableIsRawTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ts_materialization_invalidation_log_delete_inner</name><argument_list>(<argument><expr><name><name>form</name><operator>.</operator><name>mat_hypertable_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>ts_cm_functions</name><operator>-&gt;</operator><name>remote_invalidation_log_delete</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name><name>ts_cm_functions</name><operator>-&gt;</operator><name>remote_invalidation_log_delete</name></name><argument_list>(<argument><expr><name><name>form</name><operator>.</operator><name>mat_hypertable_id</name></name></expr></argument>,
															<argument><expr><name>HypertableIsMaterialization</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>raw_hypertable_has_other_caggs</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>invalidation_threshold_delete</name><argument_list>(<argument><expr><name><name>form</name><operator>.</operator><name>raw_hypertable_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name><name>cadata</name><operator>-&gt;</operator><name>bucket_width</name></name> <operator>==</operator> <name>BUCKET_WIDTH_VARIABLE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>cagg_bucket_function_delete</name><argument_list>(<argument><expr><name><name>cadata</name><operator>-&gt;</operator><name>mat_hypertable_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Perform actual deletions now */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>user_view</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>performDeletion</name><argument_list>(<argument><expr><operator>&amp;</operator><name>user_view</name></expr></argument>, <argument><expr><name>DROP_RESTRICT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>raw_hypertable_trig</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ts_hypertable_drop_trigger</name><argument_list>(<argument><expr><name><name>raw_hypertable</name><operator>.</operator><name>objectId</name></name></expr></argument>, <argument><expr><name>CAGGINVAL_TRIGGER_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>ts_cm_functions</name><operator>-&gt;</operator><name>remote_drop_dist_ht_invalidation_trigger</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name><name>ts_cm_functions</name><operator>-&gt;</operator><name>remote_drop_dist_ht_invalidation_trigger</name></name><argument_list>(<argument><expr><name><name>cadata</name><operator>-&gt;</operator><name>raw_hypertable_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>mat_hypertable</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>performDeletion</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mat_hypertable</name></expr></argument>, <argument><expr><name>DROP_CASCADE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ts_hypertable_delete_by_id</name><argument_list>(<argument><expr><name><name>cadata</name><operator>-&gt;</operator><name>mat_hypertable_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>partial_view</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>performDeletion</name><argument_list>(<argument><expr><operator>&amp;</operator><name>partial_view</name></expr></argument>, <argument><expr><name>DROP_RESTRICT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>direct_view</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>performDeletion</name><argument_list>(<argument><expr><operator>&amp;</operator><name>direct_view</name></expr></argument>, <argument><expr><name>DROP_RESTRICT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * This is a called when a hypertable gets dropped.
 *
 * If the hypertable is a raw hypertable for a continuous agg,
 * drop the continuous agg.
 *
 * If the hypertable is a materialization hypertable, error out
 * and force the user to drop the continuous agg instead.
 */</comment>
<function><type><name>void</name></type>
<name>ts_continuous_agg_drop_hypertable_callback</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>hypertable_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScanIterator</name></type> <name>iterator</name> <init>=
		<expr><call><name>ts_scan_iterator_create</name><argument_list>(<argument><expr><name>CONTINUOUS_AGG</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>, <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<macro><name>ts_scanner_foreach</name><argument_list>(<argument>&amp;iterator</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FormData_continuous_agg</name></type> <name>data</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name> <init>= <expr><call><name>ts_scan_iterator_tuple_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>continuous_agg_formdata_fill</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><name>ti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>data</name><operator>.</operator><name>raw_hypertable_id</name></name> <operator>==</operator> <name>hypertable_id</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>drop_continuous_agg</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>data</name><operator>.</operator><name>mat_hypertable_id</name></name> <operator>==</operator> <name>hypertable_id</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DEPENDENT_OBJECTS_STILL_EXIST</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot drop the materialized table because it is required by a "</literal>
							<literal type="string">"continuous aggregate"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/* Block dropping the partial and direct view if the continuous aggregate still exists */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>drop_internal_view</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FormData_continuous_agg</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScanIterator</name></type> <name>iterator</name> <init>=
		<expr><call><name>ts_scan_iterator_create</name><argument_list>(<argument><expr><name>CONTINUOUS_AGG</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>, <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>init_scan_by_mat_hypertable_id</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>, <argument><expr><name><name>fd</name><operator>-&gt;</operator><name>mat_hypertable_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>ts_scanner_foreach</name><argument_list>(<argument>&amp;iterator</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name> <init>= <expr><call><name>ts_scan_iterator_tuple_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ts_catalog_delete_tid</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>scanrel</name></name></expr></argument>, <argument><expr><call><name>ts_scanner_get_tuple_tid</name><argument_list>(<argument><expr><name>ti</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>
	<if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DEPENDENT_OBJECTS_STILL_EXIST</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(
					 <argument><expr><literal type="string">"cannot drop the partial/direct view because it is required by a continuous "</literal>
					 <literal type="string">"aggregate"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* This gets called when a view gets dropped. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>continuous_agg_drop_view_callback</name><parameter_list>(<parameter><decl><type><name>FormData_continuous_agg</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>schema</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ContinuousAggViewType</name></type> <name>vtyp</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>vtyp</name> <operator>=</operator> <call><name>ts_continuous_agg_view_type</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>schema</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name>vtyp</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>ContinuousAggUserView</name></expr>:</case>
			<expr_stmt><expr><call><name>drop_continuous_agg</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>false</name></expr></argument> <comment type="block">/* The user view has already been dropped */</comment>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>ContinuousAggPartialView</name></expr>:</case>
		<case>case <expr><name>ContinuousAggDirectView</name></expr>:</case>
			<expr_stmt><expr><call><name>drop_internal_view</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unknown continuous aggregate view type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ts_continuous_agg_drop</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>view_schema</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>view_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FormData_continuous_agg</name></type> <name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><call><name>continuous_agg_find_by_name</name><argument_list>(<argument><expr><name>view_schema</name></expr></argument>, <argument><expr><name>view_name</name></expr></argument>, <argument><expr><name>ContinuousAggAnyView</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>continuous_agg_drop_view_callback</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fd</name></expr></argument>, <argument><expr><name>view_schema</name></expr></argument>, <argument><expr><name>view_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>found</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>ts_continuous_agg_is_user_view_schema</name><parameter_list>(<parameter><decl><type><name>FormData_continuous_agg</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>schema</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>CHECK_NAME_MATCH</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>user_view_schema</name></name></expr></argument>, <argument><expr><name>schema</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>ts_continuous_agg_is_partial_view_schema</name><parameter_list>(<parameter><decl><type><name>FormData_continuous_agg</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>schema</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>CHECK_NAME_MATCH</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>partial_view_schema</name></name></expr></argument>, <argument><expr><name>schema</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>ts_continuous_agg_is_direct_view_schema</name><parameter_list>(<parameter><decl><type><name>FormData_continuous_agg</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>schema</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>CHECK_NAME_MATCH</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>direct_view_schema</name></name></expr></argument>, <argument><expr><name>schema</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>ContinuousAggViewType</name></type>
<name>ts_continuous_agg_view_type</name><parameter_list>(<parameter><decl><type><name>FormData_continuous_agg</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>schema</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>CHECK_NAME_MATCH</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>user_view_schema</name></name></expr></argument>, <argument><expr><name>schema</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>CHECK_NAME_MATCH</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>user_view_name</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>ContinuousAggUserView</name></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>CHECK_NAME_MATCH</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>partial_view_schema</name></name></expr></argument>, <argument><expr><name>schema</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			 <call><name>CHECK_NAME_MATCH</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>partial_view_name</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>ContinuousAggPartialView</name></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>CHECK_NAME_MATCH</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>direct_view_schema</name></name></expr></argument>, <argument><expr><name>schema</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			 <call><name>CHECK_NAME_MATCH</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>direct_view_name</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>ContinuousAggDirectView</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>ContinuousAggAnyView</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <name>CaggRenameCtx</name>
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>old_schema</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>old_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>new_schema</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>new_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectType</name> <modifier>*</modifier></type><name>object_type</name></decl>;</decl_stmt>
	<function_decl><type><name>void</name></type> (<modifier>*</modifier><name>process_rename</name>)<parameter_list>(<parameter><decl><type><name>FormData_continuous_agg</name> <modifier>*</modifier></type><name>form</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>do_update</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>;</function_decl>
}</block></struct></type> <name>CaggRenameCtx</name>;</typedef>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>continuous_agg_rename_process_rename_schema</name><parameter_list>(<parameter><decl><type><name>FormData_continuous_agg</name> <modifier>*</modifier></type><name>form</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>do_update</name></decl></parameter>,
											<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CaggRenameCtx</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><operator>(</operator><name>CaggRenameCtx</name> <operator>*</operator><operator>)</operator> <name>data</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ts_continuous_agg_is_user_view_schema</name><argument_list>(<argument><expr><name>form</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>old_schema</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>form</name><operator>-&gt;</operator><name>user_view_schema</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>new_schema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>do_update</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ts_continuous_agg_is_partial_view_schema</name><argument_list>(<argument><expr><name>form</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>old_schema</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>form</name><operator>-&gt;</operator><name>partial_view_schema</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>new_schema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>do_update</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ts_continuous_agg_is_direct_view_schema</name><argument_list>(<argument><expr><name>form</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>old_schema</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>form</name><operator>-&gt;</operator><name>direct_view_schema</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>new_schema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>do_update</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>continuous_agg_rename_process_rename_view</name><parameter_list>(<parameter><decl><type><name>FormData_continuous_agg</name> <modifier>*</modifier></type><name>form</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>do_update</name></decl></parameter>,
										  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CaggRenameCtx</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><operator>(</operator><name>CaggRenameCtx</name> <operator>*</operator><operator>)</operator> <name>data</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ContinuousAggViewType</name></type> <name>vtyp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>vtyp</name> <operator>=</operator> <call><name>ts_continuous_agg_view_type</name><argument_list>(<argument><expr><name>form</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>old_schema</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>old_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name>vtyp</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>ContinuousAggUserView</name></expr>:</case>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>ctx</name><operator>-&gt;</operator><name>object_type</name></name> <operator>==</operator> <name>OBJECT_VIEW</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter continuous aggregate using ALTER VIEW"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use ALTER MATERIALIZED VIEW to alter a continuous aggregate."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name><name>ctx</name><operator>-&gt;</operator><name>object_type</name></name> <operator>==</operator> <name>OBJECT_MATVIEW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name><name>ctx</name><operator>-&gt;</operator><name>object_type</name></name> <operator>=</operator> <name>OBJECT_VIEW</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>form</name><operator>-&gt;</operator><name>user_view_schema</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>new_schema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>form</name><operator>-&gt;</operator><name>user_view_name</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>new_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>do_update</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>
		<case>case <expr><name>ContinuousAggPartialView</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>form</name><operator>-&gt;</operator><name>partial_view_schema</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>new_schema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>form</name><operator>-&gt;</operator><name>partial_view_name</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>new_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>do_update</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>
		<case>case <expr><name>ContinuousAggDirectView</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>form</name><operator>-&gt;</operator><name>direct_view_schema</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>new_schema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>form</name><operator>-&gt;</operator><name>direct_view_name</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>new_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>do_update</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ScanTupleResult</name></type>
<name>continuous_agg_rename</name><parameter_list>(<parameter><decl><type><name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CaggRenameCtx</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><operator>(</operator><name>CaggRenameCtx</name> <operator>*</operator><operator>)</operator> <name>data</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FormData_continuous_agg</name></type> <name>form</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>do_update</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CatalogSecurityContext</name></type> <name>sec_ctx</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>continuous_agg_formdata_fill</name><argument_list>(<argument><expr><operator>&amp;</operator><name>form</name></expr></argument>, <argument><expr><name>ti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name><name>ctx</name><operator>-&gt;</operator><name>process_rename</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>form</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>do_update</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>do_update</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type> <name>new_tuple</name> <init>=
			<expr><call><name>continuous_agg_formdata_make_tuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name>form</name></expr></argument>, <argument><expr><call><name>ts_scanner_get_tupledesc</name><argument_list>(<argument><expr><name>ti</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ts_catalog_database_info_become_owner</name><argument_list>(<argument><expr><call><name>ts_catalog_database_info_get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ts_catalog_update_tid</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>scanrel</name></name></expr></argument>, <argument><expr><call><name>ts_scanner_get_tuple_tid</name><argument_list>(<argument><expr><name>ti</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>new_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ts_catalog_restore_user</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>new_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>SCAN_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ts_continuous_agg_rename_schema_name</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>old_schema</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>new_schema</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CaggRenameCtx</name></type> <name>cagg_rename_ctx</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>old_schema</name> <operator>=</operator> <name>old_schema</name></expr>,
		<expr><operator>.</operator><name>new_schema</name> <operator>=</operator> <name>new_schema</name></expr>,
		<expr><operator>.</operator><name>process_rename</name> <operator>=</operator> <name>continuous_agg_rename_process_rename_schema</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Catalog</name> <modifier>*</modifier></type><name>catalog</name> <init>= <expr><call><name>ts_catalog_get</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ScannerCtx</name></type> <name>scanctx</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>table</name> <operator>=</operator> <call><name>catalog_get_table_id</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>CONTINUOUS_AGG</name></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>index</name> <operator>=</operator> <name>InvalidOid</name></expr>,
		<expr><operator>.</operator><name>tuple_found</name> <operator>=</operator> <name>continuous_agg_rename</name></expr>,
		<expr><operator>.</operator><name>data</name> <operator>=</operator> <operator>&amp;</operator><name>cagg_rename_ctx</name></expr>,
		<expr><operator>.</operator><name>lockmode</name> <operator>=</operator> <name>RowExclusiveLock</name></expr>,
		<expr><operator>.</operator><name>scandirection</name> <operator>=</operator> <name>ForwardScanDirection</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ts_scanner_scan</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scanctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ts_continuous_agg_rename_view</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>old_schema</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>old_name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>new_schema</name></decl></parameter>,
							  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>new_name</name></decl></parameter>, <parameter><decl><type><name>ObjectType</name> <modifier>*</modifier></type><name>object_type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CaggRenameCtx</name></type> <name>cagg_rename_ctx</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>old_schema</name> <operator>=</operator> <name>old_schema</name></expr>,
		<expr><operator>.</operator><name>old_name</name> <operator>=</operator> <name>old_name</name></expr>,
		<expr><operator>.</operator><name>new_schema</name> <operator>=</operator> <name>new_schema</name></expr>,
		<expr><operator>.</operator><name>new_name</name> <operator>=</operator> <name>new_name</name></expr>,
		<expr><operator>.</operator><name>object_type</name> <operator>=</operator> <name>object_type</name></expr>,
		<expr><operator>.</operator><name>process_rename</name> <operator>=</operator> <name>continuous_agg_rename_process_rename_view</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Catalog</name> <modifier>*</modifier></type><name>catalog</name> <init>= <expr><call><name>ts_catalog_get</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ScannerCtx</name></type> <name>scanctx</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>table</name> <operator>=</operator> <call><name>catalog_get_table_id</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>CONTINUOUS_AGG</name></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>index</name> <operator>=</operator> <name>InvalidOid</name></expr>,
		<expr><operator>.</operator><name>tuple_found</name> <operator>=</operator> <name>continuous_agg_rename</name></expr>,
		<expr><operator>.</operator><name>data</name> <operator>=</operator> <operator>&amp;</operator><name>cagg_rename_ctx</name></expr>,
		<expr><operator>.</operator><name>lockmode</name> <operator>=</operator> <name>RowExclusiveLock</name></expr>,
		<expr><operator>.</operator><name>scandirection</name> <operator>=</operator> <name>ForwardScanDirection</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ts_scanner_scan</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scanctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>TSDLLEXPORT</name> <name>int32</name></type>
<name>ts_number_of_continuous_aggs</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanIterator</name></type> <name>iterator</name> <init>=
		<expr><call><name>ts_scan_iterator_create</name><argument_list>(<argument><expr><name>CONTINUOUS_AGG</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>, <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>ts_scanner_foreach</name><argument_list>(<argument>&amp;iterator</argument>)</argument_list></macro> <block>{<block_content> <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block>

	<return>return <expr><name>count</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32</name></type>
<name>find_raw_hypertable_for_materialization</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>mat_hypertable_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PG_USED_FOR_ASSERTS_ONLY</name> <name>short</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>htid</name> <init>= <expr><name>INVALID_HYPERTABLE_ID</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanIterator</name></type> <name>iterator</name> <init>=
		<expr><call><name>ts_scan_iterator_create</name><argument_list>(<argument><expr><name>CONTINUOUS_AGG</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>, <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>init_scan_by_mat_hypertable_id</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>, <argument><expr><name>mat_hypertable_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>ts_scanner_foreach</name><argument_list>(<argument>&amp;iterator</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>isnull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type> <name>datum</name> <init>= <expr><call><name>slot_getattr</name><argument_list>(<argument><expr><call><name>ts_scan_iterator_slot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name>Anum_continuous_agg_raw_hypertable_id</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>htid</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>count</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_scan_iterator_close</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>htid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Continuous aggregate materialization hypertables inherit integer_now func
 * from the raw hypertable (unless it was explicitly reset for cont. aggregate.
 * Walk the materialization hypertable -&gt;raw hypertable tree till
 * we find a hypertable that has integer_now_func set.
 */</comment>
<function><type><name>TSDLLEXPORT</name> <specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type>
<name>ts_continuous_agg_find_integer_now_func_by_materialization_id</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>mat_htid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type> <name>raw_htid</name> <init>= <expr><name>mat_htid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type><name>par_dim</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><name>raw_htid</name> <operator>!=</operator> <name>INVALID_HYPERTABLE_ID</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>raw_ht</name> <init>= <expr><call><name>ts_hypertable_get_by_id</name><argument_list>(<argument><expr><name>raw_htid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type><name>open_dim</name> <init>= <expr><call><name>hyperspace_get_open_dimension</name><argument_list>(<argument><expr><name><name>raw_ht</name><operator>-&gt;</operator><name>space</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>open_dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>integer_now_func</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<call><name>strlen</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>open_dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>integer_now_func_schema</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>par_dim</name> <operator>=</operator> <name>open_dim</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>mat_htid</name> <operator>=</operator> <name>raw_htid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>raw_htid</name> <operator>=</operator> <call><name>find_raw_hypertable_for_materialization</name><argument_list>(<argument><expr><name>mat_htid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<return>return <expr><name>par_dim</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>TSDLLEXPORT</name> <name>void</name></type>
<name>ts_continuous_agg_invalidate_chunk</name><parameter_list>(<parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int64</name></type> <name>start</name> <init>= <expr><call><name>ts_chunk_primary_dimension_start</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>end</name> <init>= <expr><call><name>ts_chunk_primary_dimension_end</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>hyperspace_get_open_dimension</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>space</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>fd</name><operator>.</operator><name>id</name></name> <operator>==</operator>
		   <name><name>chunk</name><operator>-&gt;</operator><name>cube</name><operator>-&gt;</operator><name>slices</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>fd</name><operator>.</operator><name>dimension_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name><name>ts_cm_functions</name><operator>-&gt;</operator><name>continuous_agg_invalidate_raw_ht</name></name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <name>Watermark</name>
<block>{
	<decl_stmt><decl><type><name>int32</name></type> <name>hyper_id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>mctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContextCallback</name></type> <name>cb</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CommandId</name></type> <name>cid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>value</name></decl>;</decl_stmt>
}</block></struct></type> <name>Watermark</name>;</typedef>

<comment type="block">/* Globally cache the watermark for better performance (by avoiding repeated
 * max bucket calculations). The watermark will be reset at the end of the
 * transaction, when the watermark function's input argument (materialized
 * hypertable ID) changes, or when a new command is executed. One could
 * potentially create a hashtable of watermarks keyed on materialized
 * hypertable ID, but this is left as a future optimization since it doesn't
 * seem to be common case that multiple continuous aggregates exist in the
 * same query. Besides, the planner can constify calls to the watermark
 * function during planning since the function is STABLE. Therefore, this is
 * only a fallback if the planner needs to constify it many times (e.g., if
 * used as an index condition on many chunks).
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>Watermark</name> <modifier>*</modifier></type><name>watermark</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Callback handler to reset the watermark after the transaction ends. This is
 * triggered by the deletion of the associated memory context.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>reset_watermark</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>watermark</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Watermark is valid for the duration of one command execution on the same
 * materialized hypertable.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>watermark_valid</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Watermark</name> <modifier>*</modifier></type><name>w</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>hyper_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>w</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>w</name><operator>-&gt;</operator><name>hyper_id</name></name> <operator>==</operator> <name>hyper_id</name> <operator>&amp;&amp;</operator> <name><name>w</name><operator>-&gt;</operator><name>cid</name></name> <operator>==</operator> <call><name>GetCurrentCommandId</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Watermark</name> <modifier>*</modifier></type>
<name>watermark_create</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ContinuousAgg</name> <modifier>*</modifier></type><name>cagg</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>top_mctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type><name>dim</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>maxdat</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>max_isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>timetype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Watermark</name> <modifier>*</modifier></type><name>w</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>mctx</name> <init>=
		<expr><call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>top_mctx</name></expr></argument>, <argument><expr><literal type="string">"Watermark function"</literal></expr></argument>, <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>w</name> <operator>=</operator> <call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>mctx</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Watermark</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>mctx</name></name> <operator>=</operator> <name>mctx</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>hyper_id</name></name> <operator>=</operator> <name><name>cagg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>mat_hypertable_id</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>cid</name></name> <operator>=</operator> <call><name>GetCurrentCommandId</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>func</name></name> <operator>=</operator> <name>reset_watermark</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextRegisterResetCallback</name><argument_list>(<argument><expr><name>mctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>w</name><operator>-&gt;</operator><name>cb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ht</name> <operator>=</operator> <call><name>ts_hypertable_get_by_id</name><argument_list>(<argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>mat_hypertable_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dim</name> <operator>=</operator> <call><name>hyperspace_get_open_dimension</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>space</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>timetype</name> <operator>=</operator> <call><name>ts_dimension_get_partition_type</name><argument_list>(<argument><expr><name>dim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>maxdat</name> <operator>=</operator> <call><name>ts_hypertable_get_open_dim_max_value</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>max_isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>max_isnull</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int64</name></type> <name>value</name> <init>= <expr><call><name>ts_time_value_to_internal</name><argument_list>(<argument><expr><name>maxdat</name></expr></argument>, <argument><expr><name>timetype</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* The materialized hypertable is already bucketed, which means the
		 * max is the start of the last bucket. Add one bucket to move to the
		 * point where the materialized data ends. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>ts_continuous_agg_bucket_width_variable</name><argument_list>(<argument><expr><name>cagg</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Since `value` is already bucketed, `bucketed = true` flag can
			 * be added to ts_compute_beginning_of_the_next_bucket_variable() as
			 * an optimization, if necessary.
			 */</comment>
			<expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator>
				<call><name>ts_compute_beginning_of_the_next_bucket_variable</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>bucket_function</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator>
				<call><name>ts_time_saturating_add</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><call><name>ts_continuous_agg_bucket_width</name><argument_list>(<argument><expr><name>cagg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>timetype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Nothing materialized, so return min */</comment>
		<expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <call><name>ts_time_get_min</name><argument_list>(<argument><expr><name>timetype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>w</name></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><call><name>TS_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>ts_continuous_agg_watermark</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*
 * Get the watermark for a real-time aggregation query on a continuous
 * aggregate.
 *
 * The watermark determines where the materialization ends for a continuous
 * aggregate. It is used by real-time aggregation as the threshold between the
 * materialized data and real-time data in the UNION query.
 *
 * The watermark is defined as the end of the last (highest) bucket in the
 * materialized hypertable of a continuous aggregate.
 *
 * The materialized hypertable ID is given as input argument.
 */</comment>
<function><type><name>Datum</name></type>
<name>ts_continuous_agg_watermark</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int32</name></type> <name>hyper_id</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ContinuousAgg</name> <modifier>*</modifier></type><name>cagg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AclResult</name></type> <name>aclresult</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"materialized hypertable cannot be NULL"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>watermark</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>watermark_valid</name><argument_list>(<argument><expr><name>watermark</name></expr></argument>, <argument><expr><name>hyper_id</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><name><name>watermark</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>watermark</name><operator>-&gt;</operator><name>mctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>cagg</name> <operator>=</operator> <call><name>ts_continuous_agg_find_by_mat_hypertable_id</name><argument_list>(<argument><expr><name>hyper_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>cagg</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid materialized hypertable ID: %d"</literal></expr></argument>, <argument><expr><name>hyper_id</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Preemptive permission check to ensure the function complains about lack
	 * of permissions on the cagg rather than the materialized hypertable */</comment>
	<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_class_aclcheck</name><argument_list>(<argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_SELECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>OBJECT_MATVIEW</name></expr></argument>, <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>watermark</name> <operator>=</operator> <call><name>watermark_create</name><argument_list>(<argument><expr><name>cagg</name></expr></argument>, <argument><expr><name>TopTransactionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><name><name>watermark</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Determines if bucket width if variable for given continuous aggregate. */</comment>
<function><type><name>bool</name></type>
<name>ts_continuous_agg_bucket_width_variable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ContinuousAgg</name> <modifier>*</modifier></type><name>agg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>agg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>bucket_width</name></name> <operator>==</operator> <name>BUCKET_WIDTH_VARIABLE</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Determines bucket width for given continuous aggregate. */</comment>
<function><type><name>int64</name></type>
<name>ts_continuous_agg_bucket_width</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ContinuousAgg</name> <modifier>*</modifier></type><name>agg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>ts_continuous_agg_bucket_width_variable</name><argument_list>(<argument><expr><name>agg</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* should never happen, this code is useful mostly for debugging purposes */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"bucket width is not defined for a variable bucket"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>agg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>bucket_width</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Calls one of time_bucket_ng() versions depending on the arguments. This is
 * a common procedure used by ts_compute_* below.
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>generic_time_bucket</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ContinuousAggsBucketFunction</name> <modifier>*</modifier></type><name>bf</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>timestamp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* bf-&gt;timezone can't be NULL. If timezone is not specified, "" is stored */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>bf</name><operator>-&gt;</operator><name>timezone</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>bf</name><operator>-&gt;</operator><name>experimental</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>bf</name><operator>-&gt;</operator><name>timezone</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>TIMESTAMP_NOT_FINITE</name><argument_list>(<argument><expr><name><name>bf</name><operator>-&gt;</operator><name>origin</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* using default origin */</comment>
				<return>return <expr><call><name>DirectFunctionCall3</name><argument_list>(<argument><expr><name>ts_timestamptz_timezone_bucket</name></expr></argument>,
										   <argument><expr><call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><name><name>bf</name><operator>-&gt;</operator><name>bucket_width</name></name></expr></argument>)</argument_list></call></expr></argument>,
										   <argument><expr><name>timestamp</name></expr></argument>,
										   <argument><expr><call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>bf</name><operator>-&gt;</operator><name>timezone</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* custom origin specified */</comment>
				<return>return <expr><call><name>DirectFunctionCall4</name><argument_list>(<argument><expr><name>ts_timestamptz_timezone_bucket</name></expr></argument>,
										   <argument><expr><call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><name><name>bf</name><operator>-&gt;</operator><name>bucket_width</name></name></expr></argument>)</argument_list></call></expr></argument>,
										   <argument><expr><name>timestamp</name></expr></argument>,
										   <argument><expr><call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>bf</name><operator>-&gt;</operator><name>timezone</name></name></expr></argument>)</argument_list></call></expr></argument>,
										   <argument><expr><call><name>TimestampTzGetDatum</name><argument_list>(<argument><expr><operator>(</operator><name>TimestampTz</name><operator>)</operator> <name><name>bf</name><operator>-&gt;</operator><name>origin</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>TIMESTAMP_NOT_FINITE</name><argument_list>(<argument><expr><name><name>bf</name><operator>-&gt;</operator><name>origin</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* using default origin */</comment>
			<return>return <expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>ts_timestamp_bucket</name></expr></argument>,
									   <argument><expr><call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><name><name>bf</name><operator>-&gt;</operator><name>bucket_width</name></name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* custom origin specified */</comment>
			<return>return <expr><call><name>DirectFunctionCall3</name><argument_list>(<argument><expr><name>ts_timestamp_bucket</name></expr></argument>,
									   <argument><expr><call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><name><name>bf</name><operator>-&gt;</operator><name>bucket_width</name></name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><name>timestamp</name></expr></argument>,
									   <argument><expr><call><name>TimestampGetDatum</name><argument_list>(<argument><expr><name><name>bf</name><operator>-&gt;</operator><name>origin</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>bf</name><operator>-&gt;</operator><name>timezone</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>TIMESTAMP_NOT_FINITE</name><argument_list>(<argument><expr><name><name>bf</name><operator>-&gt;</operator><name>origin</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* using default origin */</comment>
				<return>return <expr><call><name>DirectFunctionCall3</name><argument_list>(<argument><expr><name>ts_time_bucket_ng_timezone</name></expr></argument>,
										   <argument><expr><call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><name><name>bf</name><operator>-&gt;</operator><name>bucket_width</name></name></expr></argument>)</argument_list></call></expr></argument>,
										   <argument><expr><name>timestamp</name></expr></argument>,
										   <argument><expr><call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>bf</name><operator>-&gt;</operator><name>timezone</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* custom origin specified */</comment>
				<return>return <expr><call><name>DirectFunctionCall4</name><argument_list>(<argument><expr><name>ts_time_bucket_ng_timezone_origin</name></expr></argument>,
										   <argument><expr><call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><name><name>bf</name><operator>-&gt;</operator><name>bucket_width</name></name></expr></argument>)</argument_list></call></expr></argument>,
										   <argument><expr><name>timestamp</name></expr></argument>,
										   <argument><expr><call><name>TimestampTzGetDatum</name><argument_list>(<argument><expr><operator>(</operator><name>TimestampTz</name><operator>)</operator> <name><name>bf</name><operator>-&gt;</operator><name>origin</name></name></expr></argument>)</argument_list></call></expr></argument>,
										   <argument><expr><call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>bf</name><operator>-&gt;</operator><name>timezone</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>TIMESTAMP_NOT_FINITE</name><argument_list>(<argument><expr><name><name>bf</name><operator>-&gt;</operator><name>origin</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* using default origin */</comment>
			<return>return <expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>ts_time_bucket_ng_timestamp</name></expr></argument>,
									   <argument><expr><call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><name><name>bf</name><operator>-&gt;</operator><name>bucket_width</name></name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* custom origin specified */</comment>
			<return>return <expr><call><name>DirectFunctionCall3</name><argument_list>(<argument><expr><name>ts_time_bucket_ng_timestamp</name></expr></argument>,
									   <argument><expr><call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><name><name>bf</name><operator>-&gt;</operator><name>bucket_width</name></name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><name>timestamp</name></expr></argument>,
									   <argument><expr><call><name>TimestampGetDatum</name><argument_list>(<argument><expr><name><name>bf</name><operator>-&gt;</operator><name>origin</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Adds one bf-&gt;bucket_size interval to the timestamp. This is a common
 * procedure used by ts_compute_* below.
 *
 * If bf-&gt;timezone is specified, the math happens in this timezone.
 * Otherwise, it happens in UTC.
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>generic_add_interval</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ContinuousAggsBucketFunction</name> <modifier>*</modifier></type><name>bf</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>timestamp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type> <name>tzname</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>has_timezone</name></decl>;</decl_stmt>

	<comment type="block">/* bf-&gt;timezone can't be NULL. If timezone is not specified, "" is stored */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>bf</name><operator>-&gt;</operator><name>timezone</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>has_timezone</name> <operator>=</operator> <operator>(</operator><call><name>strlen</name><argument_list>(<argument><expr><name><name>bf</name><operator>-&gt;</operator><name>timezone</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>has_timezone</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Convert 'timestamp' to TIMESTAMP at given timezone.
		 * The code is equal to 'timestamptz AT TIME ZONE tzname'.
		 */</comment>
		<expr_stmt><expr><name>tzname</name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>bf</name><operator>-&gt;</operator><name>timezone</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>timestamp</name> <operator>=</operator> <call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>timestamptz_zone</name></expr></argument>, <argument><expr><name>tzname</name></expr></argument>, <argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>timestamp</name> <operator>=</operator>
		<call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>timestamp_pl_interval</name></expr></argument>, <argument><expr><name>timestamp</name></expr></argument>, <argument><expr><call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><name><name>bf</name><operator>-&gt;</operator><name>bucket_width</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>has_timezone</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tzname</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>timestamp</name> <operator>=</operator> <call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>timestamp_zone</name></expr></argument>, <argument><expr><name>tzname</name></expr></argument>, <argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>timestamp</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Computes inscribed refresh_window for variable-sized buckets.
 *
 * The algorithm is simple:
 *
 * end = time_bucket(bucket_size, end)
 *
 * if(start != time_bucket(bucket_size, start))
 *     start = time_bucket(bucket_size, start) + interval bucket_size
 *
 */</comment>
<function><type><name>void</name></type>
<name>ts_compute_inscribed_bucketed_refresh_window_variable</name><parameter_list>(<parameter><decl><type><name>int64</name> <modifier>*</modifier></type><name>start</name></decl></parameter>, <parameter><decl><type><name>int64</name> <modifier>*</modifier></type><name>end</name></decl></parameter>,
													  <parameter><decl><type><specifier>const</specifier> <name>ContinuousAggsBucketFunction</name> <modifier>*</modifier></type><name>bf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type> <name>start_old</name></decl>, <decl><type ref="prev"/><name>end_old</name></decl>, <decl><type ref="prev"/><name>start_new</name></decl>, <decl><type ref="prev"/><name>end_new</name></decl>;</decl_stmt>
	<comment type="block">/*
	 * It's OK to use TIMESTAMPOID here. Variable-sized buckets can be used
	 * only for dates, timestamps and timestamptz's. For all these types our
	 * internal time representation is microseconds relative the UNIX epoch.
	 * So the results will be correct regardless of the actual type used in
	 * the CAGG. For more details see ts_internal_to_time_value() implementation.
	 */</comment>
	<expr_stmt><expr><name>start_old</name> <operator>=</operator> <call><name>ts_internal_to_time_value</name><argument_list>(<argument><expr><operator>*</operator><name>start</name></expr></argument>, <argument><expr><name>TIMESTAMPOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>end_old</name> <operator>=</operator> <call><name>ts_internal_to_time_value</name><argument_list>(<argument><expr><operator>*</operator><name>end</name></expr></argument>, <argument><expr><name>TIMESTAMPOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>start_new</name> <operator>=</operator> <call><name>generic_time_bucket</name><argument_list>(<argument><expr><name>bf</name></expr></argument>, <argument><expr><name>start_old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>end_new</name> <operator>=</operator> <call><name>generic_time_bucket</name><argument_list>(<argument><expr><name>bf</name></expr></argument>, <argument><expr><name>end_old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>DatumGetTimestamp</name><argument_list>(<argument><expr><name>start_new</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>DatumGetTimestamp</name><argument_list>(<argument><expr><name>start_old</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>start_new</name> <operator>=</operator> <call><name>generic_add_interval</name><argument_list>(<argument><expr><name>bf</name></expr></argument>, <argument><expr><name>start_new</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>start</name> <operator>=</operator> <call><name>ts_time_value_to_internal</name><argument_list>(<argument><expr><name>start_new</name></expr></argument>, <argument><expr><name>TIMESTAMPOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>end</name> <operator>=</operator> <call><name>ts_time_value_to_internal</name><argument_list>(<argument><expr><name>end_new</name></expr></argument>, <argument><expr><name>TIMESTAMPOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Computes circumscribed refresh_window for variable-sized buckets.
 *
 * The algorithm is simple:
 *
 * start = time_bucket(bucket_size, start)
 *
 * if(end != time_bucket(bucket_size, end))
 *     end = time_bucket(bucket_size, end) + interval bucket_size
 */</comment>
<function><type><name>void</name></type>
<name>ts_compute_circumscribed_bucketed_refresh_window_variable</name><parameter_list>(<parameter><decl><type><name>int64</name> <modifier>*</modifier></type><name>start</name></decl></parameter>, <parameter><decl><type><name>int64</name> <modifier>*</modifier></type><name>end</name></decl></parameter>,
														  <parameter><decl><type><specifier>const</specifier> <name>ContinuousAggsBucketFunction</name> <modifier>*</modifier></type><name>bf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type> <name>start_old</name></decl>, <decl><type ref="prev"/><name>end_old</name></decl>, <decl><type ref="prev"/><name>start_new</name></decl>, <decl><type ref="prev"/><name>end_new</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * It's OK to use TIMESTAMPOID here.
	 * See the comment in ts_compute_inscribed_bucketed_refresh_window_variable()
	 */</comment>
	<expr_stmt><expr><name>start_old</name> <operator>=</operator> <call><name>ts_internal_to_time_value</name><argument_list>(<argument><expr><operator>*</operator><name>start</name></expr></argument>, <argument><expr><name>TIMESTAMPOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>end_old</name> <operator>=</operator> <call><name>ts_internal_to_time_value</name><argument_list>(<argument><expr><operator>*</operator><name>end</name></expr></argument>, <argument><expr><name>TIMESTAMPOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>start_new</name> <operator>=</operator> <call><name>generic_time_bucket</name><argument_list>(<argument><expr><name>bf</name></expr></argument>, <argument><expr><name>start_old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>end_new</name> <operator>=</operator> <call><name>generic_time_bucket</name><argument_list>(<argument><expr><name>bf</name></expr></argument>, <argument><expr><name>end_old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>DatumGetTimestamp</name><argument_list>(<argument><expr><name>end_new</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>DatumGetTimestamp</name><argument_list>(<argument><expr><name>end_old</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>end_new</name> <operator>=</operator> <call><name>generic_add_interval</name><argument_list>(<argument><expr><name>bf</name></expr></argument>, <argument><expr><name>end_new</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>start</name> <operator>=</operator> <call><name>ts_time_value_to_internal</name><argument_list>(<argument><expr><name>start_new</name></expr></argument>, <argument><expr><name>TIMESTAMPOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>end</name> <operator>=</operator> <call><name>ts_time_value_to_internal</name><argument_list>(<argument><expr><name>end_new</name></expr></argument>, <argument><expr><name>TIMESTAMPOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Calculates the beginning of the next bucket.
 *
 * The algorithm is just:
 *
 * val = time_bucket(bucket_size, val) + interval bucket_size
 */</comment>
<function><type><name>int64</name></type>
<name>ts_compute_beginning_of_the_next_bucket_variable</name><parameter_list>(<parameter><decl><type><name>int64</name></type> <name>timeval</name></decl></parameter>,
												 <parameter><decl><type><specifier>const</specifier> <name>ContinuousAggsBucketFunction</name> <modifier>*</modifier></type><name>bf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type> <name>val_new</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>val_old</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * It's OK to use TIMESTAMPOID here.
	 * See the comment in ts_compute_inscribed_bucketed_refresh_window_variable()
	 */</comment>
	<expr_stmt><expr><name>val_old</name> <operator>=</operator> <call><name>ts_internal_to_time_value</name><argument_list>(<argument><expr><name>timeval</name></expr></argument>, <argument><expr><name>TIMESTAMPOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>val_new</name> <operator>=</operator> <call><name>generic_time_bucket</name><argument_list>(<argument><expr><name>bf</name></expr></argument>, <argument><expr><name>val_old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>val_new</name> <operator>=</operator> <call><name>generic_add_interval</name><argument_list>(<argument><expr><name>bf</name></expr></argument>, <argument><expr><name>val_new</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>ts_time_value_to_internal</name><argument_list>(<argument><expr><name>val_new</name></expr></argument>, <argument><expr><name>TIMESTAMPOID</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Oid</name></type>
<name>ts_cagg_permissions_check</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>cagg_oid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>userid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>ownerid</name> <init>= <expr><call><name>ts_rel_get_owner</name><argument_list>(<argument><expr><name>cagg_oid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>has_privs_of_role</name><argument_list>(<argument><expr><name>userid</name></expr></argument>, <argument><expr><name>ownerid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must be owner of continuous aggregate \"%s\""</literal></expr></argument>, <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>cagg_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>ownerid</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Query</name> <modifier>*</modifier></type>
<name>ts_continuous_agg_get_query</name><parameter_list>(<parameter><decl><type><name>ContinuousAgg</name> <modifier>*</modifier></type><name>cagg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>cagg_view_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>cagg_view_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RuleLock</name> <modifier>*</modifier></type><name>cagg_view_rules</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RewriteRule</name> <modifier>*</modifier></type><name>rule</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>cagg_view_query</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Get the direct_view definition for the finalized version because
	 * the user view doesn't have the "GROUP BY" clause anymore.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>ContinuousAggIsFinalized</name><argument_list>(<argument><expr><name>cagg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>cagg_view_oid</name> <operator>=</operator>
			<call><name>get_relname_relid</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>direct_view_name</name></name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><call><name>get_namespace_oid</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>direct_view_schema</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>cagg_view_oid</name> <operator>=</operator>
			<call><name>get_relname_relid</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>user_view_name</name></name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><call><name>get_namespace_oid</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>user_view_schema</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>cagg_view_rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>cagg_view_oid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cagg_view_rules</name> <operator>=</operator> <name><name>cagg_view_rel</name><operator>-&gt;</operator><name>rd_rules</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cagg_view_rules</name> <operator>&amp;&amp;</operator> <name><name>cagg_view_rules</name><operator>-&gt;</operator><name>numLocks</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rule</name> <operator>=</operator> <name><name>cagg_view_rules</name><operator>-&gt;</operator><name>rules</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>rule</name><operator>-&gt;</operator><name>event</name></name> <operator>!=</operator> <name>CMD_SELECT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TS_UNEXPECTED</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected rule event for view"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>cagg_view_query</name> <operator>=</operator> <operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>rule</name><operator>-&gt;</operator><name>actions</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>cagg_view_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>cagg_view_query</name></expr>;</return>
</block_content>}</block></function>
</unit>
