<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/timescaledb/src/ts_catalog/catalog.c"><comment type="block">/*
 * This file and its contents are licensed under the Apache License 2.0.
 * Please see the included NOTICE for copyright information and
 * LICENSE-APACHE for a copy of the license.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postgres.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_namespace.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/namespace.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/indexing.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/lsyscache.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/builtins.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/regproc.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/syscache.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/inval.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/xact.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/htup_details.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;miscadmin.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;commands/dbcommands.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;commands/sequence.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compat/compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ts_catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"extension.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cache_invalidate.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>TableInfoDef</name></type> <name><name>catalog_table_names</name><index>[<expr><name>_MAX_CATALOG_TABLES</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{
	<expr><index>[<expr><name>HYPERTABLE</name></expr>]</index> <operator>=</operator> <block>{
		<expr><operator>.</operator><name>schema_name</name> <operator>=</operator> <name>CATALOG_SCHEMA_NAME</name></expr>,
		<expr><operator>.</operator><name>table_name</name> <operator>=</operator> <name>HYPERTABLE_TABLE_NAME</name></expr>,
	}</block></expr>,
	<expr><index>[<expr><name>HYPERTABLE_DATA_NODE</name></expr>]</index> <operator>=</operator> <block>{
		<expr><operator>.</operator><name>schema_name</name> <operator>=</operator> <name>CATALOG_SCHEMA_NAME</name></expr>,
		<expr><operator>.</operator><name>table_name</name> <operator>=</operator> <name>HYPERTABLE_DATA_NODE_TABLE_NAME</name></expr>,
	}</block></expr>,
	<expr><index>[<expr><name>DIMENSION</name></expr>]</index> <operator>=</operator> <block>{
		<expr><operator>.</operator><name>schema_name</name> <operator>=</operator> <name>CATALOG_SCHEMA_NAME</name></expr>,
		<expr><operator>.</operator><name>table_name</name> <operator>=</operator> <name>DIMENSION_TABLE_NAME</name></expr>,
	}</block></expr>,
	<expr><index>[<expr><name>DIMENSION_PARTITION</name></expr>]</index> <operator>=</operator> <block>{
		<expr><operator>.</operator><name>schema_name</name> <operator>=</operator> <name>CATALOG_SCHEMA_NAME</name></expr>,
		<expr><operator>.</operator><name>table_name</name> <operator>=</operator> <name>DIMENSION_PARTITION_TABLE_NAME</name></expr>,
	}</block></expr>,
	<expr><index>[<expr><name>DIMENSION_SLICE</name></expr>]</index> <operator>=</operator> <block>{
		<expr><operator>.</operator><name>schema_name</name> <operator>=</operator> <name>CATALOG_SCHEMA_NAME</name></expr>,
		<expr><operator>.</operator><name>table_name</name> <operator>=</operator> <name>DIMENSION_SLICE_TABLE_NAME</name></expr>,
	}</block></expr>,
	<expr><index>[<expr><name>CHUNK</name></expr>]</index> <operator>=</operator> <block>{
		<expr><operator>.</operator><name>schema_name</name> <operator>=</operator> <name>CATALOG_SCHEMA_NAME</name></expr>,
		<expr><operator>.</operator><name>table_name</name> <operator>=</operator> <name>CHUNK_TABLE_NAME</name></expr>,
	}</block></expr>,
	<expr><index>[<expr><name>CHUNK_CONSTRAINT</name></expr>]</index> <operator>=</operator> <block>{
		<expr><operator>.</operator><name>schema_name</name> <operator>=</operator> <name>CATALOG_SCHEMA_NAME</name></expr>,
		<expr><operator>.</operator><name>table_name</name> <operator>=</operator> <name>CHUNK_CONSTRAINT_TABLE_NAME</name></expr>,
	}</block></expr>,
	<expr><index>[<expr><name>CHUNK_INDEX</name></expr>]</index> <operator>=</operator> <block>{
		<expr><operator>.</operator><name>schema_name</name> <operator>=</operator> <name>CATALOG_SCHEMA_NAME</name></expr>,
		<expr><operator>.</operator><name>table_name</name> <operator>=</operator> <name>CHUNK_INDEX_TABLE_NAME</name></expr>,
	}</block></expr>,
	<expr><index>[<expr><name>CHUNK_DATA_NODE</name></expr>]</index> <operator>=</operator> <block>{
		<expr><operator>.</operator><name>schema_name</name> <operator>=</operator> <name>CATALOG_SCHEMA_NAME</name></expr>,
		<expr><operator>.</operator><name>table_name</name> <operator>=</operator> <name>CHUNK_DATA_NODE_TABLE_NAME</name></expr>,
	}</block></expr>,
	<expr><index>[<expr><name>TABLESPACE</name></expr>]</index> <operator>=</operator> <block>{
		<expr><operator>.</operator><name>schema_name</name> <operator>=</operator> <name>CATALOG_SCHEMA_NAME</name></expr>,
		<expr><operator>.</operator><name>table_name</name> <operator>=</operator> <name>TABLESPACE_TABLE_NAME</name></expr>,
	}</block></expr>,
	<expr><index>[<expr><name>BGW_JOB</name></expr>]</index> <operator>=</operator> <block>{
		<expr><operator>.</operator><name>schema_name</name> <operator>=</operator> <name>CONFIG_SCHEMA_NAME</name></expr>,
		<expr><operator>.</operator><name>table_name</name> <operator>=</operator> <name>BGW_JOB_TABLE_NAME</name></expr>,
	}</block></expr>,
	<expr><index>[<expr><name>BGW_JOB_STAT</name></expr>]</index> <operator>=</operator> <block>{
		<expr><operator>.</operator><name>schema_name</name> <operator>=</operator> <name>INTERNAL_SCHEMA_NAME</name></expr>,
		<expr><operator>.</operator><name>table_name</name> <operator>=</operator> <name>BGW_JOB_STAT_TABLE_NAME</name></expr>,
	}</block></expr>,
	<expr><index>[<expr><name>METADATA</name></expr>]</index> <operator>=</operator> <block>{
		<expr><operator>.</operator><name>schema_name</name> <operator>=</operator> <name>CATALOG_SCHEMA_NAME</name></expr>,
		<expr><operator>.</operator><name>table_name</name> <operator>=</operator> <name>METADATA_TABLE_NAME</name></expr>,
	}</block></expr>,
	<expr><index>[<expr><name>BGW_POLICY_CHUNK_STATS</name></expr>]</index> <operator>=</operator> <block>{
		<expr><operator>.</operator><name>schema_name</name> <operator>=</operator> <name>INTERNAL_SCHEMA_NAME</name></expr>,
		<expr><operator>.</operator><name>table_name</name> <operator>=</operator> <name>BGW_POLICY_CHUNK_STATS_TABLE_NAME</name></expr>,
	}</block></expr>,
	<expr><index>[<expr><name>CONTINUOUS_AGG</name></expr>]</index> <operator>=</operator> <block>{
		<expr><operator>.</operator><name>schema_name</name> <operator>=</operator> <name>CATALOG_SCHEMA_NAME</name></expr>,
		<expr><operator>.</operator><name>table_name</name> <operator>=</operator> <name>CONTINUOUS_AGG_TABLE_NAME</name></expr>,
	}</block></expr>,
	<expr><index>[<expr><name>CONTINUOUS_AGGS_HYPERTABLE_INVALIDATION_LOG</name></expr>]</index> <operator>=</operator> <block>{
		<expr><operator>.</operator><name>schema_name</name> <operator>=</operator> <name>CATALOG_SCHEMA_NAME</name></expr>,
		<expr><operator>.</operator><name>table_name</name> <operator>=</operator> <name>CONTINUOUS_AGGS_HYPERTABLE_INVALIDATION_LOG_TABLE_NAME</name></expr>,
	}</block></expr>,
	<expr><index>[<expr><name>CONTINUOUS_AGGS_INVALIDATION_THRESHOLD</name></expr>]</index> <operator>=</operator> <block>{
		<expr><operator>.</operator><name>schema_name</name> <operator>=</operator> <name>CATALOG_SCHEMA_NAME</name></expr>,
		<expr><operator>.</operator><name>table_name</name> <operator>=</operator> <name>CONTINUOUS_AGGS_INVALIDATION_THRESHOLD_TABLE_NAME</name></expr>,
	}</block></expr>,
	<expr><index>[<expr><name>CONTINUOUS_AGGS_MATERIALIZATION_INVALIDATION_LOG</name></expr>]</index> <operator>=</operator> <block>{
		<expr><operator>.</operator><name>schema_name</name> <operator>=</operator> <name>CATALOG_SCHEMA_NAME</name></expr>,
		<expr><operator>.</operator><name>table_name</name> <operator>=</operator> <name>CONTINUOUS_AGGS_MATERIALIZATION_INVALIDATION_LOG_TABLE_NAME</name></expr>,
	}</block></expr>,
	<expr><index>[<expr><name>HYPERTABLE_COMPRESSION</name></expr>]</index> <operator>=</operator> <block>{
		<expr><operator>.</operator><name>schema_name</name> <operator>=</operator> <name>CATALOG_SCHEMA_NAME</name></expr>,
		<expr><operator>.</operator><name>table_name</name> <operator>=</operator> <name>HYPERTABLE_COMPRESSION_TABLE_NAME</name></expr>,
	}</block></expr>,
	<expr><index>[<expr><name>COMPRESSION_CHUNK_SIZE</name></expr>]</index> <operator>=</operator> <block>{
		<expr><operator>.</operator><name>schema_name</name> <operator>=</operator> <name>CATALOG_SCHEMA_NAME</name></expr>,
		<expr><operator>.</operator><name>table_name</name> <operator>=</operator> <name>COMPRESSION_CHUNK_SIZE_TABLE_NAME</name></expr>,
	}</block></expr>,
	<expr><index>[<expr><name>REMOTE_TXN</name></expr>]</index> <operator>=</operator> <block>{
		<expr><operator>.</operator><name>schema_name</name> <operator>=</operator> <name>CATALOG_SCHEMA_NAME</name></expr>,
		<expr><operator>.</operator><name>table_name</name> <operator>=</operator> <name>REMOTE_TXN_TABLE_NAME</name></expr>,
	}</block></expr>,
	<expr><index>[<expr><name>CHUNK_COPY_OPERATION</name></expr>]</index> <operator>=</operator> <block>{
		<expr><operator>.</operator><name>schema_name</name> <operator>=</operator> <name>CATALOG_SCHEMA_NAME</name></expr>,
		<expr><operator>.</operator><name>table_name</name> <operator>=</operator> <name>CHUNK_COPY_OPERATION_TABLE_NAME</name></expr>,
	}</block></expr>,
	<expr><index>[<expr><name>CONTINUOUS_AGGS_BUCKET_FUNCTION</name></expr>]</index> <operator>=</operator> <block>{
		<expr><operator>.</operator><name>schema_name</name> <operator>=</operator> <name>CATALOG_SCHEMA_NAME</name></expr>,
		<expr><operator>.</operator><name>table_name</name> <operator>=</operator> <name>CONTINUOUS_AGGS_BUCKET_FUNCTION_TABLE_NAME</name></expr>,
	}</block></expr>,
	<expr><index>[<expr><name>JOB_ERRORS</name></expr>]</index> <operator>=</operator> <block>{
		<expr><operator>.</operator><name>schema_name</name> <operator>=</operator> <name>INTERNAL_SCHEMA_NAME</name></expr>,
		<expr><operator>.</operator><name>table_name</name> <operator>=</operator> <name>JOB_ERRORS_TABLE_NAME</name></expr>,
	}</block></expr>,
	<expr><index>[<expr><name>_MAX_CATALOG_TABLES</name></expr>]</index> <operator>=</operator> <block>{
		<expr><operator>.</operator><name>schema_name</name> <operator>=</operator> <literal type="string">"invalid schema"</literal></expr>,
		<expr><operator>.</operator><name>table_name</name> <operator>=</operator> <literal type="string">"invalid table"</literal></expr>,
	}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>TableIndexDef</name></type> <name><name>catalog_table_index_definitions</name><index>[<expr><name>_MAX_CATALOG_TABLES</name></expr>]</index></name> <init>= <expr><block>{
	<expr><index>[<expr><name>HYPERTABLE</name></expr>]</index> <operator>=</operator> <block>{
		<expr><operator>.</operator><name>length</name> <operator>=</operator> <name>_MAX_HYPERTABLE_INDEX</name></expr>,
		<expr><operator>.</operator><name>names</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><index>[]</index><operator>)</operator> <block>{
			<expr><index>[<expr><name>HYPERTABLE_ID_INDEX</name></expr>]</index> <operator>=</operator> <literal type="string">"hypertable_pkey"</literal></expr>,
			<expr><index>[<expr><name>HYPERTABLE_NAME_INDEX</name></expr>]</index> <operator>=</operator> <literal type="string">"hypertable_table_name_schema_name_key"</literal></expr>,
		}</block></expr>,
	}</block></expr>,
	<expr><index>[<expr><name>HYPERTABLE_DATA_NODE</name></expr>]</index> <operator>=</operator> <block>{
		<expr><operator>.</operator><name>length</name> <operator>=</operator> <name>_MAX_HYPERTABLE_DATA_NODE_INDEX</name></expr>,
		<expr><operator>.</operator><name>names</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><index>[]</index><operator>)</operator> <block>{
			<expr><index>[<expr><name>HYPERTABLE_DATA_NODE_HYPERTABLE_ID_NODE_NAME_IDX</name></expr>]</index> <operator>=</operator> <literal type="string">"hypertable_data_node_hypertable_id_node_name_key"</literal></expr>,
			<expr><index>[<expr><name>HYPERTABLE_DATA_NODE_NODE_HYPERTABLE_ID_NODE_NAME_IDX</name></expr>]</index> <operator>=</operator> <literal type="string">"hypertable_data_node_node_hypertable_id_node_name_key"</literal></expr>,
		}</block></expr>
	}</block></expr>,
	<expr><index>[<expr><name>DIMENSION</name></expr>]</index> <operator>=</operator> <block>{
		<expr><operator>.</operator><name>length</name> <operator>=</operator> <name>_MAX_DIMENSION_INDEX</name></expr>,
		<expr><operator>.</operator><name>names</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><index>[]</index><operator>)</operator> <block>{
			<expr><index>[<expr><name>DIMENSION_ID_IDX</name></expr>]</index> <operator>=</operator> <literal type="string">"dimension_pkey"</literal></expr>,
			<expr><index>[<expr><name>DIMENSION_HYPERTABLE_ID_COLUMN_NAME_IDX</name></expr>]</index> <operator>=</operator> <literal type="string">"dimension_hypertable_id_column_name_key"</literal></expr>,
		}</block></expr>,
	}</block></expr>,
	<expr><index>[<expr><name>DIMENSION_PARTITION</name></expr>]</index> <operator>=</operator> <block>{
		<expr><operator>.</operator><name>length</name> <operator>=</operator> <name>_MAX_DIMENSION_PARTITION_INDEX</name></expr>,
		<expr><operator>.</operator><name>names</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><index>[]</index><operator>)</operator> <block>{
			<expr><index>[<expr><name>DIMENSION_PARTITION_DIMENSION_ID_RANGE_START_IDX</name></expr>]</index> <operator>=</operator> <literal type="string">"dimension_partition_dimension_id_range_start_key"</literal></expr>,
		}</block></expr>,
	}</block></expr>,
	<expr><index>[<expr><name>DIMENSION_SLICE</name></expr>]</index> <operator>=</operator> <block>{
		<expr><operator>.</operator><name>length</name> <operator>=</operator> <name>_MAX_DIMENSION_SLICE_INDEX</name></expr>,
		<expr><operator>.</operator><name>names</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><index>[]</index><operator>)</operator> <block>{
			<expr><index>[<expr><name>DIMENSION_SLICE_ID_IDX</name></expr>]</index> <operator>=</operator> <literal type="string">"dimension_slice_pkey"</literal></expr>,
			<expr><index>[<expr><name>DIMENSION_SLICE_DIMENSION_ID_RANGE_START_RANGE_END_IDX</name></expr>]</index> <operator>=</operator> <literal type="string">"dimension_slice_dimension_id_range_start_range_end_key"</literal></expr>,
		}</block></expr>,
	}</block></expr>,
	<expr><index>[<expr><name>CHUNK</name></expr>]</index> <operator>=</operator> <block>{
		<expr><operator>.</operator><name>length</name> <operator>=</operator> <name>_MAX_CHUNK_INDEX</name></expr>,
		<expr><operator>.</operator><name>names</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><index>[]</index><operator>)</operator> <block>{
			<expr><index>[<expr><name>CHUNK_ID_INDEX</name></expr>]</index> <operator>=</operator> <literal type="string">"chunk_pkey"</literal></expr>,
			<expr><index>[<expr><name>CHUNK_HYPERTABLE_ID_INDEX</name></expr>]</index> <operator>=</operator> <literal type="string">"chunk_hypertable_id_idx"</literal></expr>,
			<expr><index>[<expr><name>CHUNK_SCHEMA_NAME_INDEX</name></expr>]</index> <operator>=</operator> <literal type="string">"chunk_schema_name_table_name_key"</literal></expr>,
			<expr><index>[<expr><name>CHUNK_COMPRESSED_CHUNK_ID_INDEX</name></expr>]</index> <operator>=</operator> <literal type="string">"chunk_compressed_chunk_id_idx"</literal></expr>,
			<expr><index>[<expr><name>CHUNK_OSM_CHUNK_INDEX</name></expr>]</index> <operator>=</operator> <literal type="string">"chunk_osm_chunk_idx"</literal></expr>,
		}</block></expr>,
	}</block></expr>,
	<expr><index>[<expr><name>CHUNK_CONSTRAINT</name></expr>]</index> <operator>=</operator> <block>{
		<expr><operator>.</operator><name>length</name> <operator>=</operator> <name>_MAX_CHUNK_CONSTRAINT_INDEX</name></expr>,
		<expr><operator>.</operator><name>names</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><index>[]</index><operator>)</operator> <block>{
			<expr><index>[<expr><name>CHUNK_CONSTRAINT_CHUNK_ID_CONSTRAINT_NAME_IDX</name></expr>]</index> <operator>=</operator> <literal type="string">"chunk_constraint_chunk_id_constraint_name_key"</literal></expr>,
			<expr><index>[<expr><name>CHUNK_CONSTRAINT_DIMENSION_SLICE_ID_IDX</name></expr>]</index> <operator>=</operator> <literal type="string">"chunk_constraint_dimension_slice_id_idx"</literal></expr>,
		}</block></expr>,
	}</block></expr>,
	<expr><index>[<expr><name>CHUNK_INDEX</name></expr>]</index> <operator>=</operator> <block>{
		<expr><operator>.</operator><name>length</name> <operator>=</operator> <name>_MAX_CHUNK_INDEX_INDEX</name></expr>,
		<expr><operator>.</operator><name>names</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><index>[]</index><operator>)</operator> <block>{
			<expr><index>[<expr><name>CHUNK_INDEX_CHUNK_ID_INDEX_NAME_IDX</name></expr>]</index> <operator>=</operator> <literal type="string">"chunk_index_chunk_id_index_name_key"</literal></expr>,
			<expr><index>[<expr><name>CHUNK_INDEX_HYPERTABLE_ID_HYPERTABLE_INDEX_NAME_IDX</name></expr>]</index> <operator>=</operator> <literal type="string">"chunk_index_hypertable_id_hypertable_index_name_idx"</literal></expr>,
		}</block></expr>,
	}</block></expr>,
	<expr><index>[<expr><name>CHUNK_DATA_NODE</name></expr>]</index> <operator>=</operator> <block>{
		<expr><operator>.</operator><name>length</name> <operator>=</operator> <name>_MAX_CHUNK_DATA_NODE_INDEX</name></expr>,
		<expr><operator>.</operator><name>names</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><index>[]</index><operator>)</operator> <block>{
			<expr><index>[<expr><name>CHUNK_DATA_NODE_CHUNK_ID_NODE_NAME_IDX</name></expr>]</index> <operator>=</operator> <literal type="string">"chunk_data_node_chunk_id_node_name_key"</literal></expr>,
			<expr><index>[<expr><name>CHUNK_DATA_NODE_NODE_CHUNK_ID_NODE_NAME_IDX</name></expr>]</index> <operator>=</operator> <literal type="string">"chunk_data_node_node_chunk_id_node_name_key"</literal></expr>,
			<expr><index>[<expr><name>CHUNK_DATA_NODE_NODE_NAME_IDX</name></expr>]</index> <operator>=</operator> <literal type="string">"chunk_data_node_node_name_idx"</literal></expr>,
		}</block></expr>
	}</block></expr>,
	<expr><index>[<expr><name>TABLESPACE</name></expr>]</index> <operator>=</operator> <block>{
		<expr><operator>.</operator><name>length</name> <operator>=</operator> <name>_MAX_TABLESPACE_INDEX</name></expr>,
		<expr><operator>.</operator><name>names</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><index>[]</index><operator>)</operator> <block>{
			<expr><index>[<expr><name>TABLESPACE_PKEY_IDX</name></expr>]</index> <operator>=</operator> <literal type="string">"tablespace_pkey"</literal></expr>,
			<expr><index>[<expr><name>TABLESPACE_HYPERTABLE_ID_TABLESPACE_NAME_IDX</name></expr>]</index> <operator>=</operator> <literal type="string">"tablespace_hypertable_id_tablespace_name_key"</literal></expr>,
		}</block></expr>,
	}</block></expr>,
	<expr><index>[<expr><name>BGW_JOB</name></expr>]</index> <operator>=</operator> <block>{
		<expr><operator>.</operator><name>length</name> <operator>=</operator> <name>_MAX_BGW_JOB_INDEX</name></expr>,
		<expr><operator>.</operator><name>names</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><index>[]</index><operator>)</operator> <block>{
			<expr><index>[<expr><name>BGW_JOB_PKEY_IDX</name></expr>]</index> <operator>=</operator> <literal type="string">"bgw_job_pkey"</literal></expr>,
			<expr><index>[<expr><name>BGW_JOB_PROC_HYPERTABLE_ID_IDX</name></expr>]</index> <operator>=</operator> <literal type="string">"bgw_job_proc_hypertable_id_idx"</literal></expr>,
		}</block></expr>,
	}</block></expr>,
	<expr><index>[<expr><name>BGW_JOB_STAT</name></expr>]</index> <operator>=</operator> <block>{
		<expr><operator>.</operator><name>length</name> <operator>=</operator> <name>_MAX_BGW_JOB_STAT_INDEX</name></expr>,
		<expr><operator>.</operator><name>names</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><index>[]</index><operator>)</operator> <block>{
			<expr><index>[<expr><name>BGW_JOB_STAT_PKEY_IDX</name></expr>]</index> <operator>=</operator> <literal type="string">"bgw_job_stat_pkey"</literal></expr>,
		}</block></expr>,
	}</block></expr>,
	<expr><index>[<expr><name>METADATA</name></expr>]</index> <operator>=</operator> <block>{
		<expr><operator>.</operator><name>length</name> <operator>=</operator> <name>_MAX_METADATA_INDEX</name></expr>,
		<expr><operator>.</operator><name>names</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><index>[]</index><operator>)</operator> <block>{
			<expr><index>[<expr><name>METADATA_PKEY_IDX</name></expr>]</index> <operator>=</operator> <literal type="string">"metadata_pkey"</literal></expr>,
		}</block></expr>,
	}</block></expr>,
	<expr><index>[<expr><name>BGW_POLICY_CHUNK_STATS</name></expr>]</index> <operator>=</operator> <block>{
		<expr><operator>.</operator><name>length</name> <operator>=</operator> <name>_MAX_BGW_POLICY_CHUNK_STATS_INDEX</name></expr>,
		<expr><operator>.</operator><name>names</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><index>[]</index><operator>)</operator> <block>{
			<expr><index>[<expr><name>BGW_POLICY_CHUNK_STATS_JOB_ID_CHUNK_ID_IDX</name></expr>]</index> <operator>=</operator> <literal type="string">"bgw_policy_chunk_stats_job_id_chunk_id_key"</literal></expr>,
		}</block></expr>
	}</block></expr>,
	<expr><index>[<expr><name>CONTINUOUS_AGG</name></expr>]</index> <operator>=</operator> <block>{
		<expr><operator>.</operator><name>length</name> <operator>=</operator> <name>_MAX_CONTINUOUS_AGG_INDEX</name></expr>,
		<expr><operator>.</operator><name>names</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><index>[]</index><operator>)</operator> <block>{
			<expr><index>[<expr><name>CONTINUOUS_AGG_PARTIAL_VIEW_SCHEMA_PARTIAL_VIEW_NAME_KEY</name></expr>]</index> <operator>=</operator> <literal type="string">"continuous_agg_partial_view_schema_partial_view_name_key"</literal></expr>,
			<expr><index>[<expr><name>CONTINUOUS_AGG_PKEY</name></expr>]</index> <operator>=</operator> <literal type="string">"continuous_agg_pkey"</literal></expr>,
			<expr><index>[<expr><name>CONTINUOUS_AGG_USER_VIEW_SCHEMA_USER_VIEW_NAME_KEY</name></expr>]</index> <operator>=</operator> <literal type="string">"continuous_agg_user_view_schema_user_view_name_key"</literal></expr>,
			<expr><index>[<expr><name>CONTINUOUS_AGG_RAW_HYPERTABLE_ID_IDX</name></expr>]</index> <operator>=</operator> <literal type="string">"continuous_agg_raw_hypertable_id_idx"</literal></expr>
		}</block></expr>,
	}</block></expr>,
	<expr><index>[<expr><name>CONTINUOUS_AGGS_HYPERTABLE_INVALIDATION_LOG</name></expr>]</index> <operator>=</operator> <block>{
		<expr><operator>.</operator><name>length</name> <operator>=</operator> <name>_MAX_CONTINUOUS_AGGS_HYPERTABLE_INVALIDATION_LOG_INDEX</name></expr>,
		<expr><operator>.</operator><name>names</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><index>[]</index><operator>)</operator> <block>{
			<expr><index>[<expr><name>CONTINUOUS_AGGS_HYPERTABLE_INVALIDATION_LOG_IDX</name></expr>]</index> <operator>=</operator> <literal type="string">"continuous_aggs_hypertable_invalidation_log_idx"</literal></expr>,
		}</block></expr>,
	}</block></expr>,
	<expr><index>[<expr><name>CONTINUOUS_AGGS_INVALIDATION_THRESHOLD</name></expr>]</index> <operator>=</operator> <block>{
		<expr><operator>.</operator><name>length</name> <operator>=</operator> <name>_MAX_CONTINUOUS_AGGS_INVALIDATION_THRESHOLD_INDEX</name></expr>,
		<expr><operator>.</operator><name>names</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><index>[]</index><operator>)</operator> <block>{
			<expr><index>[<expr><name>CONTINUOUS_AGGS_INVALIDATION_THRESHOLD_PKEY</name></expr>]</index> <operator>=</operator> <literal type="string">"continuous_aggs_invalidation_threshold_pkey"</literal></expr>,
		}</block></expr>,
	}</block></expr>,
	<expr><index>[<expr><name>CONTINUOUS_AGGS_MATERIALIZATION_INVALIDATION_LOG</name></expr>]</index> <operator>=</operator> <block>{
		<expr><operator>.</operator><name>length</name> <operator>=</operator> <name>_MAX_CONTINUOUS_AGGS_MATERIALIZATION_INVALIDATION_LOG_INDEX</name></expr>,
		<expr><operator>.</operator><name>names</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><index>[]</index><operator>)</operator> <block>{
			<expr><index>[<expr><name>CONTINUOUS_AGGS_MATERIALIZATION_INVALIDATION_LOG_IDX</name></expr>]</index> <operator>=</operator> <literal type="string">"continuous_aggs_materialization_invalidation_log_idx"</literal></expr>,
		}</block></expr>,
	}</block></expr>,
	<expr><index>[<expr><name>HYPERTABLE_COMPRESSION</name></expr>]</index> <operator>=</operator> <block>{
		<expr><operator>.</operator><name>length</name> <operator>=</operator>  <name>_MAX_HYPERTABLE_COMPRESSION_INDEX</name></expr>,
		<expr><operator>.</operator><name>names</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><index>[]</index><operator>)</operator> <block>{
			<expr><index>[<expr><name>HYPERTABLE_COMPRESSION_PKEY</name></expr>]</index> <operator>=</operator> <literal type="string">"hypertable_compression_pkey"</literal></expr>,
		}</block></expr>,
	}</block></expr>,
	<expr><index>[<expr><name>COMPRESSION_CHUNK_SIZE</name></expr>]</index> <operator>=</operator> <block>{
		<expr><operator>.</operator><name>length</name> <operator>=</operator>  <name>_MAX_COMPRESSION_CHUNK_SIZE_INDEX</name></expr>,
		<expr><operator>.</operator><name>names</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><index>[]</index><operator>)</operator> <block>{
			<expr><index>[<expr><name>COMPRESSION_CHUNK_SIZE_PKEY</name></expr>]</index> <operator>=</operator> <literal type="string">"compression_chunk_size_pkey"</literal></expr>,
		}</block></expr>,
	}</block></expr>,
	<expr><index>[<expr><name>REMOTE_TXN</name></expr>]</index> <operator>=</operator> <block>{
		<expr><operator>.</operator><name>length</name> <operator>=</operator> <name>_MAX_REMOTE_TXN_INDEX</name></expr>,
		<expr><operator>.</operator><name>names</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><index>[]</index><operator>)</operator> <block>{
			<expr><index>[<expr><name>REMOTE_TXN_PKEY_IDX</name></expr>]</index> <operator>=</operator> <literal type="string">"remote_txn_pkey"</literal></expr>,
			<expr><index>[<expr><name>REMOTE_TXN_DATA_NODE_NAME_IDX</name></expr>]</index> <operator>=</operator> <literal type="string">"remote_txn_data_node_name_idx"</literal></expr>
		}</block></expr>
	}</block></expr>,
	<expr><index>[<expr><name>CHUNK_COPY_OPERATION</name></expr>]</index> <operator>=</operator> <block>{
		<expr><operator>.</operator><name>length</name> <operator>=</operator> <name>_MAX_CHUNK_COPY_OPERATION_INDEX</name></expr>,
		<expr><operator>.</operator><name>names</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><index>[]</index><operator>)</operator> <block>{
			<expr><index>[<expr><name>CHUNK_COPY_OPERATION_PKEY_IDX</name></expr>]</index> <operator>=</operator> <literal type="string">"chunk_copy_operation_pkey"</literal></expr>,
		}</block></expr>,
	}</block></expr>,
	<expr><index>[<expr><name>CONTINUOUS_AGGS_BUCKET_FUNCTION</name></expr>]</index> <operator>=</operator> <block>{
		<expr><operator>.</operator><name>length</name> <operator>=</operator> <name>_MAX_CONTINUOUS_AGGS_BUCKET_FUNCTION_INDEX</name></expr>,
		<expr><operator>.</operator><name>names</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><index>[]</index><operator>)</operator> <block>{
			<expr><index>[<expr><name>CONTINUOUS_AGGS_BUCKET_FUNCTION_PKEY_IDX</name></expr>]</index> <operator>=</operator> <literal type="string">"continuous_aggs_bucket_function_pkey"</literal></expr>,
		}</block></expr>,
	}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>catalog_table_serial_id_names</name><index>[<expr><name>_MAX_CATALOG_TABLES</name></expr>]</index></name> <init>= <expr><block>{
	<expr><index>[<expr><name>HYPERTABLE</name></expr>]</index> <operator>=</operator> <name>CATALOG_SCHEMA_NAME</name> <literal type="string">".hypertable_id_seq"</literal></expr>,
	<expr><index>[<expr><name>HYPERTABLE_DATA_NODE</name></expr>]</index> <operator>=</operator> <name>NULL</name></expr>,
	<expr><index>[<expr><name>DIMENSION</name></expr>]</index> <operator>=</operator> <name>CATALOG_SCHEMA_NAME</name> <literal type="string">".dimension_id_seq"</literal></expr>,
	<expr><index>[<expr><name>DIMENSION_PARTITION</name></expr>]</index> <operator>=</operator> <name>NULL</name></expr>,
	<expr><index>[<expr><name>DIMENSION_SLICE</name></expr>]</index> <operator>=</operator> <name>CATALOG_SCHEMA_NAME</name> <literal type="string">".dimension_slice_id_seq"</literal></expr>,
	<expr><index>[<expr><name>CHUNK</name></expr>]</index> <operator>=</operator> <name>CATALOG_SCHEMA_NAME</name> <literal type="string">".chunk_id_seq"</literal></expr>,
	<expr><index>[<expr><name>CHUNK_CONSTRAINT</name></expr>]</index> <operator>=</operator> <name>CATALOG_SCHEMA_NAME</name> <literal type="string">".chunk_constraint_name"</literal></expr>,
	<expr><index>[<expr><name>CHUNK_INDEX</name></expr>]</index> <operator>=</operator> <name>NULL</name></expr>,
	<expr><index>[<expr><name>CHUNK_DATA_NODE</name></expr>]</index> <operator>=</operator> <name>NULL</name></expr>,
	<expr><index>[<expr><name>TABLESPACE</name></expr>]</index> <operator>=</operator> <name>CATALOG_SCHEMA_NAME</name> <literal type="string">".tablespace_id_seq"</literal></expr>,
	<expr><index>[<expr><name>BGW_JOB</name></expr>]</index> <operator>=</operator> <name>CONFIG_SCHEMA_NAME</name> <literal type="string">".bgw_job_id_seq"</literal></expr>,
	<expr><index>[<expr><name>BGW_JOB_STAT</name></expr>]</index> <operator>=</operator> <name>NULL</name></expr>,
	<expr><index>[<expr><name>CONTINUOUS_AGGS_HYPERTABLE_INVALIDATION_LOG</name></expr>]</index> <operator>=</operator> <name>NULL</name></expr>,
	<expr><index>[<expr><name>CONTINUOUS_AGGS_INVALIDATION_THRESHOLD</name></expr>]</index> <operator>=</operator> <name>NULL</name></expr>,
	<expr><index>[<expr><name>CONTINUOUS_AGGS_MATERIALIZATION_INVALIDATION_LOG</name></expr>]</index> <operator>=</operator> <name>NULL</name></expr>,
	<expr><index>[<expr><name>HYPERTABLE_COMPRESSION</name></expr>]</index> <operator>=</operator> <name>NULL</name></expr>,
	<expr><index>[<expr><name>COMPRESSION_CHUNK_SIZE</name></expr>]</index> <operator>=</operator> <name>NULL</name></expr>,
	<expr><index>[<expr><name>REMOTE_TXN</name></expr>]</index> <operator>=</operator> <name>NULL</name></expr>,
	<expr><index>[<expr><name>CHUNK_COPY_OPERATION</name></expr>]</index> <operator>=</operator> <name>CATALOG_SCHEMA_NAME</name> <literal type="string">".chunk_copy_operation_id_seq"</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>

<typedef>typedef <type><struct>struct <name>InternalFunctionDef</name>
<block>{
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>args</name></decl>;</decl_stmt>
}</block></struct></type> <name>InternalFunctionDef</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>InternalFunctionDef</name></type> <name><name>internal_function_definitions</name><index>[<expr><name>_MAX_INTERNAL_FUNCTIONS</name></expr>]</index></name> <init>= <expr><block>{
	<expr><index>[<expr><name>DDL_ADD_CHUNK_CONSTRAINT</name></expr>]</index> <operator>=</operator> <block>{
		<expr><operator>.</operator><name>name</name> <operator>=</operator> <literal type="string">"chunk_constraint_add_table_constraint"</literal></expr>,
		<expr><operator>.</operator><name>args</name> <operator>=</operator> <literal type="number">1</literal></expr>,
	}</block></expr>,
	<expr><index>[<expr><name>DDL_ADD_HYPERTABLE_FK_CONSTRAINT</name></expr>]</index> <operator>=</operator> <block>{
		<expr><operator>.</operator><name>name</name> <operator>=</operator> <literal type="string">"hypertable_constraint_add_table_fk_constraint"</literal></expr>,
		<expr><operator>.</operator><name>args</name> <operator>=</operator> <literal type="number">4</literal></expr>,
	}</block></expr>,
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Names for proxy tables used for cache invalidation. Must match names in
 * sql/cache.sql */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>cache_proxy_table_names</name><index>[<expr><name>_MAX_CACHE_TYPES</name></expr>]</index></name> <init>= <expr><block>{
	<expr><index>[<expr><name>CACHE_TYPE_HYPERTABLE</name></expr>]</index> <operator>=</operator> <literal type="string">"cache_inval_hypertable"</literal></expr>,
	<expr><index>[<expr><name>CACHE_TYPE_BGW_JOB</name></expr>]</index> <operator>=</operator> <literal type="string">"cache_inval_bgw_job"</literal></expr>,
	<expr><index>[<expr><name>CACHE_TYPE_EXTENSION</name></expr>]</index> <operator>=</operator> <literal type="string">"cache_inval_extension"</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Catalog information for the current database. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>Catalog</name></type> <name>s_catalog</name> <init>= <expr><block>{
	<expr><operator>.</operator><name>initialized</name> <operator>=</operator> <name>false</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>CatalogDatabaseInfo</name></type> <name>database_info</name> <init>= <expr><block>{
	<expr><operator>.</operator><name>database_id</name> <operator>=</operator> <name>InvalidOid</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>catalog_is_valid</name><parameter_list>(<parameter><decl><type><name>Catalog</name> <modifier>*</modifier></type><name>catalog</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>catalog</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>catalog</name><operator>-&gt;</operator><name>initialized</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get the user ID of the catalog owner.
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>catalog_owner</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>owner_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>nsp_oid</name> <init>= <expr><call><name>get_namespace_oid</name><argument_list>(<argument><expr><name>CATALOG_SCHEMA_NAME</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>NAMESPACEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>nsp_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_SCHEMA</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"schema with OID %u does not exist"</literal></expr></argument>, <argument><expr><name>nsp_oid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>owner_oid</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_namespace</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>nspowner</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>owner_oid</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>catalog_table_name</name><parameter_list>(<parameter><decl><type><name>CatalogTable</name></type> <name>table</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>catalog_table_names</name><index>[<expr><name>table</name></expr>]</index></name><operator>.</operator><name>table_name</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>catalog_database_info_init</name><parameter_list>(<parameter><decl><type><name>CatalogDatabaseInfo</name> <modifier>*</modifier></type><name>info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>database_id</name></name> <operator>=</operator> <name>MyDatabaseId</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>database_name</name></name></expr></argument>, <argument><expr><call><name>get_database_name</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>schema_id</name></name> <operator>=</operator> <call><name>get_namespace_oid</name><argument_list>(<argument><expr><name>CATALOG_SCHEMA_NAME</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>owner_uid</name></name> <operator>=</operator> <call><name>catalog_owner</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>schema_id</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"OID lookup failed for schema \"%s\""</literal></expr></argument>, <argument><expr><name>CATALOG_SCHEMA_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>TSDLLEXPORT</name> <name>CatalogDatabaseInfo</name> <modifier>*</modifier></type>
<name>ts_catalog_database_info_get</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ts_extension_is_loaded</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"tried calling catalog_database_info_get when extension isn't loaded"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>database_info</name><operator>.</operator><name>database_id</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsTransactionState</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot initialize catalog_database_info outside of a transaction"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>database_info</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CatalogDatabaseInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>catalog_database_info_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>database_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><operator>&amp;</operator><name>database_info</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * The rest of the arguments are used to populate the first arg.
 */</comment>
<function><type><name>void</name></type>
<name>ts_catalog_table_info_init</name><parameter_list>(<parameter><decl><type><name>CatalogTableInfo</name> <modifier>*</modifier></type><name>tables_info</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>max_tables</name></decl></parameter>,
						   <parameter><decl><type><specifier>const</specifier> <name>TableInfoDef</name> <modifier>*</modifier></type><name>table_ary</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TableIndexDef</name> <modifier>*</modifier></type><name>index_ary</name></decl></parameter>,
						   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>serial_id_ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_tables</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>schema_oid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>id</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sequence_name</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Size</name></type> <name>number_indexes</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>schema_oid</name> <operator>=</operator> <call><name>get_namespace_oid</name><argument_list>(<argument><expr><name><name>table_ary</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>schema_name</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>get_relname_relid</name><argument_list>(<argument><expr><name><name>table_ary</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>table_name</name></expr></argument>, <argument><expr><name>schema_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				 <argument><expr><literal type="string">"OID lookup failed for table \"%s.%s\""</literal></expr></argument>,
				 <argument><expr><name><name>table_ary</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>schema_name</name></expr></argument>,
				 <argument><expr><name><name>table_ary</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>table_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>tables_info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>id</name> <operator>=</operator> <name>id</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>number_indexes</name> <operator>=</operator> <name><name>index_ary</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>length</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>number_indexes</name> <operator>&lt;=</operator> <name>_MAX_TABLE_INDEXES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>number_indexes</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>get_relname_relid</name><argument_list>(<argument><expr><name><name>index_ary</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>names</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>schema_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"OID lookup failed for table index \"%s\""</literal></expr></argument>, <argument><expr><name><name>index_ary</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>names</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>tables_info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>index_ids</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>id</name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><name><name>tables_info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name> <operator>=</operator> <name><name>table_ary</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>table_name</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tables_info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>schema_name</name> <operator>=</operator> <name><name>table_ary</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>schema_name</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>sequence_name</name> <operator>=</operator> <name><name>serial_id_ary</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>sequence_name</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>sequence</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>sequence</name> <operator>=</operator> <call><name>makeRangeVarFromNameList</name><argument_list>(<argument><expr><call><name>stringToQualifiedNameList</name><argument_list>(<argument><expr><name>sequence_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tables_info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>serial_relid</name> <operator>=</operator> <call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name>sequence</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tables_info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>serial_relid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>TSDLLEXPORT</name> <name>Catalog</name> <modifier>*</modifier></type>
<name>ts_catalog_get</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid database ID"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ts_extension_is_loaded</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"tried calling catalog_get when extension isn't loaded"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>s_catalog</name><operator>.</operator><name>initialized</name></name> <operator>||</operator> <operator>!</operator><call><name>IsTransactionState</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>&amp;</operator><name>s_catalog</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s_catalog</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Catalog</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_catalog_table_info_init</name><argument_list>(<argument><expr><name><name>s_catalog</name><operator>.</operator><name>tables</name></name></expr></argument>,
							   <argument><expr><name>_MAX_CATALOG_TABLES</name></expr></argument>,
							   <argument><expr><name>catalog_table_names</name></expr></argument>,
							   <argument><expr><name>catalog_table_index_definitions</name></expr></argument>,
							   <argument><expr><name>catalog_table_serial_id_names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>_TS_MAX_SCHEMA</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>s_catalog</name><operator>.</operator><name>extension_schema_id</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>get_namespace_oid</name><argument_list>(<argument><expr><name><name>ts_extension_schema_names</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>_MAX_CACHE_TYPES</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>s_catalog</name><operator>.</operator><name>caches</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>inval_proxy_id</name> <operator>=</operator>
			<call><name>get_relname_relid</name><argument_list>(<argument><expr><name><name>cache_proxy_table_names</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
							  <argument><expr><name><name>s_catalog</name><operator>.</operator><name>extension_schema_id</name><index>[<expr><name>TS_CACHE_SCHEMA</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>ts_cache_invalidate_set_proxy_tables</name><argument_list>(<argument><expr><name><name>s_catalog</name><operator>.</operator><name>caches</name><index>[<expr><name>CACHE_TYPE_HYPERTABLE</name></expr>]</index></name><operator>.</operator><name>inval_proxy_id</name></expr></argument>,
										 <argument><expr><name><name>s_catalog</name><operator>.</operator><name>caches</name><index>[<expr><name>CACHE_TYPE_BGW_JOB</name></expr>]</index></name><operator>.</operator><name>inval_proxy_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>_MAX_INTERNAL_FUNCTIONS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>InternalFunctionDef</name></type> <name>def</name> <init>= <expr><name><name>internal_function_definitions</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>FuncCandidateList</name></type> <name>funclist</name> <init>=
			<expr><call><name>FuncnameGetCandidates</name><argument_list>(<argument><expr><call><name>list_make2</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>INTERNAL_SCHEMA_NAME</name></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name><name>def</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name><name>def</name><operator>.</operator><name>args</name></name></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument>,
								  <argument><expr><name>false</name></expr></argument>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_GE</name></expr></cpp:if>
								  <argument><expr><name>false</name></expr></argument>, <comment type="block">/* include_out_arguments */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
								  <argument><expr><name>false</name></expr></argument>,
								  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>funclist</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>funclist</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				 <argument><expr><literal type="string">"OID lookup failed for the function \"%s\" with %d args"</literal></expr></argument>,
				 <argument><expr><name><name>def</name><operator>.</operator><name>name</name></name></expr></argument>,
				 <argument><expr><name><name>def</name><operator>.</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>s_catalog</name><operator>.</operator><name>functions</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>function_id</name> <operator>=</operator> <name><name>funclist</name><operator>-&gt;</operator><name>oid</name></name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>s_catalog</name><operator>.</operator><name>initialized</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<return>return <expr><operator>&amp;</operator><name>s_catalog</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ts_catalog_reset</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>s_catalog</name><operator>.</operator><name>initialized</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>database_info</name><operator>.</operator><name>database_id</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ts_cache_invalidate_set_proxy_tables</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>CatalogTable</name></type>
<name>catalog_get_table</name><parameter_list>(<parameter><decl><type><name>Catalog</name> <modifier>*</modifier></type><name>catalog</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>catalog_is_valid</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>schema_name</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relname</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>_MAX_CATALOG_TABLES</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>catalog_table_names</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>schema_name</name></expr></argument>, <argument><expr><name>schema_name</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
				<call><name>strcmp</name><argument_list>(<argument><expr><call><name>catalog_table_name</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>relname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><operator>(</operator><name>CatalogTable</name><operator>)</operator> <name>i</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>

		<return>return <expr><name>INVALID_CATALOG_TABLE</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>_MAX_CATALOG_TABLES</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><name><name>catalog</name><operator>-&gt;</operator><name>tables</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>id</name> <operator>==</operator> <name>relid</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>(</operator><name>CatalogTable</name><operator>)</operator> <name>i</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>

	<return>return <expr><name>INVALID_CATALOG_TABLE</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ts_is_catalog_table</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>catalog_get_table</name><argument_list>(<argument><expr><call><name>ts_catalog_get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>INVALID_CATALOG_TABLE</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get the next serial ID for a catalog table, if one exists for the given table.
 */</comment>
<function><type><name>TSDLLEXPORT</name> <name>int64</name></type>
<name>ts_catalog_table_next_seq_id</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Catalog</name> <modifier>*</modifier></type><name>catalog</name></decl></parameter>, <parameter><decl><type><name>CatalogTable</name></type> <name>table</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relid</name> <init>= <expr><name><name>catalog</name><operator>-&gt;</operator><name>tables</name><index>[<expr><name>table</name></expr>]</index></name><operator>.</operator><name>serial_relid</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			 <argument><expr><literal type="string">"no serial ID column for table \"%s.%s\""</literal></expr></argument>,
			 <argument><expr><name><name>catalog_table_names</name><index>[<expr><name>table</name></expr>]</index></name><operator>.</operator><name>schema_name</name></expr></argument>,
			 <argument><expr><call><name>catalog_table_name</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><call><name>DatumGetInt64</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>nextval_oid</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Oid</name></type>
<name>ts_catalog_get_cache_proxy_id</name><parameter_list>(<parameter><decl><type><name>Catalog</name> <modifier>*</modifier></type><name>catalog</name></decl></parameter>, <parameter><decl><type><name>CacheType</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>catalog_is_valid</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>schema</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * The catalog can be invalid during upgrade scripts. Try a non-cached
		 * relation lookup, but we need to be in a transaction for
		 * get_namespace_oid() to work.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsTransactionState</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>schema</name> <operator>=</operator> <call><name>get_namespace_oid</name><argument_list>(<argument><expr><name>CACHE_SCHEMA_NAME</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>schema</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></if></if_stmt>

		<return>return <expr><call><name>get_relname_relid</name><argument_list>(<argument><expr><name><name>cache_proxy_table_names</name><index>[<expr><name>type</name></expr>]</index></name></expr></argument>, <argument><expr><name>schema</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>catalog</name><operator>-&gt;</operator><name>caches</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>inval_proxy_id</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Become the user that owns the catalog schema.
 *
 * This might be necessary for users that do operations that require changes to
 * the catalog.
 *
 * The caller should pass a CatalogSecurityContext where the current security
 * context will be saved. The original security context can later be restored
 * with ts_catalog_restore_user().
 */</comment>
<function><type><name>TSDLLEXPORT</name> <name>bool</name></type>
<name>ts_catalog_database_info_become_owner</name><parameter_list>(<parameter><decl><type><name>CatalogDatabaseInfo</name> <modifier>*</modifier></type><name>database_info</name></decl></parameter>,
									  <parameter><decl><type><name>CatalogSecurityContext</name> <modifier>*</modifier></type><name>sec_ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>GetUserIdAndSecContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sec_ctx</name><operator>-&gt;</operator><name>saved_uid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>sec_ctx</name><operator>-&gt;</operator><name>saved_security_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>sec_ctx</name><operator>-&gt;</operator><name>saved_uid</name></name> <operator>!=</operator> <name><name>database_info</name><operator>-&gt;</operator><name>owner_uid</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SetUserIdAndSecContext</name><argument_list>(<argument><expr><name><name>database_info</name><operator>-&gt;</operator><name>owner_uid</name></name></expr></argument>,
							   <argument><expr><name><name>sec_ctx</name><operator>-&gt;</operator><name>saved_security_context</name></name> <operator>|</operator> <name>SECURITY_LOCAL_USERID_CHANGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Restore the security context of the original user after becoming the catalog
 * owner. The user should pass the original CatalogSecurityContext that was used
 * with ts_catalog_database_info_become_owner().
 */</comment>
<function><type><name>TSDLLEXPORT</name> <name>void</name></type>
<name>ts_catalog_restore_user</name><parameter_list>(<parameter><decl><type><name>CatalogSecurityContext</name> <modifier>*</modifier></type><name>sec_ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>SetUserIdAndSecContext</name><argument_list>(<argument><expr><name><name>sec_ctx</name><operator>-&gt;</operator><name>saved_uid</name></name></expr></argument>, <argument><expr><name><name>sec_ctx</name><operator>-&gt;</operator><name>saved_security_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Insert a new row into a catalog table.
 */</comment>
<function><type><name>void</name></type>
<name>ts_catalog_insert_only</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CatalogTupleInsert</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_catalog_invalidate_cache</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>CMD_INSERT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ts_catalog_insert</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ts_catalog_insert_only</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Make changes visible */</comment>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Insert a new row into a catalog table.
 */</comment>
<function><type><name>TSDLLEXPORT</name> <name>void</name></type>
<name>ts_catalog_insert_values</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name> <init>= <expr><call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ts_catalog_insert</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ts_catalog_update_tid_only</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>tid</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_catalog_invalidate_cache</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>CMD_UPDATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ts_catalog_update_tid</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>tid</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ts_catalog_update_tid_only</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Make changes visible */</comment>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>TSDLLEXPORT</name> <name>void</name></type>
<name>ts_catalog_update</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ts_catalog_update_tid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ts_catalog_delete_tid_only</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>tid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CatalogTupleDelete</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_catalog_invalidate_cache</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>CMD_DELETE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ts_catalog_delete_tid</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>tid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ts_catalog_delete_tid_only</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ts_catalog_delete_only</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ts_catalog_delete_tid_only</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ts_catalog_delete</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ts_catalog_delete_tid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Invalidate TimescaleDB catalog caches.
 *
 * This function should be called whenever a TimescaleDB catalog table changes
 * in a way that might invalidate associated caches. It is currently called in
 * two distinct ways:
 *
 * 1. If a catalog table changes via the catalog API in catalog.c
 * 2. Via a trigger if a SQL INSERT/UPDATE/DELETE occurs on a catalog table
 *
 * Since triggers (2) require full parsing, planning and execution of SQL
 * statements, they aren't supported for simple catalog updates via (1) in
 * native code and are therefore discouraged. Ideally, catalog updates should
 * happen consistently via method (1) in the future, obviating the need for
 * triggers on catalog tables that cause side effects.
 *
 * The invalidation event is signaled to other backends (processes) via the
 * relcache invalidation mechanism on a dummy relation (table).
 *
 * Parameters: The OID of the catalog table that changed, and the operation
 * involved (e.g., INSERT, UPDATE, DELETE).
 */</comment>
<function><type><name>void</name></type>
<name>ts_catalog_invalidate_cache</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>catalog_relid</name></decl></parameter>, <parameter><decl><type><name>CmdType</name></type> <name>operation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Catalog</name> <modifier>*</modifier></type><name>catalog</name> <init>= <expr><call><name>ts_catalog_get</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CatalogTable</name></type> <name>table</name> <init>= <expr><call><name>catalog_get_table</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>catalog_relid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relid</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>table</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>CHUNK</name></expr>:</case>
		<case>case <expr><name>CHUNK_CONSTRAINT</name></expr>:</case>
		<case>case <expr><name>CHUNK_DATA_NODE</name></expr>:</case>
		<case>case <expr><name>DIMENSION_SLICE</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>operation</name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>||</operator> <name>operation</name> <operator>==</operator> <name>CMD_DELETE</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>ts_catalog_get_cache_proxy_id</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>CACHE_TYPE_HYPERTABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>CacheInvalidateRelcacheByRelid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>HYPERTABLE</name></expr>:</case>
		<case>case <expr><name>HYPERTABLE_DATA_NODE</name></expr>:</case>
		<case>case <expr><name>DIMENSION</name></expr>:</case>
		<case>case <expr><name>DIMENSION_PARTITION</name></expr>:</case>
		<case>case <expr><name>CONTINUOUS_AGG</name></expr>:</case>
			<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>ts_catalog_get_cache_proxy_id</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>CACHE_TYPE_HYPERTABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CacheInvalidateRelcacheByRelid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>BGW_JOB</name></expr>:</case>
			<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>ts_catalog_get_cache_proxy_id</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>CACHE_TYPE_BGW_JOB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CacheInvalidateRelcacheByRelid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>CHUNK_INDEX</name></expr>:</case>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/* Scanner helper functions specifically for the catalog tables */</comment>
<function><type><name>TSDLLEXPORT</name> <name>bool</name></type>
<name>ts_catalog_scan_one</name><parameter_list>(<parameter><decl><type><name>CatalogTable</name></type> <name>table</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>indexid</name></decl></parameter>, <parameter><decl><type><name>ScanKeyData</name> <modifier>*</modifier></type><name>scankey</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>num_keys</name></decl></parameter>,
					<parameter><decl><type><name>tuple_found_func</name></type> <name>tuple_found</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>table_name</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Catalog</name> <modifier>*</modifier></type><name>catalog</name> <init>= <expr><call><name>ts_catalog_get</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ScannerCtx</name></type> <name>scanctx</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>table</name> <operator>=</operator> <call><name>catalog_get_table_id</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>index</name> <operator>=</operator> <call><name>catalog_get_index</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>table</name></expr></argument>, <argument><expr><name>indexid</name></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>nkeys</name> <operator>=</operator> <name>num_keys</name></expr>,
		<expr><operator>.</operator><name>scankey</name> <operator>=</operator> <name>scankey</name></expr>,
		<expr><operator>.</operator><name>tuple_found</name> <operator>=</operator> <name>tuple_found</name></expr>,
		<expr><operator>.</operator><name>data</name> <operator>=</operator> <name>data</name></expr>,
		<expr><operator>.</operator><name>lockmode</name> <operator>=</operator> <name>lockmode</name></expr>,
		<expr><operator>.</operator><name>scandirection</name> <operator>=</operator> <name>ForwardScanDirection</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>ts_scanner_scan_one</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scanctx</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>table_name</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>TSDLLEXPORT</name> <name>void</name></type>
<name>ts_catalog_scan_all</name><parameter_list>(<parameter><decl><type><name>CatalogTable</name></type> <name>table</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>indexid</name></decl></parameter>, <parameter><decl><type><name>ScanKeyData</name> <modifier>*</modifier></type><name>scankey</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>num_keys</name></decl></parameter>,
					<parameter><decl><type><name>tuple_found_func</name></type> <name>tuple_found</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Catalog</name> <modifier>*</modifier></type><name>catalog</name> <init>= <expr><call><name>ts_catalog_get</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ScannerCtx</name></type> <name>scanctx</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>table</name> <operator>=</operator> <call><name>catalog_get_table_id</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>index</name> <operator>=</operator> <call><name>catalog_get_index</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>table</name></expr></argument>, <argument><expr><name>indexid</name></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>nkeys</name> <operator>=</operator> <name>num_keys</name></expr>,
		<expr><operator>.</operator><name>scankey</name> <operator>=</operator> <name>scankey</name></expr>,
		<expr><operator>.</operator><name>tuple_found</name> <operator>=</operator> <name>tuple_found</name></expr>,
		<expr><operator>.</operator><name>data</name> <operator>=</operator> <name>data</name></expr>,
		<expr><operator>.</operator><name>lockmode</name> <operator>=</operator> <name>lockmode</name></expr>,
		<expr><operator>.</operator><name>scandirection</name> <operator>=</operator> <name>ForwardScanDirection</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ts_scanner_scan</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scanctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
