<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/timescaledb/src/scanner.c"><comment type="block">/*
 * This file and its contents are licensed under the Apache License 2.0.
 * Please see the included NOTICE for copyright information and
 * LICENSE-APACHE for a copy of the license.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postgres.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/relscan.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/xact.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/htup_details.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;executor/tuptable.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;storage/lmgr.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;storage/bufmgr.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;storage/procarray.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/rel.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/palloc.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/snapmgr.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"scanner.h"</cpp:file></cpp:include>

<enum>enum <name>ScannerType</name>
<block>{
	<decl><name>ScannerTypeTable</name></decl>,
	<decl><name>ScannerTypeIndex</name></decl>,
}</block>;</enum>

<comment type="block">/*
 * Scanner can implement both index and heap scans in a single interface.
 */</comment>
<typedef>typedef <type><struct>struct <name>Scanner</name>
<block>{
	<function_decl><type><name>Relation</name></type> (<modifier>*</modifier><name>openscan</name>)<parameter_list>(<parameter><decl><type><name>ScannerCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>;</function_decl>
	<function_decl><type><name>ScanDesc</name></type> (<modifier>*</modifier><name>beginscan</name>)<parameter_list>(<parameter><decl><type><name>ScannerCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>;</function_decl>
	<function_decl><type><name>bool</name></type> (<modifier>*</modifier><name>getnext</name>)<parameter_list>(<parameter><decl><type><name>ScannerCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>;</function_decl>
	<function_decl><type><name>void</name></type> (<modifier>*</modifier><name>rescan</name>)<parameter_list>(<parameter><decl><type><name>ScannerCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>;</function_decl>
	<function_decl><type><name>void</name></type> (<modifier>*</modifier><name>endscan</name>)<parameter_list>(<parameter><decl><type><name>ScannerCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>;</function_decl>
	<function_decl><type><name>void</name></type> (<modifier>*</modifier><name>closescan</name>)<parameter_list>(<parameter><decl><type><name>ScannerCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>;</function_decl>
}</block></struct></type> <name>Scanner</name>;</typedef>

<comment type="block">/* Functions implementing heap scans */</comment>
<function><type><specifier>static</specifier> <name>Relation</name></type>
<name>table_scanner_open</name><parameter_list>(<parameter><decl><type><name>ScannerCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>tablerel</name></name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>table</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>lockmode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>ctx</name><operator>-&gt;</operator><name>tablerel</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ScanDesc</name></type>
<name>table_scanner_beginscan</name><parameter_list>(<parameter><decl><type><name>ScannerCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>internal</name><operator>.</operator><name>scan</name><operator>.</operator><name>table_scan</name></name> <operator>=</operator>
		<call><name>table_beginscan</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>tablerel</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>snapshot</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>nkeys</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>scankey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>ctx</name><operator>-&gt;</operator><name>internal</name><operator>.</operator><name>scan</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>table_scanner_getnext</name><parameter_list>(<parameter><decl><type><name>ScannerCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>success</name> <init>= <expr><call><name>table_scan_getnextslot</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>internal</name><operator>.</operator><name>scan</name><operator>.</operator><name>table_scan</name></name></expr></argument>,
										  <argument><expr><name>ForwardScanDirection</name></expr></argument>,
										  <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>internal</name><operator>.</operator><name>tinfo</name><operator>.</operator><name>slot</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>success</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>table_scanner_rescan</name><parameter_list>(<parameter><decl><type><name>ScannerCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>table_rescan</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>internal</name><operator>.</operator><name>scan</name><operator>.</operator><name>table_scan</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>scankey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>table_scanner_endscan</name><parameter_list>(<parameter><decl><type><name>ScannerCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>table_endscan</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>internal</name><operator>.</operator><name>scan</name><operator>.</operator><name>table_scan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>table_scanner_close</name><parameter_list>(<parameter><decl><type><name>ScannerCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKMODE</name></type> <name>lockmode</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SCANNER_F_KEEPLOCK</name><operator>)</operator></expr> ?</condition><then> <expr><name>NoLock</name></expr> </then><else>: <expr><name><name>ctx</name><operator>-&gt;</operator><name>lockmode</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>tablerel</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Functions implementing index scans */</comment>
<function><type><specifier>static</specifier> <name>Relation</name></type>
<name>index_scanner_open</name><parameter_list>(<parameter><decl><type><name>ScannerCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>tablerel</name></name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>table</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>lockmode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>indexrel</name></name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>lockmode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>ctx</name><operator>-&gt;</operator><name>indexrel</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ScanDesc</name></type>
<name>index_scanner_beginscan</name><parameter_list>(<parameter><decl><type><name>ScannerCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>InternalScannerCtx</name> <modifier>*</modifier></type><name>ictx</name> <init>= <expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>internal</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>ictx</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>index_scan</name></name> <operator>=</operator>
		<call><name>index_beginscan</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>tablerel</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>indexrel</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>snapshot</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>nkeys</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>norderbys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ictx</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>index_scan</name><operator>-&gt;</operator><name>xs_want_itup</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>want_itup</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>index_rescan</name><argument_list>(<argument><expr><name><name>ictx</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>index_scan</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>scankey</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>nkeys</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>norderbys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>ictx</name><operator>-&gt;</operator><name>scan</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>index_scanner_getnext</name><parameter_list>(<parameter><decl><type><name>ScannerCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>InternalScannerCtx</name> <modifier>*</modifier></type><name>ictx</name> <init>= <expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>internal</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>success</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>index_getnext_slot</name><argument_list>(<argument><expr><name><name>ictx</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>index_scan</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>scandirection</name></name></expr></argument>, <argument><expr><name><name>ictx</name><operator>-&gt;</operator><name>tinfo</name><operator>.</operator><name>slot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ictx</name><operator>-&gt;</operator><name>tinfo</name><operator>.</operator><name>ituple</name></name> <operator>=</operator> <name><name>ictx</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>index_scan</name><operator>-&gt;</operator><name>xs_itup</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ictx</name><operator>-&gt;</operator><name>tinfo</name><operator>.</operator><name>ituple_desc</name></name> <operator>=</operator> <name><name>ictx</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>index_scan</name><operator>-&gt;</operator><name>xs_itupdesc</name></name></expr>;</expr_stmt>

	<return>return <expr><name>success</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>index_scanner_rescan</name><parameter_list>(<parameter><decl><type><name>ScannerCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>index_rescan</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>internal</name><operator>.</operator><name>scan</name><operator>.</operator><name>index_scan</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>scankey</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>nkeys</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>norderbys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>index_scanner_endscan</name><parameter_list>(<parameter><decl><type><name>ScannerCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>index_endscan</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>internal</name><operator>.</operator><name>scan</name><operator>.</operator><name>index_scan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>index_scanner_close</name><parameter_list>(<parameter><decl><type><name>ScannerCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKMODE</name></type> <name>lockmode</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SCANNER_F_KEEPLOCK</name><operator>)</operator></expr> ?</condition><then> <expr><name>NoLock</name></expr> </then><else>: <expr><name><name>ctx</name><operator>-&gt;</operator><name>lockmode</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>indexrel</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>lockmode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>tablerel</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Two scanners by type: heap and index scanners.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>Scanner</name></type> <name><name>scanners</name><index>[]</index></name> <init>= <expr><block>{
	<expr><index>[<expr><name>ScannerTypeTable</name></expr>]</index> <operator>=</operator> <block>{
		<expr><operator>.</operator><name>openscan</name> <operator>=</operator> <name>table_scanner_open</name></expr>,
		<expr><operator>.</operator><name>beginscan</name> <operator>=</operator> <name>table_scanner_beginscan</name></expr>,
		<expr><operator>.</operator><name>getnext</name> <operator>=</operator> <name>table_scanner_getnext</name></expr>,
		<expr><operator>.</operator><name>rescan</name> <operator>=</operator> <name>table_scanner_rescan</name></expr>,
		<expr><operator>.</operator><name>endscan</name> <operator>=</operator> <name>table_scanner_endscan</name></expr>,
		<expr><operator>.</operator><name>closescan</name> <operator>=</operator> <name>table_scanner_close</name></expr>,
	}</block></expr>,
	<expr><index>[<expr><name>ScannerTypeIndex</name></expr>]</index> <operator>=</operator> <block>{
		<expr><operator>.</operator><name>openscan</name> <operator>=</operator> <name>index_scanner_open</name></expr>,
		<expr><operator>.</operator><name>beginscan</name> <operator>=</operator> <name>index_scanner_beginscan</name></expr>,
		<expr><operator>.</operator><name>getnext</name> <operator>=</operator> <name>index_scanner_getnext</name></expr>,
		<expr><operator>.</operator><name>rescan</name> <operator>=</operator> <name>index_scanner_rescan</name></expr>,
		<expr><operator>.</operator><name>endscan</name> <operator>=</operator> <name>index_scanner_endscan</name></expr>,
		<expr><operator>.</operator><name>closescan</name> <operator>=</operator> <name>index_scanner_close</name></expr>,
	}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>Scanner</name> <modifier>*</modifier></type>
<name>scanner_ctx_get_scanner</name><parameter_list>(<parameter><decl><type><name>ScannerCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>&amp;</operator><name><name>scanners</name><index>[<expr><name>ScannerTypeIndex</name></expr>]</index></name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><operator>&amp;</operator><name><name>scanners</name><index>[<expr><name>ScannerTypeTable</name></expr>]</index></name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>TSDLLEXPORT</name> <name>void</name></type>
<name>ts_scanner_rescan</name><parameter_list>(<parameter><decl><type><name>ScannerCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ScanKey</name></type> <name>scankey</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Scanner</name> <modifier>*</modifier></type><name>scanner</name> <init>= <expr><call><name>scanner_ctx_get_scanner</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldmcxt</name></decl>;</decl_stmt>

	<comment type="block">/* If scankey is NULL, the existing scan key was already updated or the
	 * old should be reused */</comment>
	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>scankey</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>scankey</name></name></expr></argument>, <argument><expr><name>scankey</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>ctx</name><operator>-&gt;</operator><name>scankey</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>oldmcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>internal</name><operator>.</operator><name>scan_mcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name><name>scanner</name><operator>-&gt;</operator><name>rescan</name></name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldmcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>prepare_scan</name><parameter_list>(<parameter><decl><type><name>ScannerCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>internal</name><operator>.</operator><name>ended</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>internal</name><operator>.</operator><name>registered_snapshot</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>internal</name><operator>.</operator><name>scan_mcxt</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>internal</name><operator>.</operator><name>scan_mcxt</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>snapshot</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We use SnapshotSelf by default, for historical reasons mostly, but
		 * we probably want to move to an MVCC snapshot as the default. The
		 * difference is that a Self snapshot is an "instant" snapshot and can
		 * see its own changes. More importantly, however, unlike an MVCC
		 * snapshot, a Self snapshot is not subject to the strictness of
		 * SERIALIZABLE isolation mode.
		 *
		 * This is important in case of, e.g., concurrent chunk creation by
		 * two transactions; we'd like a transaction to use a new chunk as
		 * soon as the creating transaction commits, so that there aren't
		 * multiple transactions creating the same chunk and all but one fails
		 * with a conflict. However, under SERIALIZABLE mode a transaction is
		 * only allowed to read data from transactions that were committed
		 * prior to transaction start. This means that two or more
		 * transactions that create the same chunk must have all but the first
		 * committed transaction fail.
		 *
		 * Therefore, we probably want to exempt internal bookkeeping metadata
		 * from full SERIALIZABLE semantics (at least in the case of chunk
		 * creation), or otherwise the INSERT behavior will be different for
		 * hypertables compared to regular tables under SERIALIZABLE
		 * mode.
		 */</comment>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldmcxt</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>internal</name><operator>.</operator><name>scan_mcxt</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>snapshot</name></name> <operator>=</operator> <call><name>RegisterSnapshot</name><argument_list>(<argument><expr><call><name>GetSnapshotData</name><argument_list>(<argument><expr><name>SnapshotSelf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>internal</name><operator>.</operator><name>registered_snapshot</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldmcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>TSDLLEXPORT</name> <name>Relation</name></type>
<name>ts_scanner_open</name><parameter_list>(<parameter><decl><type><name>ScannerCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Scanner</name> <modifier>*</modifier></type><name>scanner</name> <init>= <expr><call><name>scanner_ctx_get_scanner</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldmcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>==</operator> <name><name>ctx</name><operator>-&gt;</operator><name>tablerel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>prepare_scan</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>internal</name><operator>.</operator><name>scan_mcxt</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldmcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>internal</name><operator>.</operator><name>scan_mcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name><name>scanner</name><operator>-&gt;</operator><name>openscan</name></name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldmcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>rel</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Start either a heap or index scan depending on the information in the
 * ScannerCtx. ScannerCtx must be setup by caller with the proper information
 * for the scan, including filters and callbacks for found tuples.
 */</comment>
<function><type><name>TSDLLEXPORT</name> <name>void</name></type>
<name>ts_scanner_start_scan</name><parameter_list>(<parameter><decl><type><name>ScannerCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>InternalScannerCtx</name> <modifier>*</modifier></type><name>ictx</name> <init>= <expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>internal</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Scanner</name> <modifier>*</modifier></type><name>scanner</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tuple_desc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldmcxt</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ictx</name><operator>-&gt;</operator><name>started</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>ictx</name><operator>-&gt;</operator><name>ended</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>tablerel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>table</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>tablerel</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>==</operator> <name><name>ctx</name><operator>-&gt;</operator><name>indexrel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ts_scanner_open</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Relations already opened by caller: Only need to prepare the scan
		 * and set relation Oids so that the scanner knows which scanner
		 * implementation to use. Respect the auto-closing behavior set by the
		 * user, which is to auto close if unspecified.
		 */</comment>
		<expr_stmt><expr><call><name>prepare_scan</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>table</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>tablerel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>indexrel</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>indexrel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>internal</name><operator>.</operator><name>scan_mcxt</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldmcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>internal</name><operator>.</operator><name>scan_mcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>scanner</name> <operator>=</operator> <call><name>scanner_ctx_get_scanner</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name><name>scanner</name><operator>-&gt;</operator><name>beginscan</name></name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple_desc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>tablerel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ictx</name><operator>-&gt;</operator><name>tinfo</name><operator>.</operator><name>scanrel</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>tablerel</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ictx</name><operator>-&gt;</operator><name>tinfo</name><operator>.</operator><name>mctx</name></name> <operator>=</operator> <ternary><condition><expr><name><name>ctx</name><operator>-&gt;</operator><name>result_mctx</name></name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><name>CurrentMemoryContext</name></expr> </then><else>: <expr><name><name>ctx</name><operator>-&gt;</operator><name>result_mctx</name></name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ictx</name><operator>-&gt;</operator><name>tinfo</name><operator>.</operator><name>slot</name></name> <operator>=</operator> <call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><name>tuple_desc</name></expr></argument>, <argument><expr><call><name>table_slot_callbacks</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>tablerel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldmcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Call pre-scan handler, if any. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>prescan</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name><name>ctx</name><operator>-&gt;</operator><name>prescan</name></name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>ictx</name><operator>-&gt;</operator><name>started</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>ts_scanner_limit_reached</name><parameter_list>(<parameter><decl><type><name>ScannerCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>ctx</name><operator>-&gt;</operator><name>limit</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>internal</name><operator>.</operator><name>tinfo</name><operator>.</operator><name>count</name></name> <operator>&gt;=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>limit</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>scanner_cleanup</name><parameter_list>(<parameter><decl><type><name>ScannerCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>InternalScannerCtx</name> <modifier>*</modifier></type><name>ictx</name> <init>= <expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>internal</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ictx</name><operator>-&gt;</operator><name>registered_snapshot</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>UnregisterSnapshot</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>snapshot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>ictx</name><operator>-&gt;</operator><name>tinfo</name><operator>.</operator><name>slot</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name><name>ictx</name><operator>-&gt;</operator><name>tinfo</name><operator>.</operator><name>slot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ictx</name><operator>-&gt;</operator><name>tinfo</name><operator>.</operator><name>slot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>ictx</name><operator>-&gt;</operator><name>scan_mcxt</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>ictx</name><operator>-&gt;</operator><name>scan_mcxt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>TSDLLEXPORT</name> <name>void</name></type>
<name>ts_scanner_end_scan</name><parameter_list>(<parameter><decl><type><name>ScannerCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>InternalScannerCtx</name> <modifier>*</modifier></type><name>ictx</name> <init>= <expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>internal</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Scanner</name> <modifier>*</modifier></type><name>scanner</name> <init>= <expr><call><name>scanner_ctx_get_scanner</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldmcxt</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ictx</name><operator>-&gt;</operator><name>ended</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Call post-scan handler, if any. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>postscan</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name><name>ctx</name><operator>-&gt;</operator><name>postscan</name></name><argument_list>(<argument><expr><name><name>ictx</name><operator>-&gt;</operator><name>tinfo</name><operator>.</operator><name>count</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>oldmcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>internal</name><operator>.</operator><name>scan_mcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name><name>scanner</name><operator>-&gt;</operator><name>endscan</name></name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldmcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>scanner_cleanup</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ictx</name><operator>-&gt;</operator><name>ended</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ictx</name><operator>-&gt;</operator><name>started</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>TSDLLEXPORT</name> <name>void</name></type>
<name>ts_scanner_close</name><parameter_list>(<parameter><decl><type><name>ScannerCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Scanner</name> <modifier>*</modifier></type><name>scanner</name> <init>= <expr><call><name>scanner_ctx_get_scanner</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>internal</name><operator>.</operator><name>ended</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>tablerel</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name><name>scanner</name><operator>-&gt;</operator><name>closescan</name></name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>tablerel</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>indexrel</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>TSDLLEXPORT</name> <name>TupleInfo</name> <modifier>*</modifier></type>
<name>ts_scanner_next</name><parameter_list>(<parameter><decl><type><name>ScannerCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>InternalScannerCtx</name> <modifier>*</modifier></type><name>ictx</name> <init>= <expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>internal</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Scanner</name> <modifier>*</modifier></type><name>scanner</name> <init>= <expr><call><name>scanner_ctx_get_scanner</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>is_valid</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ts_scanner_limit_reached</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldmcxt</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>internal</name><operator>.</operator><name>scan_mcxt</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>is_valid</name> <operator>=</operator> <call><name><name>scanner</name><operator>-&gt;</operator><name>getnext</name></name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldmcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<while>while <condition>(<expr><name>is_valid</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>filter</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name><name>ctx</name><operator>-&gt;</operator><name>filter</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ictx</name><operator>-&gt;</operator><name>tinfo</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>SCAN_INCLUDE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>ictx</name><operator>-&gt;</operator><name>tinfo</name><operator>.</operator><name>count</name></name><operator>++</operator></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>tuplock</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><name><name>ictx</name><operator>-&gt;</operator><name>tinfo</name><operator>.</operator><name>slot</name></name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>ictx</name><operator>-&gt;</operator><name>tinfo</name><operator>.</operator><name>lockresult</name></name> <operator>=</operator> <call><name>table_tuple_lock</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>tablerel</name></name></expr></argument>,
														  <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>slot</name><operator>-&gt;</operator><name>tts_tid</name></name><operator>)</operator></expr></argument>,
														  <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>snapshot</name></name></expr></argument>,
														  <argument><expr><name>slot</name></expr></argument>,
														  <argument><expr><call><name>GetCurrentCommandId</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>,
														  <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>tuplock</name><operator>-&gt;</operator><name>lockmode</name></name></expr></argument>,
														  <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>tuplock</name><operator>-&gt;</operator><name>waitpolicy</name></name></expr></argument>,
														  <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>tuplock</name><operator>-&gt;</operator><name>lockflags</name></name></expr></argument>,
														  <argument><expr><operator>&amp;</operator><name><name>ictx</name><operator>-&gt;</operator><name>tinfo</name><operator>.</operator><name>lockfd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* stop at a valid tuple */</comment>
			<return>return <expr><operator>&amp;</operator><name><name>ictx</name><operator>-&gt;</operator><name>tinfo</name></name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>ts_scanner_limit_reached</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>is_valid</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldmcxt</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>internal</name><operator>.</operator><name>scan_mcxt</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>is_valid</name> <operator>=</operator> <call><name><name>scanner</name><operator>-&gt;</operator><name>getnext</name></name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldmcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SCANNER_F_NOEND</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ts_scanner_end_scan</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SCANNER_F_NOEND_AND_NOCLOSE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ts_scanner_close</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Perform either a heap or index scan depending on the information in the
 * ScannerCtx. ScannerCtx must be setup by caller with the proper information
 * for the scan, including filters and callbacks for found tuples.
 *
 * Return the number of tuples that were found.
 */</comment>
<function><type><name>TSDLLEXPORT</name> <name>int</name></type>
<name>ts_scanner_scan</name><parameter_list>(<parameter><decl><type><name>ScannerCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleInfo</name> <modifier>*</modifier></type><name>tinfo</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>internal</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>internal</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><call><name>ts_scanner_start_scan</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><operator>(</operator><name>tinfo</name> <operator>=</operator> <call><name>ts_scanner_next</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</condition><incr/>)</control>
	<block>{<block_content>
		<comment type="block">/* Call tuple_found handler. Abort the scan if the handler wants us to */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>tuple_found</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name><name>ctx</name><operator>-&gt;</operator><name>tuple_found</name></name><argument_list>(<argument><expr><name>tinfo</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>SCAN_DONE</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SCANNER_F_NOEND</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ts_scanner_end_scan</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SCANNER_F_NOEND_AND_NOCLOSE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ts_scanner_close</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name><name>ctx</name><operator>-&gt;</operator><name>internal</name><operator>.</operator><name>tinfo</name><operator>.</operator><name>count</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>TSDLLEXPORT</name> <name>bool</name></type>
<name>ts_scanner_scan_one</name><parameter_list>(<parameter><decl><type><name>ScannerCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>fail_if_not_found</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>item_type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>num_found</name> <init>= <expr><call><name>ts_scanner_scan</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>limit</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name>num_found</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><literal type="number">0</literal></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>fail_if_not_found</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"%s not found"</literal></expr></argument>, <argument><expr><name>item_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		<case>case <expr><literal type="number">1</literal></expr>:</case>
			<return>return <expr><name>true</name></expr>;</return>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"more than one %s found"</literal></expr></argument>, <argument><expr><name>item_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>ItemPointer</name></type>
<name>ts_scanner_get_tuple_tid</name><parameter_list>(<parameter><decl><type><name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>&amp;</operator><name><name>ti</name><operator>-&gt;</operator><name>slot</name><operator>-&gt;</operator><name>tts_tid</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>HeapTuple</name></type>
<name>ts_scanner_fetch_heap_tuple</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>materialize</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>should_free</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>ExecFetchSlotHeapTuple</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>slot</name></name></expr></argument>, <argument><expr><name>materialize</name></expr></argument>, <argument><expr><name>should_free</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>TupleDesc</name></type>
<name>ts_scanner_get_tupledesc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>ti</name><operator>-&gt;</operator><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type>
<name>ts_scanner_alloc_result</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>mctx</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
