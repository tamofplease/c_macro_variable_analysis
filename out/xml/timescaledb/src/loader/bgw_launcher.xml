<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/timescaledb/src/loader/bgw_launcher.c"><comment type="block">/*
 * This file and its contents are licensed under the Apache License 2.0.
 * Please see the included NOTICE for copyright information and
 * LICENSE-APACHE for a copy of the license.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postgres.h&gt;</cpp:file></cpp:include>

<comment type="block">/* BGW includes below */</comment>
<comment type="block">/* These are always necessary for a bgworker */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;miscadmin.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postmaster/bgworker.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;storage/ipc.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;storage/latch.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;storage/lwlock.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;storage/proc.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;storage/shmem.h&gt;</cpp:file></cpp:include>

<comment type="block">/* for setting our wait event during waitlatch*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pgstat.h&gt;</cpp:file></cpp:include>

<comment type="block">/* needed for getting database list*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/heapam.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/htup_details.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_database.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/snapmgr.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/xact.h&gt;</cpp:file></cpp:include>

<comment type="block">/* and checking db list for whether we're in a template*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/syscache.h&gt;</cpp:file></cpp:include>

<comment type="block">/* for calling external function*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fmgr.h&gt;</cpp:file></cpp:include>

<comment type="block">/* for signal handling (specifically die() function) */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;tcop/tcopprot.h&gt;</cpp:file></cpp:include>

<comment type="block">/* for looking up sending proc information for message handling */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;storage/procarray.h&gt;</cpp:file></cpp:include>

<comment type="block">/* for allocating the htab storage */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/memutils.h&gt;</cpp:file></cpp:include>

<comment type="block">/* for getting settings correct before loading the versioned scheduler */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_db_role_setting.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../compat/compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../extension_constants.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"loader.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"bgw_counter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"bgw_message_queue.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"bgw_launcher.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BGW_DB_SCHEDULER_FUNCNAME</name></cpp:macro> <cpp:value>"ts_bgw_scheduler_main"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BGW_ENTRYPOINT_FUNCNAME</name></cpp:macro> <cpp:value>"ts_bgw_db_scheduler_entrypoint"</cpp:value></cpp:define>

<typedef>typedef <type><enum>enum <name>AckResult</name>
<block>{
	<decl><name>ACK_FAILURE</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
	<decl><name>ACK_SUCCESS</name></decl>,
}</block></enum></type> <name>AckResult</name>;</typedef>

<comment type="block">/* See state machine in README.md */</comment>
<typedef>typedef <type><enum>enum <name>SchedulerState</name>
<block>{
	<comment type="block">/* Scheduler should be started but has not been allocated or started */</comment>
	<decl><name>ENABLED</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
	<comment type="block">/* The scheduler has been allocated a spot in timescaleDB's worker counter */</comment>
	<decl><name>ALLOCATED</name></decl>,
	<comment type="block">/* Scheduler has been started */</comment>
	<decl><name>STARTED</name></decl>,

	<comment type="block">/*
	 * Scheduler is stopped and should not be started automatically. START and
	 * RESTART messages can re-enable the scheduler.
	 */</comment>
	<decl><name>DISABLED</name></decl>
}</block></enum></type> <name>SchedulerState</name>;</typedef>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TS_DEBUG</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BGW_LAUNCHER_RESTART_TIME_S</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BGW_LAUNCHER_RESTART_TIME_S</name></cpp:macro> <cpp:value>60</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>sig_atomic_t</name></type> <name>got_SIGHUP</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>launcher_sighup</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* based on av_sighup_handler */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>got_SIGHUP</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Main bgw launcher for the cluster.
 *
 * Run through the TimescaleDB loader, so needs to have a small footprint as
 * any interactions it has will need to remain backwards compatible for the
 * foreseeable future.
 *
 * Notes: multiple databases in an instance (PG cluster) can have TimescaleDB
 * installed. They are not necessarily the same version of TimescaleDB (though
 * they could be) Shared memory is allocated and background workers are
 * registered at shared_preload_libraries time We do not know what databases
 * exist, nor which databases TimescaleDB is installed in (if any) at
 * shared_preload_libraries time.
 */</comment>

<expr_stmt><expr><call><name>TS_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>ts_bgw_cluster_launcher_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TS_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>ts_bgw_db_scheduler_entrypoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<typedef>typedef <type><struct>struct <name>DbHashEntry</name>
<block>{
	<decl_stmt><decl><type><name>Oid</name></type> <name>db_oid</name></decl>;</decl_stmt>									 <comment type="block">/* key for the hash table, must be first */</comment>
	<decl_stmt><decl><type><name>BackgroundWorkerHandle</name> <modifier>*</modifier></type><name>db_scheduler_handle</name></decl>;</decl_stmt> <comment type="block">/* needed to shut down
												  * properly */</comment>
	<decl_stmt><decl><type><name>SchedulerState</name></type> <name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VirtualTransactionId</name></type> <name>vxid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>state_transition_failures</name></decl>;</decl_stmt>
}</block></struct></type> <name>DbHashEntry</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>scheduler_state_trans_enabled_to_allocated</name><parameter_list>(<parameter><decl><type><name>DbHashEntry</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>bgw_on_postmaster_death</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>on_exit_reset</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="block">/* don't call exit hooks cause we want to bail
					  * out quickly */</comment>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ADMIN_SHUTDOWN</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"postmaster exited while TimescaleDB background worker launcher was working"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>report_bgw_limit_exceeded</name><parameter_list>(<parameter><decl><type><name>DbHashEntry</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>state_transition_failures</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIGURATION_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"TimescaleDB background worker limit of %d exceeded"</literal></expr></argument>,
						<argument><expr><name>ts_guc_max_background_workers</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Consider increasing timescaledb.max_background_workers."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>state_transition_failures</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>report_error_on_worker_register_failure</name><parameter_list>(<parameter><decl><type><name>DbHashEntry</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>state_transition_failures</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_RESOURCES</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no available background worker slots"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Consider increasing max_worker_processes in tandem with "</literal>
						 <literal type="string">"timescaledb.max_background_workers."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>state_transition_failures</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Aliasing a few things in bgworker.h so that we exit correctly on postmaster
 * death so we don't have to duplicate code basically telling it we shouldn't
 * call exit hooks cause we want to bail out quickly - similar to how the
 * quickdie function works when we receive a sigquit. This should work
 * similarly because postmaster death is a similar severity of issue.
 * Additionally, we're wrapping these calls to make sure we never have a NULL
 * handle, if we have a null handle, we return normal things.
 */</comment>
<function><type><specifier>static</specifier> <name>BgwHandleStatus</name></type>
<name>get_background_worker_pid</name><parameter_list>(<parameter><decl><type><name>BackgroundWorkerHandle</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>, <parameter><decl><type><name>pid_t</name> <modifier>*</modifier></type><name>pidp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BgwHandleStatus</name></type> <name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pid_t</name></type> <name>pid</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>handle</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>status</name> <operator>=</operator> <name>BGWH_STOPPED</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>GetBackgroundWorkerPid</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>pidp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>pidp</name> <operator>=</operator> <name>pid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>BGWH_POSTMASTER_DIED</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>bgw_on_postmaster_death</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>wait_for_background_worker_startup</name><parameter_list>(<parameter><decl><type><name>BackgroundWorkerHandle</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>, <parameter><decl><type><name>pid_t</name> <modifier>*</modifier></type><name>pidp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BgwHandleStatus</name></type> <name>status</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>handle</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>status</name> <operator>=</operator> <name>BGWH_STOPPED</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>WaitForBackgroundWorkerStartup</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>pidp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * We don't care whether we get BGWH_STOPPED or BGWH_STARTED here, because
	 * the worker could have started and stopped very quickly before we read
	 * it. We can't get BGWH_NOT_YET_STARTED as that's what we're waiting for.
	 * We do care if the Postmaster died however.
	 */</comment>

	<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>BGWH_POSTMASTER_DIED</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>bgw_on_postmaster_death</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>status</name> <operator>==</operator> <name>BGWH_STOPPED</name> <operator>||</operator> <name>status</name> <operator>==</operator> <name>BGWH_STARTED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>wait_for_background_worker_shutdown</name><parameter_list>(<parameter><decl><type><name>BackgroundWorkerHandle</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BgwHandleStatus</name></type> <name>status</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>handle</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>status</name> <operator>=</operator> <name>BGWH_STOPPED</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>WaitForBackgroundWorkerShutdown</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* We can only ever get BGWH_STOPPED stopped unless the Postmaster died. */</comment>
	<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>BGWH_POSTMASTER_DIED</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>bgw_on_postmaster_death</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>status</name> <operator>==</operator> <name>BGWH_STOPPED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>terminate_background_worker</name><parameter_list>(<parameter><decl><type><name>BackgroundWorkerHandle</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>handle</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>TerminateBackgroundWorker</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>extern</specifier> <name>void</name></type>
<name>ts_bgw_cluster_launcher_register</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BackgroundWorker</name></type> <name>worker</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>worker</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>worker</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* set up worker settings for our main worker */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>worker</name><operator>.</operator><name>bgw_name</name></name></expr></argument>, <argument><expr><name>BGW_MAXLEN</name></expr></argument>, <argument><expr><literal type="string">"TimescaleDB Background Worker Launcher"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>worker</name><operator>.</operator><name>bgw_flags</name></name> <operator>=</operator> <name>BGWORKER_SHMEM_ACCESS</name> <operator>|</operator> <name>BGWORKER_BACKEND_DATABASE_CONNECTION</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>worker</name><operator>.</operator><name>bgw_restart_time</name></name> <operator>=</operator> <name>BGW_LAUNCHER_RESTART_TIME_S</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Starting at BgWorkerStart_RecoveryFinished means we won't ever get
	 * started on a hot_standby see
	 * https://www.postgresql.org/docs/10/static/bgworker.html as it's not
	 * documented in bgworker.c.
	 */</comment>
	<expr_stmt><expr><name><name>worker</name><operator>.</operator><name>bgw_start_time</name></name> <operator>=</operator> <name>BgWorkerStart_RecoveryFinished</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>worker</name><operator>.</operator><name>bgw_notify_pid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>worker</name><operator>.</operator><name>bgw_library_name</name></name></expr></argument>, <argument><expr><name>BGW_MAXLEN</name></expr></argument>, <argument><expr><name>EXTENSION_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>worker</name><operator>.</operator><name>bgw_function_name</name></name></expr></argument>, <argument><expr><name>BGW_MAXLEN</name></expr></argument>, <argument><expr><literal type="string">"ts_bgw_cluster_launcher_main"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RegisterBackgroundWorker</name><argument_list>(<argument><expr><operator>&amp;</operator><name>worker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Register a background worker that calls the main TimescaleDB background
 * worker launcher library (i.e. loader) and uses the scheduler entrypoint
 * function.  The scheduler entrypoint will deal with starting a new worker,
 * and waiting on any txns that it needs to, if we pass along a vxid in the
 * bgw_extra field of the BgWorker.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>register_entrypoint_for_db</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>db_id</name></decl></parameter>, <parameter><decl><type><name>VirtualTransactionId</name></type> <name>vxid</name></decl></parameter>, <parameter><decl><type><name>BackgroundWorkerHandle</name> <modifier>*</modifier><modifier>*</modifier></type><name>handle</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BackgroundWorker</name></type> <name>worker</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>worker</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>worker</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>worker</name><operator>.</operator><name>bgw_name</name></name></expr></argument>, <argument><expr><name>BGW_MAXLEN</name></expr></argument>, <argument><expr><literal type="string">"TimescaleDB Background Worker Scheduler"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>worker</name><operator>.</operator><name>bgw_flags</name></name> <operator>=</operator> <name>BGWORKER_SHMEM_ACCESS</name> <operator>|</operator> <name>BGWORKER_BACKEND_DATABASE_CONNECTION</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>worker</name><operator>.</operator><name>bgw_restart_time</name></name> <operator>=</operator> <name>BGW_NEVER_RESTART</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>worker</name><operator>.</operator><name>bgw_start_time</name></name> <operator>=</operator> <name>BgWorkerStart_RecoveryFinished</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>worker</name><operator>.</operator><name>bgw_library_name</name></name></expr></argument>, <argument><expr><name>BGW_MAXLEN</name></expr></argument>, <argument><expr><name>EXTENSION_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>worker</name><operator>.</operator><name>bgw_function_name</name></name></expr></argument>, <argument><expr><name>BGW_MAXLEN</name></expr></argument>, <argument><expr><name>BGW_ENTRYPOINT_FUNCNAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>worker</name><operator>.</operator><name>bgw_notify_pid</name></name> <operator>=</operator> <name>MyProcPid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>worker</name><operator>.</operator><name>bgw_main_arg</name></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>db_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>worker</name><operator>.</operator><name>bgw_extra</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vxid</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>VirtualTransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>RegisterDynamicBackgroundWorker</name><argument_list>(<argument><expr><operator>&amp;</operator><name>worker</name></expr></argument>, <argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Initializes the launcher's hash table of schedulers.
 * Return value is guaranteed to be not-null, because otherwise the function
 * will have thrown an error.
 */</comment>
<function><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type>
<name>init_database_htab</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASHCTL</name></type> <name>info</name> <init>= <expr><block>{ <expr><operator>.</operator><name>keysize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>,
					 <expr><operator>.</operator><name>entrysize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DbHashEntry</name></expr></argument>)</argument_list></sizeof></expr>,
					 <expr><operator>.</operator><name>hcxt</name> <operator>=</operator> <name>TopMemoryContext</name></expr> }</block></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"launcher_db_htab"</literal></expr></argument>,
					   <argument><expr><name>ts_guc_max_background_workers</name></expr></argument>,
					   <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>,
					   <argument><expr><name>HASH_BLOBS</name> <operator>|</operator> <name>HASH_CONTEXT</name> <operator>|</operator> <name>HASH_ELEM</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Insert a scheduler entry into the hash table. Correctly set entry values. */</comment>
<function><type><specifier>static</specifier> <name>DbHashEntry</name> <modifier>*</modifier></type>
<name>db_hash_entry_create_if_not_exists</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>db_htab</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>db_oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DbHashEntry</name> <modifier>*</modifier></type><name>db_he</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>found</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>db_he</name> <operator>=</operator> <operator>(</operator><name>DbHashEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>db_htab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>db_oid</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>db_he</name><operator>-&gt;</operator><name>db_scheduler_handle</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>db_he</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>ENABLED</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SetInvalidVirtualTransactionId</name><argument_list>(<argument><expr><name><name>db_he</name><operator>-&gt;</operator><name>vxid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>db_he</name><operator>-&gt;</operator><name>state_transition_failures</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<comment type="block">/*
		 * Try to allocate a spot right away to give schedulers priority over
		 * other bgws. This is especially important on initial server startup
		 * where we want to reserve slots for all schedulers before starting
		 * any. This is done so that background workers started by schedulers
		 * don't race for open slots with other schedulers on startup.
		 */</comment>
		<expr_stmt><expr><call><name>scheduler_state_trans_enabled_to_allocated</name><argument_list>(<argument><expr><name>db_he</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>db_he</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Model this on autovacuum.c -&gt; get_database_list.
 *
 * Note that we are not doing
 * all the things around memory context that they do, because the hashtable
 * we're using to store db entries is automatically created in its own memory
 * context (a child of TopMemoryContext) This can get called at two different
 * times 1) when the cluster launcher starts and is looking for dbs and 2) if
 * it restarts due to a postmaster signal.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>populate_database_htab</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>db_htab</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TableScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tup</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * by this time we should already be connected to the db, and only have
	 * access to shared catalogs
	 */</comment>
	<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>DatabaseRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>table_beginscan_catalog</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_database</name></type> <name>pgdb</name> <init>= <expr><operator>(</operator><name>Form_pg_database</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pgdb</name><operator>-&gt;</operator><name>datallowconn</name></name> <operator>||</operator> <name><name>pgdb</name><operator>-&gt;</operator><name>datistemplate</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt> <comment type="block">/* don't bother with dbs that don't allow
					   * connections or are templates */</comment>
		<expr_stmt><expr><call><name>db_hash_entry_create_if_not_exists</name><argument_list>(<argument><expr><name>db_htab</name></expr></argument>, <argument><expr><name><name>pgdb</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>heap_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>scheduler_modify_state</name><parameter_list>(<parameter><decl><type><name>DbHashEntry</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>, <parameter><decl><type><name>SchedulerState</name></type> <name>new_state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>new_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>state_transition_failures</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>new_state</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* TRANSITION FUNCTIONS */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>scheduler_state_trans_disabled_to_enabled</name><parameter_list>(<parameter><decl><type><name>DbHashEntry</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>DISABLED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>db_scheduler_handle</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>scheduler_modify_state</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>ENABLED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>scheduler_state_trans_enabled_to_allocated</name><parameter_list>(<parameter><decl><type><name>DbHashEntry</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>ENABLED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>db_scheduler_handle</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Reserve a spot for this scheduler with BGW counter */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ts_bgw_total_workers_increment</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>report_bgw_limit_exceeded</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>scheduler_modify_state</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>ALLOCATED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>scheduler_state_trans_started_to_allocated</name><parameter_list>(<parameter><decl><type><name>DbHashEntry</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>STARTED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>get_background_worker_pid</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>db_scheduler_handle</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BGWH_STOPPED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>db_scheduler_handle</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>db_scheduler_handle</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>db_scheduler_handle</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>scheduler_modify_state</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>ALLOCATED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>scheduler_state_trans_allocated_to_started</name><parameter_list>(<parameter><decl><type><name>DbHashEntry</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pid_t</name></type> <name>worker_pid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>worker_registered</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>ALLOCATED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>db_scheduler_handle</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>worker_registered</name> <operator>=</operator>
		<call><name>register_entrypoint_for_db</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>db_oid</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>vxid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>db_scheduler_handle</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>worker_registered</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>report_error_on_worker_register_failure</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>wait_for_background_worker_startup</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>db_scheduler_handle</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>worker_pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetInvalidVirtualTransactionId</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>vxid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>scheduler_modify_state</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>STARTED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>scheduler_state_trans_enabled_to_disabled</name><parameter_list>(<parameter><decl><type><name>DbHashEntry</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>ENABLED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>db_scheduler_handle</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>scheduler_modify_state</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>DISABLED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>scheduler_state_trans_allocated_to_disabled</name><parameter_list>(<parameter><decl><type><name>DbHashEntry</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>ALLOCATED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>db_scheduler_handle</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ts_bgw_total_workers_decrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>scheduler_modify_state</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>DISABLED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>scheduler_state_trans_started_to_disabled</name><parameter_list>(<parameter><decl><type><name>DbHashEntry</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>STARTED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>get_background_worker_pid</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>db_scheduler_handle</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BGWH_STOPPED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ts_bgw_total_workers_decrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>db_scheduler_handle</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>db_scheduler_handle</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>db_scheduler_handle</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>scheduler_modify_state</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>DISABLED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>scheduler_state_trans_automatic</name><parameter_list>(<parameter><decl><type><name>DbHashEntry</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>state</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>ENABLED</name></expr>:</case>
			<expr_stmt><expr><call><name>scheduler_state_trans_enabled_to_allocated</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>ALLOCATED</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>scheduler_state_trans_allocated_to_started</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>ALLOCATED</name></expr>:</case>
			<expr_stmt><expr><call><name>scheduler_state_trans_allocated_to_started</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>STARTED</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>get_background_worker_pid</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>db_scheduler_handle</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BGWH_STOPPED</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>scheduler_state_trans_started_to_disabled</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>DISABLED</name></expr>:</case>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>scheduler_state_trans_automatic_all</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>db_htab</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>hash_seq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DbHashEntry</name> <modifier>*</modifier></type><name>current_entry</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_seq</name></expr></argument>, <argument><expr><name>db_htab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>current_entry</name> <operator>=</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_seq</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>scheduler_state_trans_automatic</name><argument_list>(<argument><expr><name>current_entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></function>

<comment type="block">/* This is called when we're going to shut down so we don't leave things messy*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>launcher_pre_shmem_cleanup</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>db_htab</name> <init>= <expr><operator>*</operator><operator>(</operator><name>HTAB</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>hash_seq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DbHashEntry</name> <modifier>*</modifier></type><name>current_entry</name></decl>;</decl_stmt>

	<comment type="block">/* db_htab will be NULL if we fail during init_database_htab */</comment>
	<if_stmt><if>if <condition>(<expr><name>db_htab</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_seq</name></expr></argument>, <argument><expr><name>db_htab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Stop everyone (or at least tell the Postmaster we don't care about
		 * them anymore)
		 */</comment>
		<while>while <condition>(<expr><operator>(</operator><name>current_entry</name> <operator>=</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_seq</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>current_entry</name><operator>-&gt;</operator><name>db_scheduler_handle</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>terminate_background_worker</name><argument_list>(<argument><expr><name><name>current_entry</name><operator>-&gt;</operator><name>db_scheduler_handle</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>current_entry</name><operator>-&gt;</operator><name>db_scheduler_handle</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></while>

		<expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name>db_htab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Reset our pid in the queue so that others know we've died and don't
	 * wait forever
	 */</comment>
	<expr_stmt><expr><call><name>ts_bgw_message_queue_shmem_cleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *************
 * Actions for message types we could receive off of the bgw_message_queue.
 *************
 */</comment>

<comment type="block">/*
 * This should be idempotent. If we find the background worker and it's not
 * stopped, do nothing. In order to maintain idempotency, a scheduler in the
 * ENABLED, ALLOCATED or STARTED state cannot get a new vxid to wait on. (We
 * cannot pass in a new vxid to wait on for an already-started scheduler in any
 * case). This means that actions like restart, which are not idempotent, will
 * not have their effects changed by subsequent start actions, no matter the
 * state they are in when the start action is received.
 */</comment>
<function><type><specifier>static</specifier> <name>AckResult</name></type>
<name>message_start_action</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>db_htab</name></decl></parameter>, <parameter><decl><type><name>BgwMessage</name> <modifier>*</modifier></type><name>message</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DbHashEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>db_hash_entry_create_if_not_exists</name><argument_list>(<argument><expr><name>db_htab</name></expr></argument>, <argument><expr><name><name>message</name><operator>-&gt;</operator><name>db_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>DISABLED</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>scheduler_state_trans_disabled_to_enabled</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>scheduler_state_trans_automatic</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><ternary><condition><expr><name><name>entry</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>STARTED</name></expr> ?</condition><then> <expr><name>ACK_SUCCESS</name></expr> </then><else>: <expr><name>ACK_FAILURE</name></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AckResult</name></type>
<name>message_stop_action</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>db_htab</name></decl></parameter>, <parameter><decl><type><name>BgwMessage</name> <modifier>*</modifier></type><name>message</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DbHashEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the entry does not exist try to create it so we can put it in the
	 * DISABLED state. Otherwise, it will be created during the next poll and
	 * then will end up in the ENABLED state and proceed to being STARTED. But
	 * this is not the behavior we want.
	 */</comment>
	<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>db_hash_entry_create_if_not_exists</name><argument_list>(<argument><expr><name>db_htab</name></expr></argument>, <argument><expr><name><name>message</name><operator>-&gt;</operator><name>db_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>state</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>ENABLED</name></expr>:</case>
			<expr_stmt><expr><call><name>scheduler_state_trans_enabled_to_disabled</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>ALLOCATED</name></expr>:</case>
			<expr_stmt><expr><call><name>scheduler_state_trans_allocated_to_disabled</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>STARTED</name></expr>:</case>
			<expr_stmt><expr><call><name>terminate_background_worker</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>db_scheduler_handle</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>wait_for_background_worker_shutdown</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>db_scheduler_handle</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>scheduler_state_trans_started_to_disabled</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DISABLED</name></expr>:</case>
			<break>break;</break>
	</block_content>}</block></switch>
	<return>return <expr><ternary><condition><expr><name><name>entry</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>DISABLED</name></expr> ?</condition><then> <expr><name>ACK_SUCCESS</name></expr> </then><else>: <expr><name>ACK_FAILURE</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * This function will stop and restart a scheduler in the STARTED state,  ENABLE
 * a scheduler if it does not exist or is in the DISABLED state and set the vxid
 * to wait on for a scheduler in any state. It is not idempotent. Additionally,
 * one might think that this function would simply be a combination of stop and
 * start above, but it is not as we maintain the worker's "slot" by never
 * releasing the worker from our "pool" of background workers as stopping and
 * starting would.  We don't want a race condition where some other db steals
 * the scheduler of the other by requesting a worker at the wrong time. (This is
 * accomplished by moving from STARTED to ALLOCATED after shutting down the
 * worker, never releasing the entry and transitioning all the way back to
 * ENABLED).
 */</comment>
<function><type><specifier>static</specifier> <name>AckResult</name></type>
<name>message_restart_action</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>db_htab</name></decl></parameter>, <parameter><decl><type><name>BgwMessage</name> <modifier>*</modifier></type><name>message</name></decl></parameter>, <parameter><decl><type><name>VirtualTransactionId</name></type> <name>vxid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DbHashEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>db_hash_entry_create_if_not_exists</name><argument_list>(<argument><expr><name>db_htab</name></expr></argument>, <argument><expr><name><name>message</name><operator>-&gt;</operator><name>db_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>vxid</name></name> <operator>=</operator> <name>vxid</name></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>state</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>ENABLED</name></expr>:</case>
			<break>break;</break>
		<case>case <expr><name>ALLOCATED</name></expr>:</case>
			<break>break;</break>
		<case>case <expr><name>STARTED</name></expr>:</case>
			<expr_stmt><expr><call><name>terminate_background_worker</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>db_scheduler_handle</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>wait_for_background_worker_shutdown</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>db_scheduler_handle</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>scheduler_state_trans_started_to_allocated</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DISABLED</name></expr>:</case>
			<expr_stmt><expr><call><name>scheduler_state_trans_disabled_to_enabled</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>scheduler_state_trans_automatic</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><ternary><condition><expr><name><name>entry</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>STARTED</name></expr> ?</condition><then> <expr><name>ACK_SUCCESS</name></expr> </then><else>: <expr><name>ACK_FAILURE</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Handle 1 message.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>launcher_handle_message</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>db_htab</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BgwMessage</name> <modifier>*</modifier></type><name>message</name> <init>= <expr><call><name>ts_bgw_message_receive</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>sender</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VirtualTransactionId</name></type> <name>vxid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AckResult</name></type> <name>action_result</name> <init>= <expr><name>ACK_FAILURE</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>message</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>sender</name> <operator>=</operator> <call><name>BackendPidGetProc</name><argument_list>(<argument><expr><name><name>message</name><operator>-&gt;</operator><name>sender_pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>sender</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"TimescaleDB background worker launcher received message from non-existent "</literal>
						<literal type="string">"backend"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>GET_VXID_FROM_PGPROC</name><argument_list>(<argument><expr><name>vxid</name></expr></argument>, <argument><expr><operator>*</operator><name>sender</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>message</name><operator>-&gt;</operator><name>message_type</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>START</name></expr>:</case>
			<expr_stmt><expr><name>action_result</name> <operator>=</operator> <call><name>message_start_action</name><argument_list>(<argument><expr><name>db_htab</name></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>STOP</name></expr>:</case>
			<expr_stmt><expr><name>action_result</name> <operator>=</operator> <call><name>message_stop_action</name><argument_list>(<argument><expr><name>db_htab</name></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RESTART</name></expr>:</case>
			<expr_stmt><expr><name>action_result</name> <operator>=</operator> <call><name>message_restart_action</name><argument_list>(<argument><expr><name>db_htab</name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>vxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>ts_bgw_message_send_ack</name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><name>action_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * The default, `bgworker_die()`, can't be used due to the fact that it
 * handles signals synchronously, rather than waiting for a
 * CHECK_FOR_INTERRUPTS(). `die()` (which is arguably misnamed) sets flags
 * that will cause the backend to exit on the next call to
 * CHECK_FOR_INTERRUPTS(), which can happen either in our code or in functions
 * within the Postgres codebase that we call. This means that we don't need to
 * wait for the next time control is returned to our loop to exit, which would
 * be necessary if we set our own flag and checked it in a loop
 * condition. However, because it cannot exit 0, the launcher will be
 * restarted by the postmaster, even when it has received a SIGTERM, which we
 * decided was the proper behavior. If users want to disable the launcher,
 * they can set `timescaledb.max_background_workers = 0` and then we will
 * `proc_exit(0)` before doing anything else.
 */</comment>

<function><type><specifier>extern</specifier> <name>Datum</name></type>
<name>ts_bgw_cluster_launcher_main</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HTAB</name> <modifier>*</modifier><modifier>*</modifier></type><name>htab_storage</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>db_htab</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGINT</name></expr></argument>, <argument><expr><name>StatementCancelHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>, <argument><expr><name>die</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGHUP</name></expr></argument>, <argument><expr><name>launcher_sighup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Some SIGHUPS may already have been dropped, so we must load the file here */</comment>
	<expr_stmt><expr><name>got_SIGHUP</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ProcessConfigFile</name><argument_list>(<argument><expr><name>PGC_SIGHUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>BackgroundWorkerUnblockSignals</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"TimescaleDB background worker launcher started"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* set counter back to zero on restart */</comment>
	<expr_stmt><expr><call><name>ts_bgw_counter_reinit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ts_bgw_total_workers_increment</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Should be the first thing happening so if we already exceeded our
		 * limits it means we have a limit of 0 and we should just exit We
		 * have to exit(0) because if we exit in error we get restarted by the
		 * postmaster.
		 */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIGURATION_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"TimescaleDB background worker is set to 0"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"TimescaleDB background worker launcher shutting down."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Connect to the db, no db name yet, so can only access shared catalogs */</comment>
	<expr_stmt><expr><call><name>BackgroundWorkerInitializeConnection</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgstat_report_appname</name><argument_list>(<argument><expr><name><name>MyBgworkerEntry</name><operator>-&gt;</operator><name>bgw_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"TimescaleDB background worker launcher connected to shared catalogs"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>htab_storage</name> <operator>=</operator> <call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>htab_storage</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We must setup the cleanup function _before_ initializing any state it
	 * touches (specifically the bgw_message_queue and db_htab). Failing to do
	 * this can cause cascading failures when the launcher fails in
	 * init_database_htab (eg. due to running out of shared memory) but
	 * doesn't deregister itself from the shared bgw_message_queue.
	 */</comment>
	<expr_stmt><expr><call><name>before_shmem_exit</name><argument_list>(<argument><expr><name>launcher_pre_shmem_cleanup</name></expr></argument>, <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>htab_storage</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ts_bgw_message_queue_set_reader</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>db_htab</name> <operator>=</operator> <call><name>init_database_htab</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>htab_storage</name> <operator>=</operator> <name>db_htab</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>populate_database_htab</name><argument_list>(<argument><expr><name>db_htab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>wl_rc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>handled_msgs</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>populate_database_htab</name><argument_list>(<argument><expr><name>db_htab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>handled_msgs</name> <operator>=</operator> <call><name>launcher_handle_message</name><argument_list>(<argument><expr><name>db_htab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>scheduler_state_trans_automatic_all</name><argument_list>(<argument><expr><name>db_htab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>handled_msgs</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>wl_rc</name> <operator>=</operator> <call><name>WaitLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>,
						  <argument><expr><name>WL_LATCH_SET</name> <operator>|</operator> <name>WL_POSTMASTER_DEATH</name> <operator>|</operator> <name>WL_TIMEOUT</name></expr></argument>,
						  <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name>ts_guc_bgw_launcher_poll_time</name></expr></argument>,
						  <argument><expr><name>PG_WAIT_EXTENSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>wl_rc</name> <operator>&amp;</operator> <name>WL_POSTMASTER_DEATH</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>bgw_on_postmaster_death</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>got_SIGHUP</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>got_SIGHUP</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ProcessConfigFile</name><argument_list>(<argument><expr><name>PGC_SIGHUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Inside the entrypoint, we must check again if we're in a template db
 * even though we excluded template dbs in populate_database_htab because
 * we can be called on, say, CREATE EXTENSION in a template db and then
 * we'll not stop til next server shutdown so if we hit this point and are
 * in a template db, we throw an error and shut down Check in the syscache
 * rather than searching through the entire database catalog again.
 * Modelled on autovacuum.c -&gt; do_autovacuum.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>database_is_template_check</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Form_pg_database</name></type> <name>pgdb</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>DATABASEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"TimescaleDB background worker failed to find entry for database in "</literal>
						<literal type="string">"syscache"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>pgdb</name> <operator>=</operator> <operator>(</operator><name>Form_pg_database</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>pgdb</name><operator>-&gt;</operator><name>datistemplate</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"TimescaleDB background worker connected to template database, exiting"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Before we morph into the scheduler, we also need to reload configs from their
 * defaults if the database default has changed. Defaults are changed in the
 * post_restore function where we change the db default for the restoring guc
 * wait until the txn commits and then must see if the txn made the change.
 * Checks for changes are normally run at connection startup, but because we
 * have to connect in order to wait on the txn we have to re-run after the wait.
 * This function is based on the postgres function in postinit.c by the same
 * name.
 */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_settings</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>databaseid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type> <name>relsetting</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>relsetting</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>DbRoleSettingRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* read all the settings under the same snapshot for efficiency */</comment>
	<expr_stmt><expr><name>snapshot</name> <operator>=</operator> <call><name>RegisterSnapshot</name><argument_list>(<argument><expr><call><name>GetCatalogSnapshot</name><argument_list>(<argument><expr><name>DbRoleSettingRelationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Later settings are ignored if set earlier. */</comment>
	<expr_stmt><expr><call><name>ApplySetting</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>, <argument><expr><name>databaseid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>relsetting</name></expr></argument>, <argument><expr><name>PGC_S_DATABASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ApplySetting</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>relsetting</name></expr></argument>, <argument><expr><name>PGC_S_GLOBAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>UnregisterSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>relsetting</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * This can be run either from the cluster launcher at db_startup time, or
 * in the case of an install/uninstall/update of the extension, in the
 * first case, we have no vxid that we're waiting on. In the second case,
 * we do, because we have to wait so that we see the effects of said txn.
 * So we wait for it to finish, then we  morph into the new db_scheduler
 * worker using whatever version is now installed (or exit gracefully if
 * no version is now installed).
 */</comment>
<function><type><specifier>extern</specifier> <name>Datum</name></type>
<name>ts_bgw_db_scheduler_entrypoint</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>db_id</name> <init>= <expr><call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name><name>MyBgworkerEntry</name><operator>-&gt;</operator><name>bgw_main_arg</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>ts_installed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>version</name><index>[<expr><name>MAX_VERSION_LEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VirtualTransactionId</name></type> <name>vxid</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGINT</name></expr></argument>, <argument><expr><name>StatementCancelHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>, <argument><expr><name>die</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>BackgroundWorkerUnblockSignals</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>BackgroundWorkerInitializeConnectionByOid</name><argument_list>(<argument><expr><name>db_id</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgstat_report_appname</name><argument_list>(<argument><expr><name><name>MyBgworkerEntry</name><operator>-&gt;</operator><name>bgw_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Wait until whatever vxid that potentially called us finishes before we
	 * happens in a txn so it's cleaned up correctly if we get a sigkill in
	 * the meantime, but we will need stop after and take a new txn so we can
	 * see the correct state after its effects
	 */</comment>
	<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vxid</name></expr></argument>, <argument><expr><name><name>MyBgworkerEntry</name><operator>-&gt;</operator><name>bgw_extra</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>VirtualTransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>VirtualTransactionIdIsValid</name><argument_list>(<argument><expr><name>vxid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>VirtualXactLock</name><argument_list>(<argument><expr><name>vxid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * now we can start our transaction and get the version currently
	 * installed
	 */</comment>
	<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check whether a database is a template database and raise an error if
	 * so, as we don't want to run in template dbs.
	 */</comment>
	<expr_stmt><expr><call><name>database_is_template_check</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*  Process any config changes caused by an ALTER DATABASE */</comment>
	<expr_stmt><expr><call><name>process_settings</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ts_installed</name> <operator>=</operator> <call><name>ts_loader_extension_exists</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ts_installed</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>version</name></expr></argument>, <argument><expr><call><name>ts_loader_extension_version</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>MAX_VERSION_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ts_loader_extension_check</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ts_installed</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type> <name><name>soname</name><index>[<expr><name>MAX_SO_NAME_LEN</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGFunction</name></type> <name>versioned_scheduler_main</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>soname</name></expr></argument>, <argument><expr><name>MAX_SO_NAME_LEN</name></expr></argument>, <argument><expr><literal type="string">"%s-%s"</literal></expr></argument>, <argument><expr><name>EXTENSION_SO</name></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>versioned_scheduler_main</name> <operator>=</operator>
			<call><name>load_external_function</name><argument_list>(<argument><expr><name>soname</name></expr></argument>, <argument><expr><name>BGW_DB_SCHEDULER_FUNCNAME</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>versioned_scheduler_main</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"TimescaleDB version %s does not have a background worker, exiting"</literal></expr></argument>,
							<argument><expr><name>soname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content> <comment type="block">/* essentially we morph into the versioned
			  * worker here */</comment>
			<expr_stmt><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>versioned_scheduler_main</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
