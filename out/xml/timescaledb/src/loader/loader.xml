<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/timescaledb/src/loader/loader.c"><comment type="block">/*
 * This file and its contents are licensed under the Apache License 2.0.
 * Please see the included NOTICE for copyright information and
 * LICENSE-APACHE for a copy of the license.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postgres.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/xact.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/heapam.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../compat/compat-msvc-enter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postmaster/bgworker.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;commands/extension.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;commands/user.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;miscadmin.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;parser/analyze.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;storage/ipc.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;tcop/utility.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../compat/compat-msvc-exit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/guc.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/inval.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/print.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;commands/dbcommands.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;commands/defrem.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/parallel.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"extension_utils.c"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"export.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compat/compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"extension_constants.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"loader/loader.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"loader/function_telemetry.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"loader/bgw_counter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"loader/bgw_interface.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"loader/bgw_launcher.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"loader/bgw_message_queue.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"loader/lwlocks.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"loader/seclabel.h"</cpp:file></cpp:include>

<comment type="block">/*
 * Loading process:
 *
 *   1. _PG_init starts up cluster-wide background worker stuff, and sets the
 *      post_parse_analyze_hook (a postgres-defined hook which is called after
 *      every statement is parsed) to our function post_analyze_hook
 *   2. When a command is run with timescale not loaded, post_analyze_hook:
 *        a. Gets the extension version.
 *        b. Loads the versioned extension.
 *        c. Grabs the post_parse_analyze_hook from the versioned extension
 *           (src/init.c:post_analyze_hook) and stores it in
 *           extension_post_parse_analyze_hook.
 *        d. Sets the post_parse_analyze_hook back to what it was before we
 *           loaded the versioned extension (this hook eventually called our
 *           post_analyze_hook, but may not be our function, for instance, if
 *           another extension is loaded).
 *        e. Calls extension_post_parse_analyze_hook.
 *        f. Calls the prev_post_parse_analyze_hook.
 *
 * Some notes on design:
 *
 * We do not check for the installation of the extension upon loading the extension and instead rely
 * on a hook for a few reasons:
 *
 * 1) We probably can't:
 *    - The shared_preload_libraries is called in PostmasterMain which is way before InitPostgres is
 *      called. Note: This happens even before the fork of the backend, so we don't even know which
 *      database this is for.
 *    - This means we cannot query for the existence of the extension yet because the caches are
 *      initialized in InitPostgres.
 *
 * 2) We actually don't want to load the extension in two cases:
 *    a) We are upgrading the extension.
 *    b) We set the guc timescaledb.disable_load.
 *
 * 3) We include a section for the bgw launcher and some workers below the rest, separated with its
 *    own notes, some function definitions are included as they are referenced by other loader
 *    functions.
 *
 */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PG_MODULE_MAGIC</name></cpp:ifdef>
<expr_stmt><expr><name>PG_MODULE_MAGIC</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POST_LOAD_INIT_FN</name></cpp:macro> <cpp:value>"ts_post_load_init"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GUC_DISABLE_LOAD_NAME</name></cpp:macro> <cpp:value>"timescaledb.disable_load"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GUC_LAUNCHER_POLL_TIME_MS</name></cpp:macro> <cpp:value>"timescaledb.bgw_launcher_poll_time"</cpp:value></cpp:define>

<comment type="block">/*
 * The loader really shouldn't load if we're in a parallel worker as there is a
 * separate infrastructure for loading libraries inside of parallel workers. The
 * issue is that IsParallelWorker() doesn't work on Windows because the var used
 * is not dll exported correctly, so we have an alternate macro that looks for
 * the parallel worker flags in MyBgworkerEntry, if it exists.
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CalledInParallelWorker</name><parameter_list>()</parameter_list></cpp:macro>                                                                   \
	<cpp:value>(MyBgworkerEntry != NULL &amp;&amp; (MyBgworkerEntry-&gt;bgw_flags &amp; BGWORKER_CLASS_PARALLEL) != 0)</cpp:value></cpp:define>
<function_decl><type><specifier>extern</specifier> <name>void</name> <name>TSDLLEXPORT</name></type> <name>_PG_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* was the versioned-extension loaded*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>loader_present</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* The shared object library version loaded, as a string. Will be all
 * zero-initialized if no extension is loaded. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>soversion</name><index>[<expr><name>MAX_VERSION_LEN</name></expr>]</index></name></decl>;</decl_stmt>

<comment type="block">/* GUC to disable the load */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>guc_disable_load</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ts_guc_bgw_launcher_poll_time</name> <init>= <expr><name>BGW_LAUNCHER_POLL_TIME_MS</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* This is the hook that existed before the loader was installed */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>post_parse_analyze_hook_type</name></type> <name>prev_post_parse_analyze_hook</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>shmem_startup_hook_type</name></type> <name>prev_shmem_startup_hook</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG15_GE</name></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <name>shmem_request_hook_type</name></type> <name>prev_shmem_request_hook</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><specifier>static</specifier> <name>ProcessUtility_hook_type</name></type> <name>prev_ProcessUtility_hook</name></decl>;</decl_stmt>

<comment type="block">/* This is timescaleDB's versioned-extension's post_parse_analyze_hook */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>post_parse_analyze_hook_type</name></type> <name>extension_post_parse_analyze_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>inline</specifier> <specifier>static</specifier> <name>void</name></type> <name>extension_check</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_LT</name></expr></cpp:if>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>call_extension_post_parse_analyze_hook</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>call_extension_post_parse_analyze_hook</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
												   <parameter><decl><type><name>JumbleState</name> <modifier>*</modifier></type><name>jstate</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>extension_is_loaded</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* The extension is loaded when the version is set to a non-null string */</comment>
	<return>return <expr><name><name>soversion</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>extern</specifier> <name>char</name> <modifier>*</modifier></type>
<name>ts_loader_extension_version</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>extension_version</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>extern</specifier> <name>bool</name></type>
<name>ts_loader_extension_exists</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>extension_exists</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>drop_statement_drops_extension</name><parameter_list>(<parameter><decl><type><name>DropStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>extension_exists</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>removeType</name></name> <operator>==</operator> <name>OBJECT_EXTENSION</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objects</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ext_name</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objects</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>ext_name</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>ext_name</name></expr></argument>, <argument><expr><name>EXTENSION_NAME</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>extension_owner</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scandesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>entry</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>is_null</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>extension_owner</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>ExtensionRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_extension_extname</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
				<argument><expr><name>F_NAMEEQ</name></expr></argument>,
				<argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>EXTENSION_NAME</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>scandesc</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ExtensionNameIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scandesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We assume that there can be at most one matching tuple */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pg_extension_extowner</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_null</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>extension_owner</name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scandesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>extension_owner</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"extension not found while getting owner"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>extension_owner</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>drop_owned_statement_drops_extension</name><parameter_list>(<parameter><decl><type><name>DropOwnedStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>extension_owner_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>role_ids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>extension_exists</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsTransactionState</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>extension_owner_oid</name> <operator>=</operator> <call><name>extension_owner</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>role_ids</name> <operator>=</operator> <call><name>roleSpecsToIds</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>roles</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check privileges */</comment>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>role_ids</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>role_id</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>role_id</name> <operator>==</operator> <name>extension_owner_oid</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>should_load_on_variable_set</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>utility_stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>VariableSetStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>VariableSetStmt</name> <operator>*</operator><operator>)</operator> <name>utility_stmt</name></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>VAR_SET_VALUE</name></expr>:</case>
		<case>case <expr><name>VAR_SET_DEFAULT</name></expr>:</case>
		<case>case <expr><name>VAR_RESET</name></expr>:</case>
			<comment type="block">/* Do not load when setting the guc to disable load */</comment>
			<return>return <expr><name><name>stmt</name><operator>-&gt;</operator><name>name</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>GUC_DISABLE_LOAD_NAME</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>
		<default>default:</default>
			<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>should_load_on_alter_extension</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>utility_stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlterExtensionStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>AlterExtensionStmt</name> <operator>*</operator><operator>)</operator> <name>utility_stmt</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>extname</name></name></expr></argument>, <argument><expr><name>EXTENSION_NAME</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* disallow loading two .so from different versions */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>extension_is_loaded</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"extension \"%s\" cannot be updated after the old version has already been "</literal>
						<literal type="string">"loaded"</literal></expr></argument>,
						<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>extname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Start a new session and execute ALTER EXTENSION as the first command. "</literal>
						 <literal type="string">"Make sure to pass the \"-X\" flag to psql."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* do not load the current (old) version's .so */</comment>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>should_load_on_create_extension</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>utility_stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CreateExtensionStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>CreateExtensionStmt</name> <operator>*</operator><operator>)</operator> <name>utility_stmt</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>is_extension</name> <init>= <expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>extname</name></name></expr></argument>, <argument><expr><name>EXTENSION_NAME</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_extension</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* If set, a library has already been loaded */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>extension_is_loaded</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If the extension exists and the create statement has an IF NOT EXISTS
	 * option, we continue without loading and let CREATE EXTENSION bail out
	 * with a standard NOTICE. We can only do this if the extension actually
	 * exists (is created), or else we might potentially load the shared
	 * library of another version of the extension. Loading typically happens
	 * on CREATE EXTENSION (via CREATE FUNCTION as SQL files are installed)
	 * even if we do not explicitly load the library here. If we load another
	 * version of the library, in addition to the currently loaded version, we
	 * might taint the backend.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>extension_exists</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name><name>stmt</name><operator>-&gt;</operator><name>if_not_exists</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* disallow loading two .so from different versions */</comment>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"extension \"%s\" has already been loaded with another version"</literal></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>extname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The loaded version is \"%s\"."</literal></expr></argument>, <argument><expr><name>soversion</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Start a new session and execute CREATE EXTENSION as the first command. "</literal>
					 <literal type="string">"Make sure to pass the \"-X\" flag to psql."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>should_load_on_drop_extension</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>utility_stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>!</operator><call><name>drop_statement_drops_extension</name><argument_list>(<argument><expr><operator>(</operator><name>DropStmt</name> <operator>*</operator><operator>)</operator> <name>utility_stmt</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>load_utility_cmd</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>utility_stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>utility_stmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_VariableSetStmt</name></expr>:</case>
			<return>return <expr><call><name>should_load_on_variable_set</name><argument_list>(<argument><expr><name>utility_stmt</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_AlterExtensionStmt</name></expr>:</case>
			<return>return <expr><call><name>should_load_on_alter_extension</name><argument_list>(<argument><expr><name>utility_stmt</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_CreateExtensionStmt</name></expr>:</case>
			<return>return <expr><call><name>should_load_on_create_extension</name><argument_list>(<argument><expr><name>utility_stmt</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_DropStmt</name></expr>:</case>
			<return>return <expr><call><name>should_load_on_drop_extension</name><argument_list>(<argument><expr><name>utility_stmt</name></expr></argument>)</argument_list></call></expr>;</return>
		<default>default:</default>
			<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>stop_workers_on_db_drop</name><parameter_list>(<parameter><decl><type><name>DropdbStmt</name> <modifier>*</modifier></type><name>drop_db_statement</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Don't check if extension exists here because even though the current
	 * database might not have TimescaleDB installed the database we are
	 * dropping might.
	 */</comment>
	<decl_stmt><decl><type><name>Oid</name></type> <name>dropped_db_oid</name> <init>= <expr><call><name>get_database_oid</name><argument_list>(<argument><expr><name><name>drop_db_statement</name><operator>-&gt;</operator><name>dbname</name></name></expr></argument>, <argument><expr><name><name>drop_db_statement</name><operator>-&gt;</operator><name>missing_ok</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>dropped_db_oid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"TimescaleDB background worker scheduler for database %u will be stopped"</literal></expr></argument>,
						<argument><expr><name>dropped_db_oid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ts_bgw_message_send_and_wait</name><argument_list>(<argument><expr><name>STOP</name></expr></argument>, <argument><expr><name>dropped_db_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_LT</name></expr></cpp:if>
<name>post_analyze_hook</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
post_analyze_hook<parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>JumbleState</name> <modifier>*</modifier></type><name>jstate</name></decl></parameter>)</parameter_list>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name></expr>)</condition>
	<block>{<block_content>
		<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>T_AlterDatabaseStmt</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * On ALTER DATABASE SET TABLESPACE we need to stop background
				 * workers for the command to succeed.
				 */</comment>
				<decl_stmt><decl><type><name>AlterDatabaseStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>AlterDatabaseStmt</name> <operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>option</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>option</name><operator>-&gt;</operator><name>defname</name></name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>option</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"tablespace"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>Oid</name></type> <name>db_oid</name> <init>= <expr><call><name>get_database_oid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>dbname</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>db_oid</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>ts_bgw_message_send_and_wait</name><argument_list>(<argument><expr><name>RESTART</name></expr></argument>, <argument><expr><name>db_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"you may need to manually restart any running "</literal>
											<literal type="string">"background workers after this command"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			</block_content>}</block>
			<case>case <expr><name>T_CreatedbStmt</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * If we create a database and the database used as template
				 * has background workers we need to stop those background
				 * workers connected to the template database.
				 */</comment>
				<decl_stmt><decl><type><name>CreatedbStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>CreatedbStmt</name> <operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

				<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>stmt-&gt;options</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>option</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>option</name><operator>-&gt;</operator><name>defname</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>option</name><operator>-&gt;</operator><name>arg</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
						<call><name>strcmp</name><argument_list>(<argument><expr><name><name>option</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"template"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>Oid</name></type> <name>db_oid</name> <init>= <expr><call><name>get_database_oid</name><argument_list>(<argument><expr><call><name>defGetString</name><argument_list>(<argument><expr><name>option</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>db_oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>ts_bgw_message_send_and_wait</name><argument_list>(<argument><expr><name>RESTART</name></expr></argument>, <argument><expr><name>db_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block>
				<break>break;</break>
			</block_content>}</block>
			<case>case <expr><name>T_DropdbStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>DropdbStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>DropdbStmt</name> <operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * If we drop a database, we need to intercept and stop any of our
				 * schedulers that might be connected to said db.
				 */</comment>
				<expr_stmt><expr><call><name>stop_workers_on_db_drop</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>
			<case>case <expr><name>T_DropStmt</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>drop_statement_drops_extension</name><argument_list>(<argument><expr><operator>(</operator><name>DropStmt</name> <operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>)</argument_list></call></expr>)</condition>

				<comment type="block">/*
				 * if we drop the extension we should restart (in case of
				 * a rollback) the scheduler
				 */</comment>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ts_bgw_message_send_and_wait</name><argument_list>(<argument><expr><name>RESTART</name></expr></argument>, <argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><name>T_DropOwnedStmt</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>drop_owned_statement_drops_extension</name><argument_list>(<argument><expr><operator>(</operator><name>DropOwnedStmt</name> <operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ts_bgw_message_send_and_wait</name><argument_list>(<argument><expr><name>RESTART</name></expr></argument>, <argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RenameStmt</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>RenameStmt</name> <operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>utilityStmt</name></name><operator>)</operator><operator>-&gt;</operator><name>renameType</name> <operator>==</operator> <name>OBJECT_DATABASE</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>RenameStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>RenameStmt</name> <operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Oid</name></type> <name>db_oid</name> <init>= <expr><call><name>get_database_oid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>subname</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>missing_ok</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>db_oid</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>ts_bgw_message_send_and_wait</name><argument_list>(<argument><expr><name>STOP</name></expr></argument>, <argument><expr><name>db_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"you need to manually restart any running "</literal>
										<literal type="string">"background workers after this command"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			<default>default:</default>

				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>guc_disable_load</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_UTILITY</name> <operator>||</operator> <call><name>load_utility_cmd</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>extension_check</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Call the extension's hook. This is necessary since the extension is
		 * installed during the hook. If we did not do this the extension's hook
		 * would not be called during the first command because the extension
		 * would not have yet been installed. Thus the loader captures the
		 * extension hook and calls it explicitly after the check for installing
		 * the extension.
		 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_LT</name></expr></cpp:if>
	<expr_stmt><expr><call><name>call_extension_post_parse_analyze_hook</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>call_extension_post_parse_analyze_hook</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>jstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><name>prev_post_parse_analyze_hook</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_LT</name></expr></cpp:if>
		<expr_stmt><expr><call><name>prev_post_parse_analyze_hook</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><call><name>prev_post_parse_analyze_hook</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>jstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Check if a string is an UUID and error out otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_uuid</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>label</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><name>CurrentMemoryContext</name></expr></init></decl>;</decl_stmt>
	<comment type="block">/* Volatile is to work around the incorrect GCC -Wclobbered diagnostics. */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>volatile</specifier></type> <name>uuid</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>label</name></expr></argument>, <argument><expr><name>SECLABEL_DIST_TAG_SEPARATOR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>uuid</name> <operator>||</operator> <call><name>strncmp</name><argument_list>(<argument><expr><name>label</name></expr></argument>, <argument><expr><name>SECLABEL_DIST_TAG</name></expr></argument>, <argument><expr><name>uuid</name> <operator>-</operator> <name>label</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"TimescaleDB label is for internal use only"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Security label is \"%s\"."</literal></expr></argument>, <argument><expr><name>label</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Security label has to be of format \"dist_uuid:&lt;UUID&gt;\"."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>uuid_in</name></expr></argument>, <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>uuid</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ErrorData</name> <modifier>*</modifier></type><name>edata</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>edata</name> <operator>=</operator> <call><name>CopyErrorData</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>sqlerrcode</name></name> <operator>==</operator> <name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>detail</name></name> <operator>=</operator> <name><name>edata</name><operator>-&gt;</operator><name>message</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>hint</name></name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"Security label has to be of format \"dist_uuid:&lt;UUID&gt;\"."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>message</name></name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"TimescaleDB label is for internal use only"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>ReThrowError</name><argument_list>(<argument><expr><name>edata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>loader_process_utility_hook</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query_string</name></decl></parameter>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_GE</name></expr></cpp:if>
							<parameter><decl><type><name>bool</name></type> <name>readonly_tree</name></decl></parameter>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
							<parameter><decl><type><name>ProcessUtilityContext</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>,
							<parameter><decl><type><name>QueryEnvironment</name> <modifier>*</modifier></type><name>queryEnv</name></decl></parameter>, <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG13_GE</name></expr></cpp:if>
							<parameter><decl><type><name>QueryCompletion</name> <modifier>*</modifier><name>completion_tag</name>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
							<name>char</name> <modifier>*</modifier></type><name>completion_tag</name></decl></parameter>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>is_distributed_database</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dist_uuid</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ProcessUtility_hook_type</name></type> <name>process_utility</name></decl>;</decl_stmt>

	<comment type="block">/* Check if we are dropping a distributed database and get its uuid */</comment>
	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_DropdbStmt</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>DropdbStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>DropdbStmt</name></expr></argument>, <argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type> <name>dboid</name> <init>= <expr><call><name>get_database_oid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>dbname</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>missing_ok</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>dboid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>is_distributed_database</name> <operator>=</operator> <call><name>ts_seclabel_get_dist_uuid</name><argument_list>(<argument><expr><name>dboid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dist_uuid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		</block_content>}</block>
		<case>case <expr><name>T_SecLabelStmt</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SecLabelStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>SecLabelStmt</name></expr></argument>, <argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Since this statement can be in a dump output, we only print an
			 * error on anything that doesn't looks like a sane distributed
			 * UUID.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>provider</name></name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>provider</name></name></expr></argument>, <argument><expr><name>SECLABEL_DIST_PROVIDER</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>check_uuid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>label</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		</block_content>}</block>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* Process the command */</comment>
	<if_stmt><if>if <condition>(<expr><name>prev_ProcessUtility_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>process_utility</name> <operator>=</operator> <name>prev_ProcessUtility_hook</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>process_utility</name> <operator>=</operator> <name>standard_ProcessUtility</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>process_utility</name><argument_list>(<argument><expr><name>pstmt</name></expr></argument>,
					<argument><expr><name>query_string</name></expr></argument>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_GE</name></expr></cpp:if>
					<argument><expr><name>readonly_tree</name></expr></argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
					<argument><expr><name>context</name></expr></argument>,
					<argument><expr><name>params</name></expr></argument>,
					<argument><expr><name>queryEnv</name></expr></argument>,
					<argument><expr><name>dest</name></expr></argument>,
					<argument><expr><name>completion_tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Show a NOTICE warning message in case of dropping a
	 * distributed database
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>is_distributed_database</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"TimescaleDB distributed database might require "</literal>
						<literal type="string">"additional cleanup on the data nodes"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Distributed database UUID is \"%s\"."</literal></expr></argument>, <argument><expr><name>dist_uuid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>timescaledb_shmem_startup_hook</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>prev_shmem_startup_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>prev_shmem_startup_hook</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>ts_bgw_counter_shmem_startup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_bgw_message_queue_shmem_startup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_lwlocks_shmem_startup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_function_telemetry_shmem_startup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * PG15 requires all shared memory requests to be requested in a dedicated
 * hook. We group all our shared memory requests in this function and use
 * it as a normal function for PG &lt; 14 and as a hook for PG 15+.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>timescaledb_shmem_request_hook</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG15_GE</name></expr></cpp:if>
	<if_stmt><if>if <condition>(<expr><name>prev_shmem_request_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>prev_shmem_request_hook</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>ts_bgw_counter_shmem_alloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_bgw_message_queue_alloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_lwlocks_shmem_alloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_function_telemetry_shmem_alloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>extension_mark_loader_present</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>presentptr</name> <init>= <expr><call><name>find_rendezvous_variable</name><argument_list>(<argument><expr><name>RENDEZVOUS_LOADER_PRESENT_NAME</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>presentptr</name> <operator>=</operator> <operator>&amp;</operator><name>loader_present</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>_PG_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>process_shared_preload_libraries_in_progress</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>extension_load_without_preload</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>extension_mark_loader_present</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>INFO</name></expr></argument>, <argument><expr><literal type="string">"timescaledb loaded"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG15_LT</name></expr></cpp:if>
	<expr_stmt><expr><call><name>timescaledb_shmem_request_hook</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>ts_bgw_cluster_launcher_register</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_bgw_counter_setup_gucs</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_bgw_interface_register_api_version</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_seclabel_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* This is a safety-valve variable to prevent loading the full extension */</comment>
	<expr_stmt><expr><call><name>DefineCustomBoolVariable</name><argument_list>(<argument><expr><name>GUC_DISABLE_LOAD_NAME</name></expr></argument>,
							 <argument><expr><literal type="string">"Disable the loading of the actual extension"</literal></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>guc_disable_load</name></expr></argument>,
							 <argument><expr><name>false</name></expr></argument>,
							 <argument><expr><name>PGC_USERSET</name></expr></argument>,
							 <argument><expr><literal type="number">0</literal></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>DefineCustomIntVariable</name><argument_list>(<argument><expr><name>GUC_LAUNCHER_POLL_TIME_MS</name></expr></argument>,
							<argument><expr><literal type="string">"Launcher timeout value in milliseconds"</literal></expr></argument>,
							<argument><expr><literal type="string">"Configure the time the launcher waits "</literal>
							<literal type="string">"to look for new TimescaleDB instances"</literal></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>ts_guc_bgw_launcher_poll_time</name></expr></argument>,
							<argument><expr><name>BGW_LAUNCHER_POLL_TIME_MS</name></expr></argument>, <comment type="block">/* 10 ms or 60 seconds */</comment>
							<argument><expr><literal type="number">10</literal></expr></argument>,						   <comment type="block">/* min: 10ms */</comment>
							<argument><expr><name>PG_INT32_MAX</name></expr></argument>,			   <comment type="block">/* PG_INT16_MAX would be too small  */</comment>
							<argument><expr><name>PGC_POSTMASTER</name></expr></argument>,
							<argument><expr><literal type="number">0</literal></expr></argument>,
							<argument><expr><name>NULL</name></expr></argument>,
							<argument><expr><name>NULL</name></expr></argument>,
							<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Cannot check for extension here since not inside a transaction yet. Nor
	 * do we even have an assigned database yet.
	 * Using the post_parse_analyze_hook since it's the earliest available
	 * hook.
	 */</comment>
	<expr_stmt><expr><name>prev_post_parse_analyze_hook</name> <operator>=</operator> <name>post_parse_analyze_hook</name></expr>;</expr_stmt>
	<comment type="block">/* register shmem startup hook for the background worker stuff */</comment>
	<expr_stmt><expr><name>prev_shmem_startup_hook</name> <operator>=</operator> <name>shmem_startup_hook</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>post_parse_analyze_hook</name> <operator>=</operator> <name>post_analyze_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>shmem_startup_hook</name> <operator>=</operator> <name>timescaledb_shmem_startup_hook</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG15_GE</name></expr></cpp:if>
	<expr_stmt><expr><name>prev_shmem_request_hook</name> <operator>=</operator> <name>shmem_request_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>shmem_request_hook</name> <operator>=</operator> <name>timescaledb_shmem_request_hook</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* register utility hook to handle a distributed database drop */</comment>
	<expr_stmt><expr><name>prev_ProcessUtility_hook</name> <operator>=</operator> <name>ProcessUtility_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ProcessUtility_hook</name> <operator>=</operator> <name>loader_process_utility_hook</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>inline</specifier> <specifier>static</specifier> <name>void</name></type>
<name>do_load</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>version</name> <init>= <expr><call><name>extension_version</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>soname</name><index>[<expr><name>MAX_SO_NAME_LEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>post_parse_analyze_hook_type</name></type> <name>old_hook</name></decl>;</decl_stmt>

	<comment type="block">/* If the right version of the library is already loaded, we will just
	 * skip the actual loading. If the wrong version of the library is loaded,
	 * we need to kill the session since it will not be able to continue
	 * operate. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>extension_is_loaded</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>soversion</name></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" already loaded with a different version"</literal></expr></argument>, <argument><expr><name>EXTENSION_NAME</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The new version is \"%s\", this session is using version \"%s\". The "</literal>
						   <literal type="string">"session will be restarted."</literal></expr></argument>,
						   <argument><expr><name>version</name></expr></argument>,
						   <argument><expr><name>soversion</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>soversion</name></expr></argument>, <argument><expr><name>version</name></expr></argument>, <argument><expr><name>MAX_VERSION_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>soname</name></expr></argument>, <argument><expr><name>MAX_SO_NAME_LEN</name></expr></argument>, <argument><expr><literal type="string">"%s-%s"</literal></expr></argument>, <argument><expr><name>EXTENSION_SO</name></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * In a parallel worker, we're not responsible for loading libraries, it's
	 * handled by the parallel worker infrastructure which restores the
	 * library state.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>CalledInParallelWorker</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Set the config option to let versions 0.9.0 and 0.9.1 know that the
	 * loader was preloaded, newer versions use rendezvous variables instead.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>version</name></expr></argument>, <argument><expr><literal type="string">"0.9.0"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>version</name></expr></argument>, <argument><expr><literal type="string">"0.9.1"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"timescaledb.loader_present"</literal></expr></argument>, <argument><expr><literal type="string">"on"</literal></expr></argument>, <argument><expr><name>PGC_USERSET</name></expr></argument>, <argument><expr><name>PGC_S_SESSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * we need to capture the loaded extension's post analyze hook, giving it
	 * a NULL as previous
	 */</comment>
	<expr_stmt><expr><name>old_hook</name> <operator>=</operator> <name>post_parse_analyze_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>post_parse_analyze_hook</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We want to call the post_parse_analyze_hook from the versioned
	 * extension after we've loaded the versioned so. When the file is loaded
	 * it sets post_parse_analyze_hook, which we capture and store in
	 * extension_post_parse_analyze_hook to call at the end _PG_init
	 */</comment>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGFunction</name></type> <name>ts_post_load_init</name> <init>=
			<expr><call><name>load_external_function</name><argument_list>(<argument><expr><name>soname</name></expr></argument>, <argument><expr><name>POST_LOAD_INIT_FN</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>ts_post_load_init</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>ts_post_load_init</name></expr></argument>, <argument><expr><call><name>CharGetDatum</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><name>extension_post_parse_analyze_hook</name> <operator>=</operator> <name>post_parse_analyze_hook</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>post_parse_analyze_hook</name> <operator>=</operator> <name>old_hook</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>extension_post_parse_analyze_hook</name> <operator>=</operator> <name>post_parse_analyze_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>post_parse_analyze_hook</name> <operator>=</operator> <name>old_hook</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>inline</specifier> <specifier>static</specifier> <name>void</name></type>
<name>extension_check</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>enum</name> <name>ExtensionState</name></name></type> <name>state</name> <init>= <expr><call><name>extension_current_state</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>state</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>EXTENSION_STATE_TRANSITIONING</name></expr>:</case>
			<comment type="block">/*
			 * Always load as soon as the extension is transitioning. This is
			 * necessary so that the extension load before any CREATE FUNCTION
			 * calls. Otherwise, the CREATE FUNCTION calls will load the .so
			 * without capturing the post_parse_analyze_hook.
			 */</comment>
		<case>case <expr><name>EXTENSION_STATE_CREATED</name></expr>:</case>
			<expr_stmt><expr><call><name>do_load</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><name>EXTENSION_STATE_UNKNOWN</name></expr>:</case>
		<case>case <expr><name>EXTENSION_STATE_NOT_INSTALLED</name></expr>:</case>
			<return>return;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>extern</specifier> <name>void</name></type>
<name>ts_loader_extension_check</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>extension_check</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_LT</name></expr></cpp:if>
<name>call_extension_post_parse_analyze_hook</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
call_extension_post_parse_analyze_hook<parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>JumbleState</name> <modifier>*</modifier></type><name>jstate</name></decl></parameter>)</parameter_list>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>extension_is_loaded</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>extension_post_parse_analyze_hook</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_LT</name></expr></cpp:if>
		<expr_stmt><expr><call><name>extension_post_parse_analyze_hook</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><call><name>extension_post_parse_analyze_hook</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>jstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
</unit>
