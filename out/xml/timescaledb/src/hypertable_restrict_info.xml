<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/timescaledb/src/hypertable_restrict_info.c"><comment type="block">/*
 * This file and its contents are licensed under the Apache License 2.0.
 * Please see the included NOTICE for copyright information and
 * LICENSE-APACHE for a copy of the license.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postgres.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_inherits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/optimizer.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;parser/parsetree.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/array.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/builtins.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/lsyscache.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/typcache.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hypertable_restrict_info.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"chunk.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"chunk_scan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dimension.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dimension_slice.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dimension_vector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hypercube.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"partitioning.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"scan_iterator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;inttypes.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;tcop/tcopprot.h&gt;</cpp:file></cpp:include>

<typedef>typedef <type><struct>struct <name>DimensionRestrictInfo</name>
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type><name>dimension</name></decl>;</decl_stmt>
}</block></struct></type> <name>DimensionRestrictInfo</name>;</typedef>

<typedef>typedef <type><struct>struct <name>DimensionRestrictInfoOpen</name>
<block>{
	<decl_stmt><decl><type><name>DimensionRestrictInfo</name></type> <name>base</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>lower_bound</name></decl>;</decl_stmt> <comment type="block">/* internal time representation */</comment>
	<decl_stmt><decl><type><name>StrategyNumber</name></type> <name>lower_strategy</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>upper_bound</name></decl>;</decl_stmt> <comment type="block">/* internal time representation */</comment>
	<decl_stmt><decl><type><name>StrategyNumber</name></type> <name>upper_strategy</name></decl>;</decl_stmt>
}</block></struct></type> <name>DimensionRestrictInfoOpen</name>;</typedef>

<typedef>typedef <type><struct>struct <name>DimensionRestrictInfoClosed</name>
<block>{
	<decl_stmt><decl><type><name>DimensionRestrictInfo</name></type> <name>base</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>partitions</name></decl>;</decl_stmt>		 <comment type="block">/* hash values */</comment>
	<decl_stmt><decl><type><name>StrategyNumber</name></type> <name>strategy</name></decl>;</decl_stmt> <comment type="block">/* either Invalid or equal */</comment>
}</block></struct></type> <name>DimensionRestrictInfoClosed</name>;</typedef>

<typedef>typedef <type><struct>struct <name>DimensionValues</name>
<block>{
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>use_or</name></decl>;</decl_stmt> <comment type="block">/* ORed or ANDed values */</comment>
	<decl_stmt><decl><type><name>Oid</name></type> <name>type</name></decl>;</decl_stmt>	 <comment type="block">/* Oid type for values */</comment>
}</block></struct></type> <name>DimensionValues</name>;</typedef>

<function><type><specifier>static</specifier> <name>DimensionRestrictInfoOpen</name> <modifier>*</modifier></type>
<name>dimension_restrict_info_open_create</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type><name>d</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DimensionRestrictInfoOpen</name> <modifier>*</modifier></type><name>new</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DimensionRestrictInfoOpen</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>new</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>dimension</name></name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>new</name><operator>-&gt;</operator><name>lower_strategy</name></name> <operator>=</operator> <name>InvalidStrategy</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>new</name><operator>-&gt;</operator><name>upper_strategy</name></name> <operator>=</operator> <name>InvalidStrategy</name></expr>;</expr_stmt>
	<return>return <expr><name>new</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DimensionRestrictInfoClosed</name> <modifier>*</modifier></type>
<name>dimension_restrict_info_closed_create</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type><name>d</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DimensionRestrictInfoClosed</name> <modifier>*</modifier></type><name>new</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DimensionRestrictInfoClosed</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>new</name><operator>-&gt;</operator><name>partitions</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>new</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>dimension</name></name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>new</name><operator>-&gt;</operator><name>strategy</name></name> <operator>=</operator> <name>InvalidStrategy</name></expr>;</expr_stmt>
	<return>return <expr><name>new</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DimensionRestrictInfo</name> <modifier>*</modifier></type>
<name>dimension_restrict_info_create</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type><name>d</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>DIMENSION_TYPE_OPEN</name></expr>:</case>
			<return>return <expr><operator>&amp;</operator><call><name>dimension_restrict_info_open_create</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>base</name></expr>;</return>
		<case>case <expr><name>DIMENSION_TYPE_CLOSED</name></expr>:</case>
			<return>return <expr><operator>&amp;</operator><call><name>dimension_restrict_info_closed_create</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>base</name></expr>;</return>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unknown dimension type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Check if the restriction on this dimension is trivial, that is, the entire
 * range of the dimension matches.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>dimension_restrict_info_is_trivial</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DimensionRestrictInfo</name> <modifier>*</modifier></type><name>dri</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name><name>dri</name><operator>-&gt;</operator><name>dimension</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>DIMENSION_TYPE_OPEN</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>DimensionRestrictInfoOpen</name> <modifier>*</modifier></type><name>open</name> <init>= <expr><operator>(</operator><name>DimensionRestrictInfoOpen</name> <operator>*</operator><operator>)</operator> <name>dri</name></expr></init></decl>;</decl_stmt>
			<return>return <expr><name><name>open</name><operator>-&gt;</operator><name>lower_strategy</name></name> <operator>==</operator> <name>InvalidStrategy</name> <operator>&amp;&amp;</operator>
				   <name><name>open</name><operator>-&gt;</operator><name>upper_strategy</name></name> <operator>==</operator> <name>InvalidStrategy</name></expr>;</return>
		</block_content>}</block>
		<case>case <expr><name>DIMENSION_TYPE_CLOSED</name></expr>:</case>
			<return>return <expr><operator>(</operator><operator>(</operator><name>DimensionRestrictInfoClosed</name> <operator>*</operator><operator>)</operator> <name>dri</name><operator>)</operator><operator>-&gt;</operator><name>strategy</name> <operator>==</operator> <name>InvalidStrategy</name></expr>;</return>
		<default>default:</default>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>dimension_restrict_info_open_add</name><parameter_list>(<parameter><decl><type><name>DimensionRestrictInfoOpen</name> <modifier>*</modifier></type><name>dri</name></decl></parameter>, <parameter><decl><type><name>StrategyNumber</name></type> <name>strategy</name></decl></parameter>,
								 <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>, <parameter><decl><type><name>DimensionValues</name> <modifier>*</modifier></type><name>dimvalues</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>restriction_added</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* can't handle IN/ANY with multiple values */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dimvalues</name><operator>-&gt;</operator><name>use_or</name></name> <operator>&amp;&amp;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>dimvalues</name><operator>-&gt;</operator><name>values</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>item</argument>, <argument>dimvalues-&gt;values</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>restype</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type> <name>datum</name> <init>= <expr><call><name>ts_dimension_transform_value</name><argument_list>(<argument><expr><name><name>dri</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>dimension</name></name></expr></argument>,
												   <argument><expr><name>collation</name></expr></argument>,
												   <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
												   <argument><expr><name><name>dimvalues</name><operator>-&gt;</operator><name>type</name></name></expr></argument>,
												   <argument><expr><operator>&amp;</operator><name>restype</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int64</name></type> <name>value</name> <init>= <expr><call><name>ts_time_value_to_internal_or_infinite</name><argument_list>(<argument><expr><name>datum</name></expr></argument>, <argument><expr><name>restype</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><name>strategy</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>BTLessEqualStrategyNumber</name></expr>:</case>
			<case>case <expr><name>BTLessStrategyNumber</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name><name>dri</name><operator>-&gt;</operator><name>upper_strategy</name></name> <operator>==</operator> <name>InvalidStrategy</name> <operator>||</operator> <name>value</name> <operator>&lt;</operator> <name><name>dri</name><operator>-&gt;</operator><name>upper_bound</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>dri</name><operator>-&gt;</operator><name>upper_strategy</name></name> <operator>=</operator> <name>strategy</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>dri</name><operator>-&gt;</operator><name>upper_bound</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>restriction_added</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><name>BTGreaterEqualStrategyNumber</name></expr>:</case>
			<case>case <expr><name>BTGreaterStrategyNumber</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name><name>dri</name><operator>-&gt;</operator><name>lower_strategy</name></name> <operator>==</operator> <name>InvalidStrategy</name> <operator>||</operator> <name>value</name> <operator>&gt;</operator> <name><name>dri</name><operator>-&gt;</operator><name>lower_bound</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>dri</name><operator>-&gt;</operator><name>lower_strategy</name></name> <operator>=</operator> <name>strategy</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>dri</name><operator>-&gt;</operator><name>lower_bound</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>restriction_added</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><name>BTEqualStrategyNumber</name></expr>:</case>
				<expr_stmt><expr><name><name>dri</name><operator>-&gt;</operator><name>lower_bound</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>dri</name><operator>-&gt;</operator><name>upper_bound</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>dri</name><operator>-&gt;</operator><name>lower_strategy</name></name> <operator>=</operator> <name>BTGreaterEqualStrategyNumber</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>dri</name><operator>-&gt;</operator><name>upper_strategy</name></name> <operator>=</operator> <name>BTLessEqualStrategyNumber</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>restriction_added</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<comment type="block">/* unsupported strategy */</comment>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block>
	<return>return <expr><name>restriction_added</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>dimension_restrict_info_get_partitions</name><parameter_list>(<parameter><decl><type><name>DimensionRestrictInfoClosed</name> <modifier>*</modifier></type><name>dri</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>,
									   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>values</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>partitions</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>item</argument>, <argument>values</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type> <name>value</name> <init>= <expr><call><name>ts_dimension_transform_value</name><argument_list>(<argument><expr><name><name>dri</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>dimension</name></name></expr></argument>,
												   <argument><expr><name>collation</name></expr></argument>,
												   <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
												   <argument><expr><name>InvalidOid</name></expr></argument>,
												   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>partitions</name> <operator>=</operator> <call><name>list_append_unique_int</name><argument_list>(<argument><expr><name>partitions</name></expr></argument>, <argument><expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>partitions</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>dimension_restrict_info_closed_add</name><parameter_list>(<parameter><decl><type><name>DimensionRestrictInfoClosed</name> <modifier>*</modifier></type><name>dri</name></decl></parameter>, <parameter><decl><type><name>StrategyNumber</name></type> <name>strategy</name></decl></parameter>,
								   <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>, <parameter><decl><type><name>DimensionValues</name> <modifier>*</modifier></type><name>dimvalues</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>partitions</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>restriction_added</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>strategy</name> <operator>!=</operator> <name>BTEqualStrategyNumber</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>partitions</name> <operator>=</operator> <call><name>dimension_restrict_info_get_partitions</name><argument_list>(<argument><expr><name>dri</name></expr></argument>, <argument><expr><name>collation</name></expr></argument>, <argument><expr><name><name>dimvalues</name><operator>-&gt;</operator><name>values</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* the intersection is empty when using ALL operator (ANDing values)  */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>partitions</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>dimvalues</name><operator>-&gt;</operator><name>use_or</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>dri</name><operator>-&gt;</operator><name>strategy</name></name> <operator>=</operator> <name>strategy</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dri</name><operator>-&gt;</operator><name>partitions</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dri</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>InvalidStrategy</name></expr>)</condition>
	<comment type="block">/* first time through */</comment>
	<block>{<block_content>
		<expr_stmt><expr><name><name>dri</name><operator>-&gt;</operator><name>partitions</name></name> <operator>=</operator> <name>partitions</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dri</name><operator>-&gt;</operator><name>strategy</name></name> <operator>=</operator> <name>strategy</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>restriction_added</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* intersection with NULL is NULL */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>dri</name><operator>-&gt;</operator><name>partitions</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * We are always ANDing the expressions thus intersection is used.
		 */</comment>
		<expr_stmt><expr><name><name>dri</name><operator>-&gt;</operator><name>partitions</name></name> <operator>=</operator> <call><name>list_intersection_int</name><argument_list>(<argument><expr><name><name>dri</name><operator>-&gt;</operator><name>partitions</name></name></expr></argument>, <argument><expr><name>partitions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* no intersection is also a restriction  */</comment>
		<expr_stmt><expr><name>restriction_added</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>restriction_added</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>dimension_restrict_info_add</name><parameter_list>(<parameter><decl><type><name>DimensionRestrictInfo</name> <modifier>*</modifier></type><name>dri</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>strategy</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>,
							<parameter><decl><type><name>DimensionValues</name> <modifier>*</modifier></type><name>values</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name><name>dri</name><operator>-&gt;</operator><name>dimension</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>DIMENSION_TYPE_OPEN</name></expr>:</case>
			<return>return <expr><call><name>dimension_restrict_info_open_add</name><argument_list>(<argument><expr><operator>(</operator><name>DimensionRestrictInfoOpen</name> <operator>*</operator><operator>)</operator> <name>dri</name></expr></argument>,
													<argument><expr><name>strategy</name></expr></argument>,
													<argument><expr><name>collation</name></expr></argument>,
													<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>DIMENSION_TYPE_CLOSED</name></expr>:</case>
			<return>return <expr><call><name>dimension_restrict_info_closed_add</name><argument_list>(<argument><expr><operator>(</operator><name>DimensionRestrictInfoClosed</name> <operator>*</operator><operator>)</operator> <name>dri</name></expr></argument>,
													  <argument><expr><name>strategy</name></expr></argument>,
													  <argument><expr><name>collation</name></expr></argument>,
													  <argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</return>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unknown dimension type: %d"</literal></expr></argument>, <argument><expr><name><name>dri</name><operator>-&gt;</operator><name>dimension</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* suppress compiler warning on MSVC */</comment>
			<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <name>HypertableRestrictInfo</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>num_base_restrictions</name></decl>;</decl_stmt> <comment type="block">/* number of base restrictions
								* successfully added */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>num_dimensions</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DimensionRestrictInfo</name> <modifier>*</modifier></type><name><name>dimension_restriction</name><index>[<expr><name>FLEXIBLE_ARRAY_MEMBER</name></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* array of dimension
																		  * restrictions */</comment>
}</block></struct></type> <name>HypertableRestrictInfo</name>;</typedef>

<function><type><name>HypertableRestrictInfo</name> <modifier>*</modifier></type>
<name>ts_hypertable_restrict_info_create</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>num_dimensions</name> <init>= <expr><name><name>ht</name><operator>-&gt;</operator><name>space</name><operator>-&gt;</operator><name>num_dimensions</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HypertableRestrictInfo</name> <modifier>*</modifier></type><name>res</name> <init>=
		<expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HypertableRestrictInfo</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DimensionRestrictInfo</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>num_dimensions</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>num_dimensions</name></name> <operator>=</operator> <name>num_dimensions</name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_dimensions</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DimensionRestrictInfo</name> <modifier>*</modifier></type><name>dri</name> <init>= <expr><call><name>dimension_restrict_info_create</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ht</name><operator>-&gt;</operator><name>space</name><operator>-&gt;</operator><name>dimensions</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>dimension_restriction</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>dri</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DimensionRestrictInfo</name> <modifier>*</modifier></type>
<name>hypertable_restrict_info_get</name><parameter_list>(<parameter><decl><type><name>HypertableRestrictInfo</name> <modifier>*</modifier></type><name>hri</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>attno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>hri</name><operator>-&gt;</operator><name>num_dimensions</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>hri</name><operator>-&gt;</operator><name>dimension_restriction</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>dimension</name><operator>-&gt;</operator><name>column_attno</name></name> <operator>==</operator> <name>attno</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name><name>hri</name><operator>-&gt;</operator><name>dimension_restriction</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <function_decl><type><name>DimensionValues</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>get_dimension_values</name>)<parameter_list>(<parameter><decl><type><name>Const</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>use_or</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>hypertable_restrict_info_add_expr</name><parameter_list>(<parameter><decl><type><name>HypertableRestrictInfo</name> <modifier>*</modifier></type><name>hri</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>expr_args</name></decl></parameter>,
								  <parameter><decl><type><name>Oid</name></type> <name>op_oid</name></decl></parameter>, <parameter><decl><type><name>get_dimension_values</name></type> <name>func_get_dim_values</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>use_or</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>leftop</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>rightop</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DimensionRestrictInfo</name> <modifier>*</modifier></type><name>dri</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>c</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>columntype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>tce</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>strategy</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>lefttype</name></decl>, <decl><type ref="prev"/><name>righttype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DimensionValues</name> <modifier>*</modifier></type><name>dimvalues</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>expr_args</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>leftop</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>expr_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rightop</name> <operator>=</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name>expr_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>leftop</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>leftop</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>leftop</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>rightop</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>rightop</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>rightop</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>leftop</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>leftop</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>expr</name> <operator>=</operator> <name>rightop</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>rightop</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>rightop</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>expr</name> <operator>=</operator> <name>leftop</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>op_oid</name> <operator>=</operator> <call><name>get_commutator</name><argument_list>(<argument><expr><name>op_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>dri</name> <operator>=</operator> <call><name>hypertable_restrict_info_get</name><argument_list>(<argument><expr><name>hri</name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* the attribute is not a dimension */</comment>
	<if_stmt><if>if <condition>(<expr><name>dri</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>eval_const_expressions</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>op_oid</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>op_strict</name><argument_list>(<argument><expr><name>op_oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr>;</expr_stmt>

	<comment type="block">/* quick check for a NULL constant */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>constisnull</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>columntype</name> <operator>=</operator> <call><name>get_atttype</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name><name>dri</name><operator>-&gt;</operator><name>dimension</name><operator>-&gt;</operator><name>column_attno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tce</name> <operator>=</operator> <call><name>lookup_type_cache</name><argument_list>(<argument><expr><name>columntype</name></expr></argument>, <argument><expr><name>TYPECACHE_BTREE_OPFAMILY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>op_in_opfamily</name><argument_list>(<argument><expr><name>op_oid</name></expr></argument>, <argument><expr><name><name>tce</name><operator>-&gt;</operator><name>btree_opf</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>get_op_opfamily_properties</name><argument_list>(<argument><expr><name>op_oid</name></expr></argument>, <argument><expr><name><name>tce</name><operator>-&gt;</operator><name>btree_opf</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>strategy</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lefttype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>righttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dimvalues</name> <operator>=</operator> <call><name>func_get_dim_values</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>use_or</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>dimension_restrict_info_add</name><argument_list>(<argument><expr><name>dri</name></expr></argument>, <argument><expr><name>strategy</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>constcollid</name></name></expr></argument>, <argument><expr><name>dimvalues</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DimensionValues</name> <modifier>*</modifier></type>
<name>dimension_values_create</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>use_or</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DimensionValues</name> <modifier>*</modifier></type><name>dimvalues</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dimvalues</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DimensionValues</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dimvalues</name><operator>-&gt;</operator><name>values</name></name> <operator>=</operator> <name>values</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dimvalues</name><operator>-&gt;</operator><name>use_or</name></name> <operator>=</operator> <name>use_or</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dimvalues</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>

	<return>return <expr><name>dimvalues</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DimensionValues</name> <modifier>*</modifier></type>
<name>dimension_values_create_from_array</name><parameter_list>(<parameter><decl><type><name>Const</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>user_or</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayIterator</name></type> <name>iterator</name> <init>= <expr><call><name>array_create_iterator</name><argument_list>(<argument><expr><call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>elem</name> <init>= <expr><operator>(</operator><name>Datum</name><operator>)</operator> <name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>values</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>base_el_type</name></decl>;</decl_stmt>

	<while>while <condition>(<expr><call><name>array_iterate</name><argument_list>(<argument><expr><name>iterator</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elem</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>values</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/* it's an array type, lets get the base element type */</comment>
	<expr_stmt><expr><name>base_el_type</name> <operator>=</operator> <call><name>get_element_type</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>consttype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>base_el_type</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			 <argument><expr><literal type="string">"invalid base element type for array type: \"%s\""</literal></expr></argument>,
			 <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>consttype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><call><name>dimension_values_create</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><name>base_el_type</name></expr></argument>, <argument><expr><name>user_or</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DimensionValues</name> <modifier>*</modifier></type>
<name>dimension_values_create_from_single_element</name><parameter_list>(<parameter><decl><type><name>Const</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>user_or</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>dimension_values_create</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name><name>c</name><operator>-&gt;</operator><name>consttype</name></name></expr></argument>,
								   <argument><expr><name>user_or</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>hypertable_restrict_info_add_restrict_info</name><parameter_list>(<parameter><decl><type><name>HypertableRestrictInfo</name> <modifier>*</modifier></type><name>hri</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
										   <parameter><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>ri</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>added</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>e</name> <init>= <expr><name><name>ri</name><operator>-&gt;</operator><name>clause</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Same as constraint_exclusion */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>contain_mutable_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>e</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_OpExpr</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>op_expr</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>e</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>added</name> <operator>=</operator> <call><name>hypertable_restrict_info_add_expr</name><argument_list>(<argument><expr><name>hri</name></expr></argument>,
													  <argument><expr><name>root</name></expr></argument>,
													  <argument><expr><name><name>op_expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>,
													  <argument><expr><name><name>op_expr</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>,
													  <argument><expr><name>dimension_values_create_from_single_element</name></expr></argument>,
													  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>T_ScalarArrayOpExpr</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ScalarArrayOpExpr</name> <modifier>*</modifier></type><name>scalar_expr</name> <init>= <expr><operator>(</operator><name>ScalarArrayOpExpr</name> <operator>*</operator><operator>)</operator> <name>e</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>added</name> <operator>=</operator> <call><name>hypertable_restrict_info_add_expr</name><argument_list>(<argument><expr><name>hri</name></expr></argument>,
													  <argument><expr><name>root</name></expr></argument>,
													  <argument><expr><name><name>scalar_expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>,
													  <argument><expr><name><name>scalar_expr</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>,
													  <argument><expr><name>dimension_values_create_from_array</name></expr></argument>,
													  <argument><expr><name><name>scalar_expr</name><operator>-&gt;</operator><name>useOr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>
		<default>default:</default>
			<comment type="block">/* we don't support other node types */</comment>
			<break>break;</break>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><name>added</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>hri</name><operator>-&gt;</operator><name>num_base_restrictions</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ts_hypertable_restrict_info_add</name><parameter_list>(<parameter><decl><type><name>HypertableRestrictInfo</name> <modifier>*</modifier></type><name>hri</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
								<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>base_restrict_infos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>base_restrict_infos</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>ri</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>hypertable_restrict_info_add_restrict_info</name><argument_list>(<argument><expr><name>hri</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ts_hypertable_restrict_info_has_restrictions</name><parameter_list>(<parameter><decl><type><name>HypertableRestrictInfo</name> <modifier>*</modifier></type><name>hri</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>hri</name><operator>-&gt;</operator><name>num_base_restrictions</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Scan for dimension slices matching query constraints.
 *
 * Matching slices are appended to to the given dimension vector. Note that we
 * keep the table and index open as long as we do not change the number of
 * scan keys. If the keys change, but the number of keys is the same, we can
 * simply "rescan". If the number of keys change, however, we need to end the
 * scan and start again.
 */</comment>
<function><type><specifier>static</specifier> <name>DimensionVec</name> <modifier>*</modifier></type>
<name>scan_and_append_slices</name><parameter_list>(<parameter><decl><type><name>ScanIterator</name> <modifier>*</modifier></type><name>it</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>old_nkeys</name></decl></parameter>, <parameter><decl><type><name>DimensionVec</name> <modifier>*</modifier><modifier>*</modifier></type><name>dv</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>unique</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>old_nkeys</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>old_nkeys</name> <operator>!=</operator> <name><name>it</name><operator>-&gt;</operator><name>ctx</name><operator>.</operator><name>nkeys</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ts_scan_iterator_end</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ts_scan_iterator_start_or_restart_scan</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>ts_scan_iterator_next</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name> <init>= <expr><call><name>ts_scan_iterator_tuple_info</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DimensionSlice</name> <modifier>*</modifier></type><name>slice</name> <init>= <expr><call><name>ts_dimension_slice_from_tuple</name><argument_list>(<argument><expr><name>ti</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>slice</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>unique</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>dv</name> <operator>=</operator> <call><name>ts_dimension_vec_add_unique_slice</name><argument_list>(<argument><expr><name>dv</name></expr></argument>, <argument><expr><name>slice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>dv</name> <operator>=</operator> <call><name>ts_dimension_vec_add_slice</name><argument_list>(<argument><expr><name>dv</name></expr></argument>, <argument><expr><name>slice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><operator>*</operator><name>dv</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* search dimension_slice catalog table for slices that meet hri restriction
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>gather_restriction_dimension_vectors</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>HypertableRestrictInfo</name> <modifier>*</modifier></type><name>hri</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>dimension_vecs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanIterator</name></type> <name>it</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>old_nkeys</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>it</name> <operator>=</operator> <call><name>ts_dimension_slice_scan_iterator_create</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>hri</name><operator>-&gt;</operator><name>num_dimensions</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>DimensionRestrictInfo</name> <modifier>*</modifier></type><name>dri</name> <init>= <expr><name><name>hri</name><operator>-&gt;</operator><name>dimension_restriction</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DimensionVec</name> <modifier>*</modifier></type><name>dv</name> <init>= <expr><call><name>ts_dimension_vec_create</name><argument_list>(<argument><expr><name>DIMENSION_VEC_DEFAULT_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>dri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<switch>switch <condition>(<expr><name><name>dri</name><operator>-&gt;</operator><name>dimension</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>DIMENSION_TYPE_OPEN</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><specifier>const</specifier> <name>DimensionRestrictInfoOpen</name> <modifier>*</modifier></type><name>open</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>DimensionRestrictInfoOpen</name> <operator>*</operator><operator>)</operator> <name>dri</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>ts_dimension_slice_scan_iterator_set_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>,
														   <argument><expr><name><name>open</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>dimension</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>,
														   <argument><expr><name><name>open</name><operator>-&gt;</operator><name>upper_strategy</name></name></expr></argument>,
														   <argument><expr><name><name>open</name><operator>-&gt;</operator><name>upper_bound</name></name></expr></argument>,
														   <argument><expr><name><name>open</name><operator>-&gt;</operator><name>lower_strategy</name></name></expr></argument>,
														   <argument><expr><name><name>open</name><operator>-&gt;</operator><name>lower_bound</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * If we have a condition on the second index column
				 * range_start, use a backward scan direction, so that the index
				 * is able to use the second column as well to choose the
				 * starting point for the scan.
				 * If not, prefer forward direction, because backwards scan is
				 * slightly slower for some reason.
				 * Ideally we need some other index type than btree for this,
				 * because the btree index is not so suited for queries like
				 * "find an interval that contains a given point", which is what
				 * we're doing here.
				 * There is a comment in the Postgres code (_bt_start()) that
				 * explains the logic of selecting a starting point for a btree
				 * index scan in more detail.
				 */</comment>
				<expr_stmt><expr><name><name>it</name><operator>.</operator><name>ctx</name><operator>.</operator><name>scandirection</name></name> <operator>=</operator> <ternary><condition><expr><name><name>open</name><operator>-&gt;</operator><name>upper_strategy</name></name> <operator>!=</operator> <name>InvalidStrategy</name></expr> ?</condition><then>
										   <expr><name>BackwardScanDirection</name></expr> </then><else>:
										   <expr><name>ForwardScanDirection</name></expr></else></ternary></expr>;</expr_stmt>

				<expr_stmt><expr><name>dv</name> <operator>=</operator> <call><name>scan_and_append_slices</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><name>old_nkeys</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dv</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>
			<case>case <expr><name>DIMENSION_TYPE_CLOSED</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><specifier>const</specifier> <name>DimensionRestrictInfoClosed</name> <modifier>*</modifier></type><name>closed</name> <init>=
					<expr><operator>(</operator><specifier>const</specifier> <name>DimensionRestrictInfoClosed</name> <operator>*</operator><operator>)</operator> <name>dri</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* Shouldn't have trivial restriction infos here. */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>closed</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>BTEqualStrategyNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
				<macro><name>foreach</name> <argument_list>(<argument>cell</argument>, <argument>closed-&gt;partitions</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int32</name></type> <name>partition</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<comment type="block">/*
					 * slice_end &gt;= value &amp;&amp; slice_start &lt;= value.
					 * See the comment about scan direction above.
					 */</comment>
					<expr_stmt><expr><name><name>it</name><operator>.</operator><name>ctx</name><operator>.</operator><name>scandirection</name></name> <operator>=</operator> <name>BackwardScanDirection</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>ts_dimension_slice_scan_iterator_set_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>,
															   <argument><expr><name><name>dri</name><operator>-&gt;</operator><name>dimension</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>,
															   <argument><expr><name>BTLessEqualStrategyNumber</name></expr></argument>,
															   <argument><expr><name>partition</name></expr></argument>,
															   <argument><expr><name>BTGreaterEqualStrategyNumber</name></expr></argument>,
															   <argument><expr><name>partition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name>dv</name> <operator>=</operator> <call><name>scan_and_append_slices</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><name>old_nkeys</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dv</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<break>break;</break>
			</block_content>}</block>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unknown dimension type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></switch>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>dv</name><operator>-&gt;</operator><name>num_slices</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If there is a dimension where no slices match, the result will be
		 * empty.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>dv</name><operator>-&gt;</operator><name>num_slices</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ts_scan_iterator_close</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NIL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>dv</name> <operator>=</operator> <call><name>ts_dimension_vec_sort</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>dimension_vecs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>dimension_vecs</name></expr></argument>, <argument><expr><name>dv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>old_nkeys</name> <operator>=</operator> <name><name>it</name><operator>.</operator><name>ctx</name><operator>.</operator><name>nkeys</name></name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>ts_scan_iterator_close</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>dimension_vecs</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>hri</name><operator>-&gt;</operator><name>num_dimensions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>dimension_vecs</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Chunk</name> <modifier>*</modifier><modifier>*</modifier></type>
<name>ts_hypertable_restrict_info_get_chunks</name><parameter_list>(<parameter><decl><type><name>HypertableRestrictInfo</name> <modifier>*</modifier></type><name>hri</name></decl></parameter>, <parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>,
									   <parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>num_chunks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Remove the dimensions for which we don't have a restriction, that is,
	 * the entire range of the dimension matches. Such dimensions do not
	 * influence the result set, because their every slice matches, so we can
	 * just ignore them when searching for the matching chunks.
	 */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>old_dimensions</name> <init>= <expr><name><name>hri</name><operator>-&gt;</operator><name>num_dimensions</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>hri</name><operator>-&gt;</operator><name>num_dimensions</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>old_dimensions</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DimensionRestrictInfo</name> <modifier>*</modifier></type><name>dri</name> <init>= <expr><name><name>hri</name><operator>-&gt;</operator><name>dimension_restriction</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>dimension_restrict_info_is_trivial</name><argument_list>(<argument><expr><name>dri</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>hri</name><operator>-&gt;</operator><name>dimension_restriction</name><index>[<expr><name><name>hri</name><operator>-&gt;</operator><name>num_dimensions</name></name></expr>]</index></name> <operator>=</operator> <name>dri</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>hri</name><operator>-&gt;</operator><name>num_dimensions</name></name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>chunk_ids</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>hri</name><operator>-&gt;</operator><name>num_dimensions</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * No restrictions on hyperspace. Just enumerate all the chunks.
		 */</comment>
		<expr_stmt><expr><name>chunk_ids</name> <operator>=</operator> <call><name>ts_chunk_get_chunk_ids_by_hypertable_id</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Have some restrictions, enumerate the matching dimension slices.
		 */</comment>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>dimension_vectors</name> <init>= <expr><call><name>gather_restriction_dimension_vectors</name><argument_list>(<argument><expr><name>hri</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>dimension_vectors</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * No dimension slices match for some dimension for which there is
			 * a restriction. This means that no chunks match.
			 */</comment>
			<expr_stmt><expr><name>chunk_ids</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Find the chunks matching these dimension slices. */</comment>
			<expr_stmt><expr><name>chunk_ids</name> <operator>=</operator> <call><name>ts_chunk_id_find_in_subspace</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>dimension_vectors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * Always include the OSM chunk if we have one. It has some virtual
		 * dimension slices (at the moment, (+inf, +inf) slice for time, but it
		 * used to be different and might change again.) So sometimes it will
		 * match and sometimes it won't, so we have to check if it's already
		 * there not to add a duplicate.
		 */</comment>
		<decl_stmt><decl><type><name>int32</name></type> <name>osm_chunk_id</name> <init>= <expr><call><name>ts_chunk_get_osm_chunk_id</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>osm_chunk_id</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>list_member_int</name><argument_list>(<argument><expr><name>chunk_ids</name></expr></argument>, <argument><expr><name>osm_chunk_id</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>chunk_ids</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>chunk_ids</name></expr></argument>, <argument><expr><name>osm_chunk_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Sort the ids to have more favorable (closer to sequential) data access
	 * patterns to our catalog tables and indexes.
	 * We don't care about the locking order here, because this code uses
	 * AccessShareLock that doesn't conflict with itself.
	 */</comment>
	<expr_stmt><expr><name>chunk_ids</name> <operator>=</operator> <call><name>list_sort_compat</name><argument_list>(<argument><expr><name>chunk_ids</name></expr></argument>, <argument><expr><name>list_int_cmp_compat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>ts_chunk_scan_by_chunk_ids</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>space</name></name></expr></argument>, <argument><expr><name>chunk_ids</name></expr></argument>, <argument><expr><name>num_chunks</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Compare two chunks along first dimension and chunk ID (in that priority and
 * order).
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>chunk_cmp_impl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Chunk</name> <modifier>*</modifier></type><name>c1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Chunk</name> <modifier>*</modifier></type><name>c2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>cmp</name> <init>= <expr><call><name>ts_dimension_slice_cmp</name><argument_list>(<argument><expr><name><name>c1</name><operator>-&gt;</operator><name>cube</name><operator>-&gt;</operator><name>slices</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>c2</name><operator>-&gt;</operator><name>cube</name><operator>-&gt;</operator><name>slices</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>VALUE_CMP</name><argument_list>(<argument><expr><name><name>c1</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>, <argument><expr><name><name>c2</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>cmp</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>chunk_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>c1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>c2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>chunk_cmp_impl</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>Chunk</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>c1</name><operator>)</operator></expr></argument>, <argument><expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>Chunk</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>c2</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>chunk_cmp_reverse</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>c1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>c2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>chunk_cmp_impl</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>Chunk</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>c2</name><operator>)</operator></expr></argument>, <argument><expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>Chunk</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>c1</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get chunk oids ordered by time dimension
 *
 * if "chunks" is NULL, we get all the chunks from the catalog. Otherwise we
 * restrict ourselves to the passed in chunks list.
 *
 * nested_oids is a list of lists, chunks that occupy the same time slice will be
 * in the same list. In the list [[1,2,3],[4,5,6]] chunks 1, 2 and 3 are space partitions of
 * the same time slice and 4, 5 and 6 are space partitions of the next time slice.
 *
 */</comment>
<function><type><name>Chunk</name> <modifier>*</modifier><modifier>*</modifier></type>
<name>ts_hypertable_restrict_info_get_chunks_ordered</name><parameter_list>(<parameter><decl><type><name>HypertableRestrictInfo</name> <modifier>*</modifier></type><name>hri</name></decl></parameter>, <parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>,
											   <parameter><decl><type><name>Chunk</name> <modifier>*</modifier><modifier>*</modifier></type><name>chunks</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>reverse</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>nested_oids</name></decl></parameter>,
											   <parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>num_chunks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>slot_chunk_oids</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DimensionSlice</name> <modifier>*</modifier></type><name>slice</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>chunks</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>chunks</name> <operator>=</operator> <call><name>ts_hypertable_restrict_info_get_chunks</name><argument_list>(<argument><expr><name>hri</name></expr></argument>, <argument><expr><name>ht</name></expr></argument>, <argument><expr><name>num_chunks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>num_chunks</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>space</name><operator>-&gt;</operator><name>num_dimensions</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IS_OPEN_DIMENSION</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ht</name><operator>-&gt;</operator><name>space</name><operator>-&gt;</operator><name>dimensions</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>reverse</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>chunks</name></expr></argument>, <argument><expr><operator>*</operator><name>num_chunks</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Chunk</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>chunk_cmp_reverse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>chunks</name></expr></argument>, <argument><expr><operator>*</operator><name>num_chunks</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Chunk</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>chunk_cmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>*</operator><name>num_chunks</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name> <init>= <expr><name><name>chunks</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>slice</name> <operator>&amp;&amp;</operator> <call><name>ts_dimension_slice_cmp</name><argument_list>(<argument><expr><name>slice</name></expr></argument>, <argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>cube</name><operator>-&gt;</operator><name>slices</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<name>slot_chunk_oids</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>nested_oids</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>nested_oids</name></expr></argument>, <argument><expr><name>slot_chunk_oids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>slot_chunk_oids</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>nested_oids</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>slot_chunk_oids</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>slot_chunk_oids</name></expr></argument>, <argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>table_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>slice</name> <operator>=</operator> <name><name>chunk</name><operator>-&gt;</operator><name>cube</name><operator>-&gt;</operator><name>slices</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>slot_chunk_oids</name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>nested_oids</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>nested_oids</name></expr></argument>, <argument><expr><name>slot_chunk_oids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>chunks</name></expr>;</return>
</block_content>}</block></function>
</unit>
