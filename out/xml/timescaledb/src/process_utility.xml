<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/timescaledb/src/process_utility.c"><comment type="block">/*
 * This file and its contents are licensed under the Apache License 2.0.
 * Please see the included NOTICE for copyright information and
 * LICENSE-APACHE for a copy of the license.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postgres.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;foreign/foreign.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/parsenodes.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/nodes.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/makefuncs.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;tcop/utility.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/namespace.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/index.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/objectaddress.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_trigger.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;commands/copy.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;commands/vacuum.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;commands/defrem.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;commands/trigger.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;commands/tablecmds.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;commands/cluster.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;commands/event_trigger.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;commands/prepare.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/htup_details.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;commands/alter.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/xact.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;storage/lmgr.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/acl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/rel.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/inval.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/lsyscache.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/syscache.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/builtins.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/guc.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/snapmgr.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;parser/parse_utilcmd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;commands/tablespace.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_constraint.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_inherits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compat/compat.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;miscadmin.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"annotations.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"export.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"extension_constants.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"process_utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ts_catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"chunk.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"chunk_index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ts_catalog/chunk_data_node.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compat/compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"copy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"errors.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"event_trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"extension.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hypercube.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hypertable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hypertable_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ts_catalog/hypertable_data_node.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dimension_vector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"scan_iterator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"time_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"with_clause_parser.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cross_module_fn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ts_catalog/continuous_agg.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compression_with_clause.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"partitioning.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"debug_point.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_TELEMETRY</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"telemetry/functions.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cross_module_fn.h"</cpp:file></cpp:include>

<function_decl><type><name>void</name></type> <name>_process_utility_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>_process_utility_fini</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <name>ProcessUtility_hook_type</name></type> <name>prev_ProcessUtility_hook</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>expect_chunk_modification</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<function_decl><type><specifier>static</specifier> <name>DDLResult</name></type> <name>process_altertable_set_options</name><parameter_list>(<parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>DDLResult</name></type> <name>process_altertable_reset_options</name><parameter_list>(<parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Call the default ProcessUtility and handle PostgreSQL version differences */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>prev_ProcessUtility</name><parameter_list>(<parameter><decl><type><name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ProcessUtility_hook_type</name></type> <name>hook</name> <init>=
		<expr><ternary><condition><expr><name>prev_ProcessUtility_hook</name></expr> ?</condition><then> <expr><name>prev_ProcessUtility_hook</name></expr> </then><else>: <expr><name>standard_ProcessUtility</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>hook</name><argument_list>(<argument><expr><name><name>args</name><operator>-&gt;</operator><name>pstmt</name></name></expr></argument>,
		 <argument><expr><name><name>args</name><operator>-&gt;</operator><name>query_string</name></name></expr></argument>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_GE</name></expr></cpp:if>
		 <argument><expr><name><name>args</name><operator>-&gt;</operator><name>readonly_tree</name></name></expr></argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		 <argument><expr><name><name>args</name><operator>-&gt;</operator><name>context</name></name></expr></argument>,
		 <argument><expr><name><name>args</name><operator>-&gt;</operator><name>params</name></name></expr></argument>,
		 <argument><expr><name><name>args</name><operator>-&gt;</operator><name>queryEnv</name></name></expr></argument>,
		 <argument><expr><name><name>args</name><operator>-&gt;</operator><name>dest</name></name></expr></argument>,
		 <argument><expr><name><name>args</name><operator>-&gt;</operator><name>completion_tag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ObjectType</name></type>
<name>get_altertable_objecttype</name><parameter_list>(<parameter><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_GE</name></expr></cpp:if>
	<return>return <expr><name><name>stmt</name><operator>-&gt;</operator><name>objtype</name></name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<return>return <expr><name><name>stmt</name><operator>-&gt;</operator><name>relkind</name></name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ObjectType</name></type>
<name>get_createtableas_objecttype</name><parameter_list>(<parameter><decl><type><name>CreateTableAsStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_GE</name></expr></cpp:if>
	<return>return <expr><name><name>stmt</name><operator>-&gt;</operator><name>objtype</name></name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<return>return <expr><name><name>stmt</name><operator>-&gt;</operator><name>relkind</name></name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_chunk_alter_table_operation_allowed</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>expect_chunk_modification</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ts_chunk_exists_relid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>all_allowed</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<comment type="block">/* only allow if all commands are allowed */</comment>
		<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>stmt-&gt;cmds</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><operator>(</operator><name>AlterTableCmd</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<switch>switch <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>AT_SetOptions</name></expr>:</case>
				<case>case <expr><name>AT_ResetOptions</name></expr>:</case>
				<case>case <expr><name>AT_SetRelOptions</name></expr>:</case>
				<case>case <expr><name>AT_ResetRelOptions</name></expr>:</case>
				<case>case <expr><name>AT_ReplaceRelOptions</name></expr>:</case>
				<case>case <expr><name>AT_SetStatistics</name></expr>:</case>
				<case>case <expr><name>AT_SetStorage</name></expr>:</case>
				<case>case <expr><name>AT_DropCluster</name></expr>:</case>
				<case>case <expr><name>AT_ClusterOn</name></expr>:</case>
				<case>case <expr><name>AT_EnableRowSecurity</name></expr>:</case>
				<case>case <expr><name>AT_DisableRowSecurity</name></expr>:</case>
				<case>case <expr><name>AT_SetTableSpace</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_GE</name></expr></cpp:if>
				<case>case <expr><name>AT_ReAddStatistics</name></expr>:</case>
				<case>case <expr><name>AT_SetCompression</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
					<comment type="block">/* allowed on chunks */</comment>
					<break>break;</break>
				<default>default:</default>
					<comment type="block">/* disable by default */</comment>
					<expr_stmt><expr><name>all_allowed</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>all_allowed</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"operation not supported on chunk tables"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* we block some ALTER commands on continuous aggregate materialization tables
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_continuous_agg_alter_table_allowed</name><parameter_list>(<parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ContinuousAggHypertableStatus</name></type> <name>status</name> <init>= <expr><call><name>ts_continuous_agg_hypertable_status</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>status</name> <operator>&amp;</operator> <name>HypertableIsMaterialization</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* only allow if all commands are allowed */</comment>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>stmt-&gt;cmds</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><operator>(</operator><name>AlterTableCmd</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>AT_AddIndex</name></expr>:</case>
			<case>case <expr><name>AT_ReAddIndex</name></expr>:</case>
			<case>case <expr><name>AT_SetRelOptions</name></expr>:</case>
				<comment type="block">/* allowed on materialization tables */</comment>
				<continue>continue;</continue>
			<default>default:</default>
				<comment type="block">/* disable by default */</comment>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"operation not supported on materialization tables"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_alter_table_allowed_on_ht_with_compression</name><parameter_list>(<parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TS_HYPERTABLE_HAS_COMPRESSION_ENABLED</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* only allow if all commands are allowed */</comment>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>stmt-&gt;cmds</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><operator>(</operator><name>AlterTableCmd</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * ALLOWED:
			 *
			 * This is a whitelist of allowed commands.
			 */</comment>
			<case>case <expr><name>AT_AddIndex</name></expr>:</case>
			<case>case <expr><name>AT_ReAddIndex</name></expr>:</case>
			<case>case <expr><name>AT_ResetRelOptions</name></expr>:</case>
			<case>case <expr><name>AT_ReplaceRelOptions</name></expr>:</case>
			<case>case <expr><name>AT_SetRelOptions</name></expr>:</case>
			<case>case <expr><name>AT_ClusterOn</name></expr>:</case>
			<case>case <expr><name>AT_DropCluster</name></expr>:</case>
			<case>case <expr><name>AT_ChangeOwner</name></expr>:</case>
				<comment type="block">/* this is passed down in `process_altertable_change_owner` */</comment>
			<case>case <expr><name>AT_SetTableSpace</name></expr>:</case>
				<comment type="block">/* this is passed down in `process_altertable_set_tablespace_end` */</comment>
			<case>case <expr><name>AT_SetStatistics</name></expr>:</case> <comment type="block">/* should this be pushed down in some way? */</comment>
			<case>case <expr><name>AT_AddColumn</name></expr>:</case>	   <comment type="block">/* this is passed down */</comment>
			<case>case <expr><name>AT_ColumnDefault</name></expr>:</case> <comment type="block">/* this is passed down */</comment>
			<case>case <expr><name>AT_DropColumn</name></expr>:</case>	   <comment type="block">/* this is passed down */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_GE</name></expr></cpp:if>
			<case>case <expr><name>AT_ReAddStatistics</name></expr>:</case>
			<case>case <expr><name>AT_SetCompression</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				<continue>continue;</continue>
				<comment type="block">/*
				 * BLOCKED:
				 *
				 * List things that we want to explicitly block for documentation purposes
				 * But also block everything else as well.
				 */</comment>
			<case>case <expr><name>AT_EnableRowSecurity</name></expr>:</case>
			<case>case <expr><name>AT_DisableRowSecurity</name></expr>:</case>
			<case>case <expr><name>AT_ForceRowSecurity</name></expr>:</case>
			<case>case <expr><name>AT_NoForceRowSecurity</name></expr>:</case>
			<default>default:</default>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"operation not supported on hypertables that have compression "</literal>
								<literal type="string">"enabled"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_altertable_add_column_for_compressed</name><parameter_list>(<parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>ColumnDef</name> <modifier>*</modifier></type><name>col</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>col</name><operator>-&gt;</operator><name>constraints</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>has_default</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>has_notnull</name> <init>= <expr><name><name>col</name><operator>-&gt;</operator><name>is_not_null</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>is_bool</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>col-&gt;constraints</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>constraint</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>Constraint</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<switch>switch <condition>(<expr><name><name>constraint</name><operator>-&gt;</operator><name>contype</name></name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>CONSTR_NOTNULL</name></expr>:</case>
					<expr_stmt><expr><name>has_notnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<continue>continue;</continue>
				<case>case <expr><name>CONSTR_DEFAULT</name></expr>:</case>
					<comment type="block">/*
					 * Since default expressions might trigger a table rewrite we
					 * only allow Const here for now.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>raw_expr</name></name></expr></argument>, <argument><expr><name>A_Const</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>raw_expr</name></name></expr></argument>, <argument><expr><name>TypeCast</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
							<call><name>IsA</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>TypeCast</name></expr></argument>, <argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>raw_expr</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>arg</name></expr></argument>, <argument><expr><name>A_Const</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/*
							 * Ignore error only for boolean column, as values like
							 * 'True' or 'False' are treated as TypeCast.
							 */</comment>
							<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name> <init>=
								<expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>llast</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>TypeCast</name> <operator>*</operator><operator>)</operator> <name><name>constraint</name><operator>-&gt;</operator><name>raw_expr</name></name><operator>)</operator><operator>-&gt;</operator><name><name>typeName</name><operator>-&gt;</operator><name>names</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
							<expr_stmt><expr><name>is_bool</name> <operator>=</operator> <ternary><condition><expr><call><name>strstr</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"bool"</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_bool</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errmsg</name><argument_list>(
										 <argument><expr><literal type="string">"cannot add column with non-constant default expression "</literal>
										 <literal type="string">"to a hypertable that has compression enabled"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><name>has_default</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<continue>continue;</continue>

				<default>default:</default>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot add column with constraints "</literal>
									<literal type="string">"to a hypertable that has compression enabled"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>
		</block_content>}</block>
		<comment type="block">/* require a default for columns added with NOT NULL */</comment>
		<if_stmt><if>if <condition>(<expr><name>has_notnull</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>has_default</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot add column with NOT NULL constraint without default "</literal>
							<literal type="string">"to a hypertable that has compression enabled"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>col</name><operator>-&gt;</operator><name>is_not_null</name></name> <operator>||</operator> <name><name>col</name><operator>-&gt;</operator><name>identitySequence</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot add column with constraints to a hypertable that has "</literal>
						<literal type="string">"compression enabled"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* not possible to get non-null value here this is set when
	 * ALTER TABLE ALTER COLUMN ... SET TYPE &lt; &gt; USING ...
	 * but check anyway.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>col</name><operator>-&gt;</operator><name>raw_default</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>col</name><operator>-&gt;</operator><name>cooked_default</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>relation_not_only</name><parameter_list>(<parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>rv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rv</name><operator>-&gt;</operator><name>inh</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ONLY option not supported on hypertable operations"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_hypertable_to_process_args</name><parameter_list>(<parameter><decl><type><name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>args</name><operator>-&gt;</operator><name>hypertable_list</name></name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name><name>args</name><operator>-&gt;</operator><name>hypertable_list</name></name></expr></argument>, <argument><expr><name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_table_in_rangevar_list</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rvlist</name></decl></parameter>, <parameter><decl><type><name>Name</name></type> <name>schema_name</name></decl></parameter>, <parameter><decl><type><name>Name</name></type> <name>table_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>l</argument>, <argument>rvlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>rvar</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RangeVar</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>rvar</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>table_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name><name>rvar</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>schema_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_chunk_oid</name><parameter_list>(<parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>chunk_relid</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>vargs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name> <init>= <expr><name>vargs</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GrantStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>GrantStmt</name></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>parsetree</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name> <init>= <expr><call><name>ts_chunk_get_by_relid</name><argument_list>(<argument><expr><name>chunk_relid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="block">/*
	 * If chunk is in the same schema as the hypertable it could already be part of
	 * the objects list in the case of "GRANT ALL IN SCHEMA" for example
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>check_table_in_rangevar_list</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objects</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>schema_name</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>rv</name> <init>=
			<expr><call><name>makeRangeVar</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>schema_name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>objects</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objects</name></name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>block_on_foreign_server</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>server_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ForeignServer</name> <modifier>*</modifier></type><name>server</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>server_name</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>server</name> <operator>=</operator> <call><name>GetForeignServerByName</name><argument_list>(<argument><expr><name>server_name</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>server</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>ts_fdwid</name> <init>= <expr><call><name>get_foreign_data_wrapper_oid</name><argument_list>(<argument><expr><name>EXTENSION_FDW_NAME</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>server</name><operator>-&gt;</operator><name>fdwid</name></name> <operator>==</operator> <name>ts_fdwid</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DDLResult</name></type>
<name>process_create_foreign_server_start</name><parameter_list>(<parameter><decl><type><name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CreateForeignServerStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>CreateForeignServerStmt</name> <operator>*</operator><operator>)</operator> <name><name>args</name><operator>-&gt;</operator><name>parsetree</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>EXTENSION_FDW_NAME</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>fdwname</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"operation not supported for a TimescaleDB data node"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use add_data_node() to add data nodes to a "</literal>
						 <literal type="string">"distributed database."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>DDL_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_drop_foreign_server_start</name><parameter_list>(<parameter><decl><type><name>DropStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>stmt-&gt;objects</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>servername</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>block_on_foreign_server</name><argument_list>(<argument><expr><name>servername</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"operation not supported on a TimescaleDB data node"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use delete_data_node() to remove data nodes from a "</literal>
							 <literal type="string">"distributed database."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_drop_trigger_start</name><parameter_list>(<parameter><decl><type><name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><name>DropStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cache</name> <modifier>*</modifier></type><name>hcache</name> <init>= <expr><call><name>ts_hypertable_cache_pin</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>stmt-&gt;objects</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>object</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>objaddr</name></decl>;</decl_stmt>

		<comment type="block">/* Get the relation of the trigger */</comment>
		<expr_stmt><expr><name>objaddr</name> <operator>=</operator>
			<call><name>get_object_address</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>removeType</name></name></expr></argument>, <argument><expr><name>object</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>missing_ok</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>objaddr</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>objaddr</name><operator>.</operator><name>classId</name></name> <operator>==</operator> <name>TriggerRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ht</name> <operator>=</operator>
				<call><name>ts_hypertable_cache_get_entry</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>CACHE_FLAG_MISSING_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>ht</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>add_hypertable_to_process_args</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* Lock from get_object_address must be held until transaction end */</comment>
			<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DDLResult</name></type>
<name>process_create_foreign_table_start</name><parameter_list>(<parameter><decl><type><name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CreateForeignTableStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>CreateForeignTableStmt</name> <operator>*</operator><operator>)</operator> <name><name>args</name><operator>-&gt;</operator><name>parsetree</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>block_on_foreign_server</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>servername</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"operation not supported"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(
					 <argument><expr><literal type="string">"It is not possible to create stand-alone TimescaleDB foreign tables."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>DDL_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DDLResult</name></type>
<name>process_alter_foreign_server</name><parameter_list>(<parameter><decl><type><name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlterForeignServerStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>AlterForeignServerStmt</name> <operator>*</operator><operator>)</operator> <name><name>args</name><operator>-&gt;</operator><name>parsetree</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ForeignServer</name> <modifier>*</modifier></type><name>server</name> <init>= <expr><call><name>GetForeignServerByName</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>servername</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>fdwid</name> <init>= <expr><call><name>get_foreign_data_wrapper_oid</name><argument_list>(<argument><expr><name>EXTENSION_FDW_NAME</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>server</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>server</name><operator>-&gt;</operator><name>fdwid</name></name> <operator>==</operator> <name>fdwid</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>has_version</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"version not supported"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(
						 <argument><expr><literal type="string">"It is not possible to set a version on the data node configuration."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Options are validated by the FDW, but we need to block available option
		 * since that must be handled via alter_data_node(). */</comment>
		<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>stmt-&gt;options</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>elem</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>elem</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"available"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot set \"available\" using ALTER SERVER"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use alter_data_node() to set \"available\"."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>DDL_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_altertableschema</name><parameter_list>(<parameter><decl><type><name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlterObjectSchemaStmt</name> <modifier>*</modifier></type><name>alterstmt</name> <init>= <expr><operator>(</operator><name>AlterObjectSchemaStmt</name> <operator>*</operator><operator>)</operator> <name><name>args</name><operator>-&gt;</operator><name>parsetree</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cache</name> <modifier>*</modifier></type><name>hcache</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>alterstmt</name><operator>-&gt;</operator><name>objectType</name></name> <operator>==</operator> <name>OBJECT_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>alterstmt</name><operator>-&gt;</operator><name>relation</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name><name>alterstmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>ht</name> <operator>=</operator> <call><name>ts_hypertable_cache_get_cache_and_entry</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>CACHE_FLAG_MISSING_OK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>ht</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name> <init>= <expr><call><name>ts_chunk_get_by_relid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>chunk</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ts_chunk_set_schema</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>, <argument><expr><name><name>alterstmt</name><operator>-&gt;</operator><name>newschema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ts_hypertable_set_schema</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name><name>alterstmt</name><operator>-&gt;</operator><name>newschema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>add_hypertable_to_process_args</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* We use this for both materialized views and views. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_alterviewschema</name><parameter_list>(<parameter><decl><type><name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlterObjectSchemaStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>AlterObjectSchemaStmt</name> <operator>*</operator><operator>)</operator> <name><name>args</name><operator>-&gt;</operator><name>parsetree</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>schema</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objectType</name></name> <operator>==</operator> <name>OBJECT_MATVIEW</name> <operator>||</operator> <name><name>stmt</name><operator>-&gt;</operator><name>objectType</name></name> <operator>==</operator> <name>OBJECT_VIEW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>schema</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>get_rel_name</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ts_continuous_agg_rename_view</name><argument_list>(<argument><expr><name>schema</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>newschema</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>stmt</name><operator>-&gt;</operator><name>objectType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Change the schema of a hypertable or a chunk */</comment>
<function><type><specifier>static</specifier> <name>DDLResult</name></type>
<name>process_alterobjectschema</name><parameter_list>(<parameter><decl><type><name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlterObjectSchemaStmt</name> <modifier>*</modifier></type><name>alterstmt</name> <init>= <expr><operator>(</operator><name>AlterObjectSchemaStmt</name> <operator>*</operator><operator>)</operator> <name><name>args</name><operator>-&gt;</operator><name>parsetree</name></name></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>alterstmt</name><operator>-&gt;</operator><name>objectType</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>OBJECT_TABLE</name></expr>:</case>
			<expr_stmt><expr><call><name>process_altertableschema</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_MATVIEW</name></expr>:</case>
		<case>case <expr><name>OBJECT_VIEW</name></expr>:</case>
			<expr_stmt><expr><call><name>process_alterviewschema</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>
	<return>return <expr><name>DDL_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DDLResult</name></type>
<name>process_copy</name><parameter_list>(<parameter><decl><type><name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CopyStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>CopyStmt</name> <operator>*</operator><operator>)</operator> <name><name>args</name><operator>-&gt;</operator><name>parsetree</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Needed to add the appropriate number of tuples to the completion tag
	 */</comment>
	<decl_stmt><decl><type><name>uint64</name></type> <name>processed</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cache</name> <modifier>*</modifier></type><name>hcache</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relid</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>DDL_CONTINUE</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>ht</name> <operator>=</operator> <call><name>ts_hypertable_cache_get_cache_and_entry</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>CACHE_FLAG_MISSING_OK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>ht</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>DDL_CONTINUE</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* We only copy for COPY FROM (which copies into a hypertable). Since
	 * hypertable data are in the hypertable chunks and no data would be
	 * copied, we skip the copy for COPY TO, but print an informative
	 * message. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>is_from</name></name> <operator>||</operator> <name>NULL</name> <operator>==</operator> <name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>ht</name> <operator>&amp;&amp;</operator> <name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"hypertable data are in the chunks, no data will be copied"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Data for hypertables are stored in the chunks of a hypertable so "</literal>
							   <literal type="string">"COPY TO of a hypertable will not copy any data."</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use \"COPY (SELECT * FROM &lt;hypertable&gt;) TO ...\" to copy all data in "</literal>
							 <literal type="string">"hypertable, or copy each chunk individually."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>hcache</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<return>return <expr><name>DDL_CONTINUE</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PreventCommandIfReadOnly</name><argument_list>(<argument><expr><literal type="string">"COPY FROM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Performs acl check in here inside `copy_security_check` */</comment>
	<expr_stmt><expr><call><name>timescaledb_DoCopy</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>query_string</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>processed</name></expr></argument>, <argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG13_GE</name></expr></cpp:if>
	<expr_stmt><expr><name><name>args</name><operator>-&gt;</operator><name>completion_tag</name><operator>-&gt;</operator><name>commandTag</name></name> <operator>=</operator> <name>CMDTAG_COPY</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>args</name><operator>-&gt;</operator><name>completion_tag</name><operator>-&gt;</operator><name>nprocessed</name></name> <operator>=</operator> <name>processed</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<if_stmt><if>if <condition>(<expr><name><name>args</name><operator>-&gt;</operator><name>completion_tag</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>args</name><operator>-&gt;</operator><name>completion_tag</name></name></expr></argument>, <argument><expr><name>COMPLETION_TAG_BUFSIZE</name></expr></argument>, <argument><expr><literal type="string">"COPY "</literal> <name>UINT64_FORMAT</name></expr></argument>, <argument><expr><name>processed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>add_hypertable_to_process_args</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>DDL_DONE</name></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>process_chunk_t</name>)<parameter_list>(<parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>chunk_relid</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl></typedef>
<typedef>typedef <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>mt_process_chunk_t</name>)<parameter_list>(<parameter><decl><type><name>int32</name></type> <name>hypertable_id</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>chunk_relid</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<comment type="block">/*
 * Applies a function to each chunk of a hypertable.
 *
 * Returns the number of processed chunks, or -1 if the table was not a
 * hypertable.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>foreach_chunk</name><parameter_list>(<parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>process_chunk_t</name></type> <name>process_chunk</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>chunks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>ht</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>chunks</name> <operator>=</operator> <call><name>find_inheritance_children</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>chunks</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>process_chunk</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>foreach_chunk_multitransaction</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>mctx</name></decl></parameter>, <parameter><decl><type><name>mt_process_chunk_t</name></type> <name>process_chunk</name></decl></parameter>,
							   <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cache</name> <modifier>*</modifier></type><name>hcache</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>hypertable_id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>chunks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>num_chunks</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>mctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ht</name> <operator>=</operator> <call><name>ts_hypertable_cache_get_cache_and_entry</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>CACHE_FLAG_MISSING_OK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>ht</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>hypertable_id</name> <operator>=</operator> <name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>chunks</name> <operator>=</operator> <call><name>find_inheritance_children</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>num_chunks</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>chunks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>chunks</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>process_chunk</name><argument_list>(<argument><expr><name>hypertable_id</name></expr></argument>, <argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>chunks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>num_chunks</name></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <name>VacuumCtx</name>
<block>{
	<decl_stmt><decl><type><name>VacuumRelation</name> <modifier>*</modifier></type><name>ht_vacuum_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>chunk_rels</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>chunk_pairs</name></decl>;</decl_stmt>
}</block></struct></type> <name>VacuumCtx</name>;</typedef>

<typedef>typedef <type><struct>struct <name>ChunkPair</name>
<block>{
	<decl_stmt><decl><type><name>Oid</name></type> <name>uncompressed_relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>compressed_relid</name></decl>;</decl_stmt>
}</block></struct></type> <name>ChunkPair</name>;</typedef>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_compressed_chunk_to_vacuum</name><parameter_list>(<parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>comp_chunk_relid</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>VacuumCtx</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><operator>(</operator><name>VacuumCtx</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>compressed_chunk</name> <init>= <expr><call><name>ts_chunk_get_by_relid</name><argument_list>(<argument><expr><name>comp_chunk_relid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VacuumRelation</name> <modifier>*</modifier></type><name>chunk_vacuum_rel</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk_parent</name></decl>;</decl_stmt>
	<comment type="block">/* chunk is from a compressed hypertable */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TS_HYPERTABLE_IS_INTERNAL_COMPRESSION_TABLE</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*chunks for internal compression table have a parent */</comment>
	<expr_stmt><expr><name>chunk_parent</name> <operator>=</operator> <call><name>ts_chunk_get_compressed_chunk_parent</name><argument_list>(<argument><expr><name>compressed_chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>chunk_parent</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ChunkPair</name> <modifier>*</modifier></type><name>cp</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ChunkPair</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>uncompressed_relid</name></name> <operator>=</operator> <name><name>chunk_parent</name><operator>-&gt;</operator><name>table_id</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>compressed_relid</name></name> <operator>=</operator> <name>comp_chunk_relid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>chunk_pairs</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>chunk_pairs</name></name></expr></argument>, <argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* analyze/vacuum the compressed rel instead */</comment>
	<expr_stmt><expr><name>chunk_vacuum_rel</name> <operator>=</operator> <call><name>makeVacuumRelation</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>comp_chunk_relid</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>chunk_rels</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>chunk_rels</name></name></expr></argument>, <argument><expr><name>chunk_vacuum_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Adds a chunk to the list of tables to be vacuumed */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_chunk_to_vacuum</name><parameter_list>(<parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>chunk_relid</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>VacuumCtx</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><operator>(</operator><name>VacuumCtx</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name> <init>= <expr><call><name>ts_chunk_get_by_relid</name><argument_list>(<argument><expr><name>chunk_relid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VacuumRelation</name> <modifier>*</modifier></type><name>chunk_vacuum_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>chunk_range_var</name></decl>;</decl_stmt>

	<comment type="block">/* If the chunk has an associated compressed chunk, analyze that instead
	 * When we compress a chunk, we save stats for the raw chunk, do
	 * not modify that. Data now lives in the compressed chunk, so
	 * analyze it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>compressed_chunk_id</name></name> <operator>!=</operator> <name>INVALID_CHUNK_ID</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>comp_chunk</name> <init>= <expr><call><name>ts_chunk_get_by_id</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>compressed_chunk_id</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ChunkPair</name> <modifier>*</modifier></type><name>cp</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ChunkPair</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>uncompressed_relid</name></name> <operator>=</operator> <name>chunk_relid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>compressed_relid</name></name> <operator>=</operator> <name><name>comp_chunk</name><operator>-&gt;</operator><name>table_id</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>chunk_pairs</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>chunk_pairs</name></name></expr></argument>, <argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* analyze/vacuum the compressed rel instead */</comment>
		<expr_stmt><expr><name>chunk_vacuum_rel</name> <operator>=</operator> <call><name>makeVacuumRelation</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>comp_chunk</name><operator>-&gt;</operator><name>table_id</name></name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>chunk_rels</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>chunk_rels</name></name></expr></argument>, <argument><expr><name>chunk_vacuum_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>chunk_range_var</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>ht_vacuum_rel</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>chunk_range_var</name><operator>-&gt;</operator><name>relname</name></name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>chunk_range_var</name><operator>-&gt;</operator><name>schemaname</name></name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>schema_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>chunk_vacuum_rel</name> <operator>=</operator>
			<call><name>makeVacuumRelation</name><argument_list>(<argument><expr><name>chunk_range_var</name></expr></argument>, <argument><expr><name>chunk_relid</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>ht_vacuum_rel</name><operator>-&gt;</operator><name>va_cols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>chunk_rels</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>chunk_rels</name></name></expr></argument>, <argument><expr><name>chunk_vacuum_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Construct a list of VacuumRelations for all vacuumable rels in
 * the current database.  This is similar to the PostgresQL get_all_vacuum_rels
 * from vacuum.c, only it filters out distributed hypertables and chunks
 * that have been compressed.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>ts_get_all_vacuum_rels</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>is_vacuumcmd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>vacrels</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>pgclass</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TableScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cache</name> <modifier>*</modifier></type><name>hcache</name> <init>= <expr><call><name>ts_hypertable_cache_pin</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>pgclass</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>table_beginscan_catalog</name><argument_list>(<argument><expr><name>pgclass</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>tuple</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>classform</name> <init>= <expr><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>relid</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>relid</name> <operator>=</operator> <name><name>classform</name><operator>-&gt;</operator><name>oid</name></name></expr>;</expr_stmt>

		<comment type="block">/* check permissions of relation */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>vacuum_is_relation_owner</name><argument_list>(<argument><expr><name>relid</name></expr></argument>,
									  <argument><expr><name>classform</name></expr></argument>,
									  <argument><expr><ternary><condition><expr><name>is_vacuumcmd</name></expr> ?</condition><then> <expr><name>VACOPT_VACUUM</name></expr> </then><else>: <expr><name>VACOPT_ANALYZE</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * We include partitioned tables here; depending on which operation is
		 * to be performed, caller will decide whether to process or ignore
		 * them.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>classform</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator> <name><name>classform</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_MATVIEW</name> <operator>&amp;&amp;</operator>
			<name><name>classform</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>ht</name> <operator>=</operator> <call><name>ts_hypertable_cache_get_entry</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>, <argument><expr><name>CACHE_FLAG_MISSING_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>ht</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>hypertable_is_distributed</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>chunk</name> <operator>=</operator> <call><name>ts_chunk_get_by_relid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>chunk</name> <operator>&amp;&amp;</operator> <name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>compressed_chunk_id</name></name> <operator>!=</operator> <name>INVALID_CHUNK_ID</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * Build VacuumRelation(s) specifying the table OIDs to be processed.
		 * We omit a RangeVar since it wouldn't be appropriate to complain
		 * about failure to open one of these relations later.
		 */</comment>
		<expr_stmt><expr><name>vacrels</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>vacrels</name></expr></argument>, <argument><expr><call><name>makeVacuumRelation</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>table_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pgclass</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>vacrels</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Vacuums/Analyzes a hypertable and all of it's chunks */</comment>
<function><type><specifier>static</specifier> <name>DDLResult</name></type>
<name>process_vacuum</name><parameter_list>(<parameter><decl><type><name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>VacuumStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>VacuumStmt</name> <operator>*</operator><operator>)</operator> <name><name>args</name><operator>-&gt;</operator><name>parsetree</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>is_toplevel</name> <init>= <expr><operator>(</operator><name><name>args</name><operator>-&gt;</operator><name>context</name></name> <operator>==</operator> <name>PROCESS_UTILITY_TOPLEVEL</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VacuumCtx</name></type> <name>ctx</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>ht_vacuum_rel</name> <operator>=</operator> <name>NULL</name></expr>,
		<expr><operator>.</operator><name>chunk_rels</name> <operator>=</operator> <name>NIL</name></expr>,
		<expr><operator>.</operator><name>chunk_pairs</name> <operator>=</operator> <name>NIL</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>vacuum_rels</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>is_vacuumcmd</name></decl>;</decl_stmt>
	<comment type="block">/* save original VacuumRelation list */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>saved_stmt_rels</name> <init>= <expr><name><name>stmt</name><operator>-&gt;</operator><name>rels</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>is_vacuumcmd</name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>is_vacuumcmd</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>rels</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>vacuum_rels</name> <operator>=</operator> <call><name>ts_get_all_vacuum_rels</name><argument_list>(<argument><expr><name>is_vacuumcmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>Cache</name> <modifier>*</modifier></type><name>hcache</name> <init>= <expr><call><name>ts_hypertable_cache_pin</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>stmt-&gt;rels</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>VacuumRelation</name> <modifier>*</modifier></type><name>vacuum_rel</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>VacuumRelation</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type> <name>table_relid</name> <init>= <expr><name><name>vacuum_rel</name><operator>-&gt;</operator><name>oid</name></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>table_relid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>vacuum_rel</name><operator>-&gt;</operator><name>relation</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>table_relid</name> <operator>=</operator> <call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name><name>vacuum_rel</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>table_relid</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>ht</name> <operator>=</operator> <call><name>ts_hypertable_cache_get_entry</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>, <argument><expr><name>table_relid</name></expr></argument>, <argument><expr><name>CACHE_FLAG_MISSING_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>ht</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>add_hypertable_to_process_args</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* Exclude distributed hypertables from the list of relations
					 * to vacuum and analyze since they contain no local tuples.
					 *
					 * Support for VACUUM/ANALYZE operations on a distributed hypertable
					 * is implemented as a part of distributed ddl and remote
					 * statistics import functions.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>hypertable_is_distributed</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>TS_HYPERTABLE_IS_INTERNAL_COMPRESSION_TABLE</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>ht_vacuum_rel</name></name> <operator>=</operator> <name>vacuum_rel</name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>foreach_chunk</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>add_compressed_chunk_to_vacuum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>ht_vacuum_rel</name></name> <operator>=</operator> <name>vacuum_rel</name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>foreach_chunk</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>add_chunk_to_vacuum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>vacuum_rels</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>vacuum_rels</name></expr></argument>, <argument><expr><name>vacuum_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>rels</name></name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name><name>ctx</name><operator>.</operator><name>chunk_rels</name></name></expr></argument>, <argument><expr><name>vacuum_rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* The list of rels to vacuum could be empty if we are only vacuuming a
	 * distributed hypertable. In that case, we don't want to vacuum locally. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>rels</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PreventCommandDuringRecovery</name><argument_list>(<argument><expr><ternary><condition><expr><name>is_vacuumcmd</name></expr> ?</condition><then> <expr><literal type="string">"VACUUM"</literal></expr> </then><else>: <expr><literal type="string">"ANALYZE"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* ACL permission checks inside vacuum_rel and analyze_rel called by this ExecVacuum */</comment>
		<expr_stmt><expr><call><name>ExecVacuum</name><argument_list>(<argument><expr><name><name>args</name><operator>-&gt;</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>is_toplevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>ctx.chunk_pairs</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ChunkPair</name> <modifier>*</modifier></type><name>cp</name> <init>= <expr><operator>(</operator><name>ChunkPair</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name><name>ts_cm_functions</name><operator>-&gt;</operator><name>update_compressed_chunk_relstats</name></name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>uncompressed_relid</name></name></expr></argument>,
															  <argument><expr><name><name>cp</name><operator>-&gt;</operator><name>compressed_relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/*
	Restore original list. stmt-&gt;rels which has references to
	VacuumRelation list is freed up, however VacuumStmt is not
	cleaned up because of which there is a crash.
	*/</comment>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>rels</name></name> <operator>=</operator> <name>saved_stmt_rels</name></expr>;</expr_stmt>
	<return>return <expr><name>DDL_DONE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_truncate_chunk</name><parameter_list>(<parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>chunk_relid</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TruncateStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>objaddr</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>classId</name> <operator>=</operator> <name>RelationRelationId</name></expr>,
		<expr><operator>.</operator><name>objectId</name> <operator>=</operator> <name>chunk_relid</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>performDeletion</name><argument_list>(<argument><expr><operator>&amp;</operator><name>objaddr</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>behavior</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>relation_should_recurse</name><parameter_list>(<parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>rv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>rv</name><operator>-&gt;</operator><name>inh</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* handle forwarding TRUNCATEs to the chunks of a hypertable */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>handle_truncate_hypertable</name><parameter_list>(<parameter><decl><type><name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><name>TruncateStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>add_hypertable_to_process_args</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Delete the metadata */</comment>
	<expr_stmt><expr><call><name>ts_chunk_delete_by_hypertable_id</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Drop the chunk tables */</comment>
	<expr_stmt><expr><call><name>foreach_chunk</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>process_truncate_chunk</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Truncate a hypertable.
 */</comment>
<function><type><specifier>static</specifier> <name>DDLResult</name></type>
<name>process_truncate</name><parameter_list>(<parameter><decl><type><name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TruncateStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>TruncateStmt</name> <operator>*</operator><operator>)</operator> <name><name>args</name><operator>-&gt;</operator><name>parsetree</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cache</name> <modifier>*</modifier></type><name>hcache</name> <init>= <expr><call><name>ts_hypertable_cache_pin</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>hypertables</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>relations</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>list_changed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldctx</name></decl>, <decl><type ref="prev"/><name>parsetreectx</name> <init>= <expr><call><name>GetMemoryChunkContext</name><argument_list>(<argument><expr><name><name>args</name><operator>-&gt;</operator><name>parsetree</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* For all hypertables, we drop the now empty chunks. We also propagate the
	 * TRUNCATE call to the compressed version of the hypertable, if it exists.
	 */</comment>
	<comment type="block">/* Preprocess and filter out distributed hypertables */</comment>
	<macro><name>foreach</name> <argument_list>(<argument>cell</argument>, <argument>stmt-&gt;relations</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>rv</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>relid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>list_append</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rv</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Grab AccessExclusiveLock, same as regular TRUNCATE processing grabs
		 * below. We just do it preemptively here. */</comment>
		<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* We should add invalid relations to the list to raise error on the
			 * standard_ProcessUtility when we're trying to TRUNCATE a nonexistent relation */</comment>
			<expr_stmt><expr><name>list_append</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<switch>switch <condition>(<expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>RELKIND_VIEW</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>ContinuousAgg</name> <modifier>*</modifier></type><name>cagg</name> <init>= <expr><call><name>ts_continuous_agg_find_by_relid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>cagg</name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>mat_ht</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>raw_ht</name></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>relation_should_recurse</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot truncate only a continuous aggregate"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

						<expr_stmt><expr><name>mat_ht</name> <operator>=</operator> <call><name>ts_hypertable_get_by_id</name><argument_list>(<argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>mat_hypertable_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>mat_ht</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<comment type="block">/* Create list item into the same context of the list */</comment>
						<expr_stmt><expr><name>oldctx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>parsetreectx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>mat_ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>schema_name</name></name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>mat_ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<comment type="block">/* Invalidate the entire continuous aggregate since it no
						 * longer has any data */</comment>
						<expr_stmt><expr><name>raw_ht</name> <operator>=</operator> <call><name>ts_hypertable_get_by_id</name><argument_list>(<argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>raw_hypertable_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>raw_ht</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name><name>ts_cm_functions</name><operator>-&gt;</operator><name>continuous_agg_invalidate_mat_ht</name></name><argument_list>(<argument><expr><name>raw_ht</name></expr></argument>,
																		  <argument><expr><name>mat_ht</name></expr></argument>,
																		  <argument><expr><name>TS_TIME_NOBEGIN</name></expr></argument>,
																		  <argument><expr><name>TS_TIME_NOEND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<comment type="block">/* Additionally, this cagg's materialization hypertable could be the
						 * underlying hypertable for other caggs defined on top of it, in that case
						 * we must update the hypertable invalidation log */</comment>
						<decl_stmt><decl><type><name>ContinuousAggHypertableStatus</name></type> <name>agg_status</name></decl>;</decl_stmt>

						<expr_stmt><expr><name>agg_status</name> <operator>=</operator> <call><name>ts_continuous_agg_hypertable_status</name><argument_list>(<argument><expr><name><name>mat_ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>agg_status</name> <operator>&amp;</operator> <name>HypertableIsRawTable</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name><name>ts_cm_functions</name><operator>-&gt;</operator><name>continuous_agg_invalidate_raw_ht</name></name><argument_list>(<argument><expr><name>mat_ht</name></expr></argument>,
																			  <argument><expr><name>TS_TIME_NOBEGIN</name></expr></argument>,
																			  <argument><expr><name>TS_TIME_NOEND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

						<comment type="block">/* mark list as changed because we'll add the materialization hypertable */</comment>
						<expr_stmt><expr><name>list_changed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<expr_stmt><expr><name>list_append</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block>
				<case>case <expr><name>RELKIND_RELATION</name></expr>:</case>
				<comment type="block">/* TRUNCATE for foreign tables not implemented yet. This will raise an error. */</comment>
				<case>case <expr><name>RELKIND_FOREIGN_TABLE</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name> <init>=
						<expr><call><name>ts_hypertable_cache_get_entry</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>, <argument><expr><name>CACHE_FLAG_MISSING_OK</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>ht</name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>ContinuousAggHypertableStatus</name></type> <name>agg_status</name></decl>;</decl_stmt>

						<expr_stmt><expr><name>agg_status</name> <operator>=</operator> <call><name>ts_continuous_agg_hypertable_status</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<if_stmt><if>if <condition>(<expr><operator>(</operator><name>agg_status</name> <operator>&amp;</operator> <name>HypertableIsMaterialization</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot TRUNCATE a hypertable underlying a continuous "</literal>
											<literal type="string">"aggregate"</literal></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"TRUNCATE the continuous aggregate instead."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

						<if_stmt><if>if <condition>(<expr><name>agg_status</name> <operator>==</operator> <name>HypertableIsRawTable</name></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/* The truncation invalidates all associated continuous aggregates */</comment>
							<expr_stmt><expr><call><name><name>ts_cm_functions</name><operator>-&gt;</operator><name>continuous_agg_invalidate_raw_ht</name></name><argument_list>(<argument><expr><name>ht</name></expr></argument>,
																			  <argument><expr><name>TS_TIME_NOBEGIN</name></expr></argument>,
																			  <argument><expr><name>TS_TIME_NOEND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>

						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>relation_should_recurse</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot truncate only a hypertable"</literal></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Do not specify the ONLY keyword, or use truncate"</literal>
											 <literal type="string">" only on the chunks directly."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

						<expr_stmt><expr><name>hypertables</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>hypertables</name></expr></argument>, <argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hypertable_is_distributed</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name>list_append</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
						<else>else<block type="pseudo"><block_content>
							<comment type="block">/* mark list as changed because we'll not add the distributed hypertable
							 */</comment>
							<expr_stmt><expr><name>list_changed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><operator>(</operator><name>chunk</name> <operator>=</operator> <call><name>ts_chunk_get_by_relid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
					<block>{<block_content> <comment type="block">/* this is a chunk */</comment>
						<expr_stmt><expr><name>ht</name> <operator>=</operator> <call><name>ts_hypertable_cache_get_entry</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>,
														   <argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>hypertable_relid</name></name></expr></argument>,
														   <argument><expr><name>CACHE_FLAG_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<comment type="block">/*
						 * Block direct TRUNCATE on frozen chunk.
						 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_GE</name></expr></cpp:if>
						<if_stmt><if>if <condition>(<expr><call><name>ts_chunk_is_frozen</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot TRUNCATE frozen chunk \"%s\""</literal></expr></argument>, <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ht</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<comment type="block">/* If the hypertable has continuous aggregates, then invalidate
						 * the truncated region. */</comment>
						<if_stmt><if>if <condition>(<expr><call><name>ts_continuous_agg_hypertable_status</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>HypertableIsRawTable</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>ts_continuous_agg_invalidate_chunk</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<comment type="block">/* Truncate the compressed chunk too. */</comment>
						<if_stmt><if>if <condition>(<expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>compressed_chunk_id</name></name> <operator>!=</operator> <name>INVALID_CHUNK_ID</name></expr>)</condition>
						<block>{<block_content>
							<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>compressed_chunk</name> <init>=
								<expr><call><name>ts_chunk_get_by_id</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>compressed_chunk_id</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
							<if_stmt><if>if <condition>(<expr><name>compressed_chunk</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
							<block>{<block_content>
								<comment type="block">/* Create list item into the same context of the list. */</comment>
								<expr_stmt><expr><name>oldctx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>parsetreectx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>compressed_chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>schema_name</name></name></expr></argument>)</argument_list></call></expr></argument>,
												  <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>compressed_chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr></argument>,
												  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><name>list_changed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>
						</block_content>}</block></if></if_stmt>
						<expr_stmt><expr><name>list_append</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name>list_append</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
					<break>break;</break>
				</block_content>}</block>
			</block_content>}</block></switch>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Append the relation to the list in the same parse tree memory context */</comment>
		<if_stmt><if>if <condition>(<expr><name>list_append</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldctx</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>parsetreectx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>relations</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>relations</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* Update relations list just when changed to include only tables
	 * that hold data. On an access node, distributed hypertables hold
	 * no data and chunks are foreign tables, so those tables are excluded. */</comment>
	<if_stmt><if>if <condition>(<expr><name>list_changed</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>relations</name></name> <operator>=</operator> <name>relations</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>relations</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Call standard PostgreSQL handler for remaining tables */</comment>
		<expr_stmt><expr><call><name>prev_ProcessUtility</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* For all hypertables, we drop the now empty chunks */</comment>
	<macro><name>foreach</name> <argument_list>(<argument>cell</argument>, <argument>hypertables</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ht</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>handle_truncate_hypertable</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* propagate to the compressed hypertable */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>TS_HYPERTABLE_HAS_COMPRESSION_TABLE</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>compressed_ht</name> <init>=
				<expr><call><name>ts_hypertable_cache_get_entry_by_id</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>, <argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>compressed_hypertable_id</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TruncateStmt</name></type> <name>compressed_stmt</name> <init>= <expr><operator>*</operator><name>stmt</name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>compressed_stmt</name><operator>.</operator><name>relations</name></name> <operator>=</operator>
				<call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeRangeVar</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>compressed_ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>schema_name</name></name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>compressed_ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* TRUNCATE the compressed hypertable */</comment>
			<expr_stmt><expr><call><name>ExecuteTruncate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>compressed_stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>handle_truncate_hypertable</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>compressed_ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>DDL_DONE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_drop_table_chunk</name><parameter_list>(<parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>chunk_relid</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DropStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>objaddr</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>classId</name> <operator>=</operator> <name>RelationRelationId</name></expr>,
		<expr><operator>.</operator><name>objectId</name> <operator>=</operator> <name>chunk_relid</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>performDeletion</name><argument_list>(<argument><expr><operator>&amp;</operator><name>objaddr</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>behavior</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Block drop compressed chunks directly and drop corresponding compressed chunks if
 * cascade is on. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_drop_chunk</name><parameter_list>(<parameter><decl><type><name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><name>DropStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cache</name> <modifier>*</modifier></type><name>hcache</name> <init>= <expr><call><name>ts_hypertable_cache_pin</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>stmt-&gt;objects</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>object</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>relation</name> <init>= <expr><call><name>makeRangeVarFromNameList</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>relid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>relation</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>chunk</name> <operator>=</operator> <call><name>ts_chunk_get_by_relid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>chunk</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>ts_chunk_contains_compressed_data</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"dropping compressed chunks not supported"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(
							 <argument><expr><literal type="string">"Please drop the corresponding chunk on the uncompressed hypertable "</literal>
							 <literal type="string">"instead."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* if cascade is enabled, delete the compressed chunk with cascade too. Otherwise
			 *  it would be blocked if there are dependent objects */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>behavior</name></name> <operator>==</operator> <name>DROP_CASCADE</name> <operator>&amp;&amp;</operator> <name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>compressed_chunk_id</name></name> <operator>!=</operator> <name>INVALID_CHUNK_ID</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>compressed_chunk</name> <init>= <expr><call><name>ts_chunk_get_by_id</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>compressed_chunk_id</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<comment type="block">/* The chunk may have been delete by a CASCADE */</comment>
				<if_stmt><if>if <condition>(<expr><name>compressed_chunk</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ts_chunk_drop</name><argument_list>(<argument><expr><name>compressed_chunk</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>behavior</name></name></expr></argument>, <argument><expr><name>DEBUG1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>ht</name> <operator>=</operator> <call><name>ts_hypertable_cache_get_entry</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>, <argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>hypertable_relid</name></name></expr></argument>, <argument><expr><name>CACHE_FLAG_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ht</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* If the hypertable has continuous aggregates, then invalidate
			 * the dropped region. */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>ts_continuous_agg_hypertable_status</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>HypertableIsRawTable</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ts_continuous_agg_invalidate_chunk</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * We need to drop hypertable chunks and associated compressed hypertables
 * when dropping hypertables to maintain correct semantics wrt CASCADE modifiers.
 * Also block dropping compressed hypertables directly.
 */</comment>
<function><type><specifier>static</specifier> <name>DDLResult</name></type>
<name>process_drop_hypertable</name><parameter_list>(<parameter><decl><type><name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><name>DropStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cache</name> <modifier>*</modifier></type><name>hcache</name> <init>= <expr><call><name>ts_hypertable_cache_pin</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DDLResult</name></type> <name>result</name> <init>= <expr><name>DDL_CONTINUE</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>stmt-&gt;objects</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>object</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>relation</name> <init>= <expr><call><name>makeRangeVarFromNameList</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>relid</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>relation</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>ht</name> <operator>=</operator> <call><name>ts_hypertable_cache_get_entry</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>, <argument><expr><name>CACHE_FLAG_MISSING_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>ht</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objects</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot drop a hypertable along with other objects"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>TS_HYPERTABLE_IS_INTERNAL_COMPRESSION_TABLE</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"dropping compressed hypertables not supported"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Please drop the corresponding uncompressed hypertable "</literal>
									 <literal type="string">"instead."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/*
				 *  We need to drop hypertable chunks before the hypertable to avoid the need
				 *  to CASCADE such drops;
				 */</comment>
				<expr_stmt><expr><call><name>foreach_chunk</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>process_drop_table_chunk</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* The usual path for deleting an associated compressed hypertable uses
				 * DROP_RESTRICT But if we are using DROP_CASCADE we should propagate that down to
				 * the compressed hypertable.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>behavior</name></name> <operator>==</operator> <name>DROP_CASCADE</name> <operator>&amp;&amp;</operator> <call><name>TS_HYPERTABLE_HAS_COMPRESSION_TABLE</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>compressed_hypertable</name> <init>=
						<expr><call><name>ts_hypertable_get_by_id</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>compressed_hypertable_id</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><call><name>ts_hypertable_drop</name><argument_list>(<argument><expr><name>compressed_hypertable</name></expr></argument>, <argument><expr><name>DROP_CASCADE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>DDL_DONE</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *  We need to ensure that DROP INDEX uses only one hypertable per query,
 *  otherwise query string might not be reusable for execution on a
 *  data node.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_drop_hypertable_index</name><parameter_list>(<parameter><decl><type><name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><name>DropStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cache</name> <modifier>*</modifier></type><name>hcache</name> <init>= <expr><call><name>ts_hypertable_cache_pin</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>stmt-&gt;objects</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>object</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>relation</name> <init>= <expr><call><name>makeRangeVarFromNameList</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>relid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>relation</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>IndexGetRelation</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>ht</name> <operator>=</operator> <call><name>ts_hypertable_cache_get_entry</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>, <argument><expr><name>CACHE_FLAG_MISSING_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>ht</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objects</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot drop a hypertable index along with other objects"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>add_hypertable_to_process_args</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Note that DROP TABLESPACE does not have a hook in event triggers so cannot go
 * through process_ddl_sql_drop */</comment>
<function><type><specifier>static</specifier> <name>DDLResult</name></type>
<name>process_drop_tablespace</name><parameter_list>(<parameter><decl><type><name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DropTableSpaceStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>DropTableSpaceStmt</name> <operator>*</operator><operator>)</operator> <name><name>args</name><operator>-&gt;</operator><name>parsetree</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><call><name>ts_tablespace_count_attached</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>tablespacename</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"tablespace \"%s\" is still attached to %d hypertables"</literal></expr></argument>,
						<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>tablespacename</name></name></expr></argument>,
						<argument><expr><name>count</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Detach the tablespace from all hypertables before removing it."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>DDL_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_grant_add_by_rel</name><parameter_list>(<parameter><decl><type><name>GrantStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>objects</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objects</name></name></expr></argument>, <argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * If it is a "GRANT/REVOKE ON ALL TABLES IN SCHEMA" operation then we need to check if
 * the rangevar was already added when we added all objects inside the SCHEMA
 *
 * This could get a little expensive for schemas containing a lot of objects..
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_grant_add_by_name</name><parameter_list>(<parameter><decl><type><name>GrantStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>was_schema_op</name></decl></parameter>, <parameter><decl><type><name>Name</name></type> <name>schema_name</name></decl></parameter>, <parameter><decl><type><name>Name</name></type> <name>table_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>already_added</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>was_schema_op</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>already_added</name> <operator>=</operator> <call><name>check_table_in_rangevar_list</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objects</name></name></expr></argument>, <argument><expr><name>schema_name</name></expr></argument>, <argument><expr><name>table_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>already_added</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>process_grant_add_by_rel</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>,
								 <argument><expr><call><name>makeRangeVar</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>schema_name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>table_name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_relations_in_namespace</name><parameter_list>(<parameter><decl><type><name>GrantStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>Name</name></type> <name>schema_name</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>namespaceId</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>relkind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TableScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_class_relnamespace</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
				<argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_class_relkind</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
				<argument><expr><name>F_CHAREQ</name></expr></argument>,
				<argument><expr><call><name>CharGetDatum</name><argument_list>(<argument><expr><name>relkind</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>table_beginscan_catalog</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>tuple</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Name</name></type> <name>relname</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>relname</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* these are being added for the first time into this list */</comment>
		<expr_stmt><expr><call><name>process_grant_add_by_name</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>schema_name</name></expr></argument>, <argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>table_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * For "GRANT ALL ON ALL TABLES IN SCHEMA" GrantStmt, the targtype field is ACL_TARGET_ALL_IN_SCHEMA
 * whereas in regular "GRANT ON TABLE table_name", the targtype field is ACL_TARGET_OBJECT. In the
 * latter case the objects list contains a list of relation range vars whereas in the former it is
 * the list of schema names.
 *
 * To make things work we change the targtype field from ACL_TARGET_ALL_IN_SCHEMA to
 * ACL_TARGET_OBJECT and then create a new list of rangevars of all relation type entities in it and
 * assign it to the "stmt-&gt;objects" field.
 *
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_grant_add_by_schema</name><parameter_list>(<parameter><decl><type><name>GrantStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>nspnames</name> <init>= <expr><name><name>stmt</name><operator>-&gt;</operator><name>objects</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We will be adding rangevars to the "stmt-&gt;objects" field in the loop below. So
	 * we track the nspnames separately above and NIL out the objects list
	 */</comment>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>objects</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>cell</argument>, <argument>nspnames</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nspname</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>namespaceId</name> <init>= <expr><call><name>LookupExplicitNamespace</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Name</name></type> <name>schema</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>schema</name> <operator>=</operator> <operator>(</operator><name>Name</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><name>schema</name></expr></argument>, <argument><expr><name>nspname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Inspired from objectsInSchemaToOids PG function */</comment>
		<expr_stmt><expr><call><name>process_relations_in_namespace</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>schema</name></expr></argument>, <argument><expr><name>namespaceId</name></expr></argument>, <argument><expr><name>RELKIND_RELATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>process_relations_in_namespace</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>schema</name></expr></argument>, <argument><expr><name>namespaceId</name></expr></argument>, <argument><expr><name>RELKIND_VIEW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>process_relations_in_namespace</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>schema</name></expr></argument>, <argument><expr><name>namespaceId</name></expr></argument>, <argument><expr><name>RELKIND_MATVIEW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>process_relations_in_namespace</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>schema</name></expr></argument>, <argument><expr><name>namespaceId</name></expr></argument>, <argument><expr><name>RELKIND_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>process_relations_in_namespace</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>schema</name></expr></argument>, <argument><expr><name>namespaceId</name></expr></argument>, <argument><expr><name>RELKIND_PARTITIONED_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* change targtype to ACL_TARGET_OBJECT now */</comment>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>targtype</name></name> <operator>=</operator> <name>ACL_TARGET_OBJECT</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Handle GRANT / REVOKE.
 *
 * A revoke is a GrantStmt with 'is_grant' set to false.
 */</comment>
<function><type><specifier>static</specifier> <name>DDLResult</name></type>
<name>process_grant_and_revoke</name><parameter_list>(<parameter><decl><type><name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GrantStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>GrantStmt</name> <operator>*</operator><operator>)</operator> <name><name>args</name><operator>-&gt;</operator><name>parsetree</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DDLResult</name></type> <name>result</name> <init>= <expr><name>DDL_CONTINUE</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* We let the calling function handle anything that is not
	 * ACL_TARGET_OBJECT or ACL_TARGET_ALL_IN_SCHEMA */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>targtype</name></name> <operator>!=</operator> <name>ACL_TARGET_OBJECT</name> <operator>&amp;&amp;</operator> <name><name>stmt</name><operator>-&gt;</operator><name>targtype</name></name> <operator>!=</operator> <name>ACL_TARGET_ALL_IN_SCHEMA</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>DDL_CONTINUE</name></expr>;</return></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>objtype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>OBJECT_TABLESPACE</name></expr>:</case>
			<comment type="block">/*
			 * If we are granting on a tablespace, we need to apply the REVOKE
			 * first to be able to check remaining permissions.
			 */</comment>
			<expr_stmt><expr><call><name>prev_ProcessUtility</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ts_tablespace_validate_revoke</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>DDL_DONE</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>OBJECT_TABLE</name></expr>:</case>
			<comment type="block">/*
			 * Collect the hypertables in the grant statement. We only need to
			 * consider those when sending grants to other data nodes.
			 */</comment>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Cache</name> <modifier>*</modifier></type><name>hcache</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>saved_schema_objects</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type> <name>was_schema_op</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * If it's a GRANT/REVOKE ALL IN SCHEMA then we need to collect all
				 * objects in this schema and convert this into an ACL_TARGET_OBJECT
				 * entry with its objects field pointing to rangevars
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>targtype</name></name> <operator>==</operator> <name>ACL_TARGET_ALL_IN_SCHEMA</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>saved_schema_objects</name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>objects</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>process_grant_add_by_schema</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>was_schema_op</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name>hcache</name> <operator>=</operator> <call><name>ts_hypertable_cache_pin</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* First process all continuous aggregates in the list and add
				 * the associated hypertables and views to the list of objects
				 * to process */</comment>
				<macro><name>foreach</name> <argument_list>(<argument>cell</argument>, <argument>stmt-&gt;objects</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>relation</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RangeVar</name></expr></argument>, <argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>ContinuousAgg</name> <modifier>*</modifier><specifier>const</specifier></type> <name>cagg</name> <init>= <expr><call><name>ts_continuous_agg_find_by_rv</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<if_stmt><if>if <condition>(<expr><name>cagg</name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>mat_hypertable</name> <init>=
							<expr><call><name>ts_hypertable_get_by_id</name><argument_list>(<argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>mat_hypertable_id</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
						<expr_stmt><expr><call><name>process_grant_add_by_name</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>,
												  <argument><expr><name>was_schema_op</name></expr></argument>,
												  <argument><expr><operator>&amp;</operator><name><name>mat_hypertable</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>schema_name</name></name></expr></argument>,
												  <argument><expr><operator>&amp;</operator><name><name>mat_hypertable</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>process_grant_add_by_name</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>,
												  <argument><expr><name>was_schema_op</name></expr></argument>,
												  <argument><expr><operator>&amp;</operator><name><name>cagg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>direct_view_schema</name></name></expr></argument>,
												  <argument><expr><operator>&amp;</operator><name><name>cagg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>direct_view_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>process_grant_add_by_name</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>,
												  <argument><expr><name>was_schema_op</name></expr></argument>,
												  <argument><expr><operator>&amp;</operator><name><name>cagg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>partial_view_schema</name></name></expr></argument>,
												  <argument><expr><operator>&amp;</operator><name><name>cagg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>partial_view_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/*
					 * If this is a hypertable and it has a compressed
					 * hypertable associated with it, add it to the list of
					 * hypertables to process.
					 */</comment>
					<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>hypertable</name> <init>= <expr><call><name>ts_hypertable_cache_get_entry_rv</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<if_stmt><if>if <condition>(<expr><name>hypertable</name> <operator>&amp;&amp;</operator> <call><name>TS_HYPERTABLE_HAS_COMPRESSION_TABLE</name><argument_list>(<argument><expr><name>hypertable</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>compressed_hypertable</name> <init>=
							<expr><call><name>ts_hypertable_get_by_id</name><argument_list>(<argument><expr><name><name>hypertable</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>compressed_hypertable_id</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>compressed_hypertable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>process_grant_add_by_name</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>,
												  <argument><expr><name>was_schema_op</name></expr></argument>,
												  <argument><expr><operator>&amp;</operator><name><name>compressed_hypertable</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>schema_name</name></name></expr></argument>,
												  <argument><expr><operator>&amp;</operator><name><name>compressed_hypertable</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block>

				<comment type="block">/* Process all hypertables, including those added in the loop above */</comment>
				<macro><name>foreach</name> <argument_list>(<argument>cell</argument>, <argument>stmt-&gt;objects</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>relation</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RangeVar</name></expr></argument>, <argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name> <init>= <expr><call><name>ts_hypertable_cache_get_entry_rv</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>ht</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>add_hypertable_to_process_args</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>foreach_chunk</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>add_chunk_oid</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block>

				<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Execute command right away, to check any permission errors before propagating
				 * it to the distributed DDL */</comment>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name>DDL_DONE</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>objects</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>prev_ProcessUtility</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/* Restore ALL IN SCHEMA command type and it's objects */</comment>
				<if_stmt><if>if <condition>(<expr><name>was_schema_op</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>targtype</name></name> <operator>=</operator> <name>ACL_TARGET_ALL_IN_SCHEMA</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>objects</name></name> <operator>=</operator> <name>saved_schema_objects</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<break>break;</break>
			</block_content>}</block>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DDLResult</name></type>
<name>process_grant_and_revoke_role</name><parameter_list>(<parameter><decl><type><name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GrantRoleStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>GrantRoleStmt</name> <operator>*</operator><operator>)</operator> <name><name>args</name><operator>-&gt;</operator><name>parsetree</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Need to apply the REVOKE first to be able to check remaining
	 * permissions
	 */</comment>
	<expr_stmt><expr><call><name>prev_ProcessUtility</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We only care about revokes and setting privileges on a specific object */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>is_grant</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>DDL_DONE</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ts_tablespace_validate_revoke_role</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>DDL_DONE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_drop_view_start</name><parameter_list>(<parameter><decl><type><name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><name>DropStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>cell</argument>, <argument>stmt-&gt;objects</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier><specifier>const</specifier></type> <name>object</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier><specifier>const</specifier></type> <name>rv</name> <init>= <expr><call><name>makeRangeVarFromNameList</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ContinuousAgg</name> <modifier>*</modifier><specifier>const</specifier></type> <name>cagg</name> <init>= <expr><call><name>ts_continuous_agg_find_by_rv</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>cagg</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot drop continuous aggregate using DROP VIEW"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use DROP MATERIALIZED VIEW to drop a continuous aggregate."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_drop_continuous_aggregates</name><parameter_list>(<parameter><decl><type><name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><name>DropStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>caggs_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>stmt-&gt;objects</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier><specifier>const</specifier></type> <name>object</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier><specifier>const</specifier></type> <name>rv</name> <init>= <expr><call><name>makeRangeVarFromNameList</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ContinuousAgg</name> <modifier>*</modifier><specifier>const</specifier></type> <name>cagg</name> <init>= <expr><call><name>ts_continuous_agg_find_by_rv</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>cagg</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* If there is at least one cagg, the drop should be treated as a
			 * DROP VIEW. */</comment>
			<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>removeType</name></name> <operator>=</operator> <name>OBJECT_VIEW</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>++</operator><name>caggs_count</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* We check that there were only continuous aggregates or that there were
	   no continuous aggregates. Otherwise, we have a mixture of tables and
	   views and are looking for views only.*/</comment>
	<if_stmt><if>if <condition>(<expr><name>caggs_count</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>caggs_count</name> <operator>&lt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objects</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"mixing continuous aggregates and other objects not allowed"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Drop continuous aggregates and other objects in separate statements."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DDLResult</name></type>
<name>process_drop_start</name><parameter_list>(<parameter><decl><type><name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DropStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>DropStmt</name> <operator>*</operator><operator>)</operator> <name><name>args</name><operator>-&gt;</operator><name>parsetree</name></name></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>removeType</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>OBJECT_TABLE</name></expr>:</case>
			<expr_stmt><expr><call><name>process_drop_hypertable</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>TS_FALLTHROUGH</name></expr>;</expr_stmt>
		<case>case <expr><name>OBJECT_FOREIGN_TABLE</name></expr>:</case>
			<comment type="block">/* Chunks can be either normal tables, or foreign tables in the case of a distributed
			 * hypertable */</comment>
			<expr_stmt><expr><call><name>process_drop_chunk</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_INDEX</name></expr>:</case>
			<expr_stmt><expr><call><name>process_drop_hypertable_index</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_MATVIEW</name></expr>:</case>
			<expr_stmt><expr><call><name>process_drop_continuous_aggregates</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_VIEW</name></expr>:</case>
			<expr_stmt><expr><call><name>process_drop_view_start</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_FOREIGN_SERVER</name></expr>:</case>
			<expr_stmt><expr><call><name>process_drop_foreign_server_start</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_TRIGGER</name></expr>:</case>
			<expr_stmt><expr><call><name>process_drop_trigger_start</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>DDL_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>reindex_chunk</name><parameter_list>(<parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>chunk_relid</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ReindexStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>ReindexStmt</name> <operator>*</operator><operator>)</operator> <name><name>args</name><operator>-&gt;</operator><name>parsetree</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name> <init>= <expr><call><name>ts_chunk_get_by_relid</name><argument_list>(<argument><expr><name>chunk_relid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>REINDEX_OBJECT_TABLE</name></expr>:</case>
			<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>schema_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_LT</name></expr></cpp:if>
			<expr_stmt><expr><call><name>ReindexTable</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>,
						 <argument><expr><call><name>get_reindex_options</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>concurrent</name></name></expr></argument> <comment type="block">/* should test for deadlocks */</comment>
			)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>PG14_GE</name></expr></cpp:elif>
			<expr_stmt><expr><call><name>ExecReindex</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<break>break;</break>
		<case>case <expr><name>REINDEX_OBJECT_INDEX</name></expr>:</case>
			<comment type="block">/* Not supported, a.t.m. See note in process_reindex(). */</comment>
			<break>break;</break>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Reindex a hypertable and all its chunks. Currently works only for REINDEX
 * TABLE.
 */</comment>
<function><type><specifier>static</specifier> <name>DDLResult</name></type>
<name>process_reindex</name><parameter_list>(<parameter><decl><type><name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ReindexStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>ReindexStmt</name> <operator>*</operator><operator>)</operator> <name><name>args</name><operator>-&gt;</operator><name>parsetree</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cache</name> <modifier>*</modifier></type><name>hcache</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DDLResult</name></type> <name>result</name> <init>= <expr><name>DDL_CONTINUE</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/* Not a case we are interested in */</comment>
		<return>return <expr><name>DDL_CONTINUE</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>DDL_CONTINUE</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>hcache</name> <operator>=</operator> <call><name>ts_hypertable_cache_pin</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>REINDEX_OBJECT_TABLE</name></expr>:</case>
			<expr_stmt><expr><name>ht</name> <operator>=</operator> <call><name>ts_hypertable_cache_get_entry</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>, <argument><expr><name>CACHE_FLAG_MISSING_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>ht</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>PreventCommandDuringRecovery</name><argument_list>(<argument><expr><literal type="string">"REINDEX"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ts_hypertable_permissions_check_by_id</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_LT</name></expr></cpp:if>
				<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>concurrent</name></name></expr>)</condition><block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
				<if_stmt><if>if <condition>(<expr><call><name>get_reindex_options</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>REINDEXOPT_CONCURRENTLY</name></expr>)</condition><block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"concurrent index creation on hypertables is not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt>

				<comment type="block">/* Do not process remote chunks in case of distributed hypertable */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>hypertable_is_distributed</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <name>DDL_DONE</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>foreach_chunk</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>reindex_chunk</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>result</name> <operator>=</operator> <name>DDL_DONE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></else></if_stmt>

				<expr_stmt><expr><call><name>add_hypertable_to_process_args</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>REINDEX_OBJECT_INDEX</name></expr>:</case>
			<expr_stmt><expr><name>ht</name> <operator>=</operator> <call><name>ts_hypertable_cache_get_entry</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>,
											   <argument><expr><call><name>IndexGetRelation</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>,
											   <argument><expr><name>CACHE_FLAG_MISSING_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>ht</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>add_hypertable_to_process_args</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ts_hypertable_permissions_check_by_id</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Recursing to chunks is currently not supported. Need to
				 * look up all chunk indexes that corresponds to the
				 * hypertable's index.
				 */</comment>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"reindexing of a specific index on a hypertable is unsupported"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(
							 <argument><expr><literal type="string">"As a workaround, it is possible to run REINDEX TABLE to reindex all "</literal>
							 <literal type="string">"indexes on a hypertable, including all indexes on chunks."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Rename a hypertable or a chunk.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_rename_table</name><parameter_list>(<parameter><decl><type><name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><name>Cache</name> <modifier>*</modifier></type><name>hcache</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>RenameStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name> <init>= <expr><call><name>ts_hypertable_cache_get_entry</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>, <argument><expr><name>CACHE_FLAG_MISSING_OK</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>ht</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name> <init>= <expr><call><name>ts_chunk_get_by_relid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>chunk</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ts_chunk_set_name</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>newname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ts_hypertable_set_name</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>newname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>add_hypertable_to_process_args</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_rename_column</name><parameter_list>(<parameter><decl><type><name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><name>Cache</name> <modifier>*</modifier></type><name>hcache</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>RenameStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name> <init>= <expr><call><name>ts_hypertable_cache_get_entry</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>, <argument><expr><name>CACHE_FLAG_MISSING_OK</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Dimension</name> <modifier>*</modifier></type><name>dim</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>ht</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name> <init>= <expr><call><name>ts_chunk_get_by_relid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>chunk</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot rename column \"%s\" of hypertable chunk \"%s\""</literal></expr></argument>,
							<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>subname</name></name></expr></argument>,
							<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Rename the hypertable column instead."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* This was not a hypertable and not a chunk, but it could be a
		 * continuous aggregate.
		 *
		 * If this is a continuous aggregate, the rename should be done on the
		 * materialized table. Since the partial view and the direct view are
		 * not referencing the materialized table, we need to handle it here,
		 * and in addition, the dimension table contains the column name, we
		 * need to update the name there. */</comment>
		<decl_stmt><decl><type><name>ContinuousAgg</name> <modifier>*</modifier></type><name>cagg</name> <init>= <expr><call><name>ts_continuous_agg_find_by_relid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>cagg</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RenameStmt</name> <modifier>*</modifier></type><name>direct_view_stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>RenameStmt</name></expr></argument>, <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>direct_view_stmt</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>direct_view_schema</name></name></expr></argument>)</argument_list></call></expr></argument>,
													  <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>direct_view_name</name></name></expr></argument>)</argument_list></call></expr></argument>,
													  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExecRenameStmt</name><argument_list>(<argument><expr><name>direct_view_stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<decl_stmt><decl><type><name>RenameStmt</name> <modifier>*</modifier></type><name>partial_view_stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>RenameStmt</name></expr></argument>, <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>partial_view_stmt</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>partial_view_schema</name></name></expr></argument>)</argument_list></call></expr></argument>,
													   <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>partial_view_name</name></name></expr></argument>)</argument_list></call></expr></argument>,
													   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExecRenameStmt</name><argument_list>(<argument><expr><name>partial_view_stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Fetch the main table and it's relid and use that for the
			 * processing below. This is necessary to rebuild the view based
			 * on the table with the renamed columns. */</comment>
			<expr_stmt><expr><name>ht</name> <operator>=</operator> <call><name>ts_hypertable_get_by_id</name><argument_list>(<argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>mat_hypertable_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>relid</name> <operator>=</operator> <name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr>;</expr_stmt>

			<decl_stmt><decl><type><name>RenameStmt</name> <modifier>*</modifier></type><name>mat_hypertable_stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>RenameStmt</name></expr></argument>, <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>mat_hypertable_stmt</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator>
				<call><name>makeRangeVar</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>schema_name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExecRenameStmt</name><argument_list>(<argument><expr><name>mat_hypertable_stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Block renaming columns on the materialization table of a continuous
		 * agg, but only if this was an explicit request for rename on a
		 * materialization table. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>ts_continuous_agg_hypertable_status</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>HypertableIsMaterialization</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"renaming columns on materialization tables is not supported"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Column \"%s\" in materialization table \"%s\"."</literal></expr></argument>,
							   <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>subname</name></name></expr></argument>,
							   <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Rename the column on the continuous aggregate instead."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* If there were a hypertable or a continuous aggregate, we need to rename
	 * the dimension that we used as well as rebuilding the view. Otherwise,
	 * we don't do anything. */</comment>
	<if_stmt><if>if <condition>(<expr><name>ht</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>add_hypertable_to_process_args</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>dim</name> <operator>=</operator> <call><name>ts_hyperspace_get_mutable_dimension_by_name</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>space</name></name></expr></argument>,
														  <argument><expr><name>DIMENSION_TYPE_ANY</name></expr></argument>,
														  <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>subname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>dim</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ts_dimension_set_name</name><argument_list>(<argument><expr><name>dim</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>newname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>ts_cm_functions</name><operator>-&gt;</operator><name>process_rename_cmd</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name><name>ts_cm_functions</name><operator>-&gt;</operator><name>process_rename_cmd</name></name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>hcache</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_rename_index</name><parameter_list>(<parameter><decl><type><name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><name>Cache</name> <modifier>*</modifier></type><name>hcache</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>RenameStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>tablerelid</name> <init>= <expr><call><name>IndexGetRelation</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>tablerelid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>ht</name> <operator>=</operator> <call><name>ts_hypertable_cache_get_entry</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>, <argument><expr><name>tablerelid</name></expr></argument>, <argument><expr><name>CACHE_FLAG_MISSING_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>ht</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ts_chunk_index_rename_parent</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>newname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>add_hypertable_to_process_args</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name> <init>= <expr><call><name>ts_chunk_get_by_relid</name><argument_list>(<argument><expr><name>tablerelid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>chunk</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ts_chunk_index_rename</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>newname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_rename_view</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>RenameStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>schema</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ts_continuous_agg_rename_view</name><argument_list>(<argument><expr><name>schema</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>schema</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>newname</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>stmt</name><operator>-&gt;</operator><name>renameType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Visit all internal catalog tables with a schema column to check for applicable rename */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_rename_schema</name><parameter_list>(<parameter><decl><type><name>RenameStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Block any renames of our internal schemas */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NUM_TIMESCALEDB_SCHEMAS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>subname</name></name></expr></argument>, <argument><expr><name><name>ts_extension_schema_names</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TS_OPERATION_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot rename schemas used by the TimescaleDB extension"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>ts_chunks_rename_schema_name</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>subname</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>newname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_dimensions_rename_schema_name</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>subname</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>newname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_hypertables_rename_schema_name</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>subname</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>newname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_continuous_agg_rename_schema_name</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>subname</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>newname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>rename_hypertable_constraint</name><parameter_list>(<parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>chunk_relid</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RenameStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>RenameStmt</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name> <init>= <expr><call><name>ts_chunk_get_by_relid</name><argument_list>(<argument><expr><name>chunk_relid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ts_chunk_constraint_rename_hypertable_constraint</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>subname</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>newname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>alter_hypertable_constraint</name><parameter_list>(<parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>chunk_relid</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><operator>(</operator><name>AlterTableCmd</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>cmd_constraint</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>hypertable_constraint_name</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name>Constraint</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cmd_constraint</name> <operator>=</operator> <operator>(</operator><name>Constraint</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>hypertable_constraint_name</name> <operator>=</operator> <name><name>cmd_constraint</name><operator>-&gt;</operator><name>conname</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>cmd_constraint</name><operator>-&gt;</operator><name>conname</name></name> <operator>=</operator>
		<call><name>ts_chunk_constraint_get_name_from_hypertable_constraint</name><argument_list>(<argument><expr><name>chunk_relid</name></expr></argument>,
																<argument><expr><name>hypertable_constraint_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AlterTableInternal</name><argument_list>(<argument><expr><name>chunk_relid</name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Restore for next iteration */</comment>
	<expr_stmt><expr><name><name>cmd_constraint</name><operator>-&gt;</operator><name>conname</name></name> <operator>=</operator> <name>hypertable_constraint_name</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>validate_hypertable_constraint</name><parameter_list>(<parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>chunk_relid</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><operator>(</operator><name>AlterTableCmd</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>chunk_cmd</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>chunk_cmd</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator>
		<call><name>ts_chunk_constraint_get_name_from_hypertable_constraint</name><argument_list>(<argument><expr><name>chunk_relid</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>chunk_cmd</name><operator>-&gt;</operator><name>name</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* do not pass down the VALIDATE RECURSE subtype */</comment>
	<expr_stmt><expr><name><name>chunk_cmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>=</operator> <name>AT_ValidateConstraint</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AlterTableInternal</name><argument_list>(<argument><expr><name>chunk_relid</name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>chunk_cmd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>rename_hypertable_trigger</name><parameter_list>(<parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>chunk_relid</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RenameStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>RenameStmt</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name> <init>= <expr><call><name>ts_chunk_get_by_relid</name><argument_list>(<argument><expr><name>chunk_relid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>schema_name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>renametrig</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_rename_constraint_or_trigger</name><parameter_list>(<parameter><decl><type><name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><name>Cache</name> <modifier>*</modifier></type><name>hcache</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>,
									 <parameter><decl><type><name>RenameStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ht</name> <operator>=</operator> <call><name>ts_hypertable_cache_get_entry</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>, <argument><expr><name>CACHE_FLAG_MISSING_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>ht</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>relation_not_only</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>add_hypertable_to_process_args</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>renameType</name></name> <operator>==</operator> <name>OBJECT_TABCONSTRAINT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>foreach_chunk</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>rename_hypertable_constraint</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>renameType</name></name> <operator>==</operator> <name>OBJECT_TRIGGER</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>hypertable_is_distributed</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>foreach_chunk</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>rename_hypertable_trigger</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>renameType</name></name> <operator>==</operator> <name>OBJECT_TABCONSTRAINT</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name> <init>= <expr><call><name>ts_chunk_get_by_relid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>chunk</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"renaming constraints on chunks is not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DDLResult</name></type>
<name>process_rename</name><parameter_list>(<parameter><decl><type><name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RenameStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>RenameStmt</name> <operator>*</operator><operator>)</operator> <name><name>args</name><operator>-&gt;</operator><name>parsetree</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cache</name> <modifier>*</modifier></type><name>hcache</name></decl>;</decl_stmt>

	<comment type="block">/* Only get the relid if it exists for this stmt */</comment>
	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>DDL_CONTINUE</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * stmt-&gt;relation never be NULL unless we are renaming a schema or
		 * other objects, like foreign server
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>renameType</name></name> <operator>!=</operator> <name>OBJECT_SCHEMA</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>DDL_CONTINUE</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>hcache</name> <operator>=</operator> <call><name>ts_hypertable_cache_pin</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>renameType</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>OBJECT_TABLE</name></expr>:</case>
			<expr_stmt><expr><call><name>process_rename_table</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>hcache</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_COLUMN</name></expr>:</case>
			<expr_stmt><expr><call><name>process_rename_column</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>hcache</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_INDEX</name></expr>:</case>
			<expr_stmt><expr><call><name>process_rename_index</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>hcache</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_TABCONSTRAINT</name></expr>:</case>
		<case>case <expr><name>OBJECT_TRIGGER</name></expr>:</case>
			<expr_stmt><expr><call><name>process_rename_constraint_or_trigger</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>hcache</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_MATVIEW</name></expr>:</case>
		<case>case <expr><name>OBJECT_VIEW</name></expr>:</case>
			<expr_stmt><expr><call><name>process_rename_view</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_SCHEMA</name></expr>:</case>
			<expr_stmt><expr><call><name>process_rename_schema</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>DDL_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_altertable_change_owner_chunk</name><parameter_list>(<parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>chunk_relid</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>roleid</name> <init>= <expr><call><name>get_rolespec_oid</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>newowner</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ATExecChangeOwner</name><argument_list>(<argument><expr><name>chunk_relid</name></expr></argument>, <argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_altertable_change_owner</name><parameter_list>(<parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>newowner</name></name></expr></argument>, <argument><expr><name>RoleSpec</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>foreach_chunk</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>process_altertable_change_owner_chunk</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TS_HYPERTABLE_HAS_COMPRESSION_TABLE</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>compressed_hypertable</name> <init>=
			<expr><call><name>ts_hypertable_get_by_id</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>compressed_hypertable_id</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>AlterTableInternal</name><argument_list>(<argument><expr><name><name>compressed_hypertable</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>process_altertable_change_owner</name><argument_list>(<argument><expr><name>compressed_hypertable</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_add_constraint_chunk</name><parameter_list>(<parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>chunk_relid</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>hypertable_constraint_oid</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <name>arg</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name> <init>= <expr><call><name>ts_chunk_get_by_relid</name><argument_list>(<argument><expr><name>chunk_relid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ts_chunk_constraint_create_on_chunk</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>hypertable_constraint_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_altertable_add_constraint</name><parameter_list>(<parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>constraint_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>hypertable_constraint_oid</name> <init>=
		<expr><call><name>get_relation_constraint_oid</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>, <argument><expr><name>constraint_name</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>constraint_name</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>foreach_chunk</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>process_add_constraint_chunk</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hypertable_constraint_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_altertable_alter_constraint_end</name><parameter_list>(<parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>foreach_chunk</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>alter_hypertable_constraint</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_altertable_validate_constraint_end</name><parameter_list>(<parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>foreach_chunk</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>validate_hypertable_constraint</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_altertable_drop_not_null</name><parameter_list>(<parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ht</name><operator>-&gt;</operator><name>space</name><operator>-&gt;</operator><name>num_dimensions</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Dimension</name> <modifier>*</modifier></type><name>dim</name> <init>= <expr><operator>&amp;</operator><name><name>ht</name><operator>-&gt;</operator><name>space</name><operator>-&gt;</operator><name>dimensions</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IS_OPEN_DIMENSION</name><argument_list>(<argument><expr><name>dim</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>strncmp</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>column_name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TS_OPERATION_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot drop not-null constraint from a time-partitioned column"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_altertable_drop_column</name><parameter_list>(<parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ht</name><operator>-&gt;</operator><name>space</name><operator>-&gt;</operator><name>num_dimensions</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Dimension</name> <modifier>*</modifier></type><name>dim</name> <init>= <expr><operator>&amp;</operator><name><name>ht</name><operator>-&gt;</operator><name>space</name><operator>-&gt;</operator><name>dimensions</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>namestrcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>column_name</name></name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot drop column named in partition key"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Cannot drop column that is a hypertable partitioning (space or "</literal>
							   <literal type="string">"time) dimension."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* process all regular-table alter commands to make sure they aren't adding
 * foreign-key constraints to hypertables */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>verify_constraint_plaintable</name><parameter_list>(<parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>relation</name></decl></parameter>, <parameter><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>constr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cache</name> <modifier>*</modifier></type><name>hcache</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>constr</name></expr></argument>, <argument><expr><name>Constraint</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>hcache</name> <operator>=</operator> <call><name>ts_hypertable_cache_pin</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>constr</name><operator>-&gt;</operator><name>contype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>CONSTR_FOREIGN</name></expr>:</case>
			<expr_stmt><expr><name>ht</name> <operator>=</operator> <call><name>ts_hypertable_cache_get_entry_rv</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>, <argument><expr><name><name>constr</name><operator>-&gt;</operator><name>pktable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>ht</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"foreign keys to hypertables are not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Verify that a constraint is supported on a hypertable.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>verify_constraint_hypertable</name><parameter_list>(<parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>constr_node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ConstrType</name></type> <name>contype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>indexname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>keys</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>constr_node</name></expr></argument>, <argument><expr><name>Constraint</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>constr</name> <init>= <expr><operator>(</operator><name>Constraint</name> <operator>*</operator><operator>)</operator> <name>constr_node</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>contype</name> <operator>=</operator> <name><name>constr</name><operator>-&gt;</operator><name>contype</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>keys</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>contype</name> <operator>==</operator> <name>CONSTR_EXCLUSION</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>constr</name><operator>-&gt;</operator><name>exclusions</name></name></expr> </then><else>: <expr><name><name>constr</name><operator>-&gt;</operator><name>keys</name></name></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name>indexname</name> <operator>=</operator> <name><name>constr</name><operator>-&gt;</operator><name>indexname</name></name></expr>;</expr_stmt>

		<comment type="block">/* NO INHERIT constraints do not really make sense on a hypertable */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>constr</name><operator>-&gt;</operator><name>is_no_inherit</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot have NO INHERIT constraints on hypertable \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>constr_node</name></expr></argument>, <argument><expr><name>IndexStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>IndexStmt</name> <operator>*</operator><operator>)</operator> <name>constr_node</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>contype</name> <operator>=</operator> <ternary><condition><expr><name><name>stmt</name><operator>-&gt;</operator><name>primary</name></name></expr> ?</condition><then> <expr><name>CONSTR_PRIMARY</name></expr> </then><else>: <expr><name>CONSTR_UNIQUE</name></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name>keys</name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>indexParams</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>indexname</name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>idxname</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected constraint type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></else></if_stmt>

	<switch>switch <condition>(<expr><name>contype</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>CONSTR_FOREIGN</name></expr>:</case>
			<break>break;</break>
		<case>case <expr><name>CONSTR_UNIQUE</name></expr>:</case>
		<case>case <expr><name>CONSTR_PRIMARY</name></expr>:</case>

			<comment type="block">/*
			 * If this constraints is created using an existing index we need
			 * not re-verify it's columns
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>indexname</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return;</return></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>ts_indexing_verify_columns</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>space</name></name></expr></argument>, <argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>CONSTR_EXCLUSION</name></expr>:</case>
			<expr_stmt><expr><call><name>ts_indexing_verify_columns</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>space</name></name></expr></argument>, <argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>verify_constraint</name><parameter_list>(<parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>relation</name></decl></parameter>, <parameter><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>constr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cache</name> <modifier>*</modifier></type><name>hcache</name> <init>= <expr><call><name>ts_hypertable_cache_pin</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name> <init>= <expr><call><name>ts_hypertable_cache_get_entry_rv</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>ht</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>verify_constraint_plaintable</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>constr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>verify_constraint_hypertable</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>constr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>verify_constraint_list</name><parameter_list>(<parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>relation</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>constraint_list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>constraint_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>constraint</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>verify_constraint</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>constraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <name>HypertableIndexOptions</name>
<block>{
	<comment type="block">/*
	 * true if we should run one transaction per chunk, otherwise use one
	 * transaction for all the chunks
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>multitransaction</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>n_ht_atts</name></decl>;</decl_stmt>

	<comment type="block">/* Concurrency testing options. */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
	<comment type="block">/*
	 * If barrier_table is a valid Oid we try to acquire a lock on it at the
	 * start of each chunks sub-transaction.
	 */</comment>
	<decl_stmt><decl><type><name>Oid</name></type> <name>barrier_table</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * if max_chunks &gt;= 0 we'll create indices on at most max_chunks, and
	 * leave the table marked as Invalid when the command ends.
	 */</comment>
	<decl_stmt><decl><type><name>int32</name></type> <name>max_chunks</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></struct></type> <name>HypertableIndexOptions</name>;</typedef>

<typedef>typedef <type><struct>struct <name>CreateIndexInfo</name>
<block>{
	<decl_stmt><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>stmt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>obj</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>main_table_relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HypertableIndexOptions</name></type> <name>extended_options</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>mctx</name></decl>;</decl_stmt>
}</block></struct></type> <name>CreateIndexInfo</name>;</typedef>

<comment type="block">/*
 * Create index on a chunk.
 *
 * A chunk index is created based on the original IndexStmt that created the
 * "parent" index on the hypertable.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_index_chunk</name><parameter_list>(<parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>chunk_relid</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CreateIndexInfo</name> <modifier>*</modifier></type><name>info</name> <init>= <expr><operator>(</operator><name>CreateIndexInfo</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>hypertable_index_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>chunk_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>indexinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>hypertable_is_distributed</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>chunk</name> <operator>=</operator> <call><name>ts_chunk_get_by_relid</name><argument_list>(<argument><expr><name>chunk_relid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>chunk_rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>chunk_relid</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>hypertable_index_rel</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>obj</name><operator>.</operator><name>objectId</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>indexinfo</name> <operator>=</operator> <call><name>BuildIndexInfo</name><argument_list>(<argument><expr><name>hypertable_index_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>chunk_index_columns_changed</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>extended_options</name><operator>.</operator><name>n_ht_atts</name></name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>chunk_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ts_adjust_indexinfo_attnos</name><argument_list>(<argument><expr><name>indexinfo</name></expr></argument>, <argument><expr><name><name>info</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>, <argument><expr><name>chunk_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ts_chunk_index_create_from_adjusted_index_info</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>,
												   <argument><expr><name>hypertable_index_rel</name></expr></argument>,
												   <argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>,
												   <argument><expr><name>chunk_rel</name></expr></argument>,
												   <argument><expr><name>indexinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>hypertable_index_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>chunk_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_index_chunk_multitransaction</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>hypertable_id</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>chunk_relid</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CreateIndexInfo</name> <modifier>*</modifier></type><name>info</name> <init>= <expr><operator>(</operator><name>CreateIndexInfo</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CatalogSecurityContext</name></type> <name>sec_ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>hypertable_index_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>chunk_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>indexinfo</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>extended_options</name><operator>.</operator><name>multitransaction</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Start a new transaction for each relation. */</comment>
	<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>extended_options</name><operator>.</operator><name>max_chunks</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * if max_chunks is &lt; 0 then we're indexing all the chunks, if it's &gt;= 0
	 * then we're only indexing some of the chunks, and leaving the root index
	 * marked as invalid
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>extended_options</name><operator>.</operator><name>max_chunks</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>extended_options</name><operator>.</operator><name>max_chunks</name></name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>extended_options</name><operator>.</operator><name>barrier_table</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * For isolation tests, and debugging, it's useful to be able to
		 * pause CREATE INDEX immediately before it starts working on chunks.
		 * We acquire and immediately release a lock on a barrier table to do
		 * this.
		 */</comment>
		<decl_stmt><decl><type><name>Relation</name></type> <name>barrier</name> <init>= <expr><call><name>relation_open</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>extended_options</name><operator>.</operator><name>barrier_table</name></name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>barrier</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Change user since chunks are typically located in an internal schema
	 * and chunk indexes require metadata changes. In the single-transaction
	 * case, we do this once for the entire table.
	 */</comment>
	<expr_stmt><expr><call><name>ts_catalog_database_info_become_owner</name><argument_list>(<argument><expr><call><name>ts_catalog_database_info_get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Hold a lock on the hypertable index, and the chunk to prevent
	 * from being altered. Since we use the same relids across transactions,
	 * there is a potential issue if the id gets reassigned between one
	 * sub-transaction and the next. CLUSTER has a similar issue.
	 *
	 * We grab a ShareLock on the chunk, because that's what CREATE INDEX
	 * does. For the hypertable's index, we are ok using the weaker
	 * AccessShareLock, since we only need to prevent the index itself from
	 * being ALTERed or DROPed during this part of index creation.
	 */</comment>
	<expr_stmt><expr><name>chunk_rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>chunk_relid</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>hypertable_index_rel</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>obj</name><operator>.</operator><name>objectId</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>chunk</name> <operator>=</operator> <call><name>ts_chunk_get_by_relid</name><argument_list>(<argument><expr><name>chunk_relid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Validation happens when creating the hypertable's index, which goes
	 * through the usual DefineIndex mechanism.
	 */</comment>
	<expr_stmt><expr><name>indexinfo</name> <operator>=</operator> <call><name>BuildIndexInfo</name><argument_list>(<argument><expr><name>hypertable_index_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>chunk_index_columns_changed</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>extended_options</name><operator>.</operator><name>n_ht_atts</name></name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>chunk_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ts_adjust_indexinfo_attnos</name><argument_list>(<argument><expr><name>indexinfo</name></expr></argument>, <argument><expr><name><name>info</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>, <argument><expr><name>chunk_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ts_chunk_index_create_from_adjusted_index_info</name><argument_list>(<argument><expr><name>hypertable_id</name></expr></argument>,
												   <argument><expr><name>hypertable_index_rel</name></expr></argument>,
												   <argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>,
												   <argument><expr><name>chunk_rel</name></expr></argument>,
												   <argument><expr><name>indexinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>hypertable_index_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>chunk_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ts_catalog_restore_user</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<typedef>typedef <type><enum>enum <name>HypertableIndexFlags</name>
<block>{
	<decl><name>HypertableIndexFlagMultiTransaction</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
	<decl><name>HypertableIndexFlagBarrierTable</name></decl>,
	<decl><name>HypertableIndexFlagMaxChunks</name></decl>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></enum></type> <name>HypertableIndexFlags</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>WithClauseDefinition</name></type> <name><name>index_with_clauses</name><index>[]</index></name> <init>= <expr><block>{
	<expr><index>[<expr><name>HypertableIndexFlagMultiTransaction</name></expr>]</index> <operator>=</operator> <block>{<expr><operator>.</operator><name>arg_name</name> <operator>=</operator> <literal type="string">"transaction_per_chunk"</literal></expr>, <expr><operator>.</operator><name>type_id</name> <operator>=</operator> <name>BOOLOID</name></expr>,}</block></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
	<expr><index>[<expr><name>HypertableIndexFlagBarrierTable</name></expr>]</index> <operator>=</operator> <block>{<expr><operator>.</operator><name>arg_name</name> <operator>=</operator> <literal type="string">"barrier_table"</literal></expr>, <expr><operator>.</operator><name>type_id</name> <operator>=</operator> <name>REGCLASSOID</name></expr>,}</block></expr>,
	<expr><index>[<expr><name>HypertableIndexFlagMaxChunks</name></expr>]</index> <operator>=</operator> <block>{<expr><operator>.</operator><name>arg_name</name> <operator>=</operator> <literal type="string">"max_chunks"</literal></expr>, <expr><operator>.</operator><name>type_id</name> <operator>=</operator> <name>INT4OID</name></expr>, <expr><operator>.</operator><name>default_val</name> <operator>=</operator> <macro><name>Int32GetDatum</name><argument_list>(<argument>-<literal type="number">1</literal></argument>)</argument_list></macro></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>multitransaction_create_index_mark_valid</name><parameter_list>(<parameter><decl><type><name>CreateIndexInfo</name></type> <name>info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
	<return>return <expr><name><name>info</name><operator>.</operator><name>extended_options</name><operator>.</operator><name>max_chunks</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<return>return <expr><name>true</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * Create an index on a hypertable
 *
 * We override CREATE INDEX on hypertables in order to ensure that the index is
 * created on all of the hypertable's chunks, and to ensure that locks on all
 * of said chunks are acquired at the correct time.
 */</comment>
<function><type><specifier>static</specifier> <name>DDLResult</name></type>
<name>process_index_start</name><parameter_list>(<parameter><decl><type><name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>IndexStmt</name> <operator>*</operator><operator>)</operator> <name><name>args</name><operator>-&gt;</operator><name>parsetree</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cache</name> <modifier>*</modifier></type><name>hcache</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>postgres_options</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>hypertable_options</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WithClauseResult</name> <modifier>*</modifier></type><name>parsed_with_clauses</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CreateIndexInfo</name></type> <name>info</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>stmt</name> <operator>=</operator> <name>stmt</name></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
		<expr><operator>.</operator><name>extended_options</name> <operator>=</operator> <block>{<expr><literal type="number">0</literal></expr>, <expr><operator>.</operator><name>max_chunks</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>,}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>root_table_index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>main_table_relation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>main_table_desc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>main_table_index_relation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LockRelId</name></type> <name>main_table_index_lock_relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>sec_ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>uid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>, <decl><type ref="prev"/><name>saved_uid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ContinuousAgg</name> <modifier>*</modifier></type><name>cagg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>IndexStmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * PG11 adds some cases where the relation is not there, namely on
	 * declaratively partitioned tables, with partitioned indexes:
	 * https://github.com/postgres/postgres/commit/8b08f7d4820fd7a8ef6152a9dd8c6e3cb01e5f99
	 * we don't deal with them so we will just return immediately
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>DDL_CONTINUE</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>hcache</name> <operator>=</operator> <call><name>ts_hypertable_cache_pin</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ht</name> <operator>=</operator> <call><name>ts_hypertable_cache_get_entry_rv</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>ht</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Check if the relation is a Continuous Aggregate */</comment>
		<expr_stmt><expr><name>cagg</name> <operator>=</operator> <call><name>ts_continuous_agg_find_by_rv</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>cagg</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* If the relation is a CAgg and it is finalized */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>ContinuousAggIsFinalized</name><argument_list>(<argument><expr><name>cagg</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>ht</name> <operator>=</operator> <call><name>ts_hypertable_get_by_id</name><argument_list>(<argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>mat_hypertable_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"operation not supported on continuous aggreates that are not "</literal>
								<literal type="string">"finalized"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Recreate the continuous aggregate to allow index creation."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>ht</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>DDL_CONTINUE</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>unique</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"continuous aggregates do not support UNIQUE indexes"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Make the RangeVar for the underlying materialization hypertable */</comment>
		<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>schema_name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>TS_HYPERTABLE_HAS_COMPRESSION_ENABLED</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* unique indexes are not allowed on compressed hypertables*/</comment>
		<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>unique</name></name> <operator>||</operator> <name><name>stmt</name><operator>-&gt;</operator><name>primary</name></name> <operator>||</operator> <name><name>stmt</name><operator>-&gt;</operator><name>isconstraint</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"operation not supported on hypertables that have compression "</literal>
							<literal type="string">"enabled"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ts_hypertable_permissions_check_by_id</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>add_hypertable_to_process_args</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ts_with_clause_filter</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hypertable_options</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>postgres_options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <name>postgres_options</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>parsed_with_clauses</name> <operator>=</operator> <call><name>ts_with_clauses_parse</name><argument_list>(<argument><expr><name>hypertable_options</name></expr></argument>,
												<argument><expr><name>index_with_clauses</name></expr></argument>,
												<argument><expr><call><name>TS_ARRAY_LEN</name><argument_list>(<argument><expr><name>index_with_clauses</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>extended_options</name><operator>.</operator><name>multitransaction</name></name> <operator>=</operator>
		<call><name>DatumGetBool</name><argument_list>(<argument><expr><name><name>parsed_with_clauses</name><index>[<expr><name>HypertableIndexFlagMultiTransaction</name></expr>]</index></name><operator>.</operator><name>parsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>extended_options</name><operator>.</operator><name>max_chunks</name></name> <operator>=</operator>
		<call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>parsed_with_clauses</name><index>[<expr><name>HypertableIndexFlagMaxChunks</name></expr>]</index></name><operator>.</operator><name>parsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>extended_options</name><operator>.</operator><name>barrier_table</name></name> <operator>=</operator>
		<call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name><name>parsed_with_clauses</name><index>[<expr><name>HypertableIndexFlagBarrierTable</name></expr>]</index></name><operator>.</operator><name>parsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* Make sure this index is allowed */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>concurrent</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"hypertables do not support concurrent "</literal>
						<literal type="string">"index creation"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>.</operator><name>extended_options</name><operator>.</operator><name>multitransaction</name></name> <operator>&amp;&amp;</operator>
		<operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>unique</name></name> <operator>||</operator> <name><name>stmt</name><operator>-&gt;</operator><name>primary</name></name> <operator>||</operator> <name><name>stmt</name><operator>-&gt;</operator><name>isconstraint</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(
					 <argument><expr><literal type="string">"cannot use timescaledb.transaction_per_chunk with UNIQUE or PRIMARY KEY"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>.</operator><name>extended_options</name><operator>.</operator><name>multitransaction</name></name> <operator>&amp;&amp;</operator> <call><name>hypertable_is_distributed</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(
					 <argument><expr><literal type="string">"cannot use timescaledb.transaction_per_chunk with distributed hypertable"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ts_indexing_verify_index</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>space</name></name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>.</operator><name>extended_options</name><operator>.</operator><name>multitransaction</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PreventInTransactionBlock</name><argument_list>(<argument><expr><name>true</name></expr></argument>,
								  <argument><expr><literal type="string">"CREATE INDEX ... WITH (timescaledb.transaction_per_chunk)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>cagg</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If this is an index creation for cagg, then we need to switch user as the current
		 * user might not have permissions on the internal schema where cagg index will be
		 * created.
		 * Need to restore user soon after this step.
		 */</comment>
		<expr_stmt><expr><call><name>ts_cagg_permissions_check</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SWITCH_TO_TS_USER</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>direct_view_schema</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>uid</name></expr></argument>, <argument><expr><name>saved_uid</name></expr></argument>, <argument><expr><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* CREATE INDEX on the root table of the hypertable */</comment>
	<expr_stmt><expr><name>root_table_index</name> <operator>=</operator> <call><name>ts_indexing_root_table_create_index</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>,
														   <argument><expr><name><name>args</name><operator>-&gt;</operator><name>query_string</name></name></expr></argument>,
														   <argument><expr><name><name>info</name><operator>.</operator><name>extended_options</name><operator>.</operator><name>multitransaction</name></name></expr></argument>,
														   <argument><expr><call><name>hypertable_is_distributed</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>cagg</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>RESTORE_USER</name><argument_list>(<argument><expr><name>uid</name></expr></argument>, <argument><expr><name>saved_uid</name></expr></argument>, <argument><expr><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* root_table_index will have 0 objectId if the index already exists
	 * and if_not_exists is true. In that case there is nothing else
	 * to do here. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>root_table_index</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>stmt</name><operator>-&gt;</operator><name>if_not_exists</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>DDL_DONE</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>root_table_index</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>obj</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name><name>root_table_index</name><operator>.</operator><name>objectId</name></name></expr>;</expr_stmt>

	<comment type="block">/* CREATE INDEX on the chunks, unless this is a distributed hypertable */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>hypertable_is_distributed</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>DDL_DONE</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* collect information required for per chunk index creation */</comment>
	<expr_stmt><expr><name>main_table_relation</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>main_table_desc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>main_table_relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>main_table_index_relation</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name><name>info</name><operator>.</operator><name>obj</name><operator>.</operator><name>objectId</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>main_table_index_lock_relid</name> <operator>=</operator> <name><name>main_table_index_relation</name><operator>-&gt;</operator><name>rd_lockInfo</name><operator>.</operator><name>lockRelId</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>extended_options</name><operator>.</operator><name>n_ht_atts</name></name> <operator>=</operator> <name><name>main_table_desc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>main_table_relid</name></name> <operator>=</operator> <name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>main_table_index_relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>main_table_relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* create chunk indexes using the same transaction for all the chunks */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>info</name><operator>.</operator><name>extended_options</name><operator>.</operator><name>multitransaction</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CatalogSecurityContext</name></type> <name>sec_ctx</name></decl>;</decl_stmt>
		<comment type="block">/*
		 * Change user since chunk's are typically located in an internal
		 * schema and chunk indexes require metadata changes. In the
		 * multi-transaction case, we do this once per chunk.
		 */</comment>
		<expr_stmt><expr><call><name>ts_catalog_database_info_become_owner</name><argument_list>(<argument><expr><call><name>ts_catalog_database_info_get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Recurse to each chunk and create a corresponding index. */</comment>
		<expr_stmt><expr><call><name>foreach_chunk</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>process_index_chunk</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ts_catalog_restore_user</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>DDL_DONE</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* create chunk indexes using a separate transaction for each chunk */</comment>

	<comment type="block">/*
	 * Lock the index for the remainder of the command. Since we're using
	 * multiple transactions for index creation, a regular
	 * transaction-level lock won't prevent the index from being
	 * concurrently ALTERed or DELETEed. Instead, we grab a session level
	 * lock on the index, which we'll release when the command is
	 * finished. (This is the same strategy postgres uses in CREATE INDEX
	 * CONCURRENTLY)
	 */</comment>
	<expr_stmt><expr><call><name>LockRelationIdForSession</name><argument_list>(<argument><expr><operator>&amp;</operator><name>main_table_index_lock_relid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * mark the hypertable's index as invalid until all the chunk indexes
	 * are created. This allows us to determine if the CREATE INDEX
	 * completed successfully or  not
	 */</comment>
	<expr_stmt><expr><call><name>ts_indexing_mark_as_invalid</name><argument_list>(<argument><expr><name><name>info</name><operator>.</operator><name>obj</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CacheInvalidateRelcacheByRelid</name><argument_list>(<argument><expr><name><name>info</name><operator>.</operator><name>main_table_relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CacheInvalidateRelcacheByRelid</name><argument_list>(<argument><expr><name><name>info</name><operator>.</operator><name>obj</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* we need a long-lived context in which to store the list of chunks since the per-transaction
	 * context will get freed at the end of each transaction. Fortunately we're within just such a
	 * context now; the PortalContext. */</comment>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>mctx</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>foreach_chunk_multitransaction</name><argument_list>(<argument><expr><name><name>info</name><operator>.</operator><name>main_table_relid</name></name></expr></argument>,
								   <argument><expr><name><name>info</name><operator>.</operator><name>mctx</name></name></expr></argument>,
								   <argument><expr><name>process_index_chunk_multitransaction</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>info</name><operator>.</operator><name>mctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>multitransaction_create_index_mark_valid</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* we're done, the index is now valid */</comment>
		<expr_stmt><expr><call><name>ts_indexing_mark_as_valid</name><argument_list>(<argument><expr><name><name>info</name><operator>.</operator><name>obj</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CacheInvalidateRelcacheByRelid</name><argument_list>(<argument><expr><name><name>info</name><operator>.</operator><name>main_table_relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CacheInvalidateRelcacheByRelid</name><argument_list>(<argument><expr><name><name>info</name><operator>.</operator><name>obj</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>UnlockRelationIdForSession</name><argument_list>(<argument><expr><operator>&amp;</operator><name>main_table_index_lock_relid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>DEBUG_WAITPOINT</name><argument_list>(<argument><expr><literal type="string">"process_index_start_indexing_done"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>DDL_DONE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>chunk_index_mappings_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ChunkIndexMapping</name> <modifier>*</modifier></type><name><name>mapping</name><index>[]</index></name> <init>= <expr><block>{ <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>ChunkIndexMapping</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>p1</name><operator>)</operator></expr>,
										   <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>ChunkIndexMapping</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>p2</name><operator>)</operator></expr> }</block></expr></init></decl>;</decl_stmt>

	<return>return <expr><name><name>mapping</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>chunkoid</name> <operator>-</operator> <name><name>mapping</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>chunkoid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Cluster a hypertable.
 *
 * The functionality to cluster all chunks of a hypertable is based on the
 * regular cluster function's mode to cluster multiple tables. Since clustering
 * involves taking exclusive locks on all tables for extensive periods of time,
 * each subtable is clustered in its own transaction. This will release all
 * locks on subtables once they are done.
 */</comment>
<function><type><specifier>static</specifier> <name>DDLResult</name></type>
<name>process_cluster_start</name><parameter_list>(<parameter><decl><type><name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ClusterStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>ClusterStmt</name> <operator>*</operator><operator>)</operator> <name><name>args</name><operator>-&gt;</operator><name>parsetree</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cache</name> <modifier>*</modifier></type><name>hcache</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DDLResult</name></type> <name>result</name> <init>= <expr><name>DDL_CONTINUE</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>ClusterStmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If this is a re-cluster on all tables, there is nothing we need to do */</comment>
	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>DDL_CONTINUE</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>hcache</name> <operator>=</operator> <call><name>ts_hypertable_cache_pin</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ht</name> <operator>=</operator> <call><name>ts_hypertable_cache_get_entry_rv</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>ht</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>is_top_level</name> <init>= <expr><operator>(</operator><name><name>args</name><operator>-&gt;</operator><name>context</name></name> <operator>==</operator> <name>PROCESS_UTILITY_TOPLEVEL</name><operator>)</operator></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>index_relid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type> <name>index_rel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>chunk_indexes</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old</name></decl>, <decl><type ref="prev"/><name>mcxt</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>LockRelId</name></type> <name>cluster_index_lockid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ChunkIndexMapping</name> <modifier>*</modifier><modifier>*</modifier></type><name>mappings</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ts_hypertable_permissions_check_by_id</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If CLUSTER is run inside a user transaction block; we bail out or
		 * otherwise we'd be holding locks way too long.
		 */</comment>
		<expr_stmt><expr><call><name>PreventInTransactionBlock</name><argument_list>(<argument><expr><name>is_top_level</name></expr></argument>, <argument><expr><literal type="string">"CLUSTER"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>add_hypertable_to_process_args</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>stmt</name><operator>-&gt;</operator><name>indexname</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>index_relid</name> <operator>=</operator> <call><name>ts_indexing_find_clustered_index</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>index_relid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"there is no previously clustered index for table \"%s\""</literal></expr></argument>,
								<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>index_relid</name> <operator>=</operator>
				<call><name>get_relname_relid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>indexname</name></name></expr></argument>, <argument><expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>index_relid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Let regular process utility handle */</comment>
			<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>DDL_CONTINUE</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * DROP INDEX locks the table then the index, to prevent deadlocks we
		 * lock them in the same order. The main table lock will be released
		 * when the current transaction commits, and never taken again. We
		 * will use the index relation to grab a session lock on the index,
		 * which we will hold throughout CLUSTER
		 */</comment>
		<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>index_rel</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name>index_relid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cluster_index_lockid</name> <operator>=</operator> <name><name>index_rel</name><operator>-&gt;</operator><name>rd_lockInfo</name><operator>.</operator><name>lockRelId</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>index_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * mark the main table as clustered, even though it has no data, so
		 * future calls to CLUSTER don't need to pass in the index
		 */</comment>
		<expr_stmt><expr><call><name>ts_chunk_index_mark_clustered</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>, <argument><expr><name>index_relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* we will keep holding this lock throughout CLUSTER */</comment>
		<expr_stmt><expr><call><name>LockRelationIdForSession</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cluster_index_lockid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * The list of chunks and their indexes need to be on a memory context
		 * that will survive moving to a new transaction for each chunk
		 */</comment>
		<expr_stmt><expr><name>mcxt</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>PortalContext</name></expr></argument>, <argument><expr><literal type="string">"Hypertable cluster"</literal></expr></argument>, <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Get a list of chunks and indexes that correspond to the
		 * hypertable's index
		 */</comment>
		<expr_stmt><expr><name>old</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>mcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>chunk_indexes</name> <operator>=</operator> <call><name>ts_chunk_index_get_mappings</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>index_relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>chunk_indexes</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Sort the mappings on chunk OID. This makes the verbose output more
			 * predictable in tests, but isn't strictly necessary. We could also do
			 * it only for "verbose" output, but this doesn't seem worth it as the
			 * cost of sorting is quickly amortized over the actual work to cluster
			 * the chunks. */</comment>
			<expr_stmt><expr><name>mappings</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ChunkIndexMapping</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>chunk_indexes</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>chunk_indexes</argument>)</argument_list></macro>
				<expr_stmt><expr><name><name>mappings</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>mappings</name></expr></argument>,
				  <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>chunk_indexes</name></expr></argument>)</argument_list></call></expr></argument>,
				  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ChunkIndexMapping</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>,
				  <argument><expr><name>chunk_index_mappings_cmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>hcache</name><operator>-&gt;</operator><name>release_on_commit</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/* Commit to get out of starting transaction */</comment>
		<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>chunk_indexes</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ChunkIndexMapping</name> <modifier>*</modifier></type><name>cim</name> <init>= <expr><name><name>mappings</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* Start a new transaction for each relation. */</comment>
			<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* functions in indexes may want a snapshot set */</comment>
			<expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * We must mark each chunk index as clustered before calling
			 * cluster_rel() because it expects indexes that need to be
			 * rechecked (due to new transaction) to already have that mark
			 * set
			 */</comment>
			<expr_stmt><expr><call><name>ts_chunk_index_mark_clustered</name><argument_list>(<argument><expr><name><name>cim</name><operator>-&gt;</operator><name>chunkoid</name></name></expr></argument>, <argument><expr><name><name>cim</name><operator>-&gt;</operator><name>indexoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Do the job. */</comment>

			<comment type="block">/*
			 * Since we keep OIDs between transactions, there is a potential
			 * issue if an OID gets reassigned between two subtransactions
			 */</comment>
			<expr_stmt><expr><call><name>cluster_rel</name><argument_list>(<argument><expr><name><name>cim</name><operator>-&gt;</operator><name>chunkoid</name></name></expr></argument>, <argument><expr><name><name>cim</name><operator>-&gt;</operator><name>indexoid</name></name></expr></argument>, <argument><expr><call><name>get_cluster_options</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><name><name>hcache</name><operator>-&gt;</operator><name>release_on_commit</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<comment type="block">/* Start a new transaction for the cleanup work. */</comment>
		<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Clean up working storage */</comment>
		<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>mcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>UnlockRelationIdForSession</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cluster_index_lockid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>DDL_DONE</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Process create table statements.
 *
 * For regular tables, we need to ensure that they don't have any foreign key
 * constraints that point to hypertables.
 *
 * NOTE that this function should be called after parse analysis (in an end DDL
 * trigger or by running parse analysis manually).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_create_table_end</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CreateStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>CreateStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>verify_constraint_list</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>constraints</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Only after parse analysis does tableElts contain only ColumnDefs. So,
	 * if we capture this in processUtility, we should be prepared to have
	 * constraint nodes and TableLikeClauses intermixed
	 */</comment>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>stmt-&gt;tableElts</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ColumnDef</name> <modifier>*</modifier></type><name>coldef</name></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>T_ColumnDef</name></expr>:</case>
				<expr_stmt><expr><name>coldef</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>verify_constraint_list</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name><name>coldef</name><operator>-&gt;</operator><name>constraints</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Constraint</name></expr>:</case>

				<comment type="block">/*
				 * There should be no Constraints in the list after parse
				 * analysis, but this case is included anyway for completeness
				 */</comment>
				<expr_stmt><expr><call><name>verify_constraint</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_TableLikeClause</name></expr>:</case>
				<comment type="block">/* Some as above case */</comment>
				<break>break;</break>
			<default>default:</default>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>typename_get_unqual_name</name><parameter_list>(<parameter><decl><type><name>TypeName</name> <modifier>*</modifier></type><name>tn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>llast</name><argument_list>(<argument><expr><name><name>tn</name><operator>-&gt;</operator><name>names</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_alter_column_type_start</name><parameter_list>(<parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ht</name><operator>-&gt;</operator><name>space</name><operator>-&gt;</operator><name>num_dimensions</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Dimension</name> <modifier>*</modifier></type><name>dim</name> <init>= <expr><operator>&amp;</operator><name><name>ht</name><operator>-&gt;</operator><name>space</name><operator>-&gt;</operator><name>dimensions</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IS_CLOSED_DIMENSION</name><argument_list>(<argument><expr><name>dim</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>strncmp</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>column_name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TS_OPERATION_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot change the type of a hash-partitioned column"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>dim</name><operator>-&gt;</operator><name>partitioning</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<call><name>strncmp</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>column_name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TS_OPERATION_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot change the type of a column with a custom partitioning "</literal>
							<literal type="string">"function"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_alter_column_type_end</name><parameter_list>(<parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ColumnDef</name> <modifier>*</modifier></type><name>coldef</name> <init>= <expr><operator>(</operator><name>ColumnDef</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>new_type</name> <init>= <expr><call><name>TypenameGetTypid</name><argument_list>(<argument><expr><call><name>typename_get_unqual_name</name><argument_list>(<argument><expr><name><name>coldef</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Dimension</name> <modifier>*</modifier></type><name>dim</name> <init>=
		<expr><call><name>ts_hyperspace_get_mutable_dimension_by_name</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>space</name></name></expr></argument>, <argument><expr><name>DIMENSION_TYPE_ANY</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>dim</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ts_dimension_set_type</name><argument_list>(<argument><expr><name>dim</name></expr></argument>, <argument><expr><name>new_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_process_utility_set_expect_chunk_modification</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_chunk_recreate_all_constraints_for_dimension</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>space</name></name></expr></argument>, <argument><expr><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_process_utility_set_expect_chunk_modification</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_altertable_clusteron_end</name><parameter_list>(<parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>index_relid</name> <init>=
		<expr><call><name>get_relname_relid</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><call><name>get_namespace_oid</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>schema_name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* If this is part of changing the type of a column that is used in a clustered index
	 * the above lookup might fail. But in this case we don't need to mark the index clustered
	 * as postgres takes care of that already (except PG12 &lt; 12.3) */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>index_relid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>chunk_indexes</name> <init>= <expr><call><name>ts_chunk_index_get_mappings</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>index_relid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>chunk_indexes</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ChunkIndexMapping</name> <modifier>*</modifier></type><name>cim</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ts_chunk_index_mark_clustered</name><argument_list>(<argument><expr><name><name>cim</name><operator>-&gt;</operator><name>chunkoid</name></name></expr></argument>, <argument><expr><name><name>cim</name><operator>-&gt;</operator><name>indexoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Generic function to recurse ALTER TABLE commands to chunks.
 *
 * Call with foreach_chunk().
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_altertable_chunk</name><parameter_list>(<parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>chunk_relid</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AlterTableInternal</name><argument_list>(<argument><expr><name>chunk_relid</name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_altertable_set_tablespace_end</name><parameter_list>(<parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NameData</name></type> <name>tspc_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tablespaces</name> <modifier>*</modifier></type><name>tspcs</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tspc_name</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tspcs</name> <operator>=</operator> <call><name>ts_tablespace_scan</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tspcs</name><operator>-&gt;</operator><name>num_tablespaces</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot set new tablespace when multiple tablespaces are attached to "</literal>
						<literal type="string">"hypertable \"%s\""</literal></expr></argument>,
						<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Detach tablespaces before altering the hypertable."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tspcs</name><operator>-&gt;</operator><name>num_tablespaces</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ts_hypertable_has_tablespace</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name><name>tspcs</name><operator>-&gt;</operator><name>tablespaces</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>tablespace_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ts_tablespace_delete</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>,
							 <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>tspcs</name><operator>-&gt;</operator><name>tablespaces</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>fd</name><operator>.</operator><name>tablespace_name</name></name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name><name>tspcs</name><operator>-&gt;</operator><name>tablespaces</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>tablespace_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ts_tablespace_attach_internal</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tspc_name</name></expr></argument>, <argument><expr><name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>foreach_chunk</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>process_altertable_chunk</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>TS_HYPERTABLE_HAS_COMPRESSION_TABLE</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>compressed_hypertable</name> <init>=
			<expr><call><name>ts_hypertable_get_by_id</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>compressed_hypertable_id</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>AlterTableInternal</name><argument_list>(<argument><expr><name><name>compressed_hypertable</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>process_altertable_set_tablespace_end</name><argument_list>(<argument><expr><name>compressed_hypertable</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_altertable_end_index</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>, <parameter><decl><type><name>CollectedCommand</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>AlterTableStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>indexrelid</name> <init>= <expr><call><name>AlterTableLookupRelation</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>tablerelid</name> <init>= <expr><call><name>IndexGetRelation</name><argument_list>(<argument><expr><name>indexrelid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cache</name> <modifier>*</modifier></type><name>hcache</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>tablerelid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>ht</name> <operator>=</operator> <call><name>ts_hypertable_cache_get_cache_and_entry</name><argument_list>(<argument><expr><name>tablerelid</name></expr></argument>, <argument><expr><name>CACHE_FLAG_MISSING_OK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>ht</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>stmt-&gt;cmds</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><operator>(</operator><name>AlterTableCmd</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<switch>switch <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>AT_SetTableSpace</name></expr>:</case>
					<expr_stmt><expr><call><name>ts_chunk_index_set_tablespace</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>indexrelid</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<default>default:</default>
					<break>break;</break>
			</block_content>}</block></switch>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>process_altertable_chunk_set_tablespace</name><parameter_list>(<parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name> <init>= <expr><call><name>ts_chunk_get_by_relid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>chunk</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ts_chunk_contains_compressed_data</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"changing tablespace of compressed chunk is not supported"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Please use the corresponding chunk on the uncompressed hypertable "</literal>
						 <literal type="string">"instead."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* set tablespace for compressed chunk */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>compressed_chunk_id</name></name> <operator>!=</operator> <name>INVALID_CHUNK_ID</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>compressed_chunk</name> <init>= <expr><call><name>ts_chunk_get_by_id</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>compressed_chunk_id</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>AlterTableInternal</name><argument_list>(<argument><expr><name><name>compressed_chunk</name><operator>-&gt;</operator><name>table_id</name></name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DDLResult</name></type>
<name>process_altertable_start_table</name><parameter_list>(<parameter><decl><type><name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>AlterTableStmt</name> <operator>*</operator><operator>)</operator> <name><name>args</name><operator>-&gt;</operator><name>parsetree</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relid</name> <init>= <expr><call><name>AlterTableLookupRelation</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cache</name> <modifier>*</modifier></type><name>hcache</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DDLResult</name></type> <name>result</name> <init>= <expr><name>DDL_CONTINUE</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>num_cmds</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>DDL_CONTINUE</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>check_chunk_alter_table_operation_allowed</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ht</name> <operator>=</operator> <call><name>ts_hypertable_cache_get_cache_and_entry</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>CACHE_FLAG_MISSING_OK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ht</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ts_hypertable_permissions_check_by_id</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>check_continuous_agg_alter_table_allowed</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>check_alter_table_allowed_on_ht_with_compression</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>relation_not_only</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>add_hypertable_to_process_args</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>num_cmds</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>cmds</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>stmt-&gt;cmds</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><operator>(</operator><name>AlterTableCmd</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>AT_AddIndex</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>istmt</name> <init>= <expr><operator>(</operator><name>IndexStmt</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name>IndexStmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>ht</name> <operator>&amp;&amp;</operator> <name><name>istmt</name><operator>-&gt;</operator><name>isconstraint</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>verify_constraint_hypertable</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
			<case>case <expr><name>AT_DropNotNull</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>ht</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>process_altertable_drop_not_null</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><name>AT_AddColumn</name></expr>:</case>
			<case>case <expr><name>AT_AddColumnRecurse</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ColumnDef</name> <modifier>*</modifier></type><name>col</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>constraint_lc</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name>ColumnDef</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>col</name> <operator>=</operator> <operator>(</operator><name>ColumnDef</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>ht</name> <operator>&amp;&amp;</operator> <call><name>TS_HYPERTABLE_HAS_COMPRESSION_ENABLED</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>check_altertable_add_column_for_compressed</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>ht</name></expr>)</condition><block type="pseudo"><block_content>
					<macro><name>foreach</name> <argument_list>(<argument>constraint_lc</argument>, <argument>col-&gt;constraints</argument>)</argument_list></macro>
						<expr_stmt><expr><call><name>verify_constraint_plaintable</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>constraint_lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<macro><name>foreach</name> <argument_list>(<argument>constraint_lc</argument>, <argument>col-&gt;constraints</argument>)</argument_list></macro>
						<expr_stmt><expr><call><name>verify_constraint_hypertable</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>constraint_lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>
			</block_content>}</block>
			<case>case <expr><name>AT_DropColumn</name></expr>:</case>
			<case>case <expr><name>AT_DropColumnRecurse</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>ht</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>process_altertable_drop_column</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><name>AT_AddConstraint</name></expr>:</case>
			<case>case <expr><name>AT_AddConstraintRecurse</name></expr>:</case>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name>Constraint</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>ht</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>verify_constraint_plaintable</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><operator>(</operator><name>Constraint</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>verify_constraint_hypertable</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>
			<case>case <expr><name>AT_AlterColumnType</name></expr>:</case>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name>ColumnDef</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>ht</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>process_alter_column_type_start</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><name>AT_AttachPartition</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>relation</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>PartitionCmd</name> <modifier>*</modifier></type><name>partstmt</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>partstmt</name> <operator>=</operator> <operator>(</operator><name>PartitionCmd</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>relation</name> <operator>=</operator> <name><name>partstmt</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><call><name>ts_hypertable_relid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"hypertables do not support native "</literal>
									<literal type="string">"postgres partitioning"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			</block_content>}</block>
			<case>case <expr><name>AT_SetRelOptions</name></expr>:</case>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>num_cmds</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ALTER TABLE &lt;hypertable&gt; SET does not support multiple "</literal>
									<literal type="string">"clauses"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>ht</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>EventTriggerAlterTableStart</name><argument_list>(<argument><expr><name><name>args</name><operator>-&gt;</operator><name>parsetree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>process_altertable_set_options</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			</block_content>}</block>
			<case>case <expr><name>AT_ResetRelOptions</name></expr>:</case>
			<case>case <expr><name>AT_ReplaceRelOptions</name></expr>:</case>
				<expr_stmt><expr><call><name>process_altertable_reset_options</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>AT_SetTableSpace</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>ht</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>process_altertable_chunk_set_tablespace</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
			<default>default:</default>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block>

	<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>continuous_agg_with_clause_perm_check</name><parameter_list>(<parameter><decl><type><name>ContinuousAgg</name> <modifier>*</modifier></type><name>cagg</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>view_relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>ownerid</name> <init>= <expr><call><name>ts_rel_get_owner</name><argument_list>(<argument><expr><name>view_relid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>has_privs_of_role</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ownerid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must be owner of continuous aggregate \"%s\""</literal></expr></argument>, <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>view_relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_altercontinuousagg_set_with</name><parameter_list>(<parameter><decl><type><name>ContinuousAgg</name> <modifier>*</modifier></type><name>cagg</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>view_relid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>defelems</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WithClauseResult</name> <modifier>*</modifier></type><name>parse_results</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>pg_options</name> <init>= <expr><name>NIL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>cagg_options</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>continuous_agg_with_clause_perm_check</name><argument_list>(<argument><expr><name>cagg</name></expr></argument>, <argument><expr><name>view_relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ts_with_clause_filter</name><argument_list>(<argument><expr><name>defelems</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cagg_options</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pg_options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>pg_options</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"only timescaledb parameters allowed in WITH clause for continuous "</literal>
						<literal type="string">"aggregate"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>cagg_options</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>parse_results</name> <operator>=</operator> <call><name>ts_continuous_agg_with_clause_parse</name><argument_list>(<argument><expr><name>cagg_options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name><name>ts_cm_functions</name><operator>-&gt;</operator><name>continuous_agg_update_options</name></name><argument_list>(<argument><expr><name>cagg</name></expr></argument>, <argument><expr><name>parse_results</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Run an alter table command on a relation */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>alter_table_by_relation</name><parameter_list>(<parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>relation</name></decl></parameter>, <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>Oid</name></type> <name>relid</name> <init>= <expr><call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>AlterTableInternal</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Run an alter table command on a relation given by name */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>alter_table_by_name</name><parameter_list>(<parameter><decl><type><name>Name</name></type> <name>schema_name</name></decl></parameter>, <parameter><decl><type><name>Name</name></type> <name>table_name</name></decl></parameter>, <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>alter_table_by_relation</name><argument_list>(<argument><expr><call><name>makeRangeVar</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>schema_name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>table_name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Alter a hypertable and do some extra processing */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>alter_hypertable_by_id</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>hypertable_id</name></decl></parameter>, <parameter><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>,
					   <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>extra</name>)<parameter_list>(<parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cache</name> <modifier>*</modifier></type><name>hcache</name> <init>= <expr><call><name>ts_hypertable_cache_pin</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name> <init>= <expr><call><name>ts_hypertable_cache_get_entry_by_id</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>, <argument><expr><name>hypertable_id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Broken continuous aggregate */</comment>
	<expr_stmt><expr><call><name>ts_hypertable_permissions_check_by_id</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_alter_table_allowed_on_ht_with_compression</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>relation_not_only</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AlterTableInternal</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call>(<modifier>*</modifier><name>extra</name>)<argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DDLResult</name></type>
<name>process_altertable_start_matview</name><parameter_list>(<parameter><decl><type><name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>AlterTableStmt</name> <operator>*</operator><operator>)</operator> <name><name>args</name><operator>-&gt;</operator><name>parsetree</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>Oid</name></type> <name>view_relid</name> <init>= <expr><call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ContinuousAgg</name> <modifier>*</modifier></type><name>cagg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>view_relid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>DDL_CONTINUE</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>cagg</name> <operator>=</operator> <call><name>ts_continuous_agg_find_by_relid</name><argument_list>(<argument><expr><name>view_relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>cagg</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>DDL_CONTINUE</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>continuous_agg_with_clause_perm_check</name><argument_list>(<argument><expr><name>cagg</name></expr></argument>, <argument><expr><name>view_relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>stmt-&gt;cmds</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><operator>(</operator><name>AlterTableCmd</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>AT_SetRelOptions</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"expected set options to contain a list"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>process_altercontinuousagg_set_with</name><argument_list>(<argument><expr><name>cagg</name></expr></argument>, <argument><expr><name>view_relid</name></expr></argument>, <argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>AT_ChangeOwner</name></expr>:</case>
				<expr_stmt><expr><call><name>alter_table_by_relation</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>alter_table_by_name</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cagg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>partial_view_schema</name></name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name><name>cagg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>partial_view_name</name></name></expr></argument>,
									<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>alter_table_by_name</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cagg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>direct_view_schema</name></name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name><name>cagg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>direct_view_name</name></name></expr></argument>,
									<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>alter_hypertable_by_id</name><argument_list>(<argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>mat_hypertable_id</name></name></expr></argument>,
									   <argument><expr><name>stmt</name></expr></argument>,
									   <argument><expr><name>cmd</name></expr></argument>,
									   <argument><expr><name>process_altertable_change_owner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>AT_SetTableSpace</name></expr>:</case>
				<expr_stmt><expr><call><name>alter_hypertable_by_id</name><argument_list>(<argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>mat_hypertable_id</name></name></expr></argument>,
									   <argument><expr><name>stmt</name></expr></argument>,
									   <argument><expr><name>cmd</name></expr></argument>,
									   <argument><expr><name>process_altertable_set_tablespace_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<default>default:</default>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter only SET options of a continuous "</literal>
								<literal type="string">"aggregate"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>
	</block_content>}</block>
	<comment type="block">/* All commands processed by us, nothing for postgres to do.*/</comment>
	<return>return <expr><name>DDL_DONE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DDLResult</name></type>
<name>process_altertable_start_view</name><parameter_list>(<parameter><decl><type><name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>AlterTableStmt</name> <operator>*</operator><operator>)</operator> <name><name>args</name><operator>-&gt;</operator><name>parsetree</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relid</name> <init>= <expr><call><name>AlterTableLookupRelation</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ContinuousAgg</name> <modifier>*</modifier></type><name>cagg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ContinuousAggViewType</name></type> <name>vtyp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>view_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>view_schema</name></decl>;</decl_stmt>

	<comment type="block">/* Check if this is a materialized view and give error if it is. */</comment>
	<expr_stmt><expr><name>cagg</name> <operator>=</operator> <call><name>ts_continuous_agg_find_by_relid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>cagg</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter continuous aggregate using ALTER VIEW"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use ALTER MATERIALIZED VIEW to alter a continuous aggregate."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Check if this is an internal view of a continuous aggregate and give
	 * error if attempts are made to alter them. */</comment>
	<expr_stmt><expr><name>view_name</name> <operator>=</operator> <call><name>get_rel_name</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>view_schema</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cagg</name> <operator>=</operator> <call><name>ts_continuous_agg_find_by_view_name</name><argument_list>(<argument><expr><name>view_schema</name></expr></argument>, <argument><expr><name>view_name</name></expr></argument>, <argument><expr><name>ContinuousAggAnyView</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>cagg</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>DDL_CONTINUE</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>vtyp</name> <operator>=</operator> <call><name>ts_continuous_agg_view_type</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cagg</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>view_schema</name></expr></argument>, <argument><expr><name>view_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>vtyp</name> <operator>==</operator> <name>ContinuousAggPartialView</name> <operator>||</operator> <name>vtyp</name> <operator>==</operator> <name>ContinuousAggDirectView</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter the internal view of a continuous aggregate"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>DDL_DONE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DDLResult</name></type>
<name>process_altertable_start</name><parameter_list>(<parameter><decl><type><name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>AlterTableStmt</name> <operator>*</operator><operator>)</operator> <name><name>args</name><operator>-&gt;</operator><name>parsetree</name></name></expr></init></decl>;</decl_stmt>
	<switch>switch <condition>(<expr><call><name>get_altertable_objecttype</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>OBJECT_TABLE</name></expr>:</case>
			<return>return <expr><call><name>process_altertable_start_table</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>OBJECT_MATVIEW</name></expr>:</case>
			<return>return <expr><call><name>process_altertable_start_matview</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>OBJECT_VIEW</name></expr>:</case>
			<return>return <expr><call><name>process_altertable_start_view</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</return>
		<default>default:</default>
			<return>return <expr><name>DDL_CONTINUE</name></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_altertable_end_subcmd</name><parameter_list>(<parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>, <parameter><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><operator>(</operator><name>AlterTableCmd</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>AlterTableCmd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>AT_ChangeOwner</name></expr>:</case>
			<expr_stmt><expr><call><name>process_altertable_change_owner</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_AddIndexConstraint</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"hypertables do not support adding a constraint "</literal>
							<literal type="string">"using an existing index"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_AddIndex</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>IndexStmt</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>idxname</name> <init>= <expr><name><name>stmt</name><operator>-&gt;</operator><name>idxname</name></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name>IndexStmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>isconstraint</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>idxname</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>idxname</name> <operator>=</operator> <call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>process_altertable_add_constraint</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>idxname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<break>break;</break>
		<case>case <expr><name>AT_AddConstraint</name></expr>:</case>
		<case>case <expr><name>AT_AddConstraintRecurse</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>Constraint</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>conname</name> <init>= <expr><name><name>stmt</name><operator>-&gt;</operator><name>conname</name></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name>Constraint</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Check constraints are recursed to chunks by default */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTR_CHECK</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>conname</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>conname</name> <operator>=</operator> <call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>process_altertable_add_constraint</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>conname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<break>break;</break>
		<case>case <expr><name>AT_AlterColumnType</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name>ColumnDef</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>process_alter_column_type_end</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_EnableTrig</name></expr>:</case>
		<case>case <expr><name>AT_EnableAlwaysTrig</name></expr>:</case>
		<case>case <expr><name>AT_EnableReplicaTrig</name></expr>:</case>
		<case>case <expr><name>AT_DisableTrig</name></expr>:</case>
		<case>case <expr><name>AT_EnableTrigAll</name></expr>:</case>
		<case>case <expr><name>AT_DisableTrigAll</name></expr>:</case>
		<case>case <expr><name>AT_EnableTrigUser</name></expr>:</case>
		<case>case <expr><name>AT_DisableTrigUser</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"hypertables do not support  "</literal>
							<literal type="string">"enabling or disabling triggers."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Break here to silence compiler */</comment>
			<break>break;</break>
		<case>case <expr><name>AT_ClusterOn</name></expr>:</case>
			<expr_stmt><expr><call><name>process_altertable_clusteron_end</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_SetUnLogged</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"logging cannot be turned off for hypertables"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Break here to silence compiler */</comment>
			<break>break;</break>
		<case>case <expr><name>AT_ReplicaIdentity</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"hypertables do not support logical replication"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Break here to silence compiler */</comment>
			<break>break;</break>
		<case>case <expr><name>AT_EnableRule</name></expr>:</case>
		<case>case <expr><name>AT_EnableAlwaysRule</name></expr>:</case>
		<case>case <expr><name>AT_EnableReplicaRule</name></expr>:</case>
		<case>case <expr><name>AT_DisableRule</name></expr>:</case>
			<comment type="block">/* should never actually get here but just in case */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"hypertables do not support rules"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Break here to silence compiler */</comment>
			<break>break;</break>
		<case>case <expr><name>AT_AlterConstraint</name></expr>:</case>
			<expr_stmt><expr><call><name>process_altertable_alter_constraint_end</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_ValidateConstraint</name></expr>:</case>
		<case>case <expr><name>AT_ValidateConstraintRecurse</name></expr>:</case>
			<expr_stmt><expr><call><name>process_altertable_validate_constraint_end</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_DropCluster</name></expr>:</case>
			<expr_stmt><expr><call><name>foreach_chunk</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>process_altertable_chunk</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_SetRelOptions</name></expr>:</case>
		<case>case <expr><name>AT_ResetRelOptions</name></expr>:</case>
		<case>case <expr><name>AT_ReplaceRelOptions</name></expr>:</case>
		<case>case <expr><name>AT_DropOids</name></expr>:</case>
		<case>case <expr><name>AT_SetOptions</name></expr>:</case>
		<case>case <expr><name>AT_ResetOptions</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_GE</name></expr></cpp:if>
		<case>case <expr><name>AT_ReAddStatistics</name></expr>:</case>
		<case>case <expr><name>AT_SetCompression</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<comment type="block">/* Avoid running this command for distributed hypertable chunks
			 * since PostgreSQL currently does not allow to alter
			 * storage options for a foreign table. */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hypertable_is_distributed</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>foreach_chunk</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>process_altertable_chunk</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_SetTableSpace</name></expr>:</case>
			<expr_stmt><expr><call><name>process_altertable_set_tablespace_end</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_AddInherit</name></expr>:</case>
		<case>case <expr><name>AT_DropInherit</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"hypertables do not support inheritance"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<case>case <expr><name>AT_SetStatistics</name></expr>:</case>
		<case>case <expr><name>AT_SetLogged</name></expr>:</case>
		<case>case <expr><name>AT_SetStorage</name></expr>:</case>
		<case>case <expr><name>AT_ColumnDefault</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">120005</literal></expr></cpp:if>
		<case>case <expr><name>AT_CookedColumnDefault</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<case>case <expr><name>AT_SetNotNull</name></expr>:</case>
		<case>case <expr><name>AT_CheckNotNull</name></expr>:</case>
		<case>case <expr><name>AT_DropNotNull</name></expr>:</case>
		<case>case <expr><name>AT_AddOf</name></expr>:</case>
		<case>case <expr><name>AT_DropOf</name></expr>:</case>
		<case>case <expr><name>AT_AddIdentity</name></expr>:</case>
		<case>case <expr><name>AT_SetIdentity</name></expr>:</case>
		<case>case <expr><name>AT_DropIdentity</name></expr>:</case>
			<comment type="block">/* all of the above are handled by default recursion */</comment>
			<break>break;</break>
		<case>case <expr><name>AT_EnableRowSecurity</name></expr>:</case>
		<case>case <expr><name>AT_DisableRowSecurity</name></expr>:</case>
		<case>case <expr><name>AT_ForceRowSecurity</name></expr>:</case>
		<case>case <expr><name>AT_NoForceRowSecurity</name></expr>:</case>
			<comment type="block">/* RLS commands should not recurse to chunks */</comment>
			<break>break;</break>
		<case>case <expr><name>AT_ReAddConstraint</name></expr>:</case>
		<case>case <expr><name>AT_ReAddIndex</name></expr>:</case>

			<comment type="block">/*
			 * all of the above are internal commands that are hit in tests
			 * and correctly handled
			 */</comment>
			<break>break;</break>
		<case>case <expr><name>AT_AddColumn</name></expr>:</case>
		<case>case <expr><name>AT_AddColumnRecurse</name></expr>:</case>
			<comment type="block">/* this is handled for compressed hypertables by tsl code */</comment>
			<break>break;</break>
		<case>case <expr><name>AT_DropColumn</name></expr>:</case>
		<case>case <expr><name>AT_DropColumnRecurse</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG13_GE</name></expr></cpp:if>
		<case>case <expr><name>AT_DropExpression</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

			<comment type="block">/*
			 * adding and dropping columns handled in
			 * process_altertable_start_table
			 */</comment>
			<break>break;</break>
		<case>case <expr><name>AT_DropConstraint</name></expr>:</case>
		<case>case <expr><name>AT_DropConstraintRecurse</name></expr>:</case>
			<comment type="block">/* drop constraints handled by process_ddl_sql_drop */</comment>
			<break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG13_LT</name></expr></cpp:if>
		<case>case <expr><name>AT_ProcessedConstraint</name></expr>:</case> <comment type="block">/* internal command never hit in our
									  * test code, so don't know how to
									  * handle */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<case>case <expr><name>AT_ReAddComment</name></expr>:</case>			   <comment type="block">/* internal command never hit in our test
											* code, so don't know how to handle */</comment>
		<case>case <expr><name>AT_AddColumnToView</name></expr>:</case>		   <comment type="block">/* only used with views */</comment>
		<case>case <expr><name>AT_AlterColumnGenericOptions</name></expr>:</case> <comment type="block">/* only used with foreign tables */</comment>
		<case>case <expr><name>AT_GenericOptions</name></expr>:</case>			   <comment type="block">/* only used with foreign tables */</comment>
		<case>case <expr><name>AT_ReAddDomainConstraint</name></expr>:</case>	   <comment type="block">/* We should handle this in future,
											* new subset of constraints in PG11
											* currently not hit in test code */</comment>
		<case>case <expr><name>AT_AttachPartition</name></expr>:</case>		   <comment type="block">/* handled in
											* process_altertable_start_table but also
											* here as failsafe */</comment>
		<case>case <expr><name>AT_DetachPartition</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_GE</name></expr></cpp:if>
		<case>case <expr><name>AT_DetachPartitionFinalize</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"operation not supported on hypertables %d"</literal></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>
	<if_stmt><if>if <condition>(<expr><name><name>ts_cm_functions</name><operator>-&gt;</operator><name>process_altertable_cmd</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name><name>ts_cm_functions</name><operator>-&gt;</operator><name>process_altertable_cmd</name></name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_altertable_end_simple_cmd</name><parameter_list>(<parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>CollectedCommand</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>AlterTableStmt</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>parsetree</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>AlterTableStmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>process_altertable_end_subcmd</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>cmds</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cmd</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>simple</name><operator>.</operator><name>secondaryObject</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_altertable_end_subcmds</name><parameter_list>(<parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>cmds</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>cmds</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CollectedATSubcmd</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>process_altertable_end_subcmd</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>parsetree</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cmd</name><operator>-&gt;</operator><name>address</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_altertable_end_table</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>, <parameter><decl><type><name>CollectedCommand</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>AlterTableStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cache</name> <modifier>*</modifier></type><name>hcache</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>AlterTableStmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>AlterTableLookupRelation</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>ht</name> <operator>=</operator> <call><name>ts_hypertable_cache_get_cache_and_entry</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>CACHE_FLAG_MISSING_OK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>ht</name></expr>)</condition>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>SCT_Simple</name></expr>:</case>
				<expr_stmt><expr><call><name>process_altertable_end_simple_cmd</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>SCT_AlterTable</name></expr>:</case>
				<expr_stmt><expr><call><name>process_altertable_end_subcmds</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>alterTable</name><operator>.</operator><name>subcmds</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_altertable_end</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>, <parameter><decl><type><name>CollectedCommand</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>AlterTableStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><call><name>get_altertable_objecttype</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>OBJECT_TABLE</name></expr>:</case>
			<expr_stmt><expr><call><name>process_altertable_end_table</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_INDEX</name></expr>:</case>
			<expr_stmt><expr><call><name>process_altertable_end_index</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DDLResult</name></type>
<name>process_create_trigger_start</name><parameter_list>(<parameter><decl><type><name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CreateTrigStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>CreateTrigStmt</name> <operator>*</operator><operator>)</operator> <name><name>args</name><operator>-&gt;</operator><name>parsetree</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cache</name> <modifier>*</modifier></type><name>hcache</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name> <name>PG_USED_FOR_ASSERTS_ONLY</name></type> <name>address</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>hcache</name> <operator>=</operator> <call><name>ts_hypertable_cache_pin</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ht</name> <operator>=</operator> <call><name>ts_hypertable_cache_get_entry_rv</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ht</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>DDL_CONTINUE</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>transitionRels</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"trigger with transition tables not supported on hypertables"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>add_hypertable_to_process_args</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>row</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>DDL_CONTINUE</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ts_hypertable_create_trigger</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>query_string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>address</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>DDL_DONE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DDLResult</name></type>
<name>process_create_rule_start</name><parameter_list>(<parameter><decl><type><name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RuleStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>RuleStmt</name> <operator>*</operator><operator>)</operator> <name><name>args</name><operator>-&gt;</operator><name>parsetree</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><call><name>ts_hypertable_relid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>DDL_CONTINUE</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"hypertables do not support rules"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>DDL_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ALTER TABLE &lt;name&gt; SET ( timescaledb.compress, ...) */</comment>
<function><type><specifier>static</specifier> <name>DDLResult</name></type>
<name>process_altertable_set_options</name><parameter_list>(<parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>pg_options</name> <init>= <expr><name>NIL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>compress_options</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WithClauseResult</name> <modifier>*</modifier></type><name>parse_results</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>inpdef</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<comment type="block">/* is this a compress table stmt */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>inpdef</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_with_clause_filter</name><argument_list>(<argument><expr><name>inpdef</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>compress_options</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pg_options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>compress_options</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>parse_results</name> <operator>=</operator> <call><name>ts_compress_hypertable_set_clause_parse</name><argument_list>(<argument><expr><name>compress_options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* We allow updating compress chunk time interval independently of other compression
		 * options. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>parse_results</name><index>[<expr><name>CompressEnabled</name></expr>]</index></name><operator>.</operator><name>is_default</name> <operator>&amp;&amp;</operator>
			<name><name>parse_results</name><index>[<expr><name>CompressChunkTimeInterval</name></expr>]</index></name><operator>.</operator><name>is_default</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"the option timescaledb.compress must be set to true to enable "</literal>
							<literal type="string">"compression"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>DDL_CONTINUE</name></expr>;</return></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>pg_options</name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"only timescaledb.compress parameters allowed when specifying compression "</literal>
						<literal type="string">"parameters for hypertable"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name><name>ts_cm_functions</name><operator>-&gt;</operator><name>process_compress_table</name></name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>ht</name></expr></argument>, <argument><expr><name>parse_results</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>DDL_DONE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DDLResult</name></type>
<name>process_altertable_reset_options</name><parameter_list>(<parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>pg_options</name> <init>= <expr><name>NIL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>compress_options</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>inpdef</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<comment type="block">/* is this a compress table stmt */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>inpdef</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_with_clause_filter</name><argument_list>(<argument><expr><name>inpdef</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>compress_options</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pg_options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>compress_options</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"compression options cannot be reset"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>DDL_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DDLResult</name></type>
<name>process_viewstmt</name><parameter_list>(<parameter><decl><type><name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ViewStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>ViewStmt</name></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>parsetree</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>pg_options</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>cagg_options</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Check if user is passing continuous aggregate parameters and print a
	 * useful error message if that is the case. */</comment>
	<expr_stmt><expr><call><name>ts_with_clause_filter</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cagg_options</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pg_options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>cagg_options</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot create continuous aggregate with CREATE VIEW"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use CREATE MATERIALIZED VIEW to create a continuous aggregate."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>DDL_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DDLResult</name></type>
<name>process_create_table_as</name><parameter_list>(<parameter><decl><type><name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CreateTableAsStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>CreateTableAsStmt</name></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>parsetree</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WithClauseResult</name> <modifier>*</modifier></type><name>parse_results</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>is_cagg</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>pg_options</name> <init>= <expr><name>NIL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>cagg_options</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>get_createtableas_objecttype</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>OBJECT_MATVIEW</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Check for creation of continuous aggregate */</comment>
		<expr_stmt><expr><call><name>ts_with_clause_filter</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>into</name><operator>-&gt;</operator><name>options</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cagg_options</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pg_options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>cagg_options</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>parse_results</name> <operator>=</operator> <call><name>ts_continuous_agg_with_clause_parse</name><argument_list>(<argument><expr><name>cagg_options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>is_cagg</name> <operator>=</operator> <call><name>DatumGetBool</name><argument_list>(<argument><expr><name><name>parse_results</name><index>[<expr><name>ContinuousEnabled</name></expr>]</index></name><operator>.</operator><name>parsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_cagg</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>DDL_CONTINUE</name></expr>;</return></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>pg_options</name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unsupported combination of storage parameters"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"A continuous aggregate does not support standard storage "</literal>
							   <literal type="string">"parameters."</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use only parameters with the \"timescaledb.\" prefix when "</literal>
							 <literal type="string">"creating a continuous aggregate."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>into</name><operator>-&gt;</operator><name>skipData</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PreventInTransactionBlock</name><argument_list>(<argument><expr><name><name>args</name><operator>-&gt;</operator><name>context</name></name> <operator>==</operator> <name>PROCESS_UTILITY_TOPLEVEL</name></expr></argument>,
									  <argument><expr><literal type="string">"CREATE MATERIALIZED VIEW ... WITH DATA"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<return>return <expr><call><name><name>ts_cm_functions</name><operator>-&gt;</operator><name>process_cagg_viewstmt</name></name><argument_list>(<argument><expr><name><name>args</name><operator>-&gt;</operator><name>parsetree</name></name></expr></argument>,
													  <argument><expr><name><name>args</name><operator>-&gt;</operator><name>query_string</name></name></expr></argument>,
													  <argument><expr><name><name>args</name><operator>-&gt;</operator><name>pstmt</name></name></expr></argument>,
													  <argument><expr><name>parse_results</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>DDL_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DDLResult</name></type>
<name>process_refresh_mat_view_start</name><parameter_list>(<parameter><decl><type><name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RefreshMatViewStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>RefreshMatViewStmt</name></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>parsetree</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>view_relid</name> <init>= <expr><call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ContinuousAgg</name> <modifier>*</modifier></type><name>cagg</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>view_relid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>DDL_CONTINUE</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>cagg</name> <operator>=</operator> <call><name>ts_continuous_agg_find_by_relid</name><argument_list>(<argument><expr><name>view_relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>cagg</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"operation not supported on continuous aggregate"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"A continuous aggregate does not support REFRESH MATERIALIZED VIEW."</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use \"refresh_continuous_aggregate\" or set up a policy to refresh the "</literal>
						 <literal type="string">"continuous aggregate."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>DDL_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DDLResult</name></type>
<name>preprocess_execute</name><parameter_list>(<parameter><decl><type><name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_TELEMETRY</name></cpp:ifdef>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExecuteStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>ExecuteStmt</name> <operator>*</operator><operator>)</operator> <name><name>args</name><operator>-&gt;</operator><name>parsetree</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PreparedStatement</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><call><name>FetchPreparedStatement</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>entry</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>DDL_CONTINUE</name></expr>;</return></block_content></block></if></if_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>entry-&gt;plansource-&gt;query_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>Query</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ts_telemetry_function_info_gather</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<return>return <expr><name>DDL_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Handle DDL commands before they have been processed by PostgreSQL.
 */</comment>
<function><type><specifier>static</specifier> <name>DDLResult</name></type>
<name>process_ddl_command_start</name><parameter_list>(<parameter><decl><type><name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>check_read_only</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ts_process_utility_handler_t</name></type> <name>handler</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name><name>args</name><operator>-&gt;</operator><name>parsetree</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_CreateForeignTableStmt</name></expr>:</case>
			<expr_stmt><expr><name>handler</name> <operator>=</operator> <name>process_create_foreign_table_start</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_AlterForeignServerStmt</name></expr>:</case>
			<expr_stmt><expr><name>handler</name> <operator>=</operator> <name>process_alter_foreign_server</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CreateForeignServerStmt</name></expr>:</case>
			<expr_stmt><expr><name>handler</name> <operator>=</operator> <name>process_create_foreign_server_start</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_AlterObjectSchemaStmt</name></expr>:</case>
			<expr_stmt><expr><name>handler</name> <operator>=</operator> <name>process_alterobjectschema</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_TruncateStmt</name></expr>:</case>
			<expr_stmt><expr><name>handler</name> <operator>=</operator> <name>process_truncate</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_AlterTableStmt</name></expr>:</case>
			<expr_stmt><expr><name>handler</name> <operator>=</operator> <name>process_altertable_start</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_RenameStmt</name></expr>:</case>
			<expr_stmt><expr><name>handler</name> <operator>=</operator> <name>process_rename</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_IndexStmt</name></expr>:</case>
			<expr_stmt><expr><name>handler</name> <operator>=</operator> <name>process_index_start</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CreateTrigStmt</name></expr>:</case>
			<expr_stmt><expr><name>handler</name> <operator>=</operator> <name>process_create_trigger_start</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_RuleStmt</name></expr>:</case>
			<expr_stmt><expr><name>handler</name> <operator>=</operator> <name>process_create_rule_start</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_DropStmt</name></expr>:</case>
			<comment type="block">/*
			 * Drop associated metadata/chunks but also continue on to drop
			 * the main table. Because chunks are deleted before the main
			 * table is dropped, the drop respects CASCADE in the expected
			 * way.
			 */</comment>
			<expr_stmt><expr><name>handler</name> <operator>=</operator> <name>process_drop_start</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_DropTableSpaceStmt</name></expr>:</case>
			<expr_stmt><expr><name>handler</name> <operator>=</operator> <name>process_drop_tablespace</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_GrantStmt</name></expr>:</case>
			<expr_stmt><expr><name>handler</name> <operator>=</operator> <name>process_grant_and_revoke</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_GrantRoleStmt</name></expr>:</case>
			<expr_stmt><expr><name>handler</name> <operator>=</operator> <name>process_grant_and_revoke_role</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CopyStmt</name></expr>:</case>
			<expr_stmt><expr><name>check_read_only</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>handler</name> <operator>=</operator> <name>process_copy</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_VacuumStmt</name></expr>:</case>
			<expr_stmt><expr><name>handler</name> <operator>=</operator> <name>process_vacuum</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ReindexStmt</name></expr>:</case>
			<expr_stmt><expr><name>handler</name> <operator>=</operator> <name>process_reindex</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ClusterStmt</name></expr>:</case>
			<expr_stmt><expr><name>handler</name> <operator>=</operator> <name>process_cluster_start</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ViewStmt</name></expr>:</case>
			<expr_stmt><expr><name>handler</name> <operator>=</operator> <name>process_viewstmt</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_RefreshMatViewStmt</name></expr>:</case>
			<expr_stmt><expr><name>handler</name> <operator>=</operator> <name>process_refresh_mat_view_start</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CreateTableAsStmt</name></expr>:</case>
			<expr_stmt><expr><name>handler</name> <operator>=</operator> <name>process_create_table_as</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ExecuteStmt</name></expr>:</case>
			<expr_stmt><expr><name>check_read_only</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>handler</name> <operator>=</operator> <name>preprocess_execute</name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><name>handler</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><name>handler</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>DDL_CONTINUE</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>check_read_only</name></expr>)</condition><block type="pseudo"><block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG13_GE</name></expr></cpp:if>
		<expr_stmt><expr><call><name>PreventCommandIfReadOnly</name><argument_list>(<argument><expr><call><name>CreateCommandName</name><argument_list>(<argument><expr><name><name>args</name><operator>-&gt;</operator><name>parsetree</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><call><name>PreventCommandIfReadOnly</name><argument_list>(<argument><expr><call><name>CreateCommandTag</name><argument_list>(<argument><expr><name><name>args</name><operator>-&gt;</operator><name>parsetree</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><call><name>handler</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Handle DDL commands after they've been processed by PostgreSQL.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_ddl_command_end</name><parameter_list>(<parameter><decl><type><name>CollectedCommand</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>parsetree</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_CreateStmt</name></expr>:</case>
			<expr_stmt><expr><call><name>process_create_table_end</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>parsetree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_AlterTableStmt</name></expr>:</case>
			<expr_stmt><expr><call><name>process_altertable_end</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>parsetree</name></name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_drop_constraint_on_chunk</name><parameter_list>(<parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>chunk_relid</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hypertable_constraint_name</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name> <init>= <expr><call><name>ts_chunk_get_by_relid</name><argument_list>(<argument><expr><name>chunk_relid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* drop both metadata and table; sql_drop won't be called recursively */</comment>
	<expr_stmt><expr><call><name>ts_chunk_constraint_delete_by_hypertable_constraint_name</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>,
															 <argument><expr><name>hypertable_constraint_name</name></expr></argument>,
															 <argument><expr><name>true</name></expr></argument>,
															 <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_drop_table_constraint</name><parameter_list>(<parameter><decl><type><name>EventTriggerDropObject</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EventTriggerDropTableConstraint</name> <modifier>*</modifier></type><name>constraint</name> <init>= <expr><operator>(</operator><name>EventTriggerDropTableConstraint</name> <operator>*</operator><operator>)</operator> <name>obj</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>EVENT_TRIGGER_DROP_TABLE_CONSTRAINT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* do not use relids because underlying table could be gone */</comment>
	<expr_stmt><expr><name>ht</name> <operator>=</operator> <call><name>ts_hypertable_get_by_name</name><argument_list>(<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>schema</name></name></expr></argument>, <argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>table</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>ht</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CatalogSecurityContext</name></type> <name>sec_ctx</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ts_catalog_database_info_become_owner</name><argument_list>(<argument><expr><call><name>ts_catalog_database_info_get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Recurse to each chunk and drop the corresponding constraint */</comment>
		<expr_stmt><expr><call><name>foreach_chunk</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>process_drop_constraint_on_chunk</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name><name>constraint</name><operator>-&gt;</operator><name>constraint_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ts_catalog_restore_user</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Cannot get the full chunk here because it's table might be dropped */</comment>
		<decl_stmt><decl><type><name>int32</name></type> <name>chunk_id</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><call><name>ts_chunk_get_id</name><argument_list>(<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>schema</name></name></expr></argument>, <argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>table</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>chunk_id</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ts_chunk_constraint_delete_by_constraint_name</name><argument_list>(<argument><expr><name>chunk_id</name></expr></argument>,
														  <argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>constraint_name</name></name></expr></argument>,
														  <argument><expr><name>true</name></expr></argument>,
														  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_drop_index</name><parameter_list>(<parameter><decl><type><name>EventTriggerDropObject</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EventTriggerDropRelation</name> <modifier>*</modifier></type><name>index</name> <init>= <expr><operator>(</operator><name>EventTriggerDropRelation</name> <operator>*</operator><operator>)</operator> <name>obj</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>EVENT_TRIGGER_DROP_INDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_chunk_index_delete_by_name</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>schema</name></name></expr></argument>, <argument><expr><name><name>index</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_drop_table</name><parameter_list>(<parameter><decl><type><name>EventTriggerDropObject</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EventTriggerDropRelation</name> <modifier>*</modifier></type><name>table</name> <init>= <expr><operator>(</operator><name>EventTriggerDropRelation</name> <operator>*</operator><operator>)</operator> <name>obj</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>EVENT_TRIGGER_DROP_TABLE</name> <operator>||</operator> <name><name>obj</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>EVENT_TRIGGER_DROP_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_hypertable_delete_by_name</name><argument_list>(<argument><expr><name><name>table</name><operator>-&gt;</operator><name>schema</name></name></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_chunk_delete_by_name</name><argument_list>(<argument><expr><name><name>table</name><operator>-&gt;</operator><name>schema</name></name></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>DROP_RESTRICT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_drop_schema</name><parameter_list>(<parameter><decl><type><name>EventTriggerDropObject</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EventTriggerDropSchema</name> <modifier>*</modifier></type><name>schema</name> <init>= <expr><operator>(</operator><name>EventTriggerDropSchema</name> <operator>*</operator><operator>)</operator> <name>obj</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>count</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>EVENT_TRIGGER_DROP_SCHEMA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>schema</name><operator>-&gt;</operator><name>schema</name></name></expr></argument>, <argument><expr><name>INTERNAL_SCHEMA_NAME</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot drop the internal schema for extension \"%s\""</literal></expr></argument>, <argument><expr><name>EXTENSION_NAME</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use DROP EXTENSION to remove the extension and the schema."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Check for any remaining hypertables that use the schema as its
	 * associated schema. For matches, we reset their associated schema to the
	 * INTERNAL schema
	 */</comment>
	<expr_stmt><expr><name>count</name> <operator>=</operator> <call><name>ts_hypertable_reset_associated_schema_name</name><argument_list>(<argument><expr><name><name>schema</name><operator>-&gt;</operator><name>schema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"the chunk storage schema changed to \"%s\" for %d hypertable%c"</literal></expr></argument>,
						<argument><expr><name>INTERNAL_SCHEMA_NAME</name></expr></argument>,
						<argument><expr><name>count</name></expr></argument>,
						<argument><expr><ternary><condition><expr><operator>(</operator><name>count</name> <operator>&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="char">'s'</literal></expr> </then><else>: <expr><literal type="char">'\0'</literal></expr></else></ternary></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_drop_trigger</name><parameter_list>(<parameter><decl><type><name>EventTriggerDropObject</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EventTriggerDropTrigger</name> <modifier>*</modifier></type><name>trigger_event</name> <init>= <expr><operator>(</operator><name>EventTriggerDropTrigger</name> <operator>*</operator><operator>)</operator> <name>obj</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>EVENT_TRIGGER_DROP_TRIGGER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* do not use relids because underlying table could be gone */</comment>
	<expr_stmt><expr><name>ht</name> <operator>=</operator> <call><name>ts_hypertable_get_by_name</name><argument_list>(<argument><expr><name><name>trigger_event</name><operator>-&gt;</operator><name>schema</name></name></expr></argument>, <argument><expr><name><name>trigger_event</name><operator>-&gt;</operator><name>table</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>ht</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Recurse to each chunk and drop the corresponding trigger */</comment>
		<expr_stmt><expr><call><name>ts_hypertable_drop_trigger</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>, <argument><expr><name><name>trigger_event</name><operator>-&gt;</operator><name>trigger_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_drop_view</name><parameter_list>(<parameter><decl><type><name>EventTriggerDropView</name> <modifier>*</modifier></type><name>dropped_view</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ts_continuous_agg_drop</name><argument_list>(<argument><expr><name><name>dropped_view</name><operator>-&gt;</operator><name>schema</name></name></expr></argument>, <argument><expr><name><name>dropped_view</name><operator>-&gt;</operator><name>view_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_drop_foreign_server</name><parameter_list>(<parameter><decl><type><name>EventTriggerDropObject</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EventTriggerDropForeignServer</name> <modifier>*</modifier></type><name>server</name> <init>= <expr><operator>(</operator><name>EventTriggerDropForeignServer</name> <operator>*</operator><operator>)</operator> <name>obj</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>EVENT_TRIGGER_DROP_FOREIGN_SERVER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_hypertable_data_node_delete_by_node_name</name><argument_list>(<argument><expr><name><name>server</name><operator>-&gt;</operator><name>servername</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_chunk_data_node_delete_by_node_name</name><argument_list>(<argument><expr><name><name>server</name><operator>-&gt;</operator><name>servername</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_ddl_sql_drop</name><parameter_list>(<parameter><decl><type><name>EventTriggerDropObject</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>EVENT_TRIGGER_DROP_TABLE_CONSTRAINT</name></expr>:</case>
			<expr_stmt><expr><call><name>process_drop_table_constraint</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EVENT_TRIGGER_DROP_INDEX</name></expr>:</case>
			<expr_stmt><expr><call><name>process_drop_index</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EVENT_TRIGGER_DROP_TABLE</name></expr>:</case>
		<case>case <expr><name>EVENT_TRIGGER_DROP_FOREIGN_TABLE</name></expr>:</case>
			<expr_stmt><expr><call><name>process_drop_table</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EVENT_TRIGGER_DROP_SCHEMA</name></expr>:</case>
			<expr_stmt><expr><call><name>process_drop_schema</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EVENT_TRIGGER_DROP_TRIGGER</name></expr>:</case>
			<expr_stmt><expr><call><name>process_drop_trigger</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EVENT_TRIGGER_DROP_VIEW</name></expr>:</case>
			<expr_stmt><expr><call><name>process_drop_view</name><argument_list>(<argument><expr><operator>(</operator><name>EventTriggerDropView</name> <operator>*</operator><operator>)</operator> <name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EVENT_TRIGGER_DROP_FOREIGN_SERVER</name></expr>:</case>
			<expr_stmt><expr><call><name>process_drop_foreign_server</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * ProcessUtility hook for DDL commands that have not yet been processed by
 * PostgreSQL.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>timescaledb_ddl_command_start</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query_string</name></decl></parameter>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_GE</name></expr></cpp:if>
							  <parameter><decl><type><name>bool</name></type> <name>readonly_tree</name></decl></parameter>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
							  <parameter><decl><type><name>ProcessUtilityContext</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>,
							  <parameter><decl><type><name>QueryEnvironment</name> <modifier>*</modifier></type><name>queryEnv</name></decl></parameter>, <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG13_GE</name></expr></cpp:if>
							  <parameter><decl><type><name>QueryCompletion</name> <modifier>*</modifier><name>completion_tag</name>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
							  <name>char</name> <modifier>*</modifier></type><name>completion_tag</name></decl></parameter>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ProcessUtilityArgs</name></type> <name>args</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>query_string</name> <operator>=</operator> <name>query_string</name></expr>,
		<expr><operator>.</operator><name>context</name> <operator>=</operator> <name>context</name></expr>,
		<expr><operator>.</operator><name>params</name> <operator>=</operator> <name>params</name></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_GE</name></expr></cpp:if>
		<expr><operator>.</operator><name>readonly_tree</name> <operator>=</operator> <name>readonly_tree</name></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr><operator>.</operator><name>dest</name> <operator>=</operator> <name>dest</name></expr>,
		<expr><operator>.</operator><name>completion_tag</name> <operator>=</operator> <name>completion_tag</name></expr>,
		<expr><operator>.</operator><name>pstmt</name> <operator>=</operator> <name>pstmt</name></expr>,
		<expr><operator>.</operator><name>parsetree</name> <operator>=</operator> <name><name>pstmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr>,
		<expr><operator>.</operator><name>queryEnv</name> <operator>=</operator> <name>queryEnv</name></expr>,
		<expr><operator>.</operator><name>parse_state</name> <operator>=</operator> <call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>hypertable_list</name> <operator>=</operator> <name>NIL</name></expr>
	}</block></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>altering_timescaledb</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DDLResult</name></type> <name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>args</name><operator>.</operator><name>parse_state</name><operator>-&gt;</operator><name>p_sourcetext</name></name> <operator>=</operator> <name>query_string</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>args</name><operator>.</operator><name>parsetree</name></name></expr></argument>, <argument><expr><name>AlterExtensionStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AlterExtensionStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>AlterExtensionStmt</name> <operator>*</operator><operator>)</operator> <name><name>args</name><operator>.</operator><name>parsetree</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>altering_timescaledb</name> <operator>=</operator> <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>extname</name></name></expr></argument>, <argument><expr><name>EXTENSION_NAME</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We don't want to load the extension if we just got the command to alter
	 * it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>altering_timescaledb</name> <operator>||</operator> <operator>!</operator><call><name>ts_extension_is_loaded</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>prev_ProcessUtility</name><argument_list>(<argument><expr><operator>&amp;</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Process Utility/DDL operation locally then pass it on for
	 * execution in TSL.
	 */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>process_ddl_command_start</name><argument_list>(<argument><expr><operator>&amp;</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We need to run tsl-side ddl_command_start hook before
	 * standard process utility hook to maintain proper invocation
	 * order of sql_drop and ddl_command_end triggers.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ts_cm_functions</name><operator>-&gt;</operator><name>ddl_command_start</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name><name>ts_cm_functions</name><operator>-&gt;</operator><name>ddl_command_start</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>DDL_CONTINUE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>prev_ProcessUtility</name><argument_list>(<argument><expr><operator>&amp;</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_ddl_event_command_end</name><parameter_list>(<parameter><decl><type><name>EventTriggerData</name> <modifier>*</modifier></type><name>trigdata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* Inhibit collecting new commands while in the trigger */</comment>
	<expr_stmt><expr><call><name>EventTriggerInhibitCommandCollection</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ts_cm_functions</name><operator>-&gt;</operator><name>ddl_command_end</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name><name>ts_cm_functions</name><operator>-&gt;</operator><name>ddl_command_end</name></name><argument_list>(<argument><expr><name>trigdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>parsetree</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_AlterTableStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateTrigStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateStmt</name></expr>:</case>
		<case>case <expr><name>T_IndexStmt</name></expr>:</case>
			<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>ts_event_trigger_ddl_commands()</argument>)</argument_list></macro>
				<expr_stmt><expr><call><name>process_ddl_command_end</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>EventTriggerUndoInhibitCommandCollection</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_ddl_event_sql_drop</name><parameter_list>(<parameter><decl><type><name>EventTriggerData</name> <modifier>*</modifier></type><name>trigdata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>dropped_objects</name> <init>= <expr><call><name>ts_event_trigger_dropped_objects</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ts_cm_functions</name><operator>-&gt;</operator><name>sql_drop</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name><name>ts_cm_functions</name><operator>-&gt;</operator><name>sql_drop</name></name><argument_list>(<argument><expr><name>dropped_objects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>dropped_objects</argument>)</argument_list></macro>
		<expr_stmt><expr><call><name>process_ddl_sql_drop</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>TS_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>ts_timescaledb_process_ddl_event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*
 * Event trigger hook for DDL commands that have alread been handled by
 * PostgreSQL (i.e., "ddl_command_end" and "sql_drop" events).
 */</comment>
<function><type><name>Datum</name></type>
<name>ts_timescaledb_process_ddl_event</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EventTriggerData</name> <modifier>*</modifier></type><name>trigdata</name> <init>= <expr><operator>(</operator><name>EventTriggerData</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CALLED_AS_EVENT_TRIGGER</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"not fired by event trigger manager"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ts_extension_is_loaded</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"ddl_command_end"</literal></expr></argument>, <argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>event</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>process_ddl_event_command_end</name><argument_list>(<argument><expr><name>trigdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"sql_drop"</literal></expr></argument>, <argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>event</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>process_ddl_event_sql_drop</name><argument_list>(<argument><expr><name>trigdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>extern</specifier> <name>void</name></type>
<name>ts_process_utility_set_expect_chunk_modification</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>expect</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>expect_chunk_modification</name> <operator>=</operator> <name>expect</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_utility_xact_abort</name><parameter_list>(<parameter><decl><type><name>XactEvent</name></type> <name>event</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>event</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>XACT_EVENT_ABORT</name></expr>:</case>
		<case>case <expr><name>XACT_EVENT_PARALLEL_ABORT</name></expr>:</case>

			<comment type="block">/*
			 * Reset the expect_chunk_modification flag because it this is an
			 * internal safety flag that is set to true only temporarily
			 * during chunk operations. It should never remain true across
			 * transactions.
			 */</comment>
			<expr_stmt><expr><name>expect_chunk_modification</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_utility_subxact_abort</name><parameter_list>(<parameter><decl><type><name>SubXactEvent</name></type> <name>event</name></decl></parameter>, <parameter><decl><type><name>SubTransactionId</name></type> <name>mySubid</name></decl></parameter>,
							  <parameter><decl><type><name>SubTransactionId</name></type> <name>parentSubid</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>event</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>SUBXACT_EVENT_ABORT_SUB</name></expr>:</case>
			<comment type="block">/* see note in process_utility_xact_abort */</comment>
			<expr_stmt><expr><name>expect_chunk_modification</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>_process_utility_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>prev_ProcessUtility_hook</name> <operator>=</operator> <name>ProcessUtility_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ProcessUtility_hook</name> <operator>=</operator> <name>timescaledb_ddl_command_start</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RegisterXactCallback</name><argument_list>(<argument><expr><name>process_utility_xact_abort</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RegisterSubXactCallback</name><argument_list>(<argument><expr><name>process_utility_subxact_abort</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>_process_utility_fini</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>ProcessUtility_hook</name> <operator>=</operator> <name>prev_ProcessUtility_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UnregisterXactCallback</name><argument_list>(<argument><expr><name>process_utility_xact_abort</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UnregisterSubXactCallback</name><argument_list>(<argument><expr><name>process_utility_subxact_abort</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
