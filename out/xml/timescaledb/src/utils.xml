<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/timescaledb/src/utils.c"><comment type="block">/*
 * This file and its contents are licensed under the Apache License 2.0.
 * Please see the included NOTICE for copyright information and
 * LICENSE-APACHE for a copy of the license.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postgres.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/genam.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/heapam.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/htup_details.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/htup.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/reloptions.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/xact.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/indexing.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/namespace.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_cast.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_inherits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_operator.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_type.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;commands/event_trigger.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;commands/tablecmds.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fmgr.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;funcapi.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/makefuncs.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;parser/parse_coerce.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;parser/parse_func.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;parser/scansup.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/acl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/builtins.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/catcache.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/date.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/fmgroids.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/fmgrprotos.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/lsyscache.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/relcache.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/syscache.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compat/compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"chunk.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hypertable_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"time_utils.h"</cpp:file></cpp:include>

<expr_stmt><expr><call><name>TS_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>ts_pg_timestamp_to_unix_microseconds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*
 * Convert a Postgres TIMESTAMP to BIGINT microseconds relative the UNIX epoch.
 */</comment>
<function><type><name>Datum</name></type>
<name>ts_pg_timestamp_to_unix_microseconds</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>timestamp</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMPTZ</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TIMESTAMP_IS_NOBEGIN</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><name>TS_TIME_NOBEGIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TIMESTAMP_IS_NOEND</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><name>TS_TIME_NOEND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>timestamp</name> <operator>&lt;</operator> <name>TS_TIMESTAMP_MIN</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>timestamp</name> <operator>&gt;=</operator> <name>TS_TIMESTAMP_END</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><name>timestamp</name> <operator>+</operator> <name>TS_EPOCH_DIFF_MICROSECONDS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>TS_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>ts_pg_unix_microseconds_to_timestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TS_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>ts_pg_unix_microseconds_to_timestamp_without_timezone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TS_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>ts_pg_unix_microseconds_to_date</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*
 * Convert BIGINT microseconds relative the UNIX epoch to a Postgres TIMESTAMP.
 */</comment>
<function><type><name>Datum</name></type>
<name>ts_pg_unix_microseconds_to_timestamp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int64</name></type> <name>microseconds</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TS_TIME_IS_NOBEGIN</name><argument_list>(<argument><expr><name>microseconds</name></expr></argument>, <argument><expr><name>TIMESTAMPTZOID</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><call><name>ts_time_datum_get_nobegin</name><argument_list>(<argument><expr><name>TIMESTAMPTZOID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TS_TIME_IS_NOEND</name><argument_list>(<argument><expr><name>microseconds</name></expr></argument>, <argument><expr><name>TIMESTAMPTZOID</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><call><name>ts_time_datum_get_noend</name><argument_list>(<argument><expr><name>TIMESTAMPTZOID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Test that the UNIX us timestamp is within bounds. Note that an int64 at
	 * UNIX epoch and microsecond precision cannot represent the upper limit
	 * of the supported date range (Julian end date), so INT64_MAX-1 is the
	 * natural upper bound for this function.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>microseconds</name> <operator>&lt;</operator> <name>TS_TIMESTAMP_INTERNAL_MIN</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TIMESTAMPTZ</name><argument_list>(<argument><expr><name>microseconds</name> <operator>-</operator> <name>TS_EPOCH_DIFF_MICROSECONDS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>ts_pg_unix_microseconds_to_date</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int64</name></type> <name>microseconds</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>res</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TS_TIME_IS_NOBEGIN</name><argument_list>(<argument><expr><name>microseconds</name></expr></argument>, <argument><expr><name>DATEOID</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><call><name>ts_time_datum_get_nobegin</name><argument_list>(<argument><expr><name>DATEOID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TS_TIME_IS_NOEND</name><argument_list>(<argument><expr><name>microseconds</name></expr></argument>, <argument><expr><name>DATEOID</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><call><name>ts_time_datum_get_noend</name><argument_list>(<argument><expr><name>DATEOID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>ts_pg_unix_microseconds_to_timestamp</name></expr></argument>, <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>microseconds</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>timestamp_date</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>int64</name></type> <name>ts_integer_to_internal</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>time_val</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>type_oid</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Convert valid timescale time column type to internal representation */</comment>
<function><type><name>TSDLLEXPORT</name> <name>int64</name></type>
<name>ts_time_value_to_internal</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>time_val</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>type_oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type> <name>res</name></decl>, <decl><type ref="prev"/><name>tz</name></decl>;</decl_stmt>

	<comment type="block">/* Handle custom time types. We currently only support binary coercible
	 * types */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_VALID_TIME_TYPE</name><argument_list>(<argument><expr><name>type_oid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>ts_type_is_int8_binary_compatible</name><argument_list>(<argument><expr><name>type_oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>DatumGetInt64</name><argument_list>(<argument><expr><name>time_val</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unknown time type \"%s\""</literal></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>type_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IS_INTEGER_TYPE</name><argument_list>(<argument><expr><name>type_oid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Integer time types have no distinction between min, max and
		 * infinity. We don't want min and max to be turned into infinity for
		 * these types so check for those values first. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>TS_TIME_DATUM_IS_MIN</name><argument_list>(<argument><expr><name>time_val</name></expr></argument>, <argument><expr><name>type_oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>ts_time_get_min</name><argument_list>(<argument><expr><name>type_oid</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>TS_TIME_DATUM_IS_MAX</name><argument_list>(<argument><expr><name>time_val</name></expr></argument>, <argument><expr><name>type_oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>ts_time_get_max</name><argument_list>(<argument><expr><name>type_oid</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TS_TIME_DATUM_IS_NOBEGIN</name><argument_list>(<argument><expr><name>time_val</name></expr></argument>, <argument><expr><name>type_oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>ts_time_get_nobegin</name><argument_list>(<argument><expr><name>type_oid</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TS_TIME_DATUM_IS_NOEND</name><argument_list>(<argument><expr><name>time_val</name></expr></argument>, <argument><expr><name>type_oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>ts_time_get_noend</name><argument_list>(<argument><expr><name>type_oid</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><name>type_oid</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>INT8OID</name></expr>:</case>
		<case>case <expr><name>INT4OID</name></expr>:</case>
		<case>case <expr><name>INT2OID</name></expr>:</case>
			<return>return <expr><call><name>ts_integer_to_internal</name><argument_list>(<argument><expr><name>time_val</name></expr></argument>, <argument><expr><name>type_oid</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>TIMESTAMPOID</name></expr>:</case>
			<comment type="block">/*
			 * for timestamps, ignore timezones, make believe the timestamp is
			 * at UTC
			 */</comment>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>ts_pg_timestamp_to_unix_microseconds</name></expr></argument>, <argument><expr><name>time_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<return>return <expr><call><name>DatumGetInt64</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>TIMESTAMPTZOID</name></expr>:</case>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>ts_pg_timestamp_to_unix_microseconds</name></expr></argument>, <argument><expr><name>time_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<return>return <expr><call><name>DatumGetInt64</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>DATEOID</name></expr>:</case>
			<expr_stmt><expr><name>tz</name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>date_timestamp</name></expr></argument>, <argument><expr><name>time_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>ts_pg_timestamp_to_unix_microseconds</name></expr></argument>, <argument><expr><name>tz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<return>return <expr><call><name>DatumGetInt64</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</return>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unknown time type \"%s\""</literal></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>type_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>TSDLLEXPORT</name> <name>int64</name></type>
<name>ts_interval_value_to_internal</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>time_val</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>type_oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>type_oid</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>INT8OID</name></expr>:</case>
		<case>case <expr><name>INT4OID</name></expr>:</case>
		<case>case <expr><name>INT2OID</name></expr>:</case>
			<return>return <expr><call><name>ts_integer_to_internal</name><argument_list>(<argument><expr><name>time_val</name></expr></argument>, <argument><expr><name>type_oid</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>INTERVALOID</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Interval</name> <modifier>*</modifier></type><name>interval</name> <init>= <expr><call><name>DatumGetIntervalP</name><argument_list>(<argument><expr><name>time_val</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>interval</name><operator>-&gt;</operator><name>month</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"months and years not supported"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"An interval must be defined as a fixed duration (such as "</literal>
								   <literal type="string">"weeks, days, hours, minutes, seconds, etc.)."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<return>return <expr><name><name>interval</name><operator>-&gt;</operator><name>time</name></name> <operator>+</operator> <operator>(</operator><name><name>interval</name><operator>-&gt;</operator><name>day</name></name> <operator>*</operator> <name>USECS_PER_DAY</name><operator>)</operator></expr>;</return>
		</block_content>}</block>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unknown interval type \"%s\""</literal></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>type_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int64</name></type>
<name>ts_integer_to_internal</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>time_val</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>type_oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>type_oid</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>INT8OID</name></expr>:</case>
			<return>return <expr><call><name>DatumGetInt64</name><argument_list>(<argument><expr><name>time_val</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>INT4OID</name></expr>:</case>
			<return>return <expr><operator>(</operator><name>int64</name><operator>)</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>time_val</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>INT2OID</name></expr>:</case>
			<return>return <expr><operator>(</operator><name>int64</name><operator>)</operator> <call><name>DatumGetInt16</name><argument_list>(<argument><expr><name>time_val</name></expr></argument>)</argument_list></call></expr>;</return>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unknown interval type \"%s\""</literal></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>type_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>int64</name></type>
<name>ts_time_value_to_internal_or_infinite</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>time_val</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>type_oid</name></decl></parameter>,
									  <parameter><decl><type><name>TimevalInfinity</name> <modifier>*</modifier></type><name>is_infinite_out</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>type_oid</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>TIMESTAMPOID</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Timestamp</name></type> <name>ts</name> <init>= <expr><call><name>DatumGetTimestamp</name><argument_list>(<argument><expr><name>time_val</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>TIMESTAMP_NOT_FINITE</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>TIMESTAMP_IS_NOBEGIN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>is_infinite_out</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><operator>*</operator><name>is_infinite_out</name> <operator>=</operator> <name>TimevalNegInfinity</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<return>return <expr><name>PG_INT64_MIN</name></expr>;</return>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>is_infinite_out</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><operator>*</operator><name>is_infinite_out</name> <operator>=</operator> <name>TimevalPosInfinity</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<return>return <expr><name>PG_INT64_MAX</name></expr>;</return>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>

			<return>return <expr><call><name>ts_time_value_to_internal</name><argument_list>(<argument><expr><name>time_val</name></expr></argument>, <argument><expr><name>type_oid</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block>
		<case>case <expr><name>TIMESTAMPTZOID</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TimestampTz</name></type> <name>ts</name> <init>= <expr><call><name>DatumGetTimestampTz</name><argument_list>(<argument><expr><name>time_val</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>TIMESTAMP_NOT_FINITE</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>TIMESTAMP_IS_NOBEGIN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>is_infinite_out</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><operator>*</operator><name>is_infinite_out</name> <operator>=</operator> <name>TimevalNegInfinity</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<return>return <expr><name>PG_INT64_MIN</name></expr>;</return>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>is_infinite_out</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><operator>*</operator><name>is_infinite_out</name> <operator>=</operator> <name>TimevalPosInfinity</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<return>return <expr><name>PG_INT64_MAX</name></expr>;</return>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>

			<return>return <expr><call><name>ts_time_value_to_internal</name><argument_list>(<argument><expr><name>time_val</name></expr></argument>, <argument><expr><name>type_oid</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block>
		<case>case <expr><name>DATEOID</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>DateADT</name></type> <name>d</name> <init>= <expr><call><name>DatumGetDateADT</name><argument_list>(<argument><expr><name>time_val</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>DATE_NOT_FINITE</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>DATE_IS_NOBEGIN</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>is_infinite_out</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><operator>*</operator><name>is_infinite_out</name> <operator>=</operator> <name>TimevalNegInfinity</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<return>return <expr><name>PG_INT64_MIN</name></expr>;</return>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>is_infinite_out</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><operator>*</operator><name>is_infinite_out</name> <operator>=</operator> <name>TimevalPosInfinity</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<return>return <expr><name>PG_INT64_MAX</name></expr>;</return>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>

			<return>return <expr><call><name>ts_time_value_to_internal</name><argument_list>(<argument><expr><name>time_val</name></expr></argument>, <argument><expr><name>type_oid</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block>
	</block_content>}</block></switch>

	<return>return <expr><call><name>ts_time_value_to_internal</name><argument_list>(<argument><expr><name>time_val</name></expr></argument>, <argument><expr><name>type_oid</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><call><name>TS_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>ts_time_to_internal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type>
<name>ts_time_to_internal</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type> <name>time</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>time_type</name> <init>= <expr><call><name>get_fn_expr_argtype</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>res</name> <init>= <expr><call><name>ts_time_value_to_internal</name><argument_list>(<argument><expr><name>time</name></expr></argument>, <argument><expr><name>time_type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>ts_integer_to_internal_value</name><parameter_list>(<parameter><decl><type><name>int64</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>type</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * convert int64 to Datum according to type
 * internally we store all times as int64 in the
 * same format postgres does
 */</comment>
<function><type><name>TSDLLEXPORT</name> <name>Datum</name></type>
<name>ts_internal_to_time_value</name><parameter_list>(<parameter><decl><type><name>int64</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>TS_TIME_IS_NOBEGIN</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>ts_time_datum_get_nobegin</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TS_TIME_IS_NOEND</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>ts_time_datum_get_noend</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><name>type</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>INT2OID</name></expr>:</case>
		<case>case <expr><name>INT4OID</name></expr>:</case>
		<case>case <expr><name>INT8OID</name></expr>:</case>
			<return>return <expr><call><name>ts_integer_to_internal_value</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>TIMESTAMPOID</name></expr>:</case>
		<case>case <expr><name>TIMESTAMPTZOID</name></expr>:</case>
			<comment type="block">/* we continue ts_time_value_to_internal's incorrect handling of TIMESTAMPs for
			 * compatibility */</comment>
			<return>return <expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>ts_pg_unix_microseconds_to_timestamp</name></expr></argument>, <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>DATEOID</name></expr>:</case>
			<return>return <expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>ts_pg_unix_microseconds_to_date</name></expr></argument>, <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
		<default>default:</default>
			<if_stmt><if>if <condition>(<expr><call><name>ts_type_is_int8_binary_compatible</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				 <argument><expr><literal type="string">"unknown time type \"%s\" in ts_internal_to_time_value"</literal></expr></argument>,
				 <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pg_unreachable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>TSDLLEXPORT</name> <name>int64</name></type>
<name>ts_internal_to_time_int64</name><parameter_list>(<parameter><decl><type><name>int64</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>TS_TIME_IS_NOBEGIN</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>ts_time_datum_get_nobegin</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TS_TIME_IS_NOEND</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>ts_time_datum_get_noend</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><name>type</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>INT2OID</name></expr>:</case>
		<case>case <expr><name>INT4OID</name></expr>:</case>
		<case>case <expr><name>INT8OID</name></expr>:</case>
			<return>return <expr><name>value</name></expr>;</return>
		<case>case <expr><name>TIMESTAMPOID</name></expr>:</case>
		<case>case <expr><name>TIMESTAMPTZOID</name></expr>:</case>
			<comment type="block">/* we continue ts_time_value_to_internal's incorrect handling of TIMESTAMPs for
			 * compatibility */</comment>
			<return>return <expr><call><name>DatumGetInt64</name><argument_list>(
				<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>ts_pg_unix_microseconds_to_timestamp</name></expr></argument>, <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>DATEOID</name></expr>:</case>
			<return>return <expr><call><name>DatumGetInt64</name><argument_list>(
				<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>ts_pg_unix_microseconds_to_date</name></expr></argument>, <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				 <argument><expr><literal type="string">"unknown time type \"%s\" in ts_internal_to_time_value"</literal></expr></argument>,
				 <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pg_unreachable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>TSDLLEXPORT</name> <name>char</name> <modifier>*</modifier></type>
<name>ts_internal_to_time_string</name><parameter_list>(<parameter><decl><type><name>int64</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type> <name>time_datum</name> <init>= <expr><call><name>ts_internal_to_time_value</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>typoutputfunc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>typIsVarlena</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name></type> <name>typoutputinfo</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typoutputfunc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typIsVarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>typoutputfunc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typoutputinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>OutputFunctionCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name>typoutputinfo</name></expr></argument>, <argument><expr><name>time_datum</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><call><name>TS_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>ts_pg_unix_microseconds_to_interval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type>
<name>ts_pg_unix_microseconds_to_interval</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int64</name></type> <name>microseconds</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name> <modifier>*</modifier></type><name>interval</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>interval</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>interval</name><operator>-&gt;</operator><name>day</name></name> <operator>=</operator> <name>microseconds</name> <operator>/</operator> <name>USECS_PER_DAY</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>interval</name><operator>-&gt;</operator><name>time</name></name> <operator>=</operator> <name>microseconds</name> <operator>%</operator> <name>USECS_PER_DAY</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_INTERVAL_P</name><argument_list>(<argument><expr><name>interval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>TSDLLEXPORT</name> <name>Datum</name></type>
<name>ts_internal_to_interval_value</name><parameter_list>(<parameter><decl><type><name>int64</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>type</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>INT2OID</name></expr>:</case>
		<case>case <expr><name>INT4OID</name></expr>:</case>
		<case>case <expr><name>INT8OID</name></expr>:</case>
			<return>return <expr><call><name>ts_integer_to_internal_value</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>INTERVALOID</name></expr>:</case>
			<return>return <expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>ts_pg_unix_microseconds_to_interval</name></expr></argument>, <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				 <argument><expr><literal type="string">"unknown time type \"%s\" in ts_internal_to_interval_value"</literal></expr></argument>,
				 <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pg_unreachable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>ts_integer_to_internal_value</name><parameter_list>(<parameter><decl><type><name>int64</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>type</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>INT2OID</name></expr>:</case>
			<return>return <expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>INT4OID</name></expr>:</case>
			<return>return <expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>INT8OID</name></expr>:</case>
			<return>return <expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				 <argument><expr><literal type="string">"unknown time type \"%s\" in ts_internal_to_time_value"</literal></expr></argument>,
				 <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pg_unreachable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/* Returns approximate period in microseconds */</comment>
<function><type><name>int64</name></type>
<name>ts_get_interval_period_approx</name><parameter_list>(<parameter><decl><type><name>Interval</name> <modifier>*</modifier></type><name>interval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>interval</name><operator>-&gt;</operator><name>time</name></name> <operator>+</operator>
		   <operator>(</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>int64</name><operator>)</operator> <name><name>interval</name><operator>-&gt;</operator><name>month</name></name> <operator>*</operator> <name>DAYS_PER_MONTH</name><operator>)</operator> <operator>+</operator> <name><name>interval</name><operator>-&gt;</operator><name>day</name></name><operator>)</operator> <operator>*</operator> <name>USECS_PER_DAY</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAYS_PER_WEEK</name></cpp:macro> <cpp:value>7</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAYS_PER_QUARTER</name></cpp:macro> <cpp:value>89</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YEARS_PER_DECADE</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YEARS_PER_CENTURY</name></cpp:macro> <cpp:value>100</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YEARS_PER_MILLENNIUM</name></cpp:macro> <cpp:value>1000</cpp:value></cpp:define>

<comment type="block">/* Returns approximate period in microseconds */</comment>
<function><type><name>int64</name></type>
<name>ts_date_trunc_interval_period_approx</name><parameter_list>(<parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>units</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>decode_type</name></decl>, <decl><type ref="prev"/><name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>lowunits</name> <init>=
		<expr><call><name>downcase_truncate_identifier</name><argument_list>(<argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>units</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>units</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>decode_type</name> <operator>=</operator> <call><name>DecodeUnits</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>lowunits</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>decode_type</name> <operator>!=</operator> <name>UNITS</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><name>val</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>DTK_WEEK</name></expr>:</case>
			<return>return <expr><name>DAYS_PER_WEEK</name> <operator>*</operator> <name>USECS_PER_DAY</name></expr>;</return>
		<case>case <expr><name>DTK_MILLENNIUM</name></expr>:</case>
			<return>return <expr><name>YEARS_PER_MILLENNIUM</name> <operator>*</operator> <name>DAYS_PER_YEAR</name> <operator>*</operator> <name>USECS_PER_DAY</name></expr>;</return>
		<case>case <expr><name>DTK_CENTURY</name></expr>:</case>
			<return>return <expr><name>YEARS_PER_CENTURY</name> <operator>*</operator> <name>DAYS_PER_YEAR</name> <operator>*</operator> <name>USECS_PER_DAY</name></expr>;</return>
		<case>case <expr><name>DTK_DECADE</name></expr>:</case>
			<return>return <expr><name>YEARS_PER_DECADE</name> <operator>*</operator> <name>DAYS_PER_YEAR</name> <operator>*</operator> <name>USECS_PER_DAY</name></expr>;</return>
		<case>case <expr><name>DTK_YEAR</name></expr>:</case>
			<return>return <expr><literal type="number">1</literal> <operator>*</operator> <name>DAYS_PER_YEAR</name> <operator>*</operator> <name>USECS_PER_DAY</name></expr>;</return>
		<case>case <expr><name>DTK_QUARTER</name></expr>:</case>
			<return>return <expr><name>DAYS_PER_QUARTER</name> <operator>*</operator> <name>USECS_PER_DAY</name></expr>;</return>
		<case>case <expr><name>DTK_MONTH</name></expr>:</case>
			<return>return <expr><name>DAYS_PER_MONTH</name> <operator>*</operator> <name>USECS_PER_DAY</name></expr>;</return>
		<case>case <expr><name>DTK_DAY</name></expr>:</case>
			<return>return <expr><name>USECS_PER_DAY</name></expr>;</return>
		<case>case <expr><name>DTK_HOUR</name></expr>:</case>
			<return>return <expr><name>USECS_PER_HOUR</name></expr>;</return>
		<case>case <expr><name>DTK_MINUTE</name></expr>:</case>
			<return>return <expr><name>USECS_PER_MINUTE</name></expr>;</return>
		<case>case <expr><name>DTK_SECOND</name></expr>:</case>
			<return>return <expr><name>USECS_PER_SEC</name></expr>;</return>
		<case>case <expr><name>DTK_MILLISEC</name></expr>:</case>
			<return>return <expr><name>USECS_PER_SEC</name> <operator>/</operator> <literal type="number">1000</literal></expr>;</return>
		<case>case <expr><name>DTK_MICROSEC</name></expr>:</case>
			<return>return <expr><literal type="number">1</literal></expr>;</return>
		<default>default:</default>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp units \"%s\" not supported"</literal></expr></argument>, <argument><expr><name>lowunits</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
	<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>Oid</name></type>
<name>ts_inheritance_parent_relid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type> <name>catalog</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>skey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>parent</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>catalog</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>InheritsRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>skey</name></expr></argument>,
				<argument><expr><name>Anum_pg_inherits_inhrelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
				<argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>InheritsRelidSeqnoIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>parent</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_inherits</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>inhparent</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>parent</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>TSDLLEXPORT</name> <name>bool</name></type>
<name>ts_type_is_int8_binary_compatible</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>sourcetype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_cast</name></type> <name>castForm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator>
		<call><name>SearchSysCache2</name><argument_list>(<argument><expr><name>CASTSOURCETARGET</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>sourcetype</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>INT8OID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* no cast */</comment>
	<expr_stmt><expr><name>castForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_cast</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>castForm</name><operator>-&gt;</operator><name>castmethod</name></name> <operator>==</operator> <name>COERCION_METHOD_BINARY</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Create a fresh struct pointer that will contain copied contents of the tuple.
 * Note that this function uses GETSTRUCT, which will not work correctly for tuple types
 * that might have variable lengths.
 * Also note that the function assumes no NULLs in the tuple.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>ts_create_struct_from_tuple</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>mctx</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>alloc_size</name></decl></parameter>,
							<parameter><decl><type><name>size_t</name></type> <name>copy_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>struct_ptr</name> <init>= <expr><call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>mctx</name></expr></argument>, <argument><expr><name>alloc_size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Make sure the function is not used when the tuple contains NULLs.
	 * Also compare the aligned sizes in the assert.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>copy_size</name> <operator>==</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name> <operator>-</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_hoff</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>struct_ptr</name></expr></argument>, <argument><expr><call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>copy_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>struct_ptr</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type>
<name>ts_create_struct_from_slot</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>mctx</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>alloc_size</name></decl></parameter>,
						   <parameter><decl><type><name>size_t</name></type> <name>copy_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>should_free</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name> <init>= <expr><call><name>ExecFetchSlotHeapTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>should_free</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>ts_create_struct_from_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>mctx</name></expr></argument>, <argument><expr><name>alloc_size</name></expr></argument>, <argument><expr><name>copy_size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>should_free</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ts_function_types_equal</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name><name>left</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name><name>right</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>arg_index</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>arg_index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>arg_index</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>arg_index</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>left</name><index>[<expr><name>arg_index</name></expr>]</index></name> <operator>!=</operator> <name><name>right</name><index>[<expr><name>arg_index</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Oid</name></type>
<name>ts_get_function_oid</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>funcname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>schema_name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name><name>arg_types</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>qualified_funcname</name> <init>=
		<expr><call><name>list_make2</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>schema_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncCandidateList</name></type> <name>func_candidates</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>func_candidates</name> <operator>=</operator> <call><name>FuncnameGetCandidates</name><argument_list>(<argument><expr><name>qualified_funcname</name></expr></argument>,
											<argument><expr><name>nargs</name></expr></argument>,
											<argument><expr><name>NIL</name></expr></argument>,
											<argument><expr><name>false</name></expr></argument>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_GE</name></expr></cpp:if>
											<argument><expr><name>false</name></expr></argument>, <comment type="block">/* include_out_arguments */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
											<argument><expr><name>false</name></expr></argument>,
											<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>func_candidates</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>func_candidates</name><operator>-&gt;</operator><name>nargs</name></name> <operator>==</operator> <name>nargs</name> <operator>&amp;&amp;</operator>
			<call><name>ts_function_types_equal</name><argument_list>(<argument><expr><name><name>func_candidates</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>arg_types</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name><name>func_candidates</name><operator>-&gt;</operator><name>oid</name></name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>func_candidates</name> <operator>=</operator> <name><name>func_candidates</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
		 <argument><expr><literal type="string">"failed to find function %s with %d args in schema \"%s\""</literal></expr></argument>,
		 <argument><expr><name>funcname</name></expr></argument>,
		 <argument><expr><name>nargs</name></expr></argument>,
		 <argument><expr><name>schema_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>InvalidOid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Find a partitioning function with a given schema and name.
 *
 * The caller can optionally pass a filter function and a type of the argument
 * that the partitioning function should take.
 */</comment>
<function><type><name>Oid</name></type>
<name>ts_lookup_proc_filtered</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>schema</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>funcname</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>rettype</name></decl></parameter>, <parameter><decl><type><name>proc_filter</name></type> <name>filter</name></decl></parameter>,
						<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>filter_arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>namespace_oid</name> <init>= <expr><call><name>LookupExplicitNamespace</name><argument_list>(<argument><expr><name>schema</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>regproc</name></type> <name>func</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CatCList</name> <modifier>*</modifier></type><name>catlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We could use SearchSysCache3 to get by (name, args, namespace), but
	 * that would not allow us to check for functions that take either
	 * ANYELEMENTOID or a dimension-specific in the same search.
	 */</comment>
	<expr_stmt><expr><name>catlist</name> <operator>=</operator> <call><name>SearchSysCacheList1</name><argument_list>(<argument><expr><name>PROCNAMEARGSNSP</name></expr></argument>, <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>catlist</name><operator>-&gt;</operator><name>n_members</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type> <name>proctup</name> <init>= <expr><operator>&amp;</operator><name><name>catlist</name><operator>-&gt;</operator><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>tuple</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>procform</name> <init>= <expr><operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>procform</name><operator>-&gt;</operator><name>pronamespace</name></name> <operator>==</operator> <name>namespace_oid</name> <operator>&amp;&amp;</operator>
			<operator>(</operator><name>filter</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>filter</name><argument_list>(<argument><expr><name>procform</name></expr></argument>, <argument><expr><name>filter_arg</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>rettype</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>rettype</name> <operator>=</operator> <name><name>procform</name><operator>-&gt;</operator><name>prorettype</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>func</name> <operator>=</operator> <name><name>procform</name><operator>-&gt;</operator><name>oid</name></name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>ReleaseSysCacheList</name><argument_list>(<argument><expr><name>catlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>func</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ts_get_operator
 *
 *    finds an operator given an exact specification (name, namespace,
 *    left and right type IDs).
 */</comment>
<function><type><name>Oid</name></type>
<name>ts_get_operator</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>namespace</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>left</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>right</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>opoid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCache4</name><argument_list>(<argument><expr><name>OPERNAMENSP</name></expr></argument>,
						  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>namespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_operator</name></type> <name>oprform</name> <init>= <expr><operator>(</operator><name>Form_pg_operator</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>opoid</name> <operator>=</operator> <name><name>oprform</name><operator>-&gt;</operator><name>oid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>opoid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ts_get_cast_func
 *
 * returns Oid of functions that implements cast from source to target
 */</comment>
<function><type><name>Oid</name></type>
<name>ts_get_cast_func</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>source</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>target</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>result</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>casttup</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>casttup</name> <operator>=</operator> <call><name>SearchSysCache2</name><argument_list>(<argument><expr><name>CASTSOURCETARGET</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>casttup</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_cast</name></type> <name>castform</name> <init>= <expr><operator>(</operator><name>Form_pg_cast</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>casttup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>castform</name><operator>-&gt;</operator><name>castfunc</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>casttup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>AppendRelInfo</name> <modifier>*</modifier></type>
<name>ts_get_appendrelinfo</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>rti</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<comment type="block">/* use append_rel_array if it has been setup */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>append_rel_array</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>append_rel_array</name><index>[<expr><name>rti</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name><name>root</name><operator>-&gt;</operator><name>append_rel_array</name><index>[<expr><name>rti</name></expr>]</index></name></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>missing_ok</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no appendrelinfo found for index %d"</literal></expr></argument>, <argument><expr><name>rti</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>root-&gt;append_rel_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appinfo</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>appinfo</name><operator>-&gt;</operator><name>child_relid</name></name> <operator>==</operator> <name>rti</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>appinfo</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>missing_ok</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no appendrelinfo found for index %d"</literal></expr></argument>, <argument><expr><name>rti</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG12</name> <operator>||</operator> <name>PG15_GE</name></expr></cpp:if>
<comment type="block">/*
 * Find an equivalence class member expression, all of whose Vars, come from
 * the indicated relation.
 *
 * This function has been copied from find_em_expr_for_rel in
 * contrib/postgres_fdw/postgres_fdw.c in postgres source.
 * This function was moved to postgres main in PG13 so we only need this
 * backport for PG12 in later versions we will use the postgres implementation.
 * PG15 removes the function again from postgres code, so we use our own
 * implementation for PG15+ again.
 */</comment>
<function><type><name>Expr</name> <modifier>*</modifier></type>
<name>ts_find_em_expr_for_rel</name><parameter_list>(<parameter><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc_em</name></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc_em</argument>, <argument>ec-&gt;ec_members</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>em</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc_em</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>em</name><operator>-&gt;</operator><name>em_relids</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><name><name>em</name><operator>-&gt;</operator><name>em_relids</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If there is more than one equivalence member whose Vars are
			 * taken entirely from this relation, we'll be content to choose
			 * any one of those.
			 */</comment>
			<return>return <expr><name><name>em</name><operator>-&gt;</operator><name>em_expr</name></name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* We didn't find any suitable equivalence class expression */</comment>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>bool</name></type>
<name>ts_has_row_security</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>classform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>relrowsecurity</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>relforcerowsecurity</name></decl>;</decl_stmt>

	<comment type="block">/* Fetch relation's relrowsecurity and relforcerowsecurity flags */</comment>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relid %u"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>classform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>relrowsecurity</name> <operator>=</operator> <name><name>classform</name><operator>-&gt;</operator><name>relrowsecurity</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>relforcerowsecurity</name> <operator>=</operator> <name><name>classform</name><operator>-&gt;</operator><name>relforcerowsecurity</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>relrowsecurity</name> <operator>||</operator> <name>relforcerowsecurity</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>List</name> <modifier>*</modifier></type>
<name>ts_get_reloptions</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>datum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>options</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pg_class_reloptions</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name> <operator>&amp;&amp;</operator> <call><name>PointerIsValid</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>untransformRelOptions</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>options</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get the integer_now function for a dimension
 */</comment>
<function><type><name>Oid</name></type>
<name>ts_get_integer_now_func</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type><name>open_dim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>rettype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>now_func</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name><name>argtypes</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>rettype</name> <operator>=</operator> <call><name>ts_dimension_get_partition_type</name><argument_list>(<argument><expr><name>open_dim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IS_INTEGER_TYPE</name><argument_list>(<argument><expr><name>rettype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>open_dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>integer_now_func</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<call><name>strlen</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>open_dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>integer_now_func_schema</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator> <operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"integer_now function not set"</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>list_make2</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>open_dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>integer_now_func_schema</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>open_dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>integer_now_func</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>now_func</name> <operator>=</operator> <call><name>LookupFuncName</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>argtypes</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>get_func_rettype</name><argument_list>(<argument><expr><name>now_func</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>rettype</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid integer_now function"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				  <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"return type of function does not match dimension type"</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>now_func</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* subtract passed in interval from the now.
 * Arguments:
 * now_func : function used to compute now.
 * interval : integer value
 * Returns:
 *  now_func() - interval
 */</comment>
<function><type><name>int64</name></type>
<name>ts_sub_integer_from_now</name><parameter_list>(<parameter><decl><type><name>int64</name></type> <name>interval</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>time_dim_type</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>now_func</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type> <name>now</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>IS_INTEGER_TYPE</name><argument_list>(<argument><expr><name>time_dim_type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>now</name> <operator>=</operator> <call><name>OidFunctionCall0</name><argument_list>(<argument><expr><name>now_func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name>time_dim_type</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>INT2OID</name></expr>:</case>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>DatumGetInt16</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>interval</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>res</name> <argument_list type="generic">&lt; <argument><expr><name>PG_INT16_MIN</name> <operator>||</operator> <name>res</name></expr></argument> &gt;</argument_list></name> <name>PG_INT16_MAX</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERVAL_FIELD_OVERFLOW</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"integer time overflow"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<return>return <expr><name>res</name></expr>;</return>
		<case>case <expr><name>INT4OID</name></expr>:</case>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>interval</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>res</name> <argument_list type="generic">&lt; <argument><expr><name>PG_INT32_MIN</name> <operator>||</operator> <name>res</name></expr></argument> &gt;</argument_list></name> <name>PG_INT32_MAX</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERVAL_FIELD_OVERFLOW</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"integer time overflow"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<return>return <expr><name>res</name></expr>;</return>
		<case>case <expr><name>INT8OID</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type> <name>overflow</name> <init>= <expr><call><name>pg_sub_s64_overflow</name><argument_list>(<argument><expr><call><name>DatumGetInt64</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>interval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>res</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>overflow</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERVAL_FIELD_OVERFLOW</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"integer time overflow"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<return>return <expr><name>res</name></expr>;</return>
		</block_content>}</block>
		<default>default:</default>
			<expr_stmt><expr><call><name>pg_unreachable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
</block_content>}</block></function>

<expr_stmt><expr><call><name>TS_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>ts_subtract_integer_from_now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type>
<name>ts_subtract_integer_from_now</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>ht_relid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>lag</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cache</name> <modifier>*</modifier></type><name>hcache</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name> <init>= <expr><call><name>ts_hypertable_cache_get_cache_and_entry</name><argument_list>(<argument><expr><name>ht_relid</name></expr></argument>, <argument><expr><name>CACHE_FLAG_NONE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hcache</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type><name>dim</name> <init>= <expr><call><name>hyperspace_get_open_dimension</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>space</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dim</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"hypertable has no open partitioning dimension"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>partitioning_type</name> <init>= <expr><call><name>ts_dimension_get_partition_type</name><argument_list>(<argument><expr><name>dim</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_INTEGER_TYPE</name><argument_list>(<argument><expr><name>partitioning_type</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"hypertable has no integer partitioning dimension"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>now_func</name> <init>= <expr><call><name>ts_get_integer_now_func</name><argument_list>(<argument><expr><name>dim</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>now_func</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find valid integer_now function for hypertable"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>int64</name></type> <name>res</name> <init>= <expr><call><name>ts_sub_integer_from_now</name><argument_list>(<argument><expr><name>lag</name></expr></argument>, <argument><expr><name>partitioning_type</name></expr></argument>, <argument><expr><name>now_func</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><call><name>TS_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>ts_relation_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type>
<name>ts_relation_size</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relid</name> <init>= <expr><ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>InvalidOid</name></expr> </then><else>: <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelationSize</name></type> <name>relsize</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name><name>values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name><name>nulls</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <init>= <expr><block>{ <expr><name>false</name></expr> }</block></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Build a tuple descriptor for our result type */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>get_call_result_type</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupdesc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TYPEFUNC_COMPOSITE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function returning record called in context "</literal>
						<literal type="string">"that cannot accept type record"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>relsize</name> <operator>=</operator> <call><name>ts_relation_size_impl</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>BlessTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><name><name>relsize</name><operator>.</operator><name>total_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><name><name>relsize</name><operator>.</operator><name>heap_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><name><name>relsize</name><operator>.</operator><name>index_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><name><name>relsize</name><operator>.</operator><name>toast_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>RelationSize</name></type>
<name>ts_relation_size_impl</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelationSize</name></type> <name>relsize</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>reloid</name> <init>= <expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name></decl>;</decl_stmt>

	<comment type="block">/* Open relation earlier to keep a lock during all function calls */</comment>
	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>try_relation_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rel</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>relsize</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Get to total relation size to be our calculation base */</comment>
	<expr_stmt><expr><name><name>relsize</name><operator>.</operator><name>total_size</name></name> <operator>=</operator> <call><name>DatumGetInt64</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>pg_total_relation_size</name></expr></argument>, <argument><expr><name>reloid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get the indexes size of the relation (don't consider TOAST indexes) */</comment>
	<expr_stmt><expr><name><name>relsize</name><operator>.</operator><name>index_size</name></name> <operator>=</operator> <call><name>DatumGetInt64</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>pg_indexes_size</name></expr></argument>, <argument><expr><name>reloid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If exists an associated TOAST calculate the total size (including indexes) */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>relsize</name><operator>.</operator><name>toast_size</name></name> <operator>=</operator>
			<call><name>DatumGetInt64</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>pg_total_relation_size</name></expr></argument>,
											  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>relsize</name><operator>.</operator><name>toast_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Calculate the HEAP size based on the total size and indexes plus toast */</comment>
	<expr_stmt><expr><name><name>relsize</name><operator>.</operator><name>heap_size</name></name> <operator>=</operator> <name><name>relsize</name><operator>.</operator><name>total_size</name></name> <operator>-</operator> <operator>(</operator><name><name>relsize</name><operator>.</operator><name>index_size</name></name> <operator>+</operator> <name><name>relsize</name><operator>.</operator><name>toast_size</name></name><operator>)</operator></expr>;</expr_stmt>

	<return>return <expr><name>relsize</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STR_VALUE</name><parameter_list>(<parameter><type><name>str</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>#str</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NODE_CASE</name><parameter_list>(<parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro>                                                                            \
	<cpp:value>case T_##name:                                                                                 \
		return STR_VALUE(name)</cpp:value></cpp:define>

<comment type="block">/*
 * Return a string with the name of the node.
 *
 */</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>ts_get_node_name</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* tags are defined in nodes/nodes.h postgres source */</comment>
	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * primitive nodes (primnodes.h)
		 */</comment>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>Alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>RangeVar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>TableFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>IntoClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG15_LT</name></expr></cpp:if>
		<comment type="block">/* PG15 removed T_Expr nodetag because it's an abstract type. */</comment>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>Expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>GroupingFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>WindowFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>SubscriptingRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>NamedArgExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>DistinctExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>NullIfExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>ScalarArrayOpExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>BoolExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>SubLink</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>SubPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>AlternativeSubPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>FieldSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>FieldStore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>CoerceViaIO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>ArrayCoerceExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>ConvertRowtypeExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>CollateExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>CaseExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>CaseWhen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>CaseTestExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>ArrayExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>RowExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>RowCompareExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>CoalesceExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>MinMaxExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>SQLValueFunction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>XmlExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>NullTest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>BooleanTest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>CoerceToDomain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>CoerceToDomainValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>SetToDefault</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>CurrentOfExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>NextValueExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>InferenceElem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>TargetEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>FromExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>OnConflictExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * plan nodes (plannodes.h)
		 */</comment>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>Plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>Result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>ProjectSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>ModifyTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>Append</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>MergeAppend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>RecursiveUnion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>BitmapAnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>BitmapOr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>Scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>SeqScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>SampleScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>IndexScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>IndexOnlyScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>BitmapIndexScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>BitmapHeapScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>TidScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>SubqueryScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>FunctionScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>ValuesScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>TableFuncScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>CteScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>NamedTuplestoreScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>WorkTableScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>ForeignScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>CustomScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>Join</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>NestLoop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>MergeJoin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>HashJoin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>Material</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>Sort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>Group</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>Agg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>WindowAgg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>Unique</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>Gather</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>GatherMerge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>Hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>SetOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>LockRows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>Limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * planner nodes (pathnodes.h)
		 */</comment>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>IndexPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>BitmapHeapPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>BitmapAndPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>BitmapOrPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>TidPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>SubqueryScanPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>ForeignPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>NestPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>MergePath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>HashPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>AppendPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>MergeAppendPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>GroupResultPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>MaterialPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>UniquePath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>GatherPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>GatherMergePath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>ProjectionPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>ProjectSetPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>SortPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>GroupPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>UpperUniquePath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>AggPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>GroupingSetsPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>MinMaxAggPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>WindowAggPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>SetOpPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>RecursiveUnionPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>LockRowsPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>ModifyTablePath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>LimitPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<case>case <expr><name>T_Path</name></expr>:</case>
			<switch>switch <condition>(<expr><call><name>castNode</name><argument_list>(<argument><expr><name>Path</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>pathtype</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>SeqScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>SampleScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>SubqueryScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>FunctionScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>TableFuncScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>ValuesScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>CteScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>NODE_CASE</name><argument_list>(<argument><expr><name>WorkTableScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<default>default:</default>
					<return>return <expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"Path (%d)"</literal></expr></argument>, <argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>Path</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>pathtype</name></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block></switch>

		<case>case <expr><name>T_CustomPath</name></expr>:</case>
			<return>return <expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"CustomPath (%s)"</literal></expr></argument>, <argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>CustomPath</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>methods</name><operator>-&gt;</operator><name>CustomName</name></name></expr></argument>)</argument_list></call></expr>;</return>

		<default>default:</default>
			<return>return <expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"Node (%d)"</literal></expr></argument>, <argument><expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Implementation marked unused in PostgreSQL lsyscache.c
 */</comment>
<function><type><name>int</name></type>
<name>ts_get_relnatts</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>reltup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>InvalidAttrNumber</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>reltup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>reltup</name><operator>-&gt;</operator><name>relnatts</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Wrap AlterTableInternal() for event trigger handling.
 *
 * AlterTableInternal can be called as a utility command, which is common in a
 * SQL function that alters a table in some form when called in the form
 * SELECT &lt;cmd&gt; INTO &lt;table&gt;. This is transformed into a process utility
 * command (CREATE TABLE AS), which expects an event trigger context to be
 * set up.
 *
 * The "cmd" parameter can be set to a higher-level command that caused the
 * alter table to occur. If "cmd" is set to NULL, the "cmds" list will be used
 * instead.
 */</comment>
<function><type><name>void</name></type>
<name>ts_alter_table_with_event_trigger</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>cmds</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>cmd</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>cmd</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>cmds</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>EventTriggerAlterTableStart</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AlterTableInternal</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>cmds</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EventTriggerAlterTableEnd</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ts_copy_relation_acl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Oid</name></type> <name>source_relid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Oid</name></type> <name>target_relid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Oid</name></type> <name>owner_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>source_tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>is_null</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>acl_datum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>class_rel</name></decl>;</decl_stmt>

	<comment type="block">/* We open it here since there is no point in trying to update the tuples
	 * if we cannot open the Relation catalog table */</comment>
	<expr_stmt><expr><name>class_rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>source_tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>source_relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>source_tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We only bother about setting the ACL if the source relation ACL is
	 * non-null */</comment>
	<expr_stmt><expr><name>acl_datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><name>source_tuple</name></expr></argument>, <argument><expr><name>Anum_pg_class_relacl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_null</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type> <name>target_tuple</name></decl>, <decl><type ref="prev"/><name>newtuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type> <name><name>new_val</name><index>[<expr><name>Natts_pg_class</name></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name><name>new_null</name><index>[<expr><name>Natts_pg_class</name></expr>]</index></name> <init>= <expr><block>{ <expr><name>false</name></expr> }</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name><name>new_repl</name><index>[<expr><name>Natts_pg_class</name></expr>]</index></name> <init>= <expr><block>{ <expr><name>false</name></expr> }</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Acl</name> <modifier>*</modifier></type><name>acl</name> <init>= <expr><call><name>DatumGetAclP</name><argument_list>(<argument><expr><name>acl_datum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>new_repl</name><index>[<expr><name>Anum_pg_class_relacl</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>new_val</name><index>[<expr><name>Anum_pg_class_relacl</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Find the tuple for the target in `pg_class` */</comment>
		<expr_stmt><expr><name>target_tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>target_relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>target_tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Update the relacl for the target tuple to use the acl from the source */</comment>
		<expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>target_tuple</name></expr></argument>,
									 <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>class_rel</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><name>new_val</name></expr></argument>,
									 <argument><expr><name>new_null</name></expr></argument>,
									 <argument><expr><name>new_repl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>class_rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newtuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* We need to update the shared dependencies as well to indicate that
		 * the target is dependent on any roles that the source is
		 * dependent on. */</comment>
		<decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>newmembers</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>nnewmembers</name> <init>= <expr><call><name>aclmembers</name><argument_list>(<argument><expr><name>acl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newmembers</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* The list of old members is intentionally empty since we are using
		 * updateAclDependencies to set the ACL for the target. We can use NULL
		 * because getOidListDiff, which is called from updateAclDependencies,
		 * can handle that. */</comment>
		<expr_stmt><expr><call><name>updateAclDependencies</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
							  <argument><expr><name>target_relid</name></expr></argument>,
							  <argument><expr><literal type="number">0</literal></expr></argument>,
							  <argument><expr><name>owner_id</name></expr></argument>,
							  <argument><expr><literal type="number">0</literal></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>,
							  <argument><expr><name>nnewmembers</name></expr></argument>,
							  <argument><expr><name>newmembers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>target_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>source_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>class_rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ts_data_node_is_available_by_server</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ForeignServer</name> <modifier>*</modifier></type><name>server</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>server-&gt;options</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>elem</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>elem</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"available"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>defGetBoolean</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* Default to available if option is not yet added */</comment>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ts_data_node_is_available</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>ts_data_node_is_available_by_server</name><argument_list>(<argument><expr><call><name>GetForeignServerByName</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
