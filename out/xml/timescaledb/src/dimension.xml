<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/timescaledb/src/dimension.c"><comment type="block">/*
 * This file and its contents are licensed under the Apache License 2.0.
 * Please see the included NOTICE for copyright information and
 * LICENSE-APACHE for a copy of the license.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postgres.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_type.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/namespace.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/relscan.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;commands/tablecmds.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/lsyscache.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/syscache.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/builtins.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/timestamp.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;funcapi.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;miscadmin.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/makefuncs.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;storage/lmgr.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ts_catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compat/compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cross_module_fn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dimension.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dimension_slice.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dimension_vector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hypertable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hypertable_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"partitioning.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"scanner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"time_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"errors.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"debug_point.h"</cpp:file></cpp:include>

<comment type="block">/* add_dimension record attribute numbers */</comment>
<enum>enum <name>Anum_add_dimension</name>
<block>{
	<decl><name>Anum_add_dimension_id</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,
	<decl><name>Anum_add_dimension_schema_name</name></decl>,
	<decl><name>Anum_add_dimension_table_name</name></decl>,
	<decl><name>Anum_add_dimension_column_name</name></decl>,
	<decl><name>Anum_add_dimension_created</name></decl>,
	<decl><name>_Anum_add_dimension_max</name></decl>,
}</block>;</enum>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Natts_add_dimension</name></cpp:macro> <cpp:value>(_Anum_add_dimension_max - 1)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>cmp_dimension_id</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>left</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>right</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type><name>diml</name> <init>= <expr><operator>(</operator><name>Dimension</name> <operator>*</operator><operator>)</operator> <name>left</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type><name>dimr</name> <init>= <expr><operator>(</operator><name>Dimension</name> <operator>*</operator><operator>)</operator> <name>right</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>diml</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name> <operator>&lt;</operator> <name><name>dimr</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>diml</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name> <operator>&gt;</operator> <name><name>dimr</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type>
<name>ts_hyperspace_get_dimension_by_id</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Hyperspace</name> <modifier>*</modifier></type><name>hs</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Dimension</name></type> <name>dim</name> <init>= <expr><block>{
		<expr><operator>.</operator><name><name>fd</name><operator>.</operator><name>id</name></name> <operator>=</operator> <name>id</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>bsearch</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dim</name></expr></argument>, <argument><expr><name><name>hs</name><operator>-&gt;</operator><name>dimensions</name></name></expr></argument>, <argument><expr><name><name>hs</name><operator>-&gt;</operator><name>num_dimensions</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Dimension</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>cmp_dimension_id</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Dimension</name> <modifier>*</modifier></type>
<name>ts_hyperspace_get_mutable_dimension_by_name</name><parameter_list>(<parameter><decl><type><name>Hyperspace</name> <modifier>*</modifier></type><name>hs</name></decl></parameter>, <parameter><decl><type><name>DimensionType</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>hs</name><operator>-&gt;</operator><name>num_dimensions</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Dimension</name> <modifier>*</modifier></type><name>dim</name> <init>= <expr><operator>&amp;</operator><name><name>hs</name><operator>-&gt;</operator><name>dimensions</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>type</name> <operator>==</operator> <name>DIMENSION_TYPE_ANY</name> <operator>||</operator> <name><name>dim</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>type</name><operator>)</operator> <operator>&amp;&amp;</operator>
			<call><name>namestrcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>column_name</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>dim</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type>
<name>ts_hyperspace_get_dimension_by_name</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Hyperspace</name> <modifier>*</modifier></type><name>hs</name></decl></parameter>, <parameter><decl><type><name>DimensionType</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>ts_hyperspace_get_mutable_dimension_by_name</name><argument_list>(<argument><expr><operator>(</operator><name>Hyperspace</name> <operator>*</operator><operator>)</operator> <name>hs</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Dimension</name> <modifier>*</modifier></type>
<name>ts_hyperspace_get_mutable_dimension</name><parameter_list>(<parameter><decl><type><name>Hyperspace</name> <modifier>*</modifier></type><name>hs</name></decl></parameter>, <parameter><decl><type><name>DimensionType</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>hs</name><operator>-&gt;</operator><name>num_dimensions</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>DIMENSION_TYPE_ANY</name> <operator>||</operator> <name><name>hs</name><operator>-&gt;</operator><name>dimensions</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>==</operator> <name>type</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><operator>&amp;</operator><name><name>hs</name><operator>-&gt;</operator><name>dimensions</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>n</name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type>
<name>ts_hyperspace_get_dimension</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Hyperspace</name> <modifier>*</modifier></type><name>hs</name></decl></parameter>, <parameter><decl><type><name>DimensionType</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>ts_hyperspace_get_mutable_dimension</name><argument_list>(<argument><expr><operator>(</operator><name>Hyperspace</name> <operator>*</operator><operator>)</operator> <name>hs</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>hyperspace_get_num_dimensions_by_type</name><parameter_list>(<parameter><decl><type><name>Hyperspace</name> <modifier>*</modifier></type><name>hs</name></decl></parameter>, <parameter><decl><type><name>DimensionType</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>hs</name><operator>-&gt;</operator><name>num_dimensions</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>DIMENSION_TYPE_ANY</name> <operator>||</operator> <name><name>hs</name><operator>-&gt;</operator><name>dimensions</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>==</operator> <name>type</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>DimensionType</name></type>
<name>dimension_type</name><parameter_list>(<parameter><decl><type><name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>slot_attisnull</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>slot</name></name></expr></argument>, <argument><expr><name>Anum_dimension_interval_length</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>slot_attisnull</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>slot</name></name></expr></argument>, <argument><expr><name>Anum_dimension_num_slices</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>DIMENSION_TYPE_CLOSED</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>slot_attisnull</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>slot</name></name></expr></argument>, <argument><expr><name>Anum_dimension_interval_length</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>slot_attisnull</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>slot</name></name></expr></argument>, <argument><expr><name>Anum_dimension_num_slices</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>DIMENSION_TYPE_OPEN</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid partitioning dimension"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* suppress compiler warning on MSVC */</comment>
	<return>return <expr><name>DIMENSION_TYPE_ANY</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dimension_fill_in_from_tuple</name><parameter_list>(<parameter><decl><type><name>Dimension</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>main_table_relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type> <name><name>values</name><index>[<expr><name>Natts_dimension</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name><name>isnull</name><index>[<expr><name>Natts_dimension</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>should_free</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name> <init>= <expr><call><name>ts_scanner_fetch_heap_tuple</name><argument_list>(<argument><expr><name>ti</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>should_free</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * With need to use heap_deform_tuple() rather than GETSTRUCT(), since
	 * optional values may be omitted from the tuple.
	 */</comment>
	<expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><call><name>ts_scanner_get_tupledesc</name><argument_list>(<argument><expr><name>ti</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <call><name>dimension_type</name><argument_list>(<argument><expr><name>ti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_dimension_id</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>hypertable_id</name></name> <operator>=</operator>
		<call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_dimension_hypertable_id</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>aligned</name></name> <operator>=</operator> <call><name>DatumGetBool</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_dimension_aligned</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>column_type</name></name> <operator>=</operator>
		<call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_dimension_column_type</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>column_name</name></name></expr></argument>,
		   <argument><expr><call><name>DatumGetName</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_dimension_column_name</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>isnull</name><index>[<expr><name>Anum_dimension_partitioning_func_schema</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator>
		<operator>!</operator><name><name>isnull</name><index>[<expr><name>Anum_dimension_partitioning_func</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>num_slices</name></name> <operator>=</operator>
			<call><name>DatumGetInt16</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_dimension_num_slices</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>partitioning_func_schema</name></name></expr></argument>,
			   <argument><expr><call><name>DatumGetName</name><argument_list>(
				   <argument><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_dimension_partitioning_func_schema</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>partitioning_func</name></name></expr></argument>,
			   <argument><expr><call><name>DatumGetName</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_dimension_partitioning_func</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>old</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>mctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>partitioning</name></name> <operator>=</operator> <call><name>ts_partitioning_info_create</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>partitioning_func_schema</name></name></expr></argument>)</argument_list></call></expr></argument>,
													  <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>partitioning_func</name></name></expr></argument>)</argument_list></call></expr></argument>,
													  <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>column_name</name></name></expr></argument>)</argument_list></call></expr></argument>,
													  <argument><expr><name><name>d</name><operator>-&gt;</operator><name>type</name></name></expr></argument>,
													  <argument><expr><name>main_table_relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Closed "space" partitions might be explicitly partitioned if it is
		 * the "first" space dimension. If it is not the first, the dimension
		 * partitions state will be NULL */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IS_CLOSED_DIMENSION</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>dimension_partitions</name></name> <operator>=</operator> <call><name>ts_dimension_partition_info_get</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>dimension_partitions</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>isnull</name><index>[<expr><name>Anum_dimension_integer_now_func_schema</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator>
		<operator>!</operator><name><name>isnull</name><index>[<expr><name>Anum_dimension_integer_now_func</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>integer_now_func_schema</name></name></expr></argument>,
				   <argument><expr><call><name>DatumGetCString</name><argument_list>(
					   <argument><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_dimension_integer_now_func_schema</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>integer_now_func</name></name></expr></argument>,
				   <argument><expr><call><name>DatumGetCString</name><argument_list>(
					   <argument><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_dimension_integer_now_func</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IS_CLOSED_DIMENSION</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>num_slices</name></name> <operator>=</operator> <call><name>DatumGetInt16</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>Anum_dimension_num_slices</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>interval_length</name></name> <operator>=</operator>
			<call><name>DatumGetInt64</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_dimension_interval_length</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>isnull</name><index>[<expr><name>Anum_dimension_compress_interval_length</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>compress_interval_length</name></name> <operator>=</operator> <call><name>DatumGetInt64</name><argument_list>(
				<argument><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_dimension_compress_interval_length</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>column_attno</name></name> <operator>=</operator> <call><name>get_attnum</name><argument_list>(<argument><expr><name>main_table_relid</name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>column_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>main_table_relid</name></name> <operator>=</operator> <name>main_table_relid</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>should_free</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>create_range_datum</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><name>DimensionSlice</name> <modifier>*</modifier></type><name>slice</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name><name>nulls</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{ <expr><name>false</name></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>get_call_result_type</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupdesc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TYPEFUNC_COMPOSITE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"function returning record called in context that cannot accept type record"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>BlessTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><name><name>slice</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>range_start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><name><name>slice</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>range_end</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DimensionSlice</name> <modifier>*</modifier></type>
<name>calculate_open_range_default</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type><name>dim</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int64</name></type> <name>range_start</name></decl>, <decl><type ref="prev"/><name>range_end</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>dimtype</name> <init>= <expr><call><name>ts_dimension_get_partition_type</name><argument_list>(<argument><expr><name>dim</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>value</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>int64</name></type> <name>dim_min</name> <init>= <expr><call><name>ts_time_get_min</name><argument_list>(<argument><expr><name>dimtype</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>range_end</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>value</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>interval_length</name></name><operator>)</operator> <operator>*</operator> <name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>interval_length</name></name></expr>;</expr_stmt>

		<comment type="block">/* prevent integer underflow */</comment>
		<if_stmt><if>if <condition>(<expr><name>dim_min</name> <operator>-</operator> <name>range_end</name> <operator>&gt;</operator> <operator>-</operator><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>interval_length</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>range_start</name> <operator>=</operator> <name>DIMENSION_SLICE_MINVALUE</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>range_start</name> <operator>=</operator> <name>range_end</name> <operator>-</operator> <name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>interval_length</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>int64</name></type> <name>dim_end</name> <init>= <expr><call><name>ts_time_get_max</name><argument_list>(<argument><expr><name>dimtype</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>range_start</name> <operator>=</operator> <operator>(</operator><name>value</name> <operator>/</operator> <name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>interval_length</name></name><operator>)</operator> <operator>*</operator> <name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>interval_length</name></name></expr>;</expr_stmt>

		<comment type="block">/* prevent integer overflow */</comment>
		<if_stmt><if>if <condition>(<expr><name>dim_end</name> <operator>-</operator> <name>range_start</name> <operator>&lt;</operator> <name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>interval_length</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>range_end</name> <operator>=</operator> <name>DIMENSION_SLICE_MAXVALUE</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>range_end</name> <operator>=</operator> <name>range_start</name> <operator>+</operator> <name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>interval_length</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><call><name>ts_dimension_slice_create</name><argument_list>(<argument><expr><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>, <argument><expr><name>range_start</name></expr></argument>, <argument><expr><name>range_end</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><call><name>TS_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>ts_dimension_calculate_open_range_default</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*
 * Expose open dimension range calculation for testing purposes.
 */</comment>
<function><type><name>Datum</name></type>
<name>ts_dimension_calculate_open_range_default</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int64</name></type> <name>value</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Dimension</name></type> <name>dim</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>DIMENSION_TYPE_OPEN</name></expr>,
		<expr><operator>.</operator><name><name>fd</name><operator>.</operator><name>id</name></name> <operator>=</operator> <literal type="number">0</literal></expr>,
		<expr><operator>.</operator><name><name>fd</name><operator>.</operator><name>interval_length</name></name> <operator>=</operator> <call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name><name>fd</name><operator>.</operator><name>column_type</name></name> <operator>=</operator> <call><name>TypenameGetTypid</name><argument_list>(<argument><expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
	}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DimensionSlice</name> <modifier>*</modifier></type><name>slice</name> <init>= <expr><call><name>calculate_open_range_default</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dim</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><call><name>create_range_datum</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>slice</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int64</name></type>
<name>calculate_closed_range_interval</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type><name>dim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>dim</name> <operator>&amp;&amp;</operator> <call><name>IS_CLOSED_DIMENSION</name><argument_list>(<argument><expr><name>dim</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>DIMENSION_SLICE_CLOSED_MAX</name> <operator>/</operator> <operator>(</operator><operator>(</operator><name>int64</name><operator>)</operator> <name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>num_slices</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DimensionSlice</name> <modifier>*</modifier></type>
<name>calculate_closed_range_default</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type><name>dim</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int64</name></type> <name>range_start</name></decl>, <decl><type ref="prev"/><name>range_end</name></decl>;</decl_stmt>

	<comment type="block">/* The interval that divides the dimension into N equal sized slices */</comment>
	<decl_stmt><decl><type><name>int64</name></type> <name>interval</name> <init>= <expr><call><name>calculate_closed_range_interval</name><argument_list>(<argument><expr><name>dim</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>last_start</name> <init>= <expr><name>interval</name> <operator>*</operator> <operator>(</operator><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>num_slices</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>value</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid value "</literal> <name>INT64_FORMAT</name> <literal type="string">" for closed dimension"</literal></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>value</name> <operator>&gt;=</operator> <name>last_start</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* put overflow from integer-division errors in last range */</comment>
		<expr_stmt><expr><name>range_start</name> <operator>=</operator> <name>last_start</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>range_end</name> <operator>=</operator> <name>DIMENSION_SLICE_MAXVALUE</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>range_start</name> <operator>=</operator> <operator>(</operator><name>value</name> <operator>/</operator> <name>interval</name><operator>)</operator> <operator>*</operator> <name>interval</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>range_end</name> <operator>=</operator> <name>range_start</name> <operator>+</operator> <name>interval</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <name>range_start</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>range_start</name> <operator>=</operator> <name>DIMENSION_SLICE_MINVALUE</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>ts_dimension_slice_create</name><argument_list>(<argument><expr><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>, <argument><expr><name>range_start</name></expr></argument>, <argument><expr><name>range_end</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><call><name>TS_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>ts_dimension_calculate_closed_range_default</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*
 * Exposed closed dimension range calculation for testing purposes.
 */</comment>
<function><type><name>Datum</name></type>
<name>ts_dimension_calculate_closed_range_default</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int64</name></type> <name>value</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Dimension</name></type> <name>dim</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>DIMENSION_TYPE_CLOSED</name></expr>,
		<expr><operator>.</operator><name><name>fd</name><operator>.</operator><name>id</name></name> <operator>=</operator> <literal type="number">0</literal></expr>,
		<expr><operator>.</operator><name><name>fd</name><operator>.</operator><name>num_slices</name></name> <operator>=</operator> <call><name>PG_GETARG_INT16</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>,
	}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DimensionSlice</name> <modifier>*</modifier></type><name>slice</name> <init>= <expr><call><name>calculate_closed_range_default</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dim</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><call><name>create_range_datum</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>slice</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>DimensionSlice</name> <modifier>*</modifier></type>
<name>ts_dimension_calculate_default_slice</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type><name>dim</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IS_OPEN_DIMENSION</name><argument_list>(<argument><expr><name>dim</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>calculate_open_range_default</name><argument_list>(<argument><expr><name>dim</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><call><name>calculate_closed_range_default</name><argument_list>(<argument><expr><name>dim</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get the ordinal value of a slice in an open dimension.
 *
 * Note that, for an open dimension, we can only deal with already created
 * slices and cannot account for, e.g., gaps in the dimension where future
 * slices might be created and thus changing the ordinal value for a slice.
 *
 * For instance, the ordinal value of slice D below is 2 (zero indexed):
 *
 * ' | A | B | &lt;gap&gt; | D | E |
 *
 * but when slice C is later created the ordinal value of D will be 3:
 *
 * ' | A | B | C | D | E |
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>ts_dimension_get_open_slice_ordinal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type><name>dim</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DimensionSlice</name> <modifier>*</modifier></type><name>slice</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DimensionVec</name> <modifier>*</modifier></type><name>vec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>dim</name> <operator>&amp;&amp;</operator> <call><name>IS_OPEN_DIMENSION</name><argument_list>(<argument><expr><name>dim</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>slice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>vec</name> <operator>=</operator> <call><name>ts_dimension_get_slices</name><argument_list>(<argument><expr><name>dim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>vec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Find the index (ordinal) of the chunk's slice in the open dimension */</comment>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>ts_dimension_vec_find_slice_index</name><argument_list>(<argument><expr><name>vec</name></expr></argument>, <argument><expr><name><name>slice</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>i</name></expr>;</return></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Returns the number of slices if the slice not found, i.e., i = -1.
		 * Dimension slice might not exist if a chunk table is created without
		 * modifying metadata. It happens only during copy/move chunk for distributed
		 * hypertable, thus this code, which is used when no space dimension exists,
		 * is unlikely to be used.
		 */</comment>
		<return>return <expr><name><name>vec</name><operator>-&gt;</operator><name>num_slices</name></name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get the ordinal value of a slice in a closed dimension.
 *
 * For closed dimensions, we calculate the ordinal value of a slice based on
 * the assumption that the dimension is fully partitioned in equal size slices
 * as given by the current partitioning configuration. In reality, though,
 * slices are created lazily so a closed dimension might have less slices in
 * time interval than the configuration suggests. Further, during time
 * intervals where repartitioning happens, there might be an unexpected number
 * of slices due to a mix of slices from both the old and the new partitioning
 * configuration. As a result, the ordinal value of a given slice might not
 * actually match the partitioning settings at a given point in time. In this case, we will return
 * the ordinal of current slice most overlapping the given slice (or first fully overlapped slice).
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>ts_dimension_get_closed_slice_ordinal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type><name>dim</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DimensionSlice</name> <modifier>*</modifier></type><name>target_slice</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int64</name></type> <name>current_slice_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>target_slice_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>candidate_slice_ordinal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>target_overlap_with_candidate_slice</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>dim</name> <operator>&amp;&amp;</operator> <call><name>IS_CLOSED_DIMENSION</name><argument_list>(<argument><expr><name>dim</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>target_slice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>num_slices</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Slicing assumes partitioning functions use the range [0, INT32_MAX], though the first slice
	 * uses INT64_MIN as its lower bound, and the last slice uses INT64_MAX as its upper bound. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>target_slice</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>range_start</name></name> <operator>==</operator> <name>DIMENSION_SLICE_MINVALUE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>target_slice</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>range_end</name></name> <operator>==</operator> <name>DIMENSION_SLICE_MAXVALUE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>num_slices</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>target_slice</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>range_start</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>target_slice</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>range_end</name></name> <operator>&lt;</operator> <name>DIMENSION_SLICE_CLOSED_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Given a target slice starting from some point p, determine a candidate slice in the current
	 * partitioning configuration that contains p. If that slice contains over half of our target
	 * slice, return it's ordinal. Otherwise return the ordinal for the next slice. */</comment>
	<expr_stmt><expr><name>current_slice_size</name> <operator>=</operator> <call><name>calculate_closed_range_interval</name><argument_list>(<argument><expr><name>dim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>target_slice_size</name> <operator>=</operator> <name><name>target_slice</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>range_end</name></name> <operator>-</operator> <name><name>target_slice</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>range_start</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>candidate_slice_ordinal</name> <operator>=</operator> <name><name>target_slice</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>range_start</name></name> <operator>/</operator> <name>current_slice_size</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>target_overlap_with_candidate_slice</name> <operator>=</operator>
		<name>current_slice_size</name> <operator>-</operator> <operator>(</operator><name><name>target_slice</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>range_start</name></name> <operator>%</operator> <name>current_slice_size</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/* Note that if the candidate slice wholly contains the target slice,
	 * target_overlap_with_candidate_slice will actually be greater than target_slice_size.  This
	 * doesn't affect the correctness of the following check. */</comment>
	<if_stmt><if>if <condition>(<expr><name>target_overlap_with_candidate_slice</name> <operator>&gt;=</operator> <name>target_slice_size</name> <operator>/</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>candidate_slice_ordinal</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>candidate_slice_ordinal</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get the ordinal value of a slice in a dimension.
 *
 * This function returns the ordinal value of a slice (starting at 0) in the
 * dimension it belongs to. In other words, the "earliest" slice along the
 * dimensional axis gets the lowest ordinal value and the "latest" the largest.
 */</comment>
<function><type><name>int</name></type>
<name>ts_dimension_get_slice_ordinal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type><name>dim</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DimensionSlice</name> <modifier>*</modifier></type><name>slice</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>dim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>slice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name> <operator>==</operator> <name><name>slice</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>dimension_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>dim</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>DIMENSION_TYPE_OPEN</name></expr>:</case>
			<return>return <expr><call><name>ts_dimension_get_open_slice_ordinal</name><argument_list>(<argument><expr><name>dim</name></expr></argument>, <argument><expr><name>slice</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>DIMENSION_TYPE_CLOSED</name></expr>:</case>
			<return>return <expr><call><name>ts_dimension_get_closed_slice_ordinal</name><argument_list>(<argument><expr><name>dim</name></expr></argument>, <argument><expr><name>slice</name></expr></argument>)</argument_list></call></expr>;</return>
		<default>default:</default>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>pg_unreachable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Hyperspace</name> <modifier>*</modifier></type>
<name>hyperspace_create</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>hypertable_id</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>main_table_relid</name></decl></parameter>, <parameter><decl><type><name>uint16</name></type> <name>num_dimensions</name></decl></parameter>,
				  <parameter><decl><type><name>MemoryContext</name></type> <name>mctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Hyperspace</name> <modifier>*</modifier></type><name>hs</name> <init>= <expr><call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>mctx</name></expr></argument>, <argument><expr><call><name>HYPERSPACE_SIZE</name><argument_list>(<argument><expr><name>num_dimensions</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>hs</name><operator>-&gt;</operator><name>hypertable_id</name></name> <operator>=</operator> <name>hypertable_id</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hs</name><operator>-&gt;</operator><name>main_table_relid</name></name> <operator>=</operator> <name>main_table_relid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hs</name><operator>-&gt;</operator><name>capacity</name></name> <operator>=</operator> <name>num_dimensions</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hs</name><operator>-&gt;</operator><name>num_dimensions</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<return>return <expr><name>hs</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ScanTupleResult</name></type>
<name>dimension_tuple_found</name><parameter_list>(<parameter><decl><type><name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Hyperspace</name> <modifier>*</modifier></type><name>hs</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Dimension</name> <modifier>*</modifier></type><name>d</name> <init>= <expr><operator>&amp;</operator><name><name>hs</name><operator>-&gt;</operator><name>dimensions</name><index>[<expr><name><name>hs</name><operator>-&gt;</operator><name>num_dimensions</name></name><operator>++</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>dimension_fill_in_from_tuple</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>ti</name></expr></argument>, <argument><expr><name><name>hs</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>SCAN_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>dimension_scan_internal</name><parameter_list>(<parameter><decl><type><name>ScanKeyData</name> <modifier>*</modifier></type><name>scankey</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nkeys</name></decl></parameter>, <parameter><decl><type><name>tuple_found_func</name></type> <name>tuple_found</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>,
						<parameter><decl><type><name>int</name></type> <name>limit</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dimension_index</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>mctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Catalog</name> <modifier>*</modifier></type><name>catalog</name> <init>= <expr><call><name>ts_catalog_get</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScannerCtx</name></type> <name>scanctx</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>table</name> <operator>=</operator> <call><name>catalog_get_table_id</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>DIMENSION</name></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>index</name> <operator>=</operator> <call><name>catalog_get_index</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>DIMENSION</name></expr></argument>, <argument><expr><name>dimension_index</name></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>nkeys</name> <operator>=</operator> <name>nkeys</name></expr>,
		<expr><operator>.</operator><name>limit</name> <operator>=</operator> <name>limit</name></expr>,
		<expr><operator>.</operator><name>scankey</name> <operator>=</operator> <name>scankey</name></expr>,
		<expr><operator>.</operator><name>data</name> <operator>=</operator> <name>data</name></expr>,
		<expr><operator>.</operator><name>tuple_found</name> <operator>=</operator> <name>tuple_found</name></expr>,
		<expr><operator>.</operator><name>lockmode</name> <operator>=</operator> <name>lockmode</name></expr>,
		<expr><operator>.</operator><name>scandirection</name> <operator>=</operator> <name>ForwardScanDirection</name></expr>,
		<expr><operator>.</operator><name>result_mctx</name> <operator>=</operator> <name>mctx</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>ts_scanner_scan</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scanctx</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Hyperspace</name> <modifier>*</modifier></type>
<name>ts_dimension_scan</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>hypertable_id</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>main_table_relid</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>num_dimensions</name></decl></parameter>,
				  <parameter><decl><type><name>MemoryContext</name></type> <name>mctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Hyperspace</name> <modifier>*</modifier></type><name>space</name> <init>= <expr><call><name>hyperspace_create</name><argument_list>(<argument><expr><name>hypertable_id</name></expr></argument>, <argument><expr><name>main_table_relid</name></expr></argument>, <argument><expr><name>num_dimensions</name></expr></argument>, <argument><expr><name>mctx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scankey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/* Perform an index scan on hypertable_id. */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scankey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_dimension_hypertable_id_column_name_idx_hypertable_id</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
				<argument><expr><name>F_INT4EQ</name></expr></argument>,
				<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>hypertable_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>dimension_scan_internal</name><argument_list>(<argument><expr><name>scankey</name></expr></argument>,
							<argument><expr><literal type="number">1</literal></expr></argument>,
							<argument><expr><name>dimension_tuple_found</name></expr></argument>,
							<argument><expr><name>space</name></expr></argument>,
							<argument><expr><name>num_dimensions</name></expr></argument>,
							<argument><expr><name>DIMENSION_HYPERTABLE_ID_COLUMN_NAME_IDX</name></expr></argument>,
							<argument><expr><name>AccessShareLock</name></expr></argument>,
							<argument><expr><name>mctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Sort dimensions in ascending order to allow binary search lookups */</comment>
	<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name><name>space</name><operator>-&gt;</operator><name>dimensions</name></name></expr></argument>, <argument><expr><name><name>space</name><operator>-&gt;</operator><name>num_dimensions</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Dimension</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>cmp_dimension_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>space</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ScanTupleResult</name></type>
<name>dimension_find_hypertable_id_tuple_found</name><parameter_list>(<parameter><decl><type><name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name> <modifier>*</modifier></type><name>hypertable_id</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>isnull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>datum</name> <init>= <expr><call><name>slot_getattr</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>slot</name></name></expr></argument>, <argument><expr><name>Anum_dimension_hypertable_id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>hypertable_id</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>SCAN_DONE</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32</name></type>
<name>ts_dimension_get_hypertable_id</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>dimension_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type> <name>hypertable_id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scankey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

	<comment type="block">/* Perform an index scan dimension_id. */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scankey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_dimension_id_idx_id</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
				<argument><expr><name>F_INT4EQ</name></expr></argument>,
				<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>dimension_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>dimension_scan_internal</name><argument_list>(<argument><expr><name>scankey</name></expr></argument>,
								  <argument><expr><literal type="number">1</literal></expr></argument>,
								  <argument><expr><name>dimension_find_hypertable_id_tuple_found</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>hypertable_id</name></expr></argument>,
								  <argument><expr><literal type="number">1</literal></expr></argument>,
								  <argument><expr><name>DIMENSION_ID_IDX</name></expr></argument>,
								  <argument><expr><name>AccessShareLock</name></expr></argument>,
								  <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>hypertable_id</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>DimensionVec</name> <modifier>*</modifier></type>
<name>ts_dimension_get_slices</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type><name>dim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>ts_dimension_slice_scan_by_dimension</name><argument_list>(<argument><expr><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>dimension_scan_update</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>dimension_id</name></decl></parameter>, <parameter><decl><type><name>tuple_found_func</name></type> <name>tuple_found</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>,
					  <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Catalog</name> <modifier>*</modifier></type><name>catalog</name> <init>= <expr><call><name>ts_catalog_get</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scankey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScannerCtx</name></type> <name>scanctx</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>table</name> <operator>=</operator> <call><name>catalog_get_table_id</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>DIMENSION</name></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>index</name> <operator>=</operator> <call><name>catalog_get_index</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>DIMENSION</name></expr></argument>, <argument><expr><name>DIMENSION_ID_IDX</name></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>nkeys</name> <operator>=</operator> <literal type="number">1</literal></expr>,
		<expr><operator>.</operator><name>limit</name> <operator>=</operator> <literal type="number">1</literal></expr>,
		<expr><operator>.</operator><name>scankey</name> <operator>=</operator> <name>scankey</name></expr>,
		<expr><operator>.</operator><name>data</name> <operator>=</operator> <name>data</name></expr>,
		<expr><operator>.</operator><name>tuple_found</name> <operator>=</operator> <name>tuple_found</name></expr>,
		<expr><operator>.</operator><name>lockmode</name> <operator>=</operator> <name>lockmode</name></expr>,
		<expr><operator>.</operator><name>scandirection</name> <operator>=</operator> <name>ForwardScanDirection</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scankey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_dimension_id_idx_id</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
				<argument><expr><name>F_INT4EQ</name></expr></argument>,
				<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>dimension_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>ts_scanner_scan</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scanctx</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ScanTupleResult</name></type>
<name>dimension_tuple_delete</name><parameter_list>(<parameter><decl><type><name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CatalogSecurityContext</name></type> <name>sec_ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>dimension_id</name> <init>= <expr><call><name>slot_getattr</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>slot</name></name></expr></argument>, <argument><expr><name>Anum_dimension_id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>delete_slices</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* delete dimension slices */</comment>
	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>delete_slices</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>delete_slices</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ts_dimension_slice_delete_by_dimension_id</name><argument_list>(<argument><expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>dimension_id</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* delete all dimension partitions */</comment>
	<expr_stmt><expr><call><name>ts_dimension_partition_info_delete</name><argument_list>(<argument><expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>dimension_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_catalog_database_info_become_owner</name><argument_list>(<argument><expr><call><name>ts_catalog_database_info_get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_catalog_delete_tid</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>scanrel</name></name></expr></argument>, <argument><expr><call><name>ts_scanner_get_tuple_tid</name><argument_list>(<argument><expr><name>ti</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_catalog_restore_user</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>SCAN_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>ts_dimension_delete_by_hypertable_id</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>hypertable_id</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>delete_slices</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scankey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/* Perform an index scan to delete based on hypertable_id */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scankey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_dimension_hypertable_id_column_name_idx_hypertable_id</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
				<argument><expr><name>F_INT4EQ</name></expr></argument>,
				<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>hypertable_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>dimension_scan_internal</name><argument_list>(<argument><expr><name>scankey</name></expr></argument>,
								   <argument><expr><literal type="number">1</literal></expr></argument>,
								   <argument><expr><name>dimension_tuple_delete</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>delete_slices</name></expr></argument>,
								   <argument><expr><literal type="number">0</literal></expr></argument>,
								   <argument><expr><name>DIMENSION_HYPERTABLE_ID_COLUMN_NAME_IDX</name></expr></argument>,
								   <argument><expr><name>RowExclusiveLock</name></expr></argument>,
								   <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ScanTupleResult</name></type>
<name>dimension_tuple_update</name><parameter_list>(<parameter><decl><type><name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Dimension</name> <modifier>*</modifier></type><name>dim</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name><name>values</name><index>[<expr><name>Natts_dimension</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name><name>nulls</name><index>[<expr><name>Natts_dimension</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CatalogSecurityContext</name></type> <name>sec_ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>should_free</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name> <init>= <expr><call><name>ts_scanner_fetch_heap_tuple</name><argument_list>(<argument><expr><name>ti</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>should_free</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>new_tuple</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><call><name>ts_scanner_get_tupledesc</name><argument_list>(<argument><expr><name>ti</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>num_slices</name></name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>interval_length</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
		   <operator>(</operator><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>num_slices</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>interval_length</name></name> <operator>&lt;=</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_dimension_column_name</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
		<call><name>NameGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>column_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_dimension_column_type</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
		<call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>column_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_dimension_num_slices</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <call><name>Int16GetDatum</name><argument_list>(<argument><expr><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>num_slices</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>nulls</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_dimension_partitioning_func</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>&amp;&amp;</operator>
		<operator>!</operator><name><name>nulls</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_dimension_partitioning_func_schema</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_dimension_partitioning_func</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
			<call><name>NameGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>partitioning_func</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_dimension_partitioning_func_schema</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
			<call><name>NameGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>partitioning_func_schema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><call><name>NameStr</name><argument_list>(<argument><expr><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>integer_now_func</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator>
		<operator>*</operator><call><name>NameStr</name><argument_list>(<argument><expr><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>integer_now_func_schema</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_dimension_integer_now_func</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
			<call><name>NameGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>integer_now_func</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_dimension_integer_now_func_schema</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
			<call><name>NameGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>integer_now_func_schema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_dimension_integer_now_func</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_dimension_integer_now_func_schema</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>nulls</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_dimension_interval_length</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_dimension_interval_length</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
			<call><name>Int64GetDatum</name><argument_list>(<argument><expr><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>interval_length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>compress_interval_length</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_dimension_compress_interval_length</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
			<call><name>Int64GetDatum</name><argument_list>(<argument><expr><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>compress_interval_length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_dimension_compress_interval_length</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_dimension_compress_interval_length</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>new_tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><call><name>ts_scanner_get_tupledesc</name><argument_list>(<argument><expr><name>ti</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_catalog_database_info_become_owner</name><argument_list>(<argument><expr><call><name>ts_catalog_database_info_get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_catalog_update_tid</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>scanrel</name></name></expr></argument>, <argument><expr><call><name>ts_scanner_get_tuple_tid</name><argument_list>(<argument><expr><name>ti</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>new_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_catalog_restore_user</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>new_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>should_free</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>SCAN_DONE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32</name></type>
<name>dimension_insert_relation</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>hypertable_id</name></decl></parameter>, <parameter><decl><type><name>Name</name></type> <name>colname</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>coltype</name></decl></parameter>,
						  <parameter><decl><type><name>int16</name></type> <name>num_slices</name></decl></parameter>, <parameter><decl><type><name>regproc</name></type> <name>partitioning_func</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>interval_length</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>desc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name><name>values</name><index>[<expr><name>Natts_dimension</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name><name>nulls</name><index>[<expr><name>Natts_dimension</name></expr>]</index></name> <init>= <expr><block>{ <expr><name>false</name></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CatalogSecurityContext</name></type> <name>sec_ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>dimension_id</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_dimension_hypertable_id</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>hypertable_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_dimension_column_name</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <call><name>NameGetDatum</name><argument_list>(<argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_dimension_column_type</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>coltype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>partitioning_func</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>pronamespace</name> <init>= <expr><call><name>get_func_namespace</name><argument_list>(<argument><expr><name>partitioning_func</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_dimension_partitioning_func</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
			<call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>namein</name></expr></argument>, <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><call><name>get_func_name</name><argument_list>(<argument><expr><name>partitioning_func</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_dimension_partitioning_func_schema</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
			<call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>namein</name></expr></argument>, <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>pronamespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_dimension_partitioning_func</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_dimension_partitioning_func_schema</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>num_slices</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Closed (hash) dimension */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>num_slices</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>interval_length</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_dimension_num_slices</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>num_slices</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_dimension_aligned</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_dimension_interval_length</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Open (time) dimension */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>num_slices</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>interval_length</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_dimension_interval_length</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
			<call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>interval_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_dimension_aligned</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_dimension_num_slices</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* no integer_now function by default */</comment>
	<expr_stmt><expr><name><name>nulls</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_dimension_integer_now_func_schema</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nulls</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_dimension_integer_now_func</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/* no compress interval length by default */</comment>
	<expr_stmt><expr><name><name>nulls</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_dimension_compress_interval_length</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ts_catalog_database_info_become_owner</name><argument_list>(<argument><expr><call><name>ts_catalog_database_info_get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dimension_id</name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><call><name>ts_catalog_table_next_seq_id</name><argument_list>(<argument><expr><call><name>ts_catalog_get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>DIMENSION</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_dimension_id</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>dimension_id</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_catalog_insert_values</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_catalog_restore_user</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>dimension_id</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32</name></type>
<name>dimension_insert</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>hypertable_id</name></decl></parameter>, <parameter><decl><type><name>Name</name></type> <name>colname</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>coltype</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>num_slices</name></decl></parameter>,
				 <parameter><decl><type><name>regproc</name></type> <name>partitioning_func</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>interval_length</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Catalog</name> <modifier>*</modifier></type><name>catalog</name> <init>= <expr><call><name>ts_catalog_get</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>dimension_id</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><call><name>catalog_get_table_id</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>DIMENSION</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dimension_id</name> <operator>=</operator> <call><name>dimension_insert_relation</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,
											 <argument><expr><name>hypertable_id</name></expr></argument>,
											 <argument><expr><name>colname</name></expr></argument>,
											 <argument><expr><name>coltype</name></expr></argument>,
											 <argument><expr><name>num_slices</name></expr></argument>,
											 <argument><expr><name>partitioning_func</name></expr></argument>,
											 <argument><expr><name>interval_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>dimension_id</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>ts_dimension_set_type</name><parameter_list>(<parameter><decl><type><name>Dimension</name> <modifier>*</modifier></type><name>dim</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>newtype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_VALID_OPEN_DIM_TYPE</name><argument_list>(<argument><expr><name>newtype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot change data type of hypertable column \"%s\" from %s to %s"</literal></expr></argument>,
						<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>column_name</name></name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>column_type</name></name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>newtype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use an integer, timestamp, or date type."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>column_type</name></name> <operator>=</operator> <name>newtype</name></expr>;</expr_stmt>

	<return>return <expr><call><name>dimension_scan_update</name><argument_list>(<argument><expr><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>, <argument><expr><name>dimension_tuple_update</name></expr></argument>, <argument><expr><name>dim</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>TSDLLEXPORT</name> <name>Oid</name></type>
<name>ts_dimension_get_partition_type</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type><name>dim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>dim</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><ternary><condition><expr><name><name>dim</name><operator>-&gt;</operator><name>partitioning</name></name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><name><name>dim</name><operator>-&gt;</operator><name>partitioning</name><operator>-&gt;</operator><name>partfunc</name><operator>.</operator><name>rettype</name></name></expr> </then><else>: <expr><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>column_type</name></name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>ts_dimension_set_name</name><parameter_list>(<parameter><decl><type><name>Dimension</name> <modifier>*</modifier></type><name>dim</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>column_name</name></name></expr></argument>, <argument><expr><name>newname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>dimension_scan_update</name><argument_list>(<argument><expr><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>, <argument><expr><name>dimension_tuple_update</name></expr></argument>, <argument><expr><name>dim</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>ts_dimension_set_chunk_interval</name><parameter_list>(<parameter><decl><type><name>Dimension</name> <modifier>*</modifier></type><name>dim</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>chunk_interval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IS_OPEN_DIMENSION</name><argument_list>(<argument><expr><name>dim</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>interval_length</name></name> <operator>=</operator> <name>chunk_interval</name></expr>;</expr_stmt>

	<return>return <expr><call><name>dimension_scan_update</name><argument_list>(<argument><expr><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>, <argument><expr><name>dimension_tuple_update</name></expr></argument>, <argument><expr><name>dim</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>ts_dimension_set_compress_interval</name><parameter_list>(<parameter><decl><type><name>Dimension</name> <modifier>*</modifier></type><name>dim</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>compress_interval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_OPEN_DIMENSION</name><argument_list>(<argument><expr><name>dim</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"trying to set compress interval on closed dimension"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"dimension ID %d"</literal></expr></argument>, <argument><expr><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>compress_interval_length</name></name> <operator>=</operator> <name>compress_interval</name></expr>;</expr_stmt>

	<return>return <expr><call><name>dimension_scan_update</name><argument_list>(<argument><expr><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>, <argument><expr><name>dimension_tuple_update</name></expr></argument>, <argument><expr><name>dim</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>ts_dimension_set_number_of_slices</name><parameter_list>(<parameter><decl><type><name>Dimension</name> <modifier>*</modifier></type><name>dim</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>num_slices</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IS_CLOSED_DIMENSION</name><argument_list>(<argument><expr><name>dim</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>num_slices</name></name> <operator>=</operator> <name>num_slices</name></expr>;</expr_stmt>

	<return>return <expr><call><name>dimension_scan_update</name><argument_list>(<argument><expr><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>, <argument><expr><name>dimension_tuple_update</name></expr></argument>, <argument><expr><name>dim</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Apply any dimension-specific transformations on a value, i.e., apply
 * partitioning function. Optionally get the type of the resulting value via
 * the restype parameter.
 */</comment>
<function><type><name>Datum</name></type>
<name>ts_dimension_transform_value</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type><name>dim</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>const_datum_type</name></decl></parameter>,
							 <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>restype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>dim</name><operator>-&gt;</operator><name>partitioning</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>ts_partitioning_func_apply</name><argument_list>(<argument><expr><name><name>dim</name><operator>-&gt;</operator><name>partitioning</name></name></expr></argument>, <argument><expr><name>collation</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>restype</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>dim</name><operator>-&gt;</operator><name>partitioning</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>restype</name> <operator>=</operator> <name><name>dim</name><operator>-&gt;</operator><name>partitioning</name><operator>-&gt;</operator><name>partfunc</name><operator>.</operator><name>rettype</name></name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>const_datum_type</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>restype</name> <operator>=</operator> <name>const_datum_type</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>restype</name> <operator>=</operator> <name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>column_type</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Point</name> <modifier>*</modifier></type>
<name>ts_point_create</name><parameter_list>(<parameter><decl><type><name>int16</name></type> <name>num_dimensions</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Point</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><call><name>POINT_SIZE</name><argument_list>(<argument><expr><name>num_dimensions</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>cardinality</name></name> <operator>=</operator> <name>num_dimensions</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>num_coords</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>TSDLLEXPORT</name> <name>Point</name> <modifier>*</modifier></type>
<name>ts_hyperspace_calculate_point</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Hyperspace</name> <modifier>*</modifier></type><name>hs</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Point</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>ts_point_create</name><argument_list>(<argument><expr><name><name>hs</name><operator>-&gt;</operator><name>num_dimensions</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>hs</name><operator>-&gt;</operator><name>num_dimensions</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type><name>d</name> <init>= <expr><operator>&amp;</operator><name><name>hs</name><operator>-&gt;</operator><name>dimensions</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type> <name>datum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>isnull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>dimtype</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>d</name><operator>-&gt;</operator><name>partitioning</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>ts_partitioning_func_apply_slot</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>partitioning</name></name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name><name>d</name><operator>-&gt;</operator><name>column_attno</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<switch>switch <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>DIMENSION_TYPE_OPEN</name></expr>:</case>
				<expr_stmt><expr><name>dimtype</name> <operator>=</operator> <call><name>ts_dimension_get_partition_type</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NOT_NULL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"NULL value in column \"%s\" violates not-null constraint"</literal></expr></argument>,
									<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>column_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Columns used for time partitioning cannot be NULL."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>coordinates</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>num_coords</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>ts_time_value_to_internal</name><argument_list>(<argument><expr><name>datum</name></expr></argument>, <argument><expr><name>dimtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DIMENSION_TYPE_CLOSED</name></expr>:</case>
				<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>coordinates</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>num_coords</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DIMENSION_TYPE_ANY</name></expr>:</case>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid dimension type when inserting tuple"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></for>

	<return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int64</name></type>
<name>interval_to_usec</name><parameter_list>(<parameter><decl><type><name>Interval</name> <modifier>*</modifier></type><name>interval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name><name>interval</name><operator>-&gt;</operator><name>month</name></name> <operator>*</operator> <name>DAYS_PER_MONTH</name> <operator>*</operator> <name>USECS_PER_DAY</name><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>interval</name><operator>-&gt;</operator><name>day</name></name> <operator>*</operator> <name>USECS_PER_DAY</name><operator>)</operator> <operator>+</operator>
		   <name><name>interval</name><operator>-&gt;</operator><name>time</name></name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INT_TYPE_MAX</name><parameter_list>(<parameter><type><name>type</name></type></parameter>)</parameter_list></cpp:macro>                                                                         \
	<cpp:value>(int64)(((type) == INT2OID) ? PG_INT16_MAX :                                                   \
								  (((type) == INT4OID) ? PG_INT32_MAX : PG_INT64_MAX))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_VALID_NUM_SLICES</name><parameter_list>(<parameter><type><name>num_slices</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((num_slices) &gt;= 1 &amp;&amp; (num_slices) &lt;= PG_INT16_MAX)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>int64</name></type>
<name>get_validated_integer_interval</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>dimtype</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>value</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">1</literal> <operator>||</operator> <name>value</name></expr></argument> &gt;</argument_list></name> <call><name>INT_TYPE_MAX</name><argument_list>(<argument><expr><name>dimtype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid interval: must be between 1 and "</literal> <name>INT64_FORMAT</name></expr></argument>,
						<argument><expr><call><name>INT_TYPE_MAX</name><argument_list>(<argument><expr><name>dimtype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IS_TIMESTAMP_TYPE</name><argument_list>(<argument><expr><name>dimtype</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>value</name> <operator>&lt;</operator> <name>USECS_PER_SEC</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_AMBIGUOUS_PARAMETER</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected interval: smaller than one second"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"The interval is specified in microseconds."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int64</name></type>
<name>dimension_interval_to_internal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colname</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>dimtype</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>valuetype</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>,
							   <parameter><decl><type><name>bool</name></type> <name>adaptive_chunking</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int64</name></type> <name>interval</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_VALID_OPEN_DIM_TYPE</name><argument_list>(<argument><expr><name>dimtype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid type for dimension \"%s\""</literal></expr></argument>, <argument><expr><name>colname</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use an integer, timestamp, or date type."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>valuetype</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IS_INTEGER_TYPE</name><argument_list>(<argument><expr><name>dimtype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"integer dimensions require an explicit interval"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><ternary><condition><expr><name>adaptive_chunking</name></expr> ?</condition><then> <expr><name>DEFAULT_CHUNK_TIME_INTERVAL_ADAPTIVE</name></expr> </then><else>:
												  <expr><name>DEFAULT_CHUNK_TIME_INTERVAL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>valuetype</name> <operator>=</operator> <name>INT8OID</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<switch>switch <condition>(<expr><name>valuetype</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>INT2OID</name></expr>:</case>
			<expr_stmt><expr><name>interval</name> <operator>=</operator> <call><name>get_validated_integer_interval</name><argument_list>(<argument><expr><name>dimtype</name></expr></argument>, <argument><expr><call><name>DatumGetInt16</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>INT4OID</name></expr>:</case>
			<expr_stmt><expr><name>interval</name> <operator>=</operator> <call><name>get_validated_integer_interval</name><argument_list>(<argument><expr><name>dimtype</name></expr></argument>, <argument><expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>INT8OID</name></expr>:</case>
			<expr_stmt><expr><name>interval</name> <operator>=</operator> <call><name>get_validated_integer_interval</name><argument_list>(<argument><expr><name>dimtype</name></expr></argument>, <argument><expr><call><name>DatumGetInt64</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>INTERVALOID</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_TIMESTAMP_TYPE</name><argument_list>(<argument><expr><name>dimtype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid interval type for %s dimension"</literal></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>dimtype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use an interval of type integer."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>interval</name> <operator>=</operator> <call><name>interval_to_usec</name><argument_list>(<argument><expr><call><name>DatumGetIntervalP</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid interval type for %s dimension"</literal></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>dimtype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <ternary><condition><expr><call><name>IS_TIMESTAMP_TYPE</name><argument_list>(<argument><expr><name>dimtype</name></expr></argument>)</argument_list></call></expr> ?</condition><then>
						 <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use an interval of type integer or interval."</literal></expr></argument>)</argument_list></call></expr> </then><else>:
						 <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use an interval of type integer."</literal></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><name>dimtype</name> <operator>==</operator> <name>DATEOID</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>interval</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>interval</name> <operator>%</operator> <name>USECS_PER_DAY</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid interval for %s dimension"</literal></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>dimtype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use an interval that is a multiple of one day."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>interval</name></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><call><name>TS_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>ts_dimension_interval_to_internal_test</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*
 * Exposed for testing purposes.
 */</comment>
<function><type><name>Datum</name></type>
<name>ts_dimension_interval_to_internal_test</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>dimtype</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>value</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>valuetype</name> <init>= <expr><ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>InvalidOid</name></expr> </then><else>: <expr><call><name>get_fn_expr_argtype</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><call><name>dimension_interval_to_internal</name><argument_list>(<argument><expr><literal type="string">"testcol"</literal></expr></argument>, <argument><expr><name>dimtype</name></expr></argument>, <argument><expr><name>valuetype</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dimension_add_not_null_on_column</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>table_relid</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>colname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlterTableCmd</name></type> <name>cmd</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>T_AlterTableCmd</name></expr>,
		<expr><operator>.</operator><name>subtype</name> <operator>=</operator> <name>AT_SetNotNull</name></expr>,
		<expr><operator>.</operator><name>name</name> <operator>=</operator> <name>colname</name></expr>,
		<expr><operator>.</operator><name>missing_ok</name> <operator>=</operator> <name>false</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"adding not-null constraint to column \"%s\""</literal></expr></argument>, <argument><expr><name>colname</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Time dimensions cannot have NULL values."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ts_alter_table_with_event_trigger</name><argument_list>(<argument><expr><name>table_relid</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>cmd</name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ts_dimension_update</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NameData</name> <modifier>*</modifier></type><name>dimname</name></decl></parameter>, <parameter><decl><type><name>DimensionType</name></type> <name>dimtype</name></decl></parameter>,
					<parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>interval</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>intervaltype</name></decl></parameter>, <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>num_slices</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>integer_now_func</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Dimension</name> <modifier>*</modifier></type><name>dim</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>ht</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TS_HYPERTABLE_NOT_EXIST</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid hypertable"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>dimtype</name> <operator>==</operator> <name>DIMENSION_TYPE_ANY</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid dimension type"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>dimname</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>hyperspace_get_num_dimensions_by_type</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>space</name></name></expr></argument>, <argument><expr><name>dimtype</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"hypertable \"%s\" has multiple %s dimensions"</literal></expr></argument>,
							<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><ternary><condition><expr><name>dimtype</name> <operator>==</operator> <name>DIMENSION_TYPE_OPEN</name></expr> ?</condition><then> <expr><literal type="string">"time"</literal></expr> </then><else>: <expr><literal type="string">"space"</literal></expr></else></ternary></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"An explicit dimension name must be specified."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>dim</name> <operator>=</operator> <call><name>ts_hyperspace_get_mutable_dimension</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>space</name></name></expr></argument>, <argument><expr><name>dimtype</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>dim</name> <operator>=</operator> <call><name>ts_hyperspace_get_mutable_dimension_by_name</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>space</name></name></expr></argument>, <argument><expr><name>dimtype</name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>dimname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>dim</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TS_DIMENSION_NOT_EXIST</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"hypertable \"%s\" does not have a matching dimension"</literal></expr></argument>,
						<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>dim</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>dimtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>interval</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>dimtype</name> <init>= <expr><call><name>ts_dimension_get_partition_type</name><argument_list>(<argument><expr><name>dim</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>intervaltype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IS_OPEN_DIMENSION</name><argument_list>(<argument><expr><name>dim</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>interval_length</name></name> <operator>=</operator>
			<call><name>dimension_interval_to_internal</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>column_name</name></name></expr></argument>)</argument_list></call></expr></argument>,
										   <argument><expr><name>dimtype</name></expr></argument>,
										   <argument><expr><operator>*</operator><name>intervaltype</name></expr></argument>,
										   <argument><expr><operator>*</operator><name>interval</name></expr></argument>,
										   <argument><expr><call><name>hypertable_adaptive_chunking_enabled</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>num_slices</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IS_CLOSED_DIMENSION</name><argument_list>(<argument><expr><name>dim</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>num_slices</name></name> <operator>=</operator> <operator>*</operator><name>num_slices</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ts_hypertable_update_dimension_partitions</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>integer_now_func</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>pronamespace</name> <init>= <expr><call><name>get_func_namespace</name><argument_list>(<argument><expr><operator>*</operator><name>integer_now_func</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>integer_now_func_schema</name></name></expr></argument>, <argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>pronamespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>integer_now_func</name></name></expr></argument>, <argument><expr><call><name>get_func_name</name><argument_list>(<argument><expr><operator>*</operator><name>integer_now_func</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>dimension_scan_update</name><argument_list>(<argument><expr><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>, <argument><expr><name>dimension_tuple_update</name></expr></argument>, <argument><expr><name>dim</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_hypertable_check_partitioning</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>TS_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>ts_dimension_set_num_slices</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type>
<name>ts_dimension_set_num_slices</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>table_relid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>num_slices_arg</name> <init>= <expr><ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Name</name></type> <name>colname</name> <init>= <expr><ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><call><name>PG_GETARG_NAME</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cache</name> <modifier>*</modifier></type><name>hcache</name> <init>= <expr><call><name>ts_hypertable_cache_pin</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type> <name>num_slices</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>TS_PREVENT_FUNC_IF_READ_ONLY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"hypertable cannot be NULL"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Verify that we're dealing with a hypertable or fail */</comment>
	<expr_stmt><expr><name>ht</name> <operator>=</operator> <call><name>ts_hypertable_cache_get_entry</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>, <argument><expr><name>table_relid</name></expr></argument>, <argument><expr><name>CACHE_FLAG_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_hypertable_permissions_check</name><argument_list>(<argument><expr><name>table_relid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>IS_VALID_NUM_SLICES</name><argument_list>(<argument><expr><name>num_slices_arg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid number of partitions: must be between 1 and %d"</literal></expr></argument>, <argument><expr><name>PG_INT16_MAX</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Our catalog stores num_slices as a smallint (int16). However, function
	 * argument is an integer (int32) so that the user need not cast it to a
	 * smallint. We therefore convert to int16 here after checking that
	 * num_slices cannot be &gt; INT16_MAX.
	 */</comment>
	<expr_stmt><expr><name>num_slices</name> <operator>=</operator> <name>num_slices_arg</name> <operator>&amp;</operator> <literal type="number">0xffff</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_dimension_update</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>colname</name></expr></argument>, <argument><expr><name>DIMENSION_TYPE_CLOSED</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num_slices</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_hypertable_func_call_on_data_nodes</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>TS_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>ts_dimension_set_interval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*
 * Update chunk_time_interval for a hypertable.
 *
 * hypertable - The OID of the table corresponding to a hypertable whose time
 *     interval should be updated
 * chunk_time_interval - The new time interval. For hypertables with integral
 *     time columns, this must be an integral type. For hypertables with a
 *     TIMESTAMP/TIMESTAMPTZ/DATE type, it can be integral which is treated as
 *     microseconds, or an INTERVAL type.
 * dimension_name - The name of the dimension
 */</comment>
<function><type><name>Datum</name></type>
<name>ts_dimension_set_interval</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>table_relid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>interval</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>intervaltype</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Name</name></type> <name>colname</name> <init>= <expr><ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><call><name>PG_GETARG_NAME</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cache</name> <modifier>*</modifier></type><name>hcache</name> <init>= <expr><call><name>ts_hypertable_cache_pin</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>TS_PREVENT_FUNC_IF_READ_ONLY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"hypertable cannot be NULL"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>ht</name> <operator>=</operator> <call><name>ts_hypertable_cache_get_entry</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>, <argument><expr><name>table_relid</name></expr></argument>, <argument><expr><name>CACHE_FLAG_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_hypertable_permissions_check</name><argument_list>(<argument><expr><name>table_relid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid interval: an explicit interval must be specified"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>intervaltype</name> <operator>=</operator> <call><name>get_fn_expr_argtype</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_dimension_update</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>colname</name></expr></argument>, <argument><expr><name>DIMENSION_TYPE_OPEN</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>interval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>intervaltype</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_hypertable_func_call_on_data_nodes</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>DimensionInfo</name> <modifier>*</modifier></type>
<name>ts_dimension_info_create_open</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>table_relid</name></decl></parameter>, <parameter><decl><type><name>Name</name></type> <name>column_name</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>interval</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>interval_type</name></decl></parameter>,
							  <parameter><decl><type><name>regproc</name></type> <name>partitioning_func</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DimensionInfo</name> <modifier>*</modifier></type><name>info</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>info</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><operator>*</operator><name>info</name> <operator>=</operator> <operator>(</operator><name>DimensionInfo</name><operator>)</operator><block>{
		<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>DIMENSION_TYPE_OPEN</name></expr>,
		<expr><operator>.</operator><name>table_relid</name> <operator>=</operator> <name>table_relid</name></expr>,
		<expr><operator>.</operator><name>colname</name> <operator>=</operator> <name>column_name</name></expr>,
		<expr><operator>.</operator><name>interval_datum</name> <operator>=</operator> <name>interval</name></expr>,
		<expr><operator>.</operator><name>interval_type</name> <operator>=</operator> <name>interval_type</name></expr>,
		<expr><operator>.</operator><name>partitioning_func</name> <operator>=</operator> <name>partitioning_func</name></expr>,
	}</block></expr>;</expr_stmt>
	<return>return <expr><name>info</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>DimensionInfo</name> <modifier>*</modifier></type>
<name>ts_dimension_info_create_closed</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>table_relid</name></decl></parameter>, <parameter><decl><type><name>Name</name></type> <name>column_name</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>num_slices</name></decl></parameter>,
								<parameter><decl><type><name>regproc</name></type> <name>partitioning_func</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DimensionInfo</name> <modifier>*</modifier></type><name>info</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>info</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><operator>*</operator><name>info</name> <operator>=</operator> <operator>(</operator><name>DimensionInfo</name><operator>)</operator><block>{
		<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>DIMENSION_TYPE_CLOSED</name></expr>,
		<expr><operator>.</operator><name>table_relid</name> <operator>=</operator> <name>table_relid</name></expr>,
		<expr><operator>.</operator><name>colname</name> <operator>=</operator> <name>column_name</name></expr>,
		<expr><operator>.</operator><name>num_slices</name> <operator>=</operator> <name>num_slices</name></expr>,
		<expr><operator>.</operator><name>num_slices_is_set</name> <operator>=</operator> <name>true</name></expr>,
		<expr><operator>.</operator><name>partitioning_func</name> <operator>=</operator> <name>partitioning_func</name></expr>,
	}</block></expr>;</expr_stmt>
	<return>return <expr><name>info</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Validate the configuration of an open ("time") dimension */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dimension_info_validate_open</name><parameter_list>(<parameter><decl><type><name>DimensionInfo</name> <modifier>*</modifier></type><name>info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>dimtype</name> <init>= <expr><name><name>info</name><operator>-&gt;</operator><name>coltype</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>DIMENSION_TYPE_OPEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>partitioning_func</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ts_partitioning_func_is_valid</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>partitioning_func</name></name></expr></argument>, <argument><expr><name><name>info</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name><name>info</name><operator>-&gt;</operator><name>coltype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid partitioning function"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"A valid partitioning function for open (time) dimensions must be "</literal>
							 <literal type="string">"IMMUTABLE, "</literal>
							 <literal type="string">"take the column type as input, and return an integer or "</literal>
							 <literal type="string">"timestamp type."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>dimtype</name> <operator>=</operator> <call><name>get_func_rettype</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>partitioning_func</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>interval</name></name> <operator>=</operator> <call><name>dimension_interval_to_internal</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name><name>info</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call></expr></argument>,
													<argument><expr><name>dimtype</name></expr></argument>,
													<argument><expr><name><name>info</name><operator>-&gt;</operator><name>interval_type</name></name></expr></argument>,
													<argument><expr><name><name>info</name><operator>-&gt;</operator><name>interval_datum</name></name></expr></argument>,
													<argument><expr><name><name>info</name><operator>-&gt;</operator><name>adaptive_chunking</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Validate the configuration of a closed ("space") dimension */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dimension_info_validate_closed</name><parameter_list>(<parameter><decl><type><name>DimensionInfo</name> <modifier>*</modifier></type><name>info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>DIMENSION_TYPE_CLOSED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>partitioning_func</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>partitioning_func</name></name> <operator>=</operator> <call><name>ts_partitioning_func_get_closed_default</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>ts_partitioning_func_is_valid</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>partitioning_func</name></name></expr></argument>, <argument><expr><name><name>info</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name><name>info</name><operator>-&gt;</operator><name>coltype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid partitioning function"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"A valid partitioning function for closed (space) dimensions must be "</literal>
						 <literal type="string">"IMMUTABLE "</literal>
						 <literal type="string">"and have the signature (anyelement) -&gt; integer."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>info</name><operator>-&gt;</operator><name>num_slices_is_set</name></name> <operator>||</operator> <operator>!</operator><call><name>IS_VALID_NUM_SLICES</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>num_slices</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid number of partitions for dimension \"%s\""</literal></expr></argument>,
						<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name><name>info</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"A closed (space) dimension must specify between 1 and %d partitions."</literal></expr></argument>,
						 <argument><expr><name>PG_INT16_MAX</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ts_dimension_info_validate</name><parameter_list>(<parameter><decl><type><name>DimensionInfo</name> <modifier>*</modifier></type><name>info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type><name>dim</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>datum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>isnull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>isgenerated</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DIMENSION_INFO_IS_SET</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid dimension info"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>num_slices_is_set</name></name> <operator>&amp;&amp;</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>interval_type</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot specify both the number of partitions and an interval"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Check that the column exists and get its NOT NULL status */</comment>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheAttName</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>table_relid</name></name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name><name>info</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" does not exist"</literal></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name><name>info</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>ATTNAME</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pg_attribute_atttypid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>coltype</name></name> <operator>=</operator> <call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>ATTNAME</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pg_attribute_attnotnull</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>set_not_null</name></name> <operator>=</operator> <operator>!</operator><call><name>DatumGetBool</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* check that the column is not generated */</comment>
	<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>ATTNAME</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pg_attribute_attgenerated</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>isgenerated</name> <operator>=</operator> <operator>(</operator><call><name>DatumGetChar</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>ATTRIBUTE_GENERATED_STORED</name><operator>)</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>isgenerated</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid partitioning column"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Generated columns cannot be used as partitioning dimensions."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>info</name><operator>-&gt;</operator><name>ht</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Check if the dimension already exists */</comment>
		<expr_stmt><expr><name>dim</name> <operator>=</operator> <call><name>ts_hyperspace_get_dimension_by_name</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>ht</name><operator>-&gt;</operator><name>space</name></name></expr></argument>,
												  <argument><expr><name>DIMENSION_TYPE_ANY</name></expr></argument>,
												  <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name><name>info</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>dim</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>info</name><operator>-&gt;</operator><name>if_not_exists</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TS_DUPLICATE_DIMENSION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" is already a dimension"</literal></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name><name>info</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>dimension_id</name></name> <operator>=</operator> <name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>skip</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" is already a dimension, skipping"</literal></expr></argument>,
							<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name><name>info</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<switch>switch <condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>DIMENSION_TYPE_CLOSED</name></expr>:</case>
			<expr_stmt><expr><call><name>dimension_info_validate_closed</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DIMENSION_TYPE_OPEN</name></expr>:</case>
			<expr_stmt><expr><call><name>dimension_info_validate_open</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DIMENSION_TYPE_ANY</name></expr>:</case>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid dimension type in configuration"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>int32</name></type>
<name>ts_dimension_add_from_info</name><parameter_list>(<parameter><decl><type><name>DimensionInfo</name> <modifier>*</modifier></type><name>info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>set_not_null</name></name> <operator>&amp;&amp;</operator> <name><name>info</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>DIMENSION_TYPE_OPEN</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dimension_add_not_null_on_column</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>table_relid</name></name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name><name>info</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>ht</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>dimension_id</name></name> <operator>=</operator> <call><name>dimension_insert</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>,
										  <argument><expr><name><name>info</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>,
										  <argument><expr><name><name>info</name><operator>-&gt;</operator><name>coltype</name></name></expr></argument>,
										  <argument><expr><name><name>info</name><operator>-&gt;</operator><name>num_slices</name></name></expr></argument>,
										  <argument><expr><name><name>info</name><operator>-&gt;</operator><name>partitioning_func</name></name></expr></argument>,
										  <argument><expr><name><name>info</name><operator>-&gt;</operator><name>interval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>info</name><operator>-&gt;</operator><name>dimension_id</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Create a datum to be returned by add_dimension DDL function
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>dimension_create_datum</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><name>DimensionInfo</name> <modifier>*</modifier></type><name>info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name><name>values</name><index>[<expr><name>Natts_add_dimension</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name><name>nulls</name><index>[<expr><name>Natts_add_dimension</name></expr>]</index></name> <init>= <expr><block>{ <expr><name>false</name></expr> }</block></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>get_call_result_type</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupdesc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TYPEFUNC_COMPOSITE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function returning record called in "</literal>
						<literal type="string">"context that cannot accept type record"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>BlessTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_add_dimension_id</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name><name>info</name><operator>-&gt;</operator><name>dimension_id</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_add_dimension_schema_name</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
		<call><name>NameGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>info</name><operator>-&gt;</operator><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>schema_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_add_dimension_table_name</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
		<call><name>NameGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>info</name><operator>-&gt;</operator><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_add_dimension_column_name</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <call><name>NameGetDatum</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_add_dimension_created</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><operator>!</operator><name><name>info</name><operator>-&gt;</operator><name>skip</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><call><name>TS_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>ts_dimension_add</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*
 * Add a new dimension to a hypertable.
 *
 * Arguments:
 * 0. Relation ID of table
 * 1. Column name
 * 2. Number of partitions / slices in close ('space') dimensions
 * 3. Interval for open ('time') dimensions
 * 4. Partitioning function
 * 5. IF NOT EXISTS option (bool)
 */</comment>
<function><type><name>Datum</name></type>
<name>ts_dimension_add</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cache</name> <modifier>*</modifier></type><name>hcache</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DimensionInfo</name></type> <name>info</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>type</name> <operator>=</operator> <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>?</operator> <name>DIMENSION_TYPE_OPEN</name> <operator>:</operator> <name>DIMENSION_TYPE_CLOSED</name></expr>,
		<expr><operator>.</operator><name>table_relid</name> <operator>=</operator> <call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>colname</name> <operator>=</operator> <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>?</operator> <name>NULL</name> <operator>:</operator> <call><name>PG_GETARG_NAME</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>num_slices</name> <operator>=</operator> <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>?</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>:</operator> <call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>num_slices_is_set</name> <operator>=</operator> <operator>!</operator><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>interval_datum</name> <operator>=</operator> <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>?</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>:</operator> <call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>interval_type</name> <operator>=</operator> <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>?</operator> <name>InvalidOid</name> <operator>:</operator> <call><name>get_fn_expr_argtype</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>partitioning_func</name> <operator>=</operator> <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>?</operator> <name>InvalidOid</name> <operator>:</operator> <call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>if_not_exists</name> <operator>=</operator> <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>?</operator> <name>false</name> <operator>:</operator> <call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>,
	}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>retval</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>TS_PREVENT_FUNC_IF_READ_ONLY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"hypertable cannot be NULL"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>info</name><operator>.</operator><name>num_slices_is_set</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>info</name><operator>.</operator><name>interval_type</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must specify either the number of partitions or an interval"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ts_hypertable_permissions_check</name><argument_list>(<argument><expr><name><name>info</name><operator>.</operator><name>table_relid</name></name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The hypertable catalog table has a CHECK(num_dimensions &gt; 0), which
	 * means, that when this function is called from create_hypertable()
	 * instead of directly, num_dimension is already set to one. We therefore
	 * need to lock the hypertable tuple here so that we can set the correct
	 * number of dimensions once we've added the new dimension.
	 *
	 * This lock is also used to serialize access from concurrent add_dimension()
	 * call and a chunk creation.
	 */</comment>
	<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name><name>info</name><operator>.</operator><name>table_relid</name></name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>DEBUG_WAITPOINT</name><argument_list>(<argument><expr><literal type="string">"add_dimension_ht_lock"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>ht</name></name> <operator>=</operator> <call><name>ts_hypertable_cache_get_cache_and_entry</name><argument_list>(<argument><expr><name><name>info</name><operator>.</operator><name>table_relid</name></name></expr></argument>, <argument><expr><name>CACHE_FLAG_NONE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>.</operator><name>num_slices_is_set</name></name> <operator>&amp;&amp;</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>info</name><operator>.</operator><name>interval_type</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot specify both the number of partitions and an interval"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>info</name><operator>.</operator><name>num_slices_is_set</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>info</name><operator>.</operator><name>interval_type</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot omit both the number of partitions and the interval"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ts_dimension_info_validate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>info</name><operator>.</operator><name>skip</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int32</name></type> <name>dimension_id</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Note that space-&gt;num_dimensions reflects the actual number of
		 * dimension rows and not the num_dimensions in the hypertable catalog
		 * table.
		 */</comment>
		<expr_stmt><expr><call><name>ts_hypertable_set_num_dimensions</name><argument_list>(<argument><expr><name><name>info</name><operator>.</operator><name>ht</name></name></expr></argument>, <argument><expr><name><name>info</name><operator>.</operator><name>ht</name><operator>-&gt;</operator><name>space</name><operator>-&gt;</operator><name>num_dimensions</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>dimension_id</name> <operator>=</operator> <call><name>ts_dimension_add_from_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* If adding the first space dimension, also add dimension partition metadata */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>DIMENSION_TYPE_CLOSED</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type><name>space_dim</name> <init>= <expr><call><name>hyperspace_get_closed_dimension</name><argument_list>(<argument><expr><name><name>info</name><operator>.</operator><name>ht</name><operator>-&gt;</operator><name>space</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>space_dim</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>data_nodes</name> <init>= <expr><call><name>ts_hypertable_get_available_data_nodes</name><argument_list>(<argument><expr><name><name>info</name><operator>.</operator><name>ht</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>ts_dimension_partition_info_recreate</name><argument_list>(<argument><expr><name>dimension_id</name></expr></argument>,
													 <argument><expr><name><name>info</name><operator>.</operator><name>num_slices</name></name></expr></argument>,
													 <argument><expr><name>data_nodes</name></expr></argument>,
													 <argument><expr><name><name>info</name><operator>.</operator><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>replication_factor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Verify that existing indexes are compatible with a hypertable */</comment>

		<comment type="block">/*
		 * Need to get a fresh copy of hypertable from the database as cache
		 * does not reflect the changes in the previous 2 lines which add a
		 * new dimension
		 */</comment>
		<expr_stmt><expr><name><name>info</name><operator>.</operator><name>ht</name></name> <operator>=</operator> <call><name>ts_hypertable_get_by_id</name><argument_list>(<argument><expr><name><name>info</name><operator>.</operator><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ts_indexing_verify_indexes</name><argument_list>(<argument><expr><name><name>info</name><operator>.</operator><name>ht</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Check that partitioning is sane */</comment>
		<expr_stmt><expr><call><name>ts_hypertable_check_partitioning</name><argument_list>(<argument><expr><name><name>info</name><operator>.</operator><name>ht</name></name></expr></argument>, <argument><expr><name>dimension_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If the hypertable has chunks, to make it compatible
		 * we add artificial dimension slice which will cover -inf / inf
		 * range.
		 *
		 * Newly created chunks will have a proper slice range according to
		 * the created dimension and its partitioning.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>ts_hypertable_has_chunks</name><argument_list>(<argument><expr><name><name>info</name><operator>.</operator><name>table_relid</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>chunk_id_list</name> <init>= <expr><call><name>ts_chunk_get_chunk_ids_by_hypertable_id</name><argument_list>(<argument><expr><name><name>info</name><operator>.</operator><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>DimensionSlice</name> <modifier>*</modifier></type><name>slice</name></decl>;</decl_stmt>
			<expr_stmt><expr><name>slice</name> <operator>=</operator> <call><name>ts_dimension_slice_create</name><argument_list>(<argument><expr><name>dimension_id</name></expr></argument>,
											  <argument><expr><name>DIMENSION_SLICE_MINVALUE</name></expr></argument>,
											  <argument><expr><name>DIMENSION_SLICE_MAXVALUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ts_dimension_slice_insert_multi</name><argument_list>(<argument><expr><operator>&amp;</operator><name>slice</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>chunk_id_list</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int32</name></type> <name>chunk_id</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name> <init>= <expr><call><name>ts_chunk_get_by_id</name><argument_list>(<argument><expr><name>chunk_id</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ChunkConstraint</name> <modifier>*</modifier></type><name>cc</name> <init>= <expr><call><name>ts_chunk_constraints_add</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>constraints</name></name></expr></argument>,
															   <argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>,
															   <argument><expr><name><name>slice</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>,
															   <argument><expr><name>NULL</name></expr></argument>,
															   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>ts_chunk_constraint_insert</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ts_hypertable_func_call_on_data_nodes</name><argument_list>(<argument><expr><name><name>info</name><operator>.</operator><name>ht</name></name></expr></argument>, <argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>dimension_create_datum</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Used as a tuple found function */</comment>
<function><type><specifier>static</specifier> <name>ScanTupleResult</name></type>
<name>dimension_rename_schema_name</name><parameter_list>(<parameter><decl><type><name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Dimension table may contain null valued columns that is why we do not use
	 * FormData_dimension *dimension = (FormData_dimension *) GETSTRUCT(tuple);
	 * pattern here
	 */</comment>
	<decl_stmt><decl><type><name>Datum</name></type> <name><name>values</name><index>[<expr><name>Natts_dimension</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name><name>nulls</name><index>[<expr><name>Natts_dimension</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name><name>doReplace</name><index>[<expr><name>Natts_dimension</name></expr>]</index></name> <init>= <expr><block>{ <expr><name>false</name></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>should_free</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name> <init>= <expr><call><name>ts_scanner_fetch_heap_tuple</name><argument_list>(<argument><expr><name>ti</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>should_free</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>new_tuple</name></decl>;</decl_stmt>
	<comment type="block">/* contains [old_name,new_name] in that order */</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>names</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>data</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Name</name></type> <name>schemaname</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><call><name>ts_scanner_get_tupledesc</name><argument_list>(<argument><expr><name>ti</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>nulls</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_dimension_partitioning_func_schema</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>||</operator>
		   <operator>!</operator><name><name>nulls</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_dimension_integer_now_func_schema</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Rename schema names */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>nulls</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_dimension_partitioning_func_schema</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>schemaname</name> <operator>=</operator>
			<call><name>DatumGetName</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_dimension_partitioning_func_schema</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>namestrcmp</name><argument_list>(<argument><expr><name>schemaname</name></expr></argument>, <argument><expr><name><name>names</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><name>schemaname</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator> <name><name>names</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_dimension_partitioning_func_schema</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
				<call><name>NameGetDatum</name><argument_list>(<argument><expr><name>schemaname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>doReplace</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_dimension_partitioning_func_schema</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>nulls</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_dimension_integer_now_func_schema</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>schemaname</name> <operator>=</operator>
			<call><name>DatumGetName</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_dimension_integer_now_func_schema</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>namestrcmp</name><argument_list>(<argument><expr><name>schemaname</name></expr></argument>, <argument><expr><name><name>names</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><name>schemaname</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator> <name><name>names</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_dimension_integer_now_func_schema</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
				<call><name>NameGetDatum</name><argument_list>(<argument><expr><name>schemaname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>doReplace</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_dimension_integer_now_func_schema</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>new_tuple</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><call><name>ts_scanner_get_tupledesc</name><argument_list>(<argument><expr><name>ti</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>doReplace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_catalog_update</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>scanrel</name></name></expr></argument>, <argument><expr><name>new_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>new_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>should_free</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>SCAN_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Go through internal dimensions table and rename all relevant schema */</comment>
<function><type><name>void</name></type>
<name>ts_dimensions_rename_schema_name</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>old_name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>new_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NameData</name></type> <name>old_schema_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scankey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Catalog</name> <modifier>*</modifier></type><name>catalog</name> <init>= <expr><call><name>ts_catalog_get</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name><name>names</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{ <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>old_name</name></expr>, <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>new_name</name></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScannerCtx</name></type> <name>scanctx</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>table</name> <operator>=</operator> <call><name>catalog_get_table_id</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>DIMENSION</name></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>index</name> <operator>=</operator> <name>InvalidOid</name></expr>,
		<expr><operator>.</operator><name>nkeys</name> <operator>=</operator> <literal type="number">1</literal></expr>,
		<expr><operator>.</operator><name>scankey</name> <operator>=</operator> <name>scankey</name></expr>,
		<expr><operator>.</operator><name>tuple_found</name> <operator>=</operator> <name>dimension_rename_schema_name</name></expr>,
		<expr><operator>.</operator><name>data</name> <operator>=</operator> <name>names</name></expr>,
		<expr><operator>.</operator><name>lockmode</name> <operator>=</operator> <name>RowExclusiveLock</name></expr>,
		<expr><operator>.</operator><name>scandirection</name> <operator>=</operator> <name>ForwardScanDirection</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>old_schema_name</name></expr></argument>, <argument><expr><name>old_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scankey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_dimension_partitioning_func_schema</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
				<argument><expr><name>F_NAMEEQ</name></expr></argument>,
				<argument><expr><call><name>NameGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>old_schema_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ts_scanner_scan</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scanctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scankey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_dimension_integer_now_func_schema</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
				<argument><expr><name>F_NAMEEQ</name></expr></argument>,
				<argument><expr><call><name>NameGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>old_schema_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ts_scanner_scan</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scanctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Create partitioning key expressions for a dimension.
 *
 * This function returns a list of Expr nodes that represent the dimension as
 * a partitioning key.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>ts_dimension_get_partexprs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type><name>dim</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>hyper_varno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>exprs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache2</name><argument_list>(<argument><expr><name>ATTNUM</name></expr></argument>,
							<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>dim</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name><name>dim</name><operator>-&gt;</operator><name>column_attno</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for attribute"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>att</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>att</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeVar</name><argument_list>(<argument><expr><name>hyper_varno</name></expr></argument>,
								<argument><expr><name><name>dim</name><operator>-&gt;</operator><name>column_attno</name></name></expr></argument>,
								<argument><expr><name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
								<argument><expr><name><name>att</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>,
								<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attcollation</name></name></expr></argument>,
								<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* The expression on the partitioning key can be the raw key or the
	 * partitioning function on the key */</comment>
	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>dim</name><operator>-&gt;</operator><name>partitioning</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>exprs</name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>dim</name><operator>-&gt;</operator><name>partitioning</name><operator>-&gt;</operator><name>partfunc</name><operator>.</operator><name>func_fmgr</name><operator>.</operator><name>fn_expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>exprs</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>exprs</name></expr>;</return>
</block_content>}</block></function>
</unit>
