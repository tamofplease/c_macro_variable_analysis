<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/timescaledb/src/hypercube.c"><comment type="block">/*
 * This file and its contents are licensed under the Apache License 2.0.
 * Please see the included NOTICE for copyright information and
 * LICENSE-APACHE for a copy of the license.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postgres.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/jsonb.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/numeric.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"export.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hypercube.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dimension_vector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ts_catalog/dimension_partition.h"</cpp:file></cpp:include>

<comment type="block">/*
 * A hypercube represents the partition bounds of a hypertable chunk.
 *
 * A hypercube consists of N slices that each represent a range in a particular
 * dimension that make up the hypercube. When a new tuple is inserted into a
 * hypertable, and no chunk exists that can hold that tuple, we need to
 * calculate a new hypercube that encloses the point corresponding to the
 * tuple. When calculating the hypercube, we need to account for alignment
 * requirements in dimensions marked as "aligned" and also ensure that there are
 * no collisions with existing chunks. Alignment issues and collisions can occur
 * when the partitioning configuration has changed (e.g., the time interval or
 * number of partitions in a particular dimension changed).
 */</comment>
<function><type><name>Hypercube</name> <modifier>*</modifier></type>
<name>ts_hypercube_alloc</name><parameter_list>(<parameter><decl><type><name>int16</name></type> <name>num_dimensions</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Hypercube</name> <modifier>*</modifier></type><name>hc</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><call><name>HYPERCUBE_SIZE</name><argument_list>(<argument><expr><name>num_dimensions</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>hc</name><operator>-&gt;</operator><name>capacity</name></name> <operator>=</operator> <name>num_dimensions</name></expr>;</expr_stmt>
	<return>return <expr><name>hc</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ts_hypercube_free</name><parameter_list>(<parameter><decl><type><name>Hypercube</name> <modifier>*</modifier></type><name>hc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>hc</name><operator>-&gt;</operator><name>num_slices</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ts_dimension_slice_free</name><argument_list>(<argument><expr><name><name>hc</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>hc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_ASSERT_CHECKING</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>hypercube_is_sorted</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Hypercube</name> <modifier>*</modifier></type><name>hc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>hc</name><operator>-&gt;</operator><name>num_slices</name></name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>hc</name><operator>-&gt;</operator><name>num_slices</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><name><name>hc</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>fd</name><operator>.</operator><name>dimension_id</name></name> <operator>&lt;</operator> <name><name>hc</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name><name>fd</name><operator>.</operator><name>dimension_id</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>Hypercube</name> <modifier>*</modifier></type>
<name>ts_hypercube_copy</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Hypercube</name> <modifier>*</modifier></type><name>hc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Hypercube</name> <modifier>*</modifier></type><name>copy</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>nbytes</name> <init>= <expr><call><name>HYPERCUBE_SIZE</name><argument_list>(<argument><expr><name><name>hc</name><operator>-&gt;</operator><name>capacity</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>copy</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>copy</name></expr></argument>, <argument><expr><name>hc</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>hc</name><operator>-&gt;</operator><name>num_slices</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>copy</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>ts_dimension_slice_copy</name><argument_list>(<argument><expr><name><name>hc</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<return>return <expr><name>copy</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ts_hypercube_equal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Hypercube</name> <modifier>*</modifier></type><name>hc1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Hypercube</name> <modifier>*</modifier></type><name>hc2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>hc1</name><operator>-&gt;</operator><name>num_slices</name></name> <operator>!=</operator> <name><name>hc2</name><operator>-&gt;</operator><name>num_slices</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>hc1</name><operator>-&gt;</operator><name>num_slices</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><call><name>ts_dimension_slice_cmp</name><argument_list>(<argument><expr><name><name>hc1</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>hc2</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>cmp_slices_by_dimension_id</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>left</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>right</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>DimensionSlice</name> <modifier>*</modifier></type><name>left_slice</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>DimensionSlice</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>left</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>DimensionSlice</name> <modifier>*</modifier></type><name>right_slice</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>DimensionSlice</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>right</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>left_slice</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>dimension_id</name></name> <operator>==</operator> <name><name>right_slice</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>dimension_id</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>left_slice</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>dimension_id</name></name> <operator>&lt;</operator> <name><name>right_slice</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>dimension_id</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>DimensionSlice</name> <modifier>*</modifier></type>
<name>ts_hypercube_add_slice_from_range</name><parameter_list>(<parameter><decl><type><name>Hypercube</name> <modifier>*</modifier></type><name>hc</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>dimension_id</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>end</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DimensionSlice</name> <modifier>*</modifier></type><name>slice</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>hc</name><operator>-&gt;</operator><name>capacity</name></name> <operator>&gt;</operator> <name><name>hc</name><operator>-&gt;</operator><name>num_slices</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>slice</name> <operator>=</operator> <call><name>ts_dimension_slice_create</name><argument_list>(<argument><expr><name>dimension_id</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hc</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name><name>hc</name><operator>-&gt;</operator><name>num_slices</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>slice</name></expr>;</expr_stmt>

	<comment type="block">/* Check if we require a sort to maintain dimension order */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>hc</name><operator>-&gt;</operator><name>num_slices</name></name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
		<name><name>slice</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>dimension_id</name></name> <operator>&lt;</operator> <name><name>hc</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name><name>hc</name><operator>-&gt;</operator><name>num_slices</name></name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name><name>fd</name><operator>.</operator><name>dimension_id</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ts_hypercube_slice_sort</name><argument_list>(<argument><expr><name>hc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>hypercube_is_sorted</name><argument_list>(<argument><expr><name>hc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>slice</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>DimensionSlice</name> <modifier>*</modifier></type>
<name>ts_hypercube_add_slice</name><parameter_list>(<parameter><decl><type><name>Hypercube</name> <modifier>*</modifier></type><name>hc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DimensionSlice</name> <modifier>*</modifier></type><name>slice</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DimensionSlice</name> <modifier>*</modifier></type><name>new_slice</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>new_slice</name> <operator>=</operator> <call><name>ts_hypercube_add_slice_from_range</name><argument_list>(<argument><expr><name>hc</name></expr></argument>,
												  <argument><expr><name><name>slice</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>dimension_id</name></name></expr></argument>,
												  <argument><expr><name><name>slice</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>range_start</name></name></expr></argument>,
												  <argument><expr><name><name>slice</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>range_end</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>new_slice</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name> <operator>=</operator> <name><name>slice</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr>;</expr_stmt>

	<return>return <expr><name>new_slice</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Sort the hypercubes slices in ascending dimension ID order. This allows us to
 * iterate slices in a consistent order.
 */</comment>
<function><type><name>void</name></type>
<name>ts_hypercube_slice_sort</name><parameter_list>(<parameter><decl><type><name>Hypercube</name> <modifier>*</modifier></type><name>hc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name><name>hc</name><operator>-&gt;</operator><name>slices</name></name></expr></argument>, <argument><expr><name><name>hc</name><operator>-&gt;</operator><name>num_slices</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DimensionSlice</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>cmp_slices_by_dimension_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>DimensionSlice</name> <modifier>*</modifier></type>
<name>ts_hypercube_get_slice_by_dimension_id</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Hypercube</name> <modifier>*</modifier></type><name>hc</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>dimension_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DimensionSlice</name></type> <name>slice</name> <init>= <expr><block>{
		<expr><operator>.</operator><name><name>fd</name><operator>.</operator><name>dimension_id</name></name> <operator>=</operator> <name>dimension_id</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><operator>&amp;</operator><name>slice</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>hc</name><operator>-&gt;</operator><name>num_slices</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>hypercube_is_sorted</name><argument_list>(<argument><expr><name>hc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>bsearch</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>,
				  <argument><expr><name><name>hc</name><operator>-&gt;</operator><name>slices</name></name></expr></argument>,
				  <argument><expr><name><name>hc</name><operator>-&gt;</operator><name>num_slices</name></name></expr></argument>,
				  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DimensionSlice</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>,
				  <argument><expr><name>cmp_slices_by_dimension_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>ptr</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>DimensionSlice</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>ptr</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Given a set of constraints, build the corresponding hypercube.
 */</comment>
<function><type><name>Hypercube</name> <modifier>*</modifier></type>
<name>ts_hypercube_from_constraints</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ChunkConstraints</name> <modifier>*</modifier></type><name>constraints</name></decl></parameter>, <parameter><decl><type><name>ScanIterator</name> <modifier>*</modifier></type><name>slice_it</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Hypercube</name> <modifier>*</modifier></type><name>hc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>old</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>ts_scan_iterator_get_result_memory_context</name><argument_list>(<argument><expr><name>slice_it</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>hc</name> <operator>=</operator> <call><name>ts_hypercube_alloc</name><argument_list>(<argument><expr><name><name>constraints</name><operator>-&gt;</operator><name>num_dimension_constraints</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>constraints</name><operator>-&gt;</operator><name>num_constraints</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ChunkConstraint</name> <modifier>*</modifier></type><name>cc</name> <init>= <expr><call><name>chunk_constraints_get</name><argument_list>(<argument><expr><name>constraints</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ScanTupLock</name></type> <name>tuplock</name> <init>= <expr><block>{
			<expr><operator>.</operator><name>lockmode</name> <operator>=</operator> <name>LockTupleKeyShare</name></expr>,
			<expr><operator>.</operator><name>waitpolicy</name> <operator>=</operator> <name>LockWaitBlock</name></expr>,
			<expr><operator>.</operator><name>lockflags</name> <operator>=</operator> <name>TUPLE_LOCK_FLAG_FIND_LAST_VERSION</name></expr>,
		}</block></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>is_dimension_constraint</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>DimensionSlice</name> <modifier>*</modifier></type><name>slice</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ScanTupLock</name> <modifier>*</modifier><specifier>const</specifier></type> <name>tuplock_ptr</name> <init>= <expr><ternary><condition><expr><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><operator>&amp;</operator><name>tuplock</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>hc</name><operator>-&gt;</operator><name>num_slices</name></name> <operator>&lt;</operator> <name><name>constraints</name><operator>-&gt;</operator><name>num_dimension_constraints</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* When building the hypercube, we reference the dimension slices
			 * to construct the hypercube.
			 *
			 * However, we cannot add a tuple lock when running in recovery
			 * mode since that prevents SELECT statements (which reach this
			 * point) from running on a read-only secondary (which runs in
			 * ephemeral recovery mode), so we only take the lock if we are not
			 * in recovery mode.
			 */</comment>
			<expr_stmt><expr><name>slice</name> <operator>=</operator> <call><name>ts_dimension_slice_scan_iterator_get_by_id</name><argument_list>(<argument><expr><name>slice_it</name></expr></argument>,
															   <argument><expr><name><name>cc</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>dimension_slice_id</name></name></expr></argument>,
															   <argument><expr><name>tuplock_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>slice</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>hc</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name><name>hc</name><operator>-&gt;</operator><name>num_slices</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>slice</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>ts_hypercube_slice_sort</name><argument_list>(<argument><expr><name>hc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>hypercube_is_sorted</name><argument_list>(<argument><expr><name>hc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>hc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Find slices in the hypercube that already exists in metadata.
 *
 * If a slice exists in metadata, the slice ID will be filled in on the
 * existing slice in the hypercube. Optionally, also lock the slice when
 * found.
 */</comment>
<function><type><name>int</name></type>
<name>ts_hypercube_find_existing_slices</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Hypercube</name> <modifier>*</modifier></type><name>cube</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ScanTupLock</name> <modifier>*</modifier></type><name>tuplock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>num_found</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>cube</name><operator>-&gt;</operator><name>num_slices</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * Check if there's already an existing slice with the calculated
		 * range. If a slice already exists, use that slice's ID instead
		 * of a new one.
		 */</comment>
		<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><call><name>ts_dimension_slice_scan_for_existing</name><argument_list>(<argument><expr><name><name>cube</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>tuplock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>num_found</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>num_found</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Calculate the hypercube that encloses the given point.
 *
 * The hypercube's dimensions are calculated one by one, and depend on the
 * current partitioning in each dimension of the N-dimensional hyperspace,
 * including any alignment requirements.
 *
 * For non-aligned dimensions, we simply calculate the hypercube's slice range
 * in that dimension given current partitioning configuration. If there is
 * already an identical slice for that dimension, we will reuse it rather than
 * creating a new one.
 *
 * For aligned dimensions, we first try to find an existing slice that covers
 * the insertion point. If an existing slice is found, we reuse it or otherwise
 * we calculate a new slice as described for non-aligned dimensions.
 *
 * If a hypercube has dimension slices that are not reused ones, we might need
 * to cut them to ensure alignment and avoid collisions with other chunk
 * hypercubes. This happens in a later step.
 */</comment>
<function><type><name>Hypercube</name> <modifier>*</modifier></type>
<name>ts_hypercube_calculate_from_point</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Hyperspace</name> <modifier>*</modifier></type><name>hs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Point</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ScanTupLock</name> <modifier>*</modifier></type><name>tuplock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Hypercube</name> <modifier>*</modifier></type><name>cube</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>cube</name> <operator>=</operator> <call><name>ts_hypercube_alloc</name><argument_list>(<argument><expr><name><name>hs</name><operator>-&gt;</operator><name>num_dimensions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* For each dimension, calculate the hypercube's slice in that dimension */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>hs</name><operator>-&gt;</operator><name>num_dimensions</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type><name>dim</name> <init>= <expr><operator>&amp;</operator><name><name>hs</name><operator>-&gt;</operator><name>dimensions</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int64</name></type> <name>value</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>coordinates</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>check_for_existing_slice</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Assert that dimensions are in ascending order */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>i</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name> <operator>&gt;</operator> <name><name>hs</name><operator>-&gt;</operator><name>dimensions</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>dim</name><operator>-&gt;</operator><name>dimension_partitions</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>DimensionPartition</name> <modifier>*</modifier></type><name>dp</name> <init>=
				<expr><call><name>ts_dimension_partition_find</name><argument_list>(<argument><expr><name><name>dim</name><operator>-&gt;</operator><name>dimension_partitions</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>cube</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator>
				<call><name>ts_dimension_slice_create</name><argument_list>(<argument><expr><name><name>dp</name><operator>-&gt;</operator><name>dimension_id</name></name></expr></argument>, <argument><expr><name><name>dp</name><operator>-&gt;</operator><name>range_start</name></name></expr></argument>, <argument><expr><name><name>dp</name><operator>-&gt;</operator><name>range_end</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>check_for_existing_slice</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<comment type="block">/*
		 * If this is an aligned dimension, we'd like to reuse any existing
		 * slice that covers the coordinate in the dimension
		 */</comment>
		<if type="elseif">else if <condition>(<expr><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>aligned</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>DimensionVec</name> <modifier>*</modifier></type><name>vec</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>vec</name> <operator>=</operator> <call><name>ts_dimension_slice_scan_limit</name><argument_list>(<argument><expr><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>tuplock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>vec</name><operator>-&gt;</operator><name>num_slices</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>cube</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>vec</name><operator>-&gt;</operator><name>slices</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * No existing slice found, or we are not aligning, so calculate
			 * the range of a new slice
			 */</comment>
			<expr_stmt><expr><name><name>cube</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>ts_dimension_calculate_default_slice</name><argument_list>(<argument><expr><name>dim</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>check_for_existing_slice</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>check_for_existing_slice</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Check if there's already an existing slice with the calculated
			 * range. If a slice already exists, use that slice's ID instead
			 * of a new one.
			 */</comment>
			<expr_stmt><expr><call><name>ts_dimension_slice_scan_for_existing</name><argument_list>(<argument><expr><name><name>cube</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>tuplock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name><name>cube</name><operator>-&gt;</operator><name>num_slices</name></name> <operator>=</operator> <name><name>hs</name><operator>-&gt;</operator><name>num_dimensions</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>hypercube_is_sorted</name><argument_list>(<argument><expr><name>cube</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>cube</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check if two hypercubes collide (overlap).
 *
 * This is basically an axis-aligned bounding box collision detection,
 * generalized to N dimensions. We check for dimension slice collisions in each
 * dimension and only if all dimensions collide there is a hypercube collision.
 */</comment>
<function><type><name>bool</name></type>
<name>ts_hypercubes_collide</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Hypercube</name> <modifier>*</modifier></type><name>cube1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Hypercube</name> <modifier>*</modifier></type><name>cube2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cube1</name><operator>-&gt;</operator><name>num_slices</name></name> <operator>==</operator> <name><name>cube2</name><operator>-&gt;</operator><name>num_slices</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>cube1</name><operator>-&gt;</operator><name>num_slices</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ts_dimension_slices_collide</name><argument_list>(<argument><expr><name><name>cube1</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>cube2</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>
</unit>
