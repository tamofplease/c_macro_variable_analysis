<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/timescaledb/src/indexing.c"><comment type="block">/*
 * This file and its contents are licensed under the Apache License 2.0.
 * Please see the included NOTICE for copyright information and
 * LICENSE-APACHE for a copy of the license.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postgres.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/xact.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/index.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/indexing.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/namespace.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_inherits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;commands/defrem.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;commands/event_trigger.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;commands/tablecmds.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;commands/tablespace.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fmgr.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/makefuncs.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/parsenodes.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/value.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;parser/parse_utilcmd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/builtins.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/lsyscache.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/syscache.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"annotations.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dimension.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"errors.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hypertable_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"partitioning.h"</cpp:file></cpp:include>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>index_has_attribute</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>indexelems</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>attrname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>indexelems</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * The type of the element varies depending on whether the list is
		 * from an index or a constraint
		 */</comment>
		<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>T_IndexElem</name></expr>:</case>
				<expr_stmt><expr><name>colname</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>IndexElem</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>name</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_String</name></expr>:</case>
				<expr_stmt><expr><name>colname</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_List</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>pair</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>pair</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>pair</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>IndexElem</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					<call><name>IsA</name><argument_list>(<argument><expr><call><name>lsecond</name><argument_list>(<argument><expr><name>pair</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>colname</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>IndexElem</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>pair</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>name</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>
				<expr_stmt><expr><name>TS_FALLTHROUGH</name></expr>;</expr_stmt>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unsupported index list element"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>

		<if_stmt><if>if <condition>(<expr><name>colname</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>strncmp</name><argument_list>(<argument><expr><name>colname</name></expr></argument>, <argument><expr><name>attrname</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Verify that index columns cover all partitioning dimensions.
 *
 * A UNIQUE, PRIMARY KEY or EXCLUSION index on a chunk must cover all
 * partitioning dimensions to guarantee uniqueness (or exclusion) across the
 * entire hypertable. Therefore we check that all dimensions are present among
 * the index columns.
 */</comment>
<function><type><name>void</name></type>
<name>ts_indexing_verify_columns</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Hyperspace</name> <modifier>*</modifier></type><name>hs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>indexelems</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>hs</name><operator>-&gt;</operator><name>num_dimensions</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type><name>dim</name> <init>= <expr><operator>&amp;</operator><name><name>hs</name><operator>-&gt;</operator><name>dimensions</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>index_has_attribute</name><argument_list>(<argument><expr><name>indexelems</name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>column_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TS_BAD_HYPERTABLE_INDEX_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot create a unique index without the column \"%s\" (used in "</literal>
							<literal type="string">"partitioning)"</literal></expr></argument>,
							<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>column_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Verify index columns.
 *
 * We only care about UNIQUE, PRIMARY KEY or EXCLUSION indexes.
 */</comment>
<function><type><name>void</name></type>
<name>ts_indexing_verify_index</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Hyperspace</name> <modifier>*</modifier></type><name>hs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>IndexStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>unique</name></name> <operator>||</operator> <name><name>stmt</name><operator>-&gt;</operator><name>excludeOpNames</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ts_indexing_verify_columns</name><argument_list>(<argument><expr><name>hs</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>indexParams</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Build a list of string Values representing column names that an index covers.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>build_indexcolumn_list</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Relation</name></type> <name>idxrel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>columns</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>idxrel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>idxattr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>idxrel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>columns</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>columns</name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>idxattr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>columns</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>create_default_index</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indexelems</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexStmt</name></type> <name>stmt</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>T_IndexStmt</name></expr>,
		<expr><operator>.</operator><name>accessMethod</name> <operator>=</operator> <name>DEFAULT_INDEX_TYPE</name></expr>,
		<expr><operator>.</operator><name>idxname</name> <operator>=</operator> <name>NULL</name></expr>,
		<expr><operator>.</operator><name>relation</name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>schema_name</name></name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>tableSpace</name> <operator>=</operator> <call><name>get_tablespace_name</name><argument_list>(<argument><expr><call><name>get_rel_tablespace</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>indexParams</name> <operator>=</operator> <name>indexelems</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>DefineIndex</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>,
				<argument><expr><operator>&amp;</operator><name>stmt</name></expr></argument>,
				<argument><expr><name>InvalidOid</name></expr></argument>, <comment type="block">/* indexRelationId */</comment>
				<argument><expr><name>InvalidOid</name></expr></argument>, <comment type="block">/* parentIndexId */</comment>
				<argument><expr><name>InvalidOid</name></expr></argument>, <comment type="block">/* parentConstraintId */</comment>
				<argument><expr><name>false</name></expr></argument>,		<comment type="block">/* is_alter_table */</comment>
				<argument><expr><name>false</name></expr></argument>,		<comment type="block">/* check_rights */</comment>
				<argument><expr><name>false</name></expr></argument>,		<comment type="block">/* check_not_in_use */</comment>
				<argument><expr><name>false</name></expr></argument>,		<comment type="block">/* skip_build */</comment>
				<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* quiet */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>get_open_dim_expr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type><name>dim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>dim</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>dim</name><operator>-&gt;</operator><name>partitioning</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name><name>dim</name><operator>-&gt;</operator><name>partitioning</name><operator>-&gt;</operator><name>partfunc</name><operator>.</operator><name>func_fmgr</name><operator>.</operator><name>fn_expr</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_open_dim_name</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type><name>dim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>dim</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>dim</name><operator>-&gt;</operator><name>partitioning</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>column_name</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>create_default_indexes</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type><name>time_dim</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type><name>space_dim</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>has_time_idx</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>has_time_space_idx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dimname</name> <init>= <expr><call><name>get_open_dim_name</name><argument_list>(<argument><expr><name>time_dim</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexElem</name></type> <name>telem</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>T_IndexElem</name></expr>,
		<expr><operator>.</operator><name>name</name> <operator>=</operator> <name>dimname</name> <operator>?</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>dimname</name> <operator>:</operator> <name>NULL</name></expr>,
		<expr><operator>.</operator><name>ordering</name> <operator>=</operator> <name>SORTBY_DESC</name></expr>,
		<expr><operator>.</operator><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>get_open_dim_expr</name><argument_list>(<argument><expr><name>time_dim</name></expr></argument>)</argument_list></call></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<comment type="block">/* In case we'd allow tables that are only space partitioned */</comment>
	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>time_dim</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Create ("time") index */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>has_time_idx</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>create_default_index</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><operator>&amp;</operator><name>telem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Create ("space", "time") index */</comment>
	<if_stmt><if>if <condition>(<expr><name>space_dim</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>has_time_space_idx</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>IndexElem</name></type> <name>selem</name> <init>= <expr><block>{
			<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>T_IndexElem</name></expr>,
			<expr><operator>.</operator><name>name</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>space_dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>column_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
			<expr><operator>.</operator><name>ordering</name> <operator>=</operator> <name>SORTBY_ASC</name></expr>,
		}</block></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>create_default_index</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><call><name>list_make2</name><argument_list>(<argument><expr><operator>&amp;</operator><name>selem</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>telem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Verify that unique, primary and exclusion indexes on a hypertable cover all
 * partitioning columns and create any default indexes.
 *
 * Default indexes are assumed to cover the first open ("time") dimension, and,
 * optionally, the first closed ("space") dimension.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>indexing_create_and_verify_hypertable_indexes</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>create_default</name></decl></parameter>,
											  <parameter><decl><type><name>bool</name></type> <name>verify</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type> <name>tblrel</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type><name>time_dim</name> <init>= <expr><call><name>ts_hyperspace_get_dimension</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>space</name></name></expr></argument>, <argument><expr><name>DIMENSION_TYPE_OPEN</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type><name>space_dim</name> <init>= <expr><call><name>ts_hyperspace_get_dimension</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>space</name></name></expr></argument>, <argument><expr><name>DIMENSION_TYPE_CLOSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>indexlist</name> <init>= <expr><call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>tblrel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>has_time_idx</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>has_time_space_idx</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>indexlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type> <name>idxrel</name> <init>= <expr><call><name>index_open</name><argument_list>(<argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>verify</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>idxrel</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indisunique</name></name> <operator>||</operator> <name><name>idxrel</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indisexclusion</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ts_indexing_verify_columns</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>space</name></name></expr></argument>, <argument><expr><call><name>build_indexcolumn_list</name><argument_list>(<argument><expr><name>idxrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Check for existence of "default" indexes */</comment>
		<if_stmt><if>if <condition>(<expr><name>create_default</name> <operator>&amp;&amp;</operator> <name>NULL</name> <operator>!=</operator> <name>time_dim</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>idxattr_time</name></decl>, <decl><type ref="prev"/><name>idxattr_space</name></decl>;</decl_stmt>

			<switch>switch <condition>(<expr><name><name>idxrel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><literal type="number">1</literal></expr>:</case>
					<comment type="block">/* ("time") index */</comment>
					<expr_stmt><expr><name>idxattr_time</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>idxrel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>namestrcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>idxattr_time</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>time_dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>column_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>has_time_idx</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<break>break;</break>
				<case>case <expr><literal type="number">2</literal></expr>:</case>
					<comment type="block">/* ("space", "time") index */</comment>
					<expr_stmt><expr><name>idxattr_space</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>idxrel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>idxattr_time</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>idxrel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>space_dim</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
						<call><name>namestrcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>idxattr_space</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>space_dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>column_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator>
							<literal type="number">0</literal> <operator>&amp;&amp;</operator>
						<call><name>namestrcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>idxattr_time</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>time_dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>column_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>has_time_space_idx</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<break>break;</break>
				<default>default:</default>
					<break>break;</break>
			</block_content>}</block></switch>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>idxrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>create_default</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>create_default_indexes</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>time_dim</name></expr></argument>, <argument><expr><name>space_dim</name></expr></argument>, <argument><expr><name>has_time_idx</name></expr></argument>, <argument><expr><name>has_time_space_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>tblrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ts_indexing_relation_has_primary_or_unique_index</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>htrel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>indexoidlist</name> <init>= <expr><call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>htrel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>htrel</name><operator>-&gt;</operator><name>rd_pkindex</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>indexoidlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>indexoid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type> <name>index_tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_index</name></type> <name>index</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>index_tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>indexoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>index_tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* should not happen */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				 <argument><expr><literal type="string">"cache lookup failed for index %u in \"%s\" "</literal></expr></argument>,
				 <argument><expr><name>indexoid</name></expr></argument>,
				 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>htrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>index</name> <operator>=</operator> <operator>(</operator><name>Form_pg_index</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>index_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>index</name><operator>-&gt;</operator><name>indisunique</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>index_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>indexoidlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* create the index on the root table of a hypertable.
 * based on postgres CREATE INDEX
 * https://github.com/postgres/postgres/blob/ebfe20dc706bd3238a9bdf3b44cd8f82337e86a8/src/backend/tcop/utility.c#L1291-L1374
 * despite not allowing CONCURRENT index creation now, we expect to do so soon, so this code
 * retains those code paths
 */</comment>
<function><type><specifier>extern</specifier> <name>ObjectAddress</name></type>
<name>ts_indexing_root_table_create_index</name><parameter_list>(<parameter><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
									<parameter><decl><type><name>bool</name></type> <name>is_multitransaction</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_distributed</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>root_table_address</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>concurrent</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PreventInTransactionBlock</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="string">"CREATE INDEX CONCURRENTLY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Look up the relation OID just once, right here at the
	 * beginning, so that we don't end up repeating the name
	 * lookup later and latching onto a different relation
	 * partway through.  To avoid lock upgrade hazards, it's
	 * important that we take the strongest lock that will
	 * eventually be needed here, so the lockmode calculation
	 * needs to match what DefineIndex() does.
	 */</comment>
	<expr_stmt><expr><name>lockmode</name> <operator>=</operator> <ternary><condition><expr><name><name>stmt</name><operator>-&gt;</operator><name>concurrent</name></name></expr> ?</condition><then> <expr><name>ShareUpdateExclusiveLock</name></expr> </then><else>: <expr><name>ShareLock</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name>relid</name> <operator>=</operator>
		<call><name>RangeVarGetRelidExtended</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>RangeVarCallbackOwnsRelation</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * single-transaction CREATE INDEX on a hypertable tables recurses to
	 * chunks, so we must acquire locks early to avoid deadlocks.
	 *
	 * We also take the opportunity to verify that all
	 * chunks are something we can put an index on, to
	 * avoid building some indexes only to fail later.
	 *
	 * Note that on distributed hypertables we only create the index on the root
	 * table, i.e., we do not recurse to chunks. Therefore, there is no need to
	 * take locks on the chunks here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_multitransaction</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_distributed</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>inheritors</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>inheritors</name> <operator>=</operator> <call><name>find_all_inheritors</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>inheritors</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type> <name>relkind</name> <init>= <expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* Note, that unlike partitioned tables, we allow index creation
			 * when chunks (partitions) are foreign tables, but in that case we
			 * actually do not create the indexes on the foreign table
			 * chunks. Instead, we distribute this index creation to the data
			 * nodes. */</comment>
			<if_stmt><if>if <condition>(<expr><name>relkind</name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator> <name>relkind</name> <operator>!=</operator> <name>RELKIND_MATVIEW</name> <operator>&amp;&amp;</operator>
				<name>relkind</name> <operator>!=</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot create index on hypertable \"%s\""</literal></expr></argument>,
								<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Table \"%s\" contains chunks of the wrong type."</literal></expr></argument>,
								   <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>inheritors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Run parse analysis ... */</comment>
	<expr_stmt><expr><name>stmt</name> <operator>=</operator> <call><name>transformIndexStmt</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* ... and do it */</comment>
	<expr_stmt><expr><call><name>EventTriggerAlterTableStart</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>root_table_address</name> <operator>=</operator> <call><name>DefineIndex</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <comment type="block">/* OID of heap relation */</comment>
									 <argument><expr><name>stmt</name></expr></argument>,
									 <argument><expr><name>InvalidOid</name></expr></argument>, <comment type="block">/* no predefined OID */</comment>
									 <argument><expr><name>InvalidOid</name></expr></argument>, <comment type="block">/* parentIndexId */</comment>
									 <argument><expr><name>InvalidOid</name></expr></argument>, <comment type="block">/* parentConstraintId */</comment>
									 <argument><expr><name>false</name></expr></argument>,		 <comment type="block">/* is_alter_table */</comment>
									 <argument><expr><name>true</name></expr></argument>,		 <comment type="block">/* check_rights */</comment>
									 <argument><expr><name>false</name></expr></argument>,		 <comment type="block">/* check_not_in_use */</comment>
									 <argument><expr><name>false</name></expr></argument>,		 <comment type="block">/* skip_build */</comment>
									 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	 <comment type="block">/* quiet */</comment>

	<return>return <expr><name>root_table_address</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ts_indexing_verify_indexes</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>indexing_create_and_verify_hypertable_indexes</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ts_indexing_create_default_indexes</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>indexing_create_and_verify_hypertable_indexes</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>TSDLLEXPORT</name> <name>Oid</name></type>
<name>ts_indexing_find_clustered_index</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>table_relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>index_relid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>table_relid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We need to find the index that has indisclustered set. */</comment>
	<macro><name>foreach</name> <argument_list>(<argument>index</argument>, <argument>RelationGetIndexList(rel)</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type> <name>idxtuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_index</name></type> <name>indexForm</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>index_relid</name> <operator>=</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>idxtuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>index_relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>idxtuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				 <argument><expr><literal type="string">"cache lookup failed for index %u when looking for a clustered index"</literal></expr></argument>,
				 <argument><expr><name>index_relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>indexForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_index</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>idxtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>indexForm</name><operator>-&gt;</operator><name>indisclustered</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>idxtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>idxtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>index_relid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>index_relid</name></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><enum>enum <name>IndexValidity</name>
<block>{
	<decl><name>IndexInvalid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
	<decl><name>IndexValid</name></decl>,
}</block></enum></type> <name>IndexValidity</name>;</typedef>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ts_indexing_mark_as</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>index_id</name></decl></parameter>, <parameter><decl><type><name>IndexValidity</name></type> <name>validity</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type> <name>pg_index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>indexTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>new_tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_index</name></type> <name>indexForm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>was_valid</name></decl>;</decl_stmt>

	<comment type="block">/* Open pg_index and fetch a writable copy of the index's tuple */</comment>
	<expr_stmt><expr><name>pg_index</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>IndexRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>indexTuple</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>index_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed when marking index %u"</literal></expr></argument>, <argument><expr><name>index_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>new_tuple</name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>indexForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_index</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>new_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>was_valid</name> <operator>=</operator> <name><name>indexForm</name><operator>-&gt;</operator><name>indisvalid</name></name></expr>;</expr_stmt>

	<comment type="block">/* Perform the requested state change on the copy */</comment>
	<switch>switch <condition>(<expr><name>validity</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>IndexValid</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>indexForm</name><operator>-&gt;</operator><name>indislive</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>indexForm</name><operator>-&gt;</operator><name>indisready</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>indexForm</name><operator>-&gt;</operator><name>indisvalid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>IndexInvalid</name></expr>:</case>
			<expr_stmt><expr><name><name>indexForm</name><operator>-&gt;</operator><name>indisvalid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>indexForm</name><operator>-&gt;</operator><name>indisclustered</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* ... and write it back */</comment>
	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>pg_index</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>indexTuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>new_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pg_index</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>was_valid</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ts_indexing_mark_as_valid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>index_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ts_indexing_mark_as</name><argument_list>(<argument><expr><name>index_id</name></expr></argument>, <argument><expr><name>IndexValid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* returns if the index was valid */</comment>
<function><type><name>bool</name></type>
<name>ts_indexing_mark_as_invalid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>index_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>ts_indexing_mark_as</name><argument_list>(<argument><expr><name>index_id</name></expr></argument>, <argument><expr><name>IndexInvalid</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
