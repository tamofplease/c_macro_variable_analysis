<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/timescaledb/src/planner/planner.c"><comment type="block">/*
 * This file and its contents are licensed under the Apache License 2.0.
 * Please see the included NOTICE for copyright information and
 * LICENSE-APACHE for a copy of the license.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postgres.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/tsmapi.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/xact.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/namespace.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;commands/extension.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;executor/nodeAgg.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;miscadmin.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/makefuncs.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/plannodes.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/appendinfo.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/clauses.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/optimizer.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/pathnode.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/paths.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/planner.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/restrictinfo.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/tlist.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;parser/parsetree.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/elog.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/fmgroids.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/guc.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/lsyscache.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/memutils.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/selfuncs.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/timestamp.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compat/compat-msvc-enter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_constraint.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/nodeFuncs.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/cost.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/plancat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;parser/analyze.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;tcop/tcopprot.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compat/compat-msvc-exit.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"annotations.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"chunk.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cross_module_fn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"debug_assert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dimension.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dimension_slice.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dimension_vector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"extension.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"func_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hypertable_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"import/allpaths.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"license_guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/chunk_append/chunk_append.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/chunk_dispatch_plan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/constraint_aware_append/constraint_aware_append.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/hypertable_modify.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"partitioning.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"planner/planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compat/compat.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG13_GE</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;common/hashfn.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/hashutils.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_TELEMETRY</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"telemetry/functions.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* define parameters necessary to generate the baserel info hash table interface */</comment>
<typedef>typedef <type><struct>struct <name>BaserelInfoEntry</name>
<block>{
	<decl_stmt><decl><type><name>Oid</name></type> <name>reloid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>uint32</name></type> <name>status</name></decl>;</decl_stmt> <comment type="block">/* hash status */</comment>
}</block></struct></type> <name>BaserelInfoEntry</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SH_PREFIX</name></cpp:macro> <cpp:value>BaserelInfo</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SH_ELEMENT_TYPE</name></cpp:macro> <cpp:value>BaserelInfoEntry</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SH_KEY_TYPE</name></cpp:macro> <cpp:value>Oid</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SH_KEY</name></cpp:macro> <cpp:value>reloid</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SH_EQUAL</name><parameter_list>(<parameter><type><name>tb</name></type></parameter>, <parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((a) == (b))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SH_HASH_KEY</name><parameter_list>(<parameter><type><name>tb</name></type></parameter>, <parameter><type><name>key</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>murmurhash32(key)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SH_SCOPE</name></cpp:macro> <cpp:value>static</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SH_DECLARE</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SH_DEFINE</name></cpp:macro></cpp:define>

<comment type="line">// We don't need most of the generated functions and there is no way to not</comment>
<comment type="line">// generate them.</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__GNUC__</name></cpp:ifdef>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>GCC</name> <name>diagnostic</name> <name>push</name></cpp:pragma>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>GCC</name> <name>diagnostic</name> <name>ignored</name> <cpp:literal>"-Wunused-function"</cpp:literal></cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="line">// Generate the baserel info hash table functions.</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/simplehash.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__GNUC__</name></cpp:ifdef>

<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>GCC</name> <name>diagnostic</name> <name>pop</name></cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><name>void</name></type> <name>_planner_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>_planner_fini</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <name>planner_hook_type</name></type> <name>prev_planner_hook</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>set_rel_pathlist_hook_type</name></type> <name>prev_set_rel_pathlist_hook</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>get_relation_info_hook_type</name></type> <name>prev_get_relation_info_hook</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>create_upper_paths_hook_type</name></type> <name>prev_create_upper_paths_hook</name></decl>;</decl_stmt>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>cagg_reorder_groupby_clause</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>subq_rte</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>rtno</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>outer_sortcl</name></decl></parameter>,
										<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>outer_tlist</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * We mark range table entries (RTEs) in a query with TS_CTE_EXPAND if we'd like
 * to control table expansion ourselves. We exploit the ctename for this purpose
 * since it is not used for regular (base) relations.
 *
 * Note that we cannot use this mark as a general way to identify hypertable
 * RTEs. Child RTEs, for instance, will inherit this value from the parent RTE
 * during expansion. While we can prevent this happening in our custom table
 * expansion, we also have to account for the case when our custom expansion
 * is turned off with a GUC.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>TS_CTE_EXPAND</name> <init>= <expr><literal type="string">"ts_expand"</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Controls which type of fetcher to use to fetch data from the data nodes.
 * There is no place to store planner-global custom information (such as in
 * PlannerInfo). Because of this, we have to use the global variable that is
 * valid inside the scope of timescaledb_planner().
 * Note that that function can be called recursively, e.g. when evaluating a
 * SQL function at the planning time. We only have to determine the fetcher type
 * in the outermost scope, so we distinguish it by that the fetcher type is set
 * to the invalid value of 'auto'.
 */</comment>
<decl_stmt><decl><type><name>DataFetcherType</name></type> <name>ts_data_node_fetcher_scan_type</name> <init>= <expr><name>AutoFetcherType</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * A simplehash hash table that records the chunks and their corresponding
 * hypertables, and also the plain baserels. We use it to tell whether a
 * relation is a hypertable chunk, inside the classify_relation function.
 * It is valid inside the scope of timescaledb_planner().
 * That function can be called recursively, e.g. when we evaluate a SQL function,
 * and this cache is initialized only at the top-level call.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>BaserelInfo_hash</name></name> <modifier>*</modifier></type><name>ts_baserel_info</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Add information about a chunk to the baserel info cache. Used to cache the
 * chunk info at the plan time chunk exclusion.
 */</comment>
<function><type><name>void</name></type>
<name>add_baserel_cache_entry_for_chunk</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>chunk_reloid</name></decl></parameter>, <parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>hypertable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>hypertable</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ts_baserel_info</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BaserelInfoEntry</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><call><name>BaserelInfo_insert</name><argument_list>(<argument><expr><name>ts_baserel_info</name></expr></argument>, <argument><expr><name>chunk_reloid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Already cached. */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>ht</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Fill the cache entry. */</comment>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>ht</name></name> <operator>=</operator> <name>hypertable</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>rte_mark_for_expansion</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>ctename</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>ctename</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>TS_CTE_EXPAND</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>inh</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ts_rte_is_marked_for_expansion</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>rte</name><operator>-&gt;</operator><name>ctename</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>ctename</name></name> <operator>==</operator> <name>TS_CTE_EXPAND</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>, <argument><expr><name>TS_CTE_EXPAND</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Planner-global hypertable cache.
 *
 * Each invocation of the planner (and our hooks) should reference the same
 * cache object. Since we warm the cache when pre-processing the query (prior to
 * invoking the planner), we'd like to ensure that we use the same cache object
 * throughout the planning of that query so that we can trust that the cache
 * holds the objects it was warmed with. Since the planner can be invoked
 * recursively, we also need to stack and pop cache objects.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>planner_hcaches</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>Cache</name> <modifier>*</modifier></type>
<name>planner_hcache_push</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cache</name> <modifier>*</modifier></type><name>hcache</name> <init>= <expr><call><name>ts_hypertable_cache_pin</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>planner_hcaches</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>, <argument><expr><name>planner_hcaches</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>hcache</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>planner_hcache_pop</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>release</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cache</name> <modifier>*</modifier></type><name>hcache</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>planner_hcaches</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>hcache</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>planner_hcaches</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>release</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>planner_hcaches</name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name>planner_hcaches</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>planner_hcache_exists</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>planner_hcaches</name> <operator>!=</operator> <name>NIL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Cache</name> <modifier>*</modifier></type>
<name>planner_hcache_get</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>planner_hcaches</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><operator>(</operator><name>Cache</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>planner_hcaches</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get the Hypertable corresponding to the given relid.
 *
 * This function gets a hypertable from a pre-warmed hypertable cache. If
 * noresolve is specified (true), then it will do a cache-only lookup (i.e., it
 * will not try to scan metadata for a new entry to put in the cache). This
 * allows fast lookups during planning to also determine if something is _not_ a
 * hypertable.
 */</comment>
<function><type><name>Hypertable</name> <modifier>*</modifier></type>
<name>ts_planner_get_hypertable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cache</name> <modifier>*</modifier></type><name>cache</name> <init>= <expr><call><name>planner_hcache_get</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>cache</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><call><name>ts_hypertable_cache_get_entry</name><argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ts_rte_is_hypertable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isdistributed</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name> <init>= <expr><call><name>ts_planner_get_hypertable</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>CACHE_FLAG_CHECK</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>isdistributed</name> <operator>&amp;&amp;</operator> <name>ht</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>isdistributed</name> <operator>=</operator> <call><name>hypertable_is_distributed</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>ht</name> <operator>!=</operator> <name>NULL</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_UPDL_CMD</name><parameter_list>(<parameter><type><name>parse</name></type></parameter>)</parameter_list></cpp:macro>                                                                         \
	<cpp:value>((parse)-&gt;commandType == CMD_UPDATE || (parse)-&gt;commandType == CMD_DELETE)</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>rootquery</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>current_query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl>;</decl_stmt>
	<comment type="block">/*
	 * The number of distributed hypertables in the query and its subqueries.
	 * Specifically, we count range table entries here, so using the same
	 * distributed table twice counts as two tables. No matter whether it's the
	 * same physical table or not, the range table entries can be scanned
	 * concurrently, and more than one of them being distributed means we have
	 * to use the cursor fetcher so that these scans can be interleaved.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>num_distributed_tables</name></decl>;</decl_stmt>
}</block></struct></type> <name>PreprocessQueryContext</name>;</typedef>

<comment type="block">/*
 * Preprocess the query tree, including, e.g., subqueries.
 *
 * Preprocessing includes:
 *
 * 1. Identifying all range table entries (RTEs) that reference
 *    hypertables. This will also warm the hypertable cache for faster lookup
 *    of both hypertables (cache hit) and non-hypertables (cache miss),
 *    without having to scan the metadata in either case.
 *
 * 2. Turning off inheritance for hypertable RTEs that we expand ourselves.
 *
 * 3. Reordering of GROUP BY clauses for continuous aggregates.
 *
 * 4. Constifying now() expressions for primary time dimension.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>preprocess_query</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>PreprocessQueryContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>FromExpr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>ts_guc_enable_optimizations</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FromExpr</name> <modifier>*</modifier></type><name>from</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>FromExpr</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>from</name><operator>-&gt;</operator><name>quals</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>ts_guc_enable_now_constify</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>from</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator>
					<call><name>ts_constify_now</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>current_query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>, <argument><expr><name><name>from</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/*
			 * We only amend space constraints for UPDATE/DELETE and SELECT FOR UPDATE
			 * as for normal SELECT we use our own hypertable expansion which can handle
			 * constraints on hashed space dimensions without further help.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>current_query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_SELECT</name> <operator>||</operator>
				<name><name>context</name><operator>-&gt;</operator><name>current_query</name><operator>-&gt;</operator><name>rowMarks</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>from</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <call><name>ts_add_space_constraints</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>root</name></name></expr></argument>,
													   <argument><expr><name><name>context</name><operator>-&gt;</operator><name>current_query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>,
													   <argument><expr><name><name>from</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>

	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>prev_query</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Cache</name> <modifier>*</modifier></type><name>hcache</name> <init>= <expr><call><name>planner_hcache_get</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Index</name></type> <name>rti</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>ret</name></decl>;</decl_stmt>

		<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>query-&gt;rtable</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RangeTblEntry</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl>;</decl_stmt>

			<switch>switch <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>RTE_SUBQUERY</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><name>ts_guc_enable_optimizations</name> <operator>&amp;&amp;</operator> <name>ts_guc_enable_cagg_reorder_groupby</name> <operator>&amp;&amp;</operator>
						<name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* applicable to selects on continuous aggregates */</comment>
						<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>outer_tlist</name> <init>= <expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>outer_sortcl</name> <init>= <expr><name><name>query</name><operator>-&gt;</operator><name>sortClause</name></name></expr></init></decl>;</decl_stmt>
						<expr_stmt><expr><call><name>cagg_reorder_groupby_clause</name><argument_list>(<argument><expr><name>rte</name></expr></argument>, <argument><expr><name>rti</name></expr></argument>, <argument><expr><name>outer_sortcl</name></expr></argument>, <argument><expr><name>outer_tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<break>break;</break>
				<case>case <expr><name>RTE_RELATION</name></expr>:</case>
					<comment type="block">/* This lookup will warm the cache with all hypertables in the query */</comment>
					<expr_stmt><expr><name>ht</name> <operator>=</operator> <call><name>ts_hypertable_cache_get_entry</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>CACHE_FLAG_MISSING_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name>ht</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* Mark hypertable RTEs we'd like to expand ourselves */</comment>
						<if_stmt><if>if <condition>(<expr><name>ts_guc_enable_optimizations</name> <operator>&amp;&amp;</operator> <name>ts_guc_enable_constraint_exclusion</name> <operator>&amp;&amp;</operator>
							<operator>!</operator><call><name>IS_UPDL_CMD</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>rootquery</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>query</name><operator>-&gt;</operator><name>resultRelation</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
							<name><name>query</name><operator>-&gt;</operator><name>rowMarks</name></name> <operator>==</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <name><name>rte</name><operator>-&gt;</operator><name>inh</name></name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>rte_mark_for_expansion</name><argument_list>(<argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

						<if_stmt><if>if <condition>(<expr><call><name>TS_HYPERTABLE_HAS_COMPRESSION_TABLE</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<decl_stmt><decl><type><name>int</name></type> <name>compr_htid</name> <init>= <expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>compressed_hypertable_id</name></name></expr></init></decl>;</decl_stmt>

							<comment type="block">/* Also warm the cache with the compressed
							 * companion hypertable */</comment>
							<expr_stmt><expr><name>ht</name> <operator>=</operator> <call><name>ts_hypertable_cache_get_entry_by_id</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>, <argument><expr><name>compr_htid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ht</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>

						<if_stmt><if>if <condition>(<expr><call><name>hypertable_is_distributed</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>num_distributed_tables</name></name><operator>++</operator></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/* To properly keep track of SELECT FROM ONLY &lt;chunk&gt; we
						 * have to mark the rte here because postgres will set
						 * rte-&gt;inh to false (when it detects the chunk has no
						 * children which is true for all our chunks) before it
						 * reaches set_rel_pathlist hook. But chunks from queries
						 * like SELECT ..  FROM ONLY &lt;chunk&gt; has rte-&gt;inh set to
						 * false and other chunks have rte-&gt;inh set to true.
						 * We want to distinguish between the two cases here by
						 * marking the chunk when rte-&gt;inh is true.
						 */</comment>
						<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name> <init>= <expr><call><name>ts_chunk_get_by_relid</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
						<if_stmt><if>if <condition>(<expr><name>chunk</name> <operator>&amp;&amp;</operator> <name><name>rte</name><operator>-&gt;</operator><name>inh</name></name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>rte_mark_for_expansion</name><argument_list>(<argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					</block_content>}</block></else></if_stmt>
					<break>break;</break>
				<default>default:</default>
					<break>break;</break>
			</block_content>}</block></switch>
			<expr_stmt><expr><name>rti</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><name>prev_query</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>current_query</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>current_query</name></name> <operator>=</operator> <name>query</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>query_tree_walker</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>preprocess_query</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>current_query</name></name> <operator>=</operator> <name>prev_query</name></expr>;</expr_stmt>
		<return>return <expr><name>ret</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>preprocess_query</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>PlannedStmt</name> <modifier>*</modifier></type>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG13_GE</name></expr></cpp:if>
<name>timescaledb_planner</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parse</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query_string</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cursor_opts</name></decl></parameter>,
					<parameter><decl><type><name>ParamListInfo</name></type> <name>bound_params</name></decl></parameter>)</parameter_list>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
timescaledb_planner<parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parse</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cursor_opts</name></decl></parameter>, <parameter><decl><type><name>ParamListInfo</name></type> <name>bound_params</name></decl></parameter>)</parameter_list>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>stmt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<comment type="block">/*
	 * Volatile is needed because these are the local variables that are
	 * modified between setjmp/longjmp calls.
	 */</comment>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>bool</name></type> <name>reset_fetcher_type</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>bool</name></type> <name>reset_baserel_info</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If we are in an aborted transaction, reject all queries.
	 * While this state will not happen during normal operation it
	 * can happen when executing plpgsql procedures.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsAbortedTransactionBlockState</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_IN_FAILED_SQL_TRANSACTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"current transaction is aborted, "</literal>
						<literal type="string">"commands ignored until end of transaction block"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>planner_hcache_push</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PreprocessQueryContext</name></type> <name>context</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PlannerGlobal</name></type> <name>glob</name> <init>= <expr><block>{
			<expr><operator>.</operator><name>boundParams</name> <operator>=</operator> <name>bound_params</name></expr>,
		}</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PlannerInfo</name></type> <name>root</name> <init>= <expr><block>{
			<expr><operator>.</operator><name>glob</name> <operator>=</operator> <operator>&amp;</operator><name>glob</name></expr>,
		}</block></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>context</name><operator>.</operator><name>root</name></name> <operator>=</operator> <operator>&amp;</operator><name>root</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>.</operator><name>rootquery</name></name> <operator>=</operator> <name>parse</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>.</operator><name>current_query</name></name> <operator>=</operator> <name>parse</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>ts_extension_is_loaded</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_TELEMETRY</name></cpp:ifdef>
			<expr_stmt><expr><call><name>ts_telemetry_function_info_gather</name><argument_list>(<argument><expr><name>parse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<comment type="block">/*
			 * Preprocess the hypertables in the query and warm up the caches.
			 */</comment>
			<expr_stmt><expr><call><name>preprocess_query</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>parse</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Determine which type of fetcher to use. If set by GUC, use what
			 * is set. If the GUC says 'auto', use the COPY fetcher if we
			 * have at most one distributed table in the query. This enables
			 * parallel plans on data nodes, which speeds up the query.
			 * We can't use parallel plans with the cursor fetcher, because the
			 * cursors don't support parallel execution. This is because a
			 * cursor can be suspended at any time, then some arbitrary user
			 * code can be executed, and then the cursor is resumed. The
			 * parallel infrastructure doesn't have enough reentrability to
			 * survive this.
			 * We have to use a cursor fetcher when we have multiple distributed
			 * tables, because we might first have to get some rows from one
			 * table and then from another, without running either of them to
			 * completion first. This happens e.g. when doing a join. If we had
			 * a connection per table, we could avoid this requirement.
			 *
			 * Note that this function can be called recursively, e.g. when
			 * trying to evaluate an SQL function at the planning stage. We must
			 * only set/reset the fetcher type at the topmost level, that's why
			 * we check it's not already set.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>ts_data_node_fetcher_scan_type</name> <operator>==</operator> <name>AutoFetcherType</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>reset_fetcher_type</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>.</operator><name>num_distributed_tables</name></name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>ts_guc_remote_data_fetcher</name> <operator>==</operator> <name>CopyFetcherType</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COPY fetcher not supported"</literal></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"COPY fetching of data is not supported in "</literal>
										 <literal type="string">"queries with multiple distributed hypertables."</literal>
										 <literal type="string">" Use cursor fetcher instead."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><name>ts_data_node_fetcher_scan_type</name> <operator>=</operator> <name>CursorFetcherType</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>ts_guc_remote_data_fetcher</name> <operator>==</operator> <name>AutoFetcherType</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>ts_data_node_fetcher_scan_type</name> <operator>=</operator> <name>CopyFetcherType</name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><name>ts_data_node_fetcher_scan_type</name> <operator>=</operator> <name>ts_guc_remote_data_fetcher</name></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>ts_baserel_info</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * The calls to timescaledb_planner can be recursive (e.g. when
				 * evaluating an immutable SQL function at planning time). We
				 * want to create and destroy the per-query baserel info table
				 * only at the top-level call, hence this flag.
				 */</comment>
				<expr_stmt><expr><name>reset_baserel_info</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * This is a per-query cache, so we create it in the current
				 * memory context for the top-level call of this function, which
				 * hopefully should exist for the duration of the query. Message
				 * or portal memory contexts could also be suitable, but they
				 * don't exist for SPI calls.
				 */</comment>
				<expr_stmt><expr><name>ts_baserel_info</name> <operator>=</operator> <call><name>BaserelInfo_create</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
													 <comment type="block">/* nelements = */</comment> <argument><expr><literal type="number">1</literal></expr></argument>,
													 <comment type="block">/* private_data = */</comment> <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>prev_planner_hook</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/* Call any earlier hooks */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG13_GE</name></expr></cpp:if>
			<expr_stmt><expr><name>stmt</name> <operator>=</operator> <operator>(</operator><name>prev_planner_hook</name><operator>)</operator> <operator>(</operator><name>parse</name><operator>,</operator> <name>query_string</name><operator>,</operator> <name>cursor_opts</name><operator>,</operator> <name>bound_params</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<expr_stmt><expr><name>stmt</name> <operator>=</operator> <operator>(</operator><name>prev_planner_hook</name><operator>)</operator> <operator>(</operator><name>parse</name><operator>,</operator> <name>cursor_opts</name><operator>,</operator> <name>bound_params</name><operator>)</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<if_stmt><else>else<block type="pseudo"><block_content>
		<comment type="block">/* Call the standard planner */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG13_GE</name></expr></cpp:if>
			<expr_stmt><expr><name>stmt</name> <operator>=</operator> <call><name>standard_planner</name><argument_list>(<argument><expr><name>parse</name></expr></argument>, <argument><expr><name>query_string</name></expr></argument>, <argument><expr><name>cursor_opts</name></expr></argument>, <argument><expr><name>bound_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<expr_stmt><expr><name>stmt</name> <operator>=</operator> <call><name>standard_planner</name><argument_list>(<argument><expr><name>parse</name></expr></argument>, <argument><expr><name>cursor_opts</name></expr></argument>, <argument><expr><name>bound_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<if_stmt><if>if <condition>(<expr><call><name>ts_extension_is_loaded</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Our top-level HypertableInsert plan node that wraps ModifyTable needs
			 * to have a final target list that is the same as the ModifyTable plan
			 * node, and we only have access to its final target list after
			 * set_plan_references() (setrefs.c) has run at the end of
			 * standard_planner. Therefore, we fixup the final target list for
			 * HypertableInsert here.
			 */</comment>
			<expr_stmt><expr><call><name>ts_hypertable_modify_fixup_tlist</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>planTree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>stmt-&gt;subplans</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>subplan</name> <init>= <expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>subplan</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ts_hypertable_modify_fixup_tlist</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>reset_baserel_info</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ts_baserel_info</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>BaserelInfo_destroy</name><argument_list>(<argument><expr><name>ts_baserel_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ts_baserel_info</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>reset_fetcher_type</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>ts_data_node_fetcher_scan_type</name> <operator>=</operator> <name>AutoFetcherType</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>reset_baserel_info</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ts_baserel_info</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>BaserelInfo_destroy</name><argument_list>(<argument><expr><name>ts_baserel_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ts_baserel_info</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>reset_fetcher_type</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>ts_data_node_fetcher_scan_type</name> <operator>=</operator> <name>AutoFetcherType</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Pop the cache, but do not release since caches are auto-released on
		 * error */</comment>
		<expr_stmt><expr><call><name>planner_hcache_pop</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>planner_hcache_pop</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>stmt</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>RangeTblEntry</name> <modifier>*</modifier></type>
<name>get_parent_rte</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>rti</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* Fast path when arrays are setup */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>append_rel_array</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>root</name><operator>-&gt;</operator><name>append_rel_array</name><index>[<expr><name>rti</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appinfo</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>append_rel_array</name><index>[<expr><name>rti</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<return>return <expr><call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name><name>appinfo</name><operator>-&gt;</operator><name>parent_relid</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>root-&gt;append_rel_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appinfo</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>AppendRelInfo</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>appinfo</name><operator>-&gt;</operator><name>child_relid</name></name> <operator>==</operator> <name>rti</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name><name>appinfo</name><operator>-&gt;</operator><name>parent_relid</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Fetch cached baserel entry. If it does not exists, create an entry for this
 * relid.
 * If this relid corresponds to a chunk, cache additional chunk
 * related metadata: like chunk_status and pointer to hypertable entry.
 * It is okay to cache a pointer to the hypertable, since this cache is
 * confined to the lifetime of the query and not used across queries.
 * If the parent reolid is known, the caller can specify it to avoid the costly
 * lookup. Otherwise pass InvalidOid.
 */</comment>
<function><type><specifier>static</specifier> <name>BaserelInfoEntry</name> <modifier>*</modifier></type>
<name>get_or_add_baserel_from_cache</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>chunk_reloid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>parent_reloid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<comment type="block">/* First, check if this reloid is in cache. */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BaserelInfoEntry</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><call><name>BaserelInfo_insert</name><argument_list>(<argument><expr><name>ts_baserel_info</name></expr></argument>, <argument><expr><name>chunk_reloid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>entry</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>parent_reloid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>ht</name> <operator>=</operator> <call><name>ts_planner_get_hypertable</name><argument_list>(<argument><expr><name>parent_reloid</name></expr></argument>, <argument><expr><name>CACHE_FLAG_CHECK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
		<comment type="block">/* Sanity check on the caller-specified hypertable reloid. */</comment>
		<decl_stmt><decl><type><name>int32</name></type> <name>parent_hypertable_id</name> <init>= <expr><call><name>ts_chunk_get_hypertable_id_by_relid</name><argument_list>(<argument><expr><name>chunk_reloid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>parent_hypertable_id</name> <operator>!=</operator> <name>INVALID_HYPERTABLE_ID</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ts_hypertable_id_to_relid</name><argument_list>(<argument><expr><name>parent_hypertable_id</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>parent_reloid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>ht</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name> <operator>==</operator> <name>parent_hypertable_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Hypertable reloid not specified by the caller, look it up by
		 * an expensive metadata scan.
		 */</comment>
		<decl_stmt><decl><type><name>int32</name></type> <name>hypertable_id</name> <init>= <expr><call><name>ts_chunk_get_hypertable_id_by_relid</name><argument_list>(<argument><expr><name>chunk_reloid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>hypertable_id</name> <operator>!=</operator> <name>INVALID_HYPERTABLE_ID</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Hypertable reloid not specified by the caller, look it up. */</comment>
			<expr_stmt><expr><name>parent_reloid</name> <operator>=</operator> <call><name>ts_hypertable_id_to_relid</name><argument_list>(<argument><expr><name>hypertable_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Ensure</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>parent_reloid</name></expr></argument>)</argument_list></call></expr></argument>,
				   <argument><expr><literal type="string">"unable to get valid parent Oid for hypertable %d"</literal></expr></argument>,
				   <argument><expr><name>hypertable_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>ht</name> <operator>=</operator> <call><name>ts_planner_get_hypertable</name><argument_list>(<argument><expr><name>parent_reloid</name></expr></argument>, <argument><expr><name>CACHE_FLAG_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ht</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name> <operator>==</operator> <name>hypertable_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Cache the result. */</comment>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>ht</name></name> <operator>=</operator> <name>ht</name></expr>;</expr_stmt>
	<return>return <expr><name>entry</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Classify a planned relation.
 *
 * This makes use of cache warming that happened during Query preprocessing in
 * the first planner hook.
 */</comment>
<function><type><specifier>static</specifier> <name>TsRelType</name></type>
<name>classify_relation</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>Hypertable</name> <modifier>*</modifier><modifier>*</modifier></type><name>ht</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ht</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>ht</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>!=</operator> <name>RELOPT_BASEREL</name> <operator>&amp;&amp;</operator> <name><name>rel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>!=</operator> <name>RELOPT_OTHER_MEMBER_REL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>TS_REL_OTHER</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>TS_REL_OTHER</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>==</operator> <name>RELOPT_BASEREL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * To correctly classify relations in subqueries we cannot call
		 * ts_planner_get_hypertable with CACHE_FLAG_CHECK which includes
		 * CACHE_FLAG_NOCREATE flag because the rel might not be in cache yet.
		 */</comment>
		<expr_stmt><expr><operator>*</operator><name>ht</name> <operator>=</operator> <call><name>ts_planner_get_hypertable</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>CACHE_FLAG_MISSING_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ht</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>TS_REL_HYPERTABLE</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * This is either a chunk seen as a standalone table, or a non-chunk
		 * baserel. We need a costly chunk metadata scan to distinguish between
		 * them, so we cache the result of this lookup to avoid doing it
		 * repeatedly.
		 */</comment>
		<decl_stmt><decl><type><name>BaserelInfoEntry</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><call><name>get_or_add_baserel_from_cache</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><operator>*</operator><name>ht</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>ht</name></name></expr>;</expr_stmt>
		<return>return <expr><ternary><condition><expr><operator>*</operator><name>ht</name></expr> ?</condition><then> <expr><name>TS_REL_CHUNK_STANDALONE</name></expr> </then><else>: <expr><name>TS_REL_OTHER</name></expr></else></ternary></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>==</operator> <name>RELOPT_OTHER_MEMBER_REL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>parent_rte</name> <init>= <expr><call><name>get_parent_rte</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * An entry of reloptkind RELOPT_OTHER_MEMBER_REL might still
	 * be a hypertable here if it was pulled up from a subquery
	 * as happens with UNION ALL for example. So we have to
	 * check for that to properly detect that pattern.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>parent_rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>ht</name> <operator>=</operator> <call><name>ts_planner_get_hypertable</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,
										<argument><expr><ternary><condition><expr><name><name>rte</name><operator>-&gt;</operator><name>inh</name></name></expr> ?</condition><then> <expr><name>CACHE_FLAG_MISSING_OK</name></expr> </then><else>: <expr><name>CACHE_FLAG_CHECK</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><ternary><condition><expr><operator>*</operator><name>ht</name></expr> ?</condition><then> <expr><name>TS_REL_HYPERTABLE</name></expr> </then><else>: <expr><name>TS_REL_OTHER</name></expr></else></ternary></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>parent_rte</name><operator>-&gt;</operator><name>relid</name></name> <operator>==</operator> <name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * A PostgreSQL table expansion peculiarity -- "self child", the root
		 * table that is expanded as a child of itself. This happens when our
		 * expansion code is turned off.
		 */</comment>
		<expr_stmt><expr><operator>*</operator><name>ht</name> <operator>=</operator> <call><name>ts_planner_get_hypertable</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>CACHE_FLAG_CHECK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><ternary><condition><expr><operator>*</operator><name>ht</name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><name>TS_REL_HYPERTABLE_CHILD</name></expr> </then><else>: <expr><name>TS_REL_OTHER</name></expr></else></ternary></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Either an other baserel or a chunk seen when expanding the hypertable.
	 * Use the baserel cache to determine what it is.
	 */</comment>
	<decl_stmt><decl><type><name>BaserelInfoEntry</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><call><name>get_or_add_baserel_from_cache</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name><name>parent_rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><operator>*</operator><name>ht</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>ht</name></name></expr>;</expr_stmt>
	<return>return <expr><ternary><condition><expr><operator>*</operator><name>ht</name></expr> ?</condition><then> <expr><name>TS_REL_CHUNK_CHILD</name></expr> </then><else>: <expr><name>TS_REL_OTHER</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>ts_sort_transform_optimization</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>should_chunk_append</name><parameter_list>(<parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ordered</name></decl></parameter>,
					<parameter><decl><type><name>int</name></type> <name>order_attno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_LT</name></expr></cpp:if>
		<expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_SELECT</name> <operator>||</operator>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<comment type="block">/*
		 * We only support chunk exclusion on UPDATE/DELETE when no JOIN is involved on PG14+.
		 */</comment>
		<operator>(</operator><operator>(</operator><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_DELETE</name> <operator>||</operator> <name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UPDATE</name><operator>)</operator> <operator>&amp;&amp;</operator>
		 <call><name>bms_num_members</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>all_baserels</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>||</operator>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<operator>!</operator><name>ts_guc_enable_chunk_append</name> <operator>||</operator> <call><name>hypertable_is_distributed</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_AppendPath</name></expr>:</case>
			<comment type="block">/*
			 * If there are clauses that have mutable functions, or clauses that reference
			 * Params this Path might benefit from startup or runtime exclusion
			 */</comment>
			<block>{<block_content>
				<decl_stmt><decl><type><name>AppendPath</name> <modifier>*</modifier></type><name>append</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>AppendPath</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

				<comment type="block">/* Don't create ChunkAppend with no children */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>append</name><operator>-&gt;</operator><name>subpaths</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

				<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>rel-&gt;baserestrictinfo</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>contain_mutable_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
						<call><name>ts_contain_param</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block>
				<return>return <expr><name>false</name></expr>;</return>
				<break>break;</break>
			</block_content>}</block>
		<case>case <expr><name>T_MergeAppendPath</name></expr>:</case>
			<comment type="block">/*
			 * Can we do ordered append
			 */</comment>
			<block>{<block_content>
				<decl_stmt><decl><type><name>MergeAppendPath</name> <modifier>*</modifier></type><name>merge</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>MergeAppendPath</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>PathKey</name> <modifier>*</modifier></type><name>pk</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ordered</name> <operator>||</operator> <name><name>path</name><operator>-&gt;</operator><name>pathkeys</name></name> <operator>==</operator> <name>NIL</name> <operator>||</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>merge</name><operator>-&gt;</operator><name>subpaths</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

				<comment type="block">/* cannot support ordered append with OSM chunks. OSM chunk
				 * ranges are not recorded with the catalog
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>ht</name> <operator>&amp;&amp;</operator> <call><name>ts_chunk_get_osm_chunk_id</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>INVALID_CHUNK_ID</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>pk</name> <operator>=</operator> <call><name>linitial_node</name><argument_list>(<argument><expr><name>PathKey</name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Check PathKey is compatible with Ordered Append ordering
				 * we created when expanding hypertable.
				 * Even though ordered is true on the RelOptInfo we have to
				 * double check that current Path fulfills requirements for
				 * Ordered Append transformation because the RelOptInfo may
				 * be used for multiple Pathes.
				 */</comment>
				<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>em_expr</name> <init>= <expr><call><name>find_em_expr_for_rel</name><argument_list>(<argument><expr><name><name>pk</name><operator>-&gt;</operator><name>pk_eclass</name></name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * If this is a join the ordering information might not be
				 * for the current rel and have no EquivalenceMember.
				 */</comment>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>em_expr</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>em_expr</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>Var</name></expr></argument>, <argument><expr><name>em_expr</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>varattno</name> <operator>==</operator> <name>order_attno</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>em_expr</name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>func</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>FuncExpr</name></expr></argument>, <argument><expr><name>em_expr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>FuncInfo</name> <modifier>*</modifier></type><name>info</name> <init>= <expr><call><name>ts_func_cache_get_bucketing_func</name><argument_list>(<argument><expr><name><name>func</name><operator>-&gt;</operator><name>funcid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>transformed</name></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>info</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>transformed</name> <operator>=</operator> <call><name><name>info</name><operator>-&gt;</operator><name>sort_transform</name></name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>transformed</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
							<call><name>castNode</name><argument_list>(<argument><expr><name>Var</name></expr></argument>, <argument><expr><name>transformed</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>varattno</name> <operator>==</operator> <name>order_attno</name></expr>)</condition><block type="pseudo"><block_content>
							<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<return>return <expr><name>false</name></expr>;</return>
				<break>break;</break>
			</block_content>}</block>
		<default>default:</default>
			<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>should_constraint_aware_append</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Constraint-aware append currently expects children that scans a real
	 * "relation" (e.g., not an "upper" relation). So, we do not run it on a
	 * distributed hypertable because the append children are typically
	 * per-server relations without a corresponding "real" table in the
	 * system. Further, per-server appends shouldn't need runtime pruning in any
	 * case. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_SELECT</name> <operator>||</operator> <call><name>hypertable_is_distributed</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><call><name>ts_constraint_aware_append_possible</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>rte_should_expand</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>is_hypertable</name> <init>= <expr><call><name>ts_rte_is_hypertable</name><argument_list>(<argument><expr><name>rte</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>is_hypertable</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>rte</name><operator>-&gt;</operator><name>inh</name></name> <operator>&amp;&amp;</operator> <call><name>ts_rte_is_marked_for_expansion</name><argument_list>(<argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>reenable_inheritance</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>rti</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>set_pathlist_for_current_rel</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>total_pages</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>reenabled_inheritance</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rel_array_size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>in_rte</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>simple_rte_array</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>rte_should_expand</name><argument_list>(<argument><expr><name>in_rte</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>in_rel</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>simple_rel_array</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name> <init>= <expr><call><name>ts_planner_get_hypertable</name><argument_list>(<argument><expr><name><name>in_rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>CACHE_FLAG_NOCREATE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ht</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>in_rel</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ts_plan_expand_hypertable_chunks</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>in_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>in_rte</name><operator>-&gt;</operator><name>inh</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>reenabled_inheritance</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<comment type="block">/* Redo set_rel_consider_parallel, as results of the call may no longer be valid here
			 * (due to adding more tables to the set of tables under consideration here). This is
			 * especially true if dealing with foreign data wrappers. */</comment>

			<comment type="block">/*
			 * An entry of reloptkind RELOPT_OTHER_MEMBER_REL might still
			 * be a hypertable here if it was pulled up from a subquery
			 * as happens with UNION ALL for example.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>in_rel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>==</operator> <name>RELOPT_BASEREL</name> <operator>||</operator>
				<name><name>in_rel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>==</operator> <name>RELOPT_OTHER_MEMBER_REL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>in_rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ts_set_rel_size</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>in_rel</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>in_rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* if we're activating inheritance during a hypertable's pathlist
			 * creation then we're past the point at which postgres will add
			 * paths for the children, and we have to do it ourselves. We delay
			 * the actual setting of the pathlists until after this loop,
			 * because set_append_rel_pathlist will eventually call this hook again.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>in_rte</name> <operator>==</operator> <name>rte</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rti</name> <operator>==</operator> <operator>(</operator><name>Index</name><operator>)</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>set_pathlist_for_current_rel</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>reenabled_inheritance</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>total_pages</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rel_array_size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>brel</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>simple_rel_array</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>brel</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>brel</name><operator>-&gt;</operator><name>relid</name></name> <operator>==</operator> <operator>(</operator><name>Index</name><operator>)</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* sanity check on array */</comment>

		<if_stmt><if>if <condition>(<expr><call><name>IS_DUMMY_REL</name><argument_list>(<argument><expr><name>brel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IS_SIMPLE_REL</name><argument_list>(<argument><expr><name>brel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>total_pages</name> <operator>+=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name><name>brel</name><operator>-&gt;</operator><name>pages</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>total_table_pages</name></name> <operator>=</operator> <name>total_pages</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>set_pathlist_for_current_rel</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>do_distributed</name></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name> <init>= <expr><call><name>ts_planner_get_hypertable</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>CACHE_FLAG_NOCREATE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ht</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* the hypertable will have been planned as if it was a regular table
		 * with no data. Since such a plan would be cheaper than any real plan,
		 * it would always be used, and we need to remove these plans before
		 * adding ours.
		 *
		 * Also, if it's a distributed hypertable and per data node queries are
		 * enabled then we will be throwing this below append path away. So only
		 * build it otherwise
		 */</comment>
		<expr_stmt><expr><name>do_distributed</name> <operator>=</operator> <operator>!</operator><call><name>IS_DUMMY_REL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>hypertable_is_distributed</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
						 <name>ts_guc_enable_per_data_node_queries</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>pathlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>partial_pathlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<comment type="block">/* allow a session parameter to override the use of this datanode only path */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TS_DEBUG</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><name>do_distributed</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>allow_dn_path</name> <init>=
				<expr><call><name>GetConfigOption</name><argument_list>(<argument><expr><literal type="string">"timescaledb.debug_allow_datanode_only_path"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>allow_dn_path</name> <operator>&amp;&amp;</operator> <call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>allow_dn_path</name></expr></argument>, <argument><expr><literal type="string">"on"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>do_distributed</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"creating per chunk append paths"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"avoiding per chunk append paths"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>do_distributed</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ts_set_append_rel_pathlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rti</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>apply_optimizations</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>TsRelType</name></type> <name>reltype</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>,
					<parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ts_guc_enable_optimizations</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><name>reltype</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>TS_REL_HYPERTABLE_CHILD</name></expr>:</case>
			<comment type="block">/* empty table so nothing to optimize */</comment>
			<break>break;</break>
		<case>case <expr><name>TS_REL_CHUNK_STANDALONE</name></expr>:</case>
		<case>case <expr><name>TS_REL_CHUNK_CHILD</name></expr>:</case>
			<expr_stmt><expr><call><name>ts_sort_transform_optimization</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * Since the sort optimization adds new paths to the rel it has
	 * to happen before any optimizations that replace pathlist.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ts_cm_functions</name><operator>-&gt;</operator><name>set_rel_pathlist_query</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name><name>ts_cm_functions</name><operator>-&gt;</operator><name>set_rel_pathlist_query</name></name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>reltype</name> <operator>==</operator> <name>TS_REL_HYPERTABLE</name> <operator>&amp;&amp;</operator>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_GE</name></expr></cpp:if>
		<operator>(</operator><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name> <operator>||</operator> <name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_DELETE</name> <operator>||</operator>
		 <name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UPDATE</name><operator>)</operator>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<comment type="block">/*
		 * For PG &lt; 14 commandType will be CMD_SELECT even when planning DELETE so we
		 * check resultRelation instead.
		 */</comment>
		<name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>resultRelation</name></name> <operator>==</operator> <literal type="number">0</literal></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TimescaleDBPrivate</name> <modifier>*</modifier></type><name>private</name> <init>= <expr><call><name>ts_get_private_reloptinfo</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>ordered</name> <init>= <expr><name><name>private</name><operator>-&gt;</operator><name>appends_ordered</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>order_attno</name> <init>= <expr><name><name>private</name><operator>-&gt;</operator><name>order_attno</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>nested_oids</name> <init>= <expr><name><name>private</name><operator>-&gt;</operator><name>nested_oids</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ht</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>rel-&gt;pathlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Path</name> <modifier>*</modifier><modifier>*</modifier></type><name>pathptr</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>*</operator><operator>)</operator> <operator>&amp;</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><operator>*</operator><name>pathptr</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>T_AppendPath</name></expr>:</case>
				<case>case <expr><name>T_MergeAppendPath</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><call><name>should_chunk_append</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>*</operator><name>pathptr</name></expr></argument>, <argument><expr><name>ordered</name></expr></argument>, <argument><expr><name>order_attno</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><operator>*</operator><name>pathptr</name> <operator>=</operator> <call><name>ts_chunk_append_path_create</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
															   <argument><expr><name>rel</name></expr></argument>,
															   <argument><expr><name>ht</name></expr></argument>,
															   <argument><expr><operator>*</operator><name>pathptr</name></expr></argument>,
															   <argument><expr><name>false</name></expr></argument>,
															   <argument><expr><name>ordered</name></expr></argument>,
															   <argument><expr><name>nested_oids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<if type="elseif">else if <condition>(<expr><call><name>should_constraint_aware_append</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>ht</name></expr></argument>, <argument><expr><operator>*</operator><name>pathptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><operator>*</operator><name>pathptr</name> <operator>=</operator> <call><name>ts_constraint_aware_append_path_create</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>*</operator><name>pathptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<break>break;</break>
				<default>default:</default>
					<break>break;</break>
			</block_content>}</block></switch>
		</block_content>}</block>

		<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>rel-&gt;partial_pathlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Path</name> <modifier>*</modifier><modifier>*</modifier></type><name>pathptr</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>*</operator><operator>)</operator> <operator>&amp;</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><operator>*</operator><name>pathptr</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>T_AppendPath</name></expr>:</case>
				<case>case <expr><name>T_MergeAppendPath</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><call><name>should_chunk_append</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>*</operator><name>pathptr</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><operator>*</operator><name>pathptr</name> <operator>=</operator>
							<call><name>ts_chunk_append_path_create</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ht</name></expr></argument>, <argument><expr><operator>*</operator><name>pathptr</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<if type="elseif">else if <condition>(<expr><call><name>should_constraint_aware_append</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>ht</name></expr></argument>, <argument><expr><operator>*</operator><name>pathptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><operator>*</operator><name>pathptr</name> <operator>=</operator> <call><name>ts_constraint_aware_append_path_create</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>*</operator><name>pathptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<break>break;</break>
				<default>default:</default>
					<break>break;</break>
			</block_content>}</block></switch>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>valid_hook_call</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>ts_extension_is_loaded</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>planner_hcache_exists</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>dml_involves_hypertable</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>rti</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Index</name></type> <name>result_rti</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>resultRelation</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>result_rte</name> <init>= <expr><call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name>result_rti</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>result_rti</name> <operator>==</operator> <name>rti</name> <operator>||</operator> <name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name> <operator>==</operator> <name><name>result_rte</name><operator>-&gt;</operator><name>relid</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>timescaledb_set_rel_pathlist</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>rti</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TsRelType</name></type> <name>reltype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl>;</decl_stmt>

	<comment type="block">/* Quick exit if this is a relation we're not interested in */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>valid_hook_call</name><argument_list>()</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IS_DUMMY_REL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>prev_set_rel_pathlist_hook</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call>(<modifier>*</modifier><name>prev_set_rel_pathlist_hook</name>)<argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rti</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>reltype</name> <operator>=</operator> <call><name>classify_relation</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check for unexpanded hypertable */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rte</name><operator>-&gt;</operator><name>inh</name></name> <operator>&amp;&amp;</operator> <call><name>ts_rte_is_marked_for_expansion</name><argument_list>(<argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>reenable_inheritance</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rti</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>ts_guc_enable_optimizations</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ts_planner_constraint_cleanup</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Call other extensions. Do it after table expansion. */</comment>
	<if_stmt><if>if <condition>(<expr><name>prev_set_rel_pathlist_hook</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call>(<modifier>*</modifier><name>prev_set_rel_pathlist_hook</name>)<argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rti</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ts_cm_functions</name><operator>-&gt;</operator><name>set_rel_pathlist</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name><name>ts_cm_functions</name><operator>-&gt;</operator><name>set_rel_pathlist</name></name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rti</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><name>reltype</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>TS_REL_HYPERTABLE_CHILD</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>ts_guc_enable_optimizations</name> <operator>&amp;&amp;</operator> <call><name>IS_UPDL_CMD</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ts_planner_constraint_cleanup</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<break>break;</break>
		<case>case <expr><name>TS_REL_CHUNK_STANDALONE</name></expr>:</case>
		<case>case <expr><name>TS_REL_CHUNK_CHILD</name></expr>:</case>
			<comment type="block">/* Check for UPDATE/DELETE (DML) on compressed chunks */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>IS_UPDL_CMD</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>dml_involves_hypertable</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>ht</name></expr></argument>, <argument><expr><name>rti</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>ts_cm_functions</name><operator>-&gt;</operator><name>set_rel_pathlist_dml</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name><name>ts_cm_functions</name><operator>-&gt;</operator><name>set_rel_pathlist_dml</name></name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rti</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>TS_FALLTHROUGH</name></expr>;</expr_stmt>
		<default>default:</default>
			<expr_stmt><expr><call><name>apply_optimizations</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>reltype</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/* This hook is meant to editorialize about the information the planner gets
 * about a relation. We use it to attach our own metadata to hypertable and
 * chunk relations that we need during planning. We also expand hypertables
 * here. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>timescaledb_get_relation_info_hook</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relation_objectid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>inhparent</name></decl></parameter>,
								   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>prev_get_relation_info_hook</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>prev_get_relation_info_hook</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>relation_objectid</name></expr></argument>, <argument><expr><name>inhparent</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>valid_hook_call</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><call><name>classify_relation</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ht</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>TS_REL_HYPERTABLE</name></expr>:</case>
		<block>{<block_content>
			<comment type="block">/* This only works for PG12 because for earlier versions the inheritance
			 * expansion happens too early during the planning phase
			 */</comment>
			<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
			<comment type="block">/* Mark hypertable RTEs we'd like to expand ourselves.
			 * Hypertables inside inlineable functions don't get marked during the query
			 * preprocessing step. Therefore we do an extra try here. However, we need to
			 * be careful for UPDATE/DELETE as Postgres (in at least version 12) plans them
			 * in a complicated way (see planner.c:inheritance_planner). First, it runs the
			 * UPDATE/DELETE through the planner as a simulated SELECT. It uses the results
			 * of this fake planning to adapt its own UPDATE/DELETE plan. Then it's planned
			 * a second time as a real UPDATE/DELETE, but with requiredPerms set to 0, as it
			 * assumes permission checking has been done already during the first planner call.
			 * We don't want to touch the UPDATE/DELETEs, so we need to check all the regular
			 * conditions here that are checked during preprocess_query, as well as the
			 * condition that rte-&gt;requiredPerms is not requiring UPDATE/DELETE on this rel.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>ts_guc_enable_optimizations</name> <operator>&amp;&amp;</operator> <name>ts_guc_enable_constraint_exclusion</name> <operator>&amp;&amp;</operator> <name>inhparent</name> <operator>&amp;&amp;</operator>
				<name><name>rte</name><operator>-&gt;</operator><name>ctename</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IS_UPDL_CMD</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>query</name><operator>-&gt;</operator><name>resultRelation</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
				<name><name>query</name><operator>-&gt;</operator><name>rowMarks</name></name> <operator>==</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>rte</name><operator>-&gt;</operator><name>requiredPerms</name></name> <operator>&amp;</operator> <operator>(</operator><name>ACL_UPDATE</name> <operator>|</operator> <name>ACL_DELETE</name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>rte_mark_for_expansion</name><argument_list>(<argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>ts_create_private_reloptinfo</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ts_plan_expand_timebucket_annotate</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>
		<case>case <expr><name>TS_REL_CHUNK_STANDALONE</name></expr>:</case>
		<case>case <expr><name>TS_REL_CHUNK_CHILD</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ts_create_private_reloptinfo</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>ts_guc_enable_transparent_decompression</name> <operator>&amp;&amp;</operator> <call><name>TS_HYPERTABLE_HAS_COMPRESSION_TABLE</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>chunk_rte</name> <init>= <expr><call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name> <init>= <expr><call><name>ts_chunk_get_by_relid</name><argument_list>(<argument><expr><name><name>chunk_rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>compressed_chunk_id</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Relation</name></type> <name>uncompressed_chunk</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>relation_objectid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>ts_get_private_reloptinfo</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>compressed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

					<comment type="block">/* Planning indexes are expensive, and if this is a compressed chunk, we
					 * know we'll never need to use indexes on the uncompressed version, since
					 * all the data is in the compressed chunk anyway. Therefore, it is much
					 * faster if we simply trash the indexlist here and never plan any useless
					 * IndexPaths at all
					 */</comment>
					<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>indexlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

					<comment type="block">/* Relation size estimates are messed up on compressed chunks due to there
					 * being no actual pages for the table in the storage manager.
					 */</comment>
					<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>pages</name></name> <operator>=</operator> <operator>(</operator><name>BlockNumber</name><operator>)</operator> <name><name>uncompressed_chunk</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpages</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>tuples</name></name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name><name>uncompressed_chunk</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltuples</name></name></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>pages</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>allvisfrac</name></name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt></block_content></block></if>
					<if type="elseif">else if <condition>(<expr><name><name>uncompressed_chunk</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relallvisible</name></name> <operator>&gt;=</operator> <operator>(</operator><name>int32</name><operator>)</operator> <name><name>rel</name><operator>-&gt;</operator><name>pages</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>allvisfrac</name></name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>allvisfrac</name></name> <operator>=</operator>
							<operator>(</operator><name>double</name><operator>)</operator> <name><name>uncompressed_chunk</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relallvisible</name></name> <operator>/</operator> <name><name>rel</name><operator>-&gt;</operator><name>pages</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

					<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>uncompressed_chunk</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		</block_content>}</block>
		<case>case <expr><name>TS_REL_HYPERTABLE_CHILD</name></expr>:</case>
			<comment type="block">/* When postgres expands an inheritance tree it also adds the
			 * parent hypertable as child relation. Since for a hypertable the
			 * parent will never have any data we can mark this relation as
			 * dummy relation so it gets ignored in later steps. This is only
			 * relevant for code paths that use the postgres inheritance code
			 * as we don't include the hypertable as child when expanding the
			 * hypertable ourself.
			 * We do exclude distributed hypertables for now to not alter
			 * the trigger behaviour on access nodes, which would otherwise
			 * no longer fire.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>IS_UPDL_CMD</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>hypertable_is_distributed</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>mark_dummy_rel</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>TS_REL_OTHER</name></expr>:</case>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>join_involves_hypertable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>relid</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>relid</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>rte</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<comment type="block">/* This might give a false positive for chunks in case of PostgreSQL
			 * expansion since the ctename is copied from the parent hypertable
			 * to the chunk */</comment>
			<return>return <expr><call><name>ts_rte_is_marked_for_expansion</name><argument_list>(<argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></while>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>involves_hypertable</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>==</operator> <name>RELOPT_JOINREL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>join_involves_hypertable</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl>;</decl_stmt>
	<return>return <expr><call><name>classify_relation</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ht</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>TS_REL_HYPERTABLE</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Replace INSERT (ModifyTablePath) paths on hypertables.
 *
 * From the ModifyTable description: "Each ModifyTable node contains
 * a list of one or more subplans, much like an Append node.  There
 * is one subplan per result relation."
 *
 * The subplans produce the tuples for INSERT, while the result relation is the
 * table we'd like to insert into.
 *
 * The way we redirect tuples to chunks is to insert an intermediate "chunk
 * dispatch" plan node, between the ModifyTable and its subplan that produces
 * the tuples. When the ModifyTable plan is executed, it tries to read a tuple
 * from the intermediate chunk dispatch plan instead of the original
 * subplan. The chunk plan reads the tuple from the original subplan, looks up
 * the chunk, sets the executor's resultRelation to the chunk table and finally
 * returns the tuple to the ModifyTable node.
 *
 * We also need to wrap the ModifyTable plan node with a HypertableInsert node
 * to give the ChunkDispatchState node access to the ModifyTableState node in
 * the execution phase.
 *
 * Conceptually, the plan modification looks like this:
 *
 * Original plan:
 *
 *		  ^
 *		  |
 *	[ ModifyTable ] -&gt; resultRelation
 *		  ^
 *		  | Tuple
 *		  |
 *	  [ subplan ]
 *
 *
 * Modified plan:
 *
 *	[ HypertableModify ]
 *		  ^
 *		  |
 *	[ ModifyTable ] -&gt; resultRelation
 *		  ^			   ^
 *		  | Tuple	  / &lt;Set resultRelation to the matching chunk table&gt;
 *		  |			 /
 * [ ChunkDispatch ]
 *		  ^
 *		  | Tuple
 *		  |
 *	  [ subplan ]
 *
 * For PG &lt; 14, the modifytable plan is modified for INSERTs only.
 * For PG14+, we modify the plan for DELETEs as well.
 *
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>replace_hypertable_modify_paths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathlist</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>input_rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>new_pathlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>pathlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>ModifyTablePath</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ModifyTablePath</name> <modifier>*</modifier></type><name>mt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>ModifyTablePath</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_GE</name></expr></cpp:if>
				<comment type="block">/* We only route UPDATE/DELETE through our CustomNode for PG 14+ because
				 * the codepath for earlier versions is different. */</comment>
				<expr><name><name>mt</name><operator>-&gt;</operator><name>operation</name></name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>||</operator> <name><name>mt</name><operator>-&gt;</operator><name>operation</name></name> <operator>==</operator> <name>CMD_DELETE</name> <operator>||</operator>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG15_GE</name></expr></cpp:if>
				<name><name>mt</name><operator>-&gt;</operator><name>operation</name></name> <operator>==</operator> <name>CMD_MERGE</name> <operator>||</operator>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				<name><name>mt</name><operator>-&gt;</operator><name>operation</name></name> <operator>==</operator> <name>CMD_INSERT</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name><name>mt</name><operator>-&gt;</operator><name>nominalRelation</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name> <init>= <expr><call><name>ts_planner_get_hypertable</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>CACHE_FLAG_CHECK</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG15_GE</name></expr></cpp:if>
				<if_stmt><if>if <condition>(<expr><name>ht</name> <operator>&amp;&amp;</operator> <name><name>mt</name><operator>-&gt;</operator><name>operation</name></name> <operator>==</operator> <name>CMD_MERGE</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"The MERGE command does not support hypertables in this "</literal>
									<literal type="string">"version"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Check https://github.com/timescale/timescaledb/issues/4929 "</literal>
									 <literal type="string">"for more information and current status"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				<if_stmt><if>if <condition>(<expr><name>ht</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>mt</name><operator>-&gt;</operator><name>operation</name></name> <operator>==</operator> <name>CMD_INSERT</name> <operator>||</operator> <operator>!</operator><call><name>hypertable_is_distributed</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>ts_hypertable_modify_path_create</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>mt</name></expr></argument>, <argument><expr><name>ht</name></expr></argument>, <argument><expr><name>input_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>new_pathlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>new_pathlist</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>new_pathlist</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>timescaledb_create_upper_paths_hook</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>UpperRelationKind</name></type> <name>stage</name></decl></parameter>,
									<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>input_rel</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>output_rel</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>partials_found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TsRelType</name></type> <name>reltype</name> <init>= <expr><name>TS_REL_OTHER</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>prev_create_upper_paths_hook</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>prev_create_upper_paths_hook</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>stage</name></expr></argument>, <argument><expr><name>input_rel</name></expr></argument>, <argument><expr><name>output_rel</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ts_extension_is_loaded</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>input_rel</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>reltype</name> <operator>=</operator> <call><name>classify_relation</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>input_rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ts_cm_functions</name><operator>-&gt;</operator><name>create_upper_paths_hook</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name><name>ts_cm_functions</name>
			<operator>-&gt;</operator><name>create_upper_paths_hook</name></name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>stage</name></expr></argument>, <argument><expr><name>input_rel</name></expr></argument>, <argument><expr><name>output_rel</name></expr></argument>, <argument><expr><name>reltype</name></expr></argument>, <argument><expr><name>ht</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>output_rel</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Modify for INSERTs on a hypertable */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>output_rel</name><operator>-&gt;</operator><name>pathlist</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>output_rel</name><operator>-&gt;</operator><name>pathlist</name></name> <operator>=</operator>
				<call><name>replace_hypertable_modify_paths</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>output_rel</name><operator>-&gt;</operator><name>pathlist</name></name></expr></argument>, <argument><expr><name>input_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>hasAggs</name></name> <operator>&amp;&amp;</operator> <name>stage</name> <operator>==</operator> <name>UPPERREL_GROUP_AGG</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Existing AggPaths are modified here.
			 * No new AggPaths should be added after this if there
			 * are partials. */</comment>
			<expr_stmt><expr><name>partials_found</name> <operator>=</operator> <call><name>ts_plan_process_partialize_agg</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>output_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ts_guc_enable_optimizations</name> <operator>||</operator> <name>input_rel</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>IS_DUMMY_REL</name><argument_list>(<argument><expr><name>input_rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>involves_hypertable</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>input_rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>stage</name> <operator>==</operator> <name>UPPERREL_GROUP_AGG</name> <operator>&amp;&amp;</operator> <name>output_rel</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>partials_found</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ts_plan_add_hashagg</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>input_rel</name></expr></argument>, <argument><expr><name>output_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>hasAggs</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ts_preprocess_first_last_aggregates</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>processed_tlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>contain_param_exec_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>contain_param_exec_walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ts_contain_param</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>contain_param_exec_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>fill_missing_groupclause</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>new_groupclause</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>orig_groupclause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>new_groupclause</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>gl</name></decl>;</decl_stmt>
		<macro><name>foreach</name> <argument_list>(<argument>gl</argument>, <argument>orig_groupclause</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>gc</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>SortGroupClause</name></expr></argument>, <argument><expr><name>gl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>list_member_ptr</name><argument_list>(<argument><expr><name>new_groupclause</name></expr></argument>, <argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt> <comment type="block">/* already in list */</comment>
			<expr_stmt><expr><name>new_groupclause</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>new_groupclause</name></expr></argument>, <argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>new_groupclause</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_cagg_view_rte</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ContinuousAgg</name> <modifier>*</modifier></type><name>cagg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>rtlc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>viewq</name> <init>= <expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>viewq</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">3</literal></expr>)</condition> <comment type="block">/* a view has 3 entries */</comment>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* should cache this information for cont. aggregates */</comment>
	<macro><name>foreach</name> <argument_list>(<argument>rtlc</argument>, <argument>viewq-&gt;rtable</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RangeTblEntry</name></expr></argument>, <argument><expr><name>rtlc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>cagg</name> <operator>=</operator> <call><name>ts_continuous_agg_find_by_relid</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>found</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Note that it modifies the passed in Query
* select * from (select a, b, max(c), min(d) from ...
				 group by a, b)
  order by b;
* is transformed as
* SELECT * from (select a, b, max(c), min(d) from ..
*                 group by B desc, A  &lt;------ note the change in order here
*              )
*  order by b desc;
*  we transform only if order by is a subset of group-by
* transformation is applicable only to continuous aggregates
* Parameters:
* subq_rte - rte for subquery (inner query that will be modified)
* outer_sortcl -- outer query's sort clause
* outer_tlist - outer query's target list
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>cagg_reorder_groupby_clause</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>subq_rte</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>rtno</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>outer_sortcl</name></decl></parameter>,
							<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>outer_tlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>not_found</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>subq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subq_rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>subq</name> <operator>=</operator> <name><name>subq_rte</name><operator>-&gt;</operator><name>subquery</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>outer_sortcl</name> <operator>&amp;&amp;</operator> <name><name>subq</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>&amp;&amp;</operator> <name><name>subq</name><operator>-&gt;</operator><name>sortClause</name></name> <operator>==</operator> <name>NIL</name> <operator>&amp;&amp;</operator>
		<call><name>check_cagg_view_rte</name><argument_list>(<argument><expr><name>subq_rte</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>new_groupclause</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<comment type="block">/* we are going to modify this. so make a copy and use it
		 if we replace */</comment>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>subq_groupclause_copy</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>subq</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>outer_sortcl</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>outer_sc</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>outer_tle</name> <init>= <expr><call><name>get_sortgroupclause_tle</name><argument_list>(<argument><expr><name>outer_sc</name></expr></argument>, <argument><expr><name>outer_tlist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>not_found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>outer_tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>Index</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>outer_tle</name><operator>-&gt;</operator><name>expr</name></name><operator>)</operator><operator>-&gt;</operator><name>varno</name> <operator>==</operator> <name>rtno</name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type> <name>outer_attno</name> <init>= <expr><operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>outer_tle</name><operator>-&gt;</operator><name>expr</name></name><operator>)</operator><operator>-&gt;</operator><name>varattno</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>subq_tle</name> <init>= <expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>subq</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>outer_attno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>subq_tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* get group clause corresponding to this */</comment>
					<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>subq_gclause</name> <init>=
						<expr><call><name>get_sortgroupref_clause</name><argument_list>(<argument><expr><name><name>subq_tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name></expr></argument>, <argument><expr><name>subq_groupclause_copy</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><name><name>subq_gclause</name><operator>-&gt;</operator><name>sortop</name></name> <operator>=</operator> <name><name>outer_sc</name><operator>-&gt;</operator><name>sortop</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>subq_gclause</name><operator>-&gt;</operator><name>nulls_first</name></name> <operator>=</operator> <name><name>outer_sc</name><operator>-&gt;</operator><name>nulls_first</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subq_gclause</name><operator>-&gt;</operator><name>eqop</name></name> <operator>==</operator> <name><name>outer_sc</name><operator>-&gt;</operator><name>eqop</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>new_groupclause</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>new_groupclause</name></expr></argument>, <argument><expr><name>subq_gclause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>not_found</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>not_found</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block>
		<comment type="block">/* all order by found in group by clause */</comment>
		<if_stmt><if>if <condition>(<expr><name>new_groupclause</name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <name>not_found</name> <operator>==</operator> <name>false</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* use new groupby clause for this subquery/view */</comment>
			<expr_stmt><expr><name><name>subq</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>=</operator> <call><name>fill_missing_groupclause</name><argument_list>(<argument><expr><name>new_groupclause</name></expr></argument>, <argument><expr><name>subq_groupclause_copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>_planner_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>prev_planner_hook</name> <operator>=</operator> <name>planner_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>planner_hook</name> <operator>=</operator> <name>timescaledb_planner</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>prev_set_rel_pathlist_hook</name> <operator>=</operator> <name>set_rel_pathlist_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>set_rel_pathlist_hook</name> <operator>=</operator> <name>timescaledb_set_rel_pathlist</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>prev_get_relation_info_hook</name> <operator>=</operator> <name>get_relation_info_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>get_relation_info_hook</name> <operator>=</operator> <name>timescaledb_get_relation_info_hook</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>prev_create_upper_paths_hook</name> <operator>=</operator> <name>create_upper_paths_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>create_upper_paths_hook</name> <operator>=</operator> <name>timescaledb_create_upper_paths_hook</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>_planner_fini</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>planner_hook</name> <operator>=</operator> <name>prev_planner_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>set_rel_pathlist_hook</name> <operator>=</operator> <name>prev_set_rel_pathlist_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>get_relation_info_hook</name> <operator>=</operator> <name>prev_get_relation_info_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>create_upper_paths_hook</name> <operator>=</operator> <name>prev_create_upper_paths_hook</name></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
