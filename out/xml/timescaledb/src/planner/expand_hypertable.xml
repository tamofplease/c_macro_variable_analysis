<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/timescaledb/src/planner/expand_hypertable.c"><comment type="block">/*
 * This file and its contents are licensed under the Apache License 2.0.
 * Please see the included NOTICE for copyright information and
 * LICENSE-APACHE for a copy of the license.
 */</comment>

<comment type="block">/* This planner optimization reduces planning times when a hypertable has many chunks.
 * It does this by expanding hypertable chunks manually, eliding the `expand_inherited_tables`
 * logic used by PG.
 *
 * Slow planning time were previously seen because `expand_inherited_tables` expands all chunks of
 * a hypertable, without regard to constraints present in the query. Then, `get_relation_info` is
 * called on all chunks before constraint exclusion. Getting the statistics on many chunks ends
 * up being expensive because RelationGetNumberOfBlocks has to open the file for each relation.
 * This gets even worse under high concurrency.
 *
 * This logic solves this by expanding only the chunks needed to fulfil the query instead of all
 * chunks. In effect, it moves chunk exclusion up in the planning process. But, we actually don't
 * use constraint exclusion here, but rather a variant of range exclusion implemented by
 * HypertableRestrictInfo.
 * */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postgres.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_constraint.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_inherits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_namespace.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_type.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/makefuncs.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/nodeFuncs.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/plannodes.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/cost.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/optimizer.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/pathnode.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/prep.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/restrictinfo.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/tlist.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;parser/parse_func.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;parser/parsetree.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;partitioning/partbounds.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/date.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/errcodes.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/fmgroids.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/fmgrprotos.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/syscache.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"chunk.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compat/compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cross_module_fn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"extension.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"extension_constants.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hypertable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hypertable_restrict_info.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"import/planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/chunk_append/chunk_append.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"partitioning.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"partialize.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"time_utils.h"</cpp:file></cpp:include>

<typedef>typedef <type><struct>struct <name>CollectQualCtx</name>
<block>{
	<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>restrictions</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>chunk_exclusion_func</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>join_conditions</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>propagate_conditions</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>all_quals</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>join_level</name></decl>;</decl_stmt>
}</block></struct></type> <name>CollectQualCtx</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>propagate_join_quals</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>CollectQualCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <name>Oid</name></type> <name>chunk_exclusion_func</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>Oid</name></type> <name><name>ts_chunks_arg_types</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>RECORDOID</name></expr>, <expr><name>INT4ARRAYOID</name></expr> }</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>init_chunk_exclusion_func</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>chunk_exclusion_func</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>l</name> <init>= <expr><call><name>list_make2</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>INTERNAL_SCHEMA_NAME</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>CHUNK_EXCL_FUNC_NAME</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>chunk_exclusion_func</name> <operator>=</operator>
			<call><name>LookupFuncName</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><call><name>lengthof</name><argument_list>(<argument><expr><name>ts_chunks_arg_types</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ts_chunks_arg_types</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>chunk_exclusion_func</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_chunk_exclusion_func</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>FuncExpr</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>funcid</name> <operator>==</operator> <name>chunk_exclusion_func</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_time_bucket_function</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>strncmp</name><argument_list>(<argument><expr><call><name>get_func_name</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>FuncExpr</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>funcid</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"time_bucket"</literal></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ts_add_append_rel_infos</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>appinfos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>append_rel_list</name></name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>append_rel_list</name></name></expr></argument>, <argument><expr><name>appinfos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* root-&gt;append_rel_array is required to be able to hold all the
	 * additional entries by previous call to expand_planner_arrays */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>append_rel_array</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>appinfos</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appinfo</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>AppendRelInfo</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>child_relid</name> <init>= <expr><name><name>appinfo</name><operator>-&gt;</operator><name>child_relid</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>child_relid</name> <operator>&lt;</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rel_array_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>append_rel_array</name><index>[<expr><name>child_relid</name></expr>]</index></name> <operator>=</operator> <name>appinfo</name></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Pre-check to determine if an expression is eligible for constification.
 * A more thorough check is in constify_timestamptz_op_interval.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_timestamptz_op_interval</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>op</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>c1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>c2</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>op</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>OpExpr</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>opresulttype</name></name> <operator>!=</operator> <name>TIMESTAMPTZOID</name> <operator>||</operator> <name><name>op</name><operator>-&gt;</operator><name>args</name><operator>-&gt;</operator><name>length</name></name> <operator>!=</operator> <literal type="number">2</literal> <operator>||</operator>
		<operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><call><name>llast</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>c1</name> <operator>=</operator> <call><name>linitial_node</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>c2</name> <operator>=</operator> <call><name>llast_node</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name><name>c1</name><operator>-&gt;</operator><name>consttype</name></name> <operator>==</operator> <name>TIMESTAMPTZOID</name> <operator>&amp;&amp;</operator> <name><name>c2</name><operator>-&gt;</operator><name>consttype</name></name> <operator>==</operator> <name>INTERVALOID</name><operator>)</operator> <operator>||</operator>
		   <operator>(</operator><name><name>c1</name><operator>-&gt;</operator><name>consttype</name></name> <operator>==</operator> <name>INTERVALOID</name> <operator>&amp;&amp;</operator> <name><name>c2</name><operator>-&gt;</operator><name>consttype</name></name> <operator>==</operator> <name>TIMESTAMPTZOID</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int64</name></type>
<name>const_datum_get_int</name><parameter_list>(<parameter><decl><type><name>Const</name> <modifier>*</modifier></type><name>cnst</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>cnst</name><operator>-&gt;</operator><name>constisnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>cnst</name><operator>-&gt;</operator><name>consttype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>INT2OID</name></expr>:</case>
			<return>return <expr><operator>(</operator><name>int64</name><operator>)</operator> <operator>(</operator><call><name>DatumGetInt16</name><argument_list>(<argument><expr><name><name>cnst</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
		<case>case <expr><name>INT4OID</name></expr>:</case>
			<return>return <expr><operator>(</operator><name>int64</name><operator>)</operator> <operator>(</operator><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>cnst</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
		<case>case <expr><name>INT8OID</name></expr>:</case>
			<return>return <expr><call><name>DatumGetInt64</name><argument_list>(<argument><expr><name><name>cnst</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"can only use const_datum_get_int with integer types"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pg_unreachable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Constify expressions of the following form in WHERE clause:
 *
 * column OP timestamptz - interval
 * column OP timestamptz + interval
 * column OP interval + timestamptz
 *
 * Iff interval has no month component.
 *
 * Since the operators for timestamptz OP interval are marked
 * as stable they will not be constified during planning.
 * However, intervals without a month component can be safely
 * constified during planning as the result of those calculations
 * do not depend on the timezone setting.
 */</comment>
<function><type><specifier>static</specifier> <name>OpExpr</name> <modifier>*</modifier></type>
<name>constify_timestamptz_op_interval</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>constraint</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>left</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>right</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>op</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>var_on_left</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name> <modifier>*</modifier></type><name>interval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>c_ts</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>c_int</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>constified</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGFunction</name></type> <name>opfunc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>ts_pl_int</name></decl>, <decl><type ref="prev"/><name>ts_mi_int</name></decl>, <decl><type ref="prev"/><name>int_pl_ts</name></decl>;</decl_stmt>

	<comment type="block">/* checked in caller already so only asserting */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>args</name><operator>-&gt;</operator><name>length</name></name> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>left</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>right</name> <operator>=</operator> <call><name>llast</name><argument_list>(<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>right</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>op</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>OpExpr</name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>var_on_left</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>right</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>op</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>OpExpr</name></expr></argument>, <argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>constraint</name></expr>;</return></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>ts_pl_int</name> <operator>=</operator> <call><name>ts_get_operator</name><argument_list>(<argument><expr><literal type="string">"+"</literal></expr></argument>, <argument><expr><name>PG_CATALOG_NAMESPACE</name></expr></argument>, <argument><expr><name>TIMESTAMPTZOID</name></expr></argument>, <argument><expr><name>INTERVALOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ts_mi_int</name> <operator>=</operator> <call><name>ts_get_operator</name><argument_list>(<argument><expr><literal type="string">"-"</literal></expr></argument>, <argument><expr><name>PG_CATALOG_NAMESPACE</name></expr></argument>, <argument><expr><name>TIMESTAMPTZOID</name></expr></argument>, <argument><expr><name>INTERVALOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>int_pl_ts</name> <operator>=</operator> <call><name>ts_get_operator</name><argument_list>(<argument><expr><literal type="string">"+"</literal></expr></argument>, <argument><expr><name>PG_CATALOG_NAMESPACE</name></expr></argument>, <argument><expr><name>INTERVALOID</name></expr></argument>, <argument><expr><name>TIMESTAMPTZOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>opno</name></name> <operator>==</operator> <name>ts_pl_int</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* TIMESTAMPTZ + INTERVAL */</comment>
		<expr_stmt><expr><name>opfunc</name> <operator>=</operator> <name>timestamptz_pl_interval</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>c_ts</name> <operator>=</operator> <call><name>linitial_node</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>c_int</name> <operator>=</operator> <call><name>llast_node</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>opno</name></name> <operator>==</operator> <name>ts_mi_int</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* TIMESTAMPTZ - INTERVAL */</comment>
		<expr_stmt><expr><name>opfunc</name> <operator>=</operator> <name>timestamptz_mi_interval</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>c_ts</name> <operator>=</operator> <call><name>linitial_node</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>c_int</name> <operator>=</operator> <call><name>llast_node</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>opno</name></name> <operator>==</operator> <name>int_pl_ts</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* INTERVAL + TIMESTAMPTZ */</comment>
		<expr_stmt><expr><name>opfunc</name> <operator>=</operator> <name>timestamptz_pl_interval</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>c_int</name> <operator>=</operator> <call><name>linitial_node</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>c_ts</name> <operator>=</operator> <call><name>llast_node</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>constraint</name></expr>;</return></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * arg types should match operator and were checked in precheck
	 * so only asserting here
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>c_ts</name><operator>-&gt;</operator><name>consttype</name></name> <operator>==</operator> <name>TIMESTAMPTZOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>c_int</name><operator>-&gt;</operator><name>consttype</name></name> <operator>==</operator> <name>INTERVALOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>c_ts</name><operator>-&gt;</operator><name>constisnull</name></name> <operator>||</operator> <name><name>c_int</name><operator>-&gt;</operator><name>constisnull</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>constraint</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>interval</name> <operator>=</operator> <call><name>DatumGetIntervalP</name><argument_list>(<argument><expr><name><name>c_int</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * constification is only safe when the interval has no month component
	 * because month length is variable and calculation depends on local timezone
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>interval</name><operator>-&gt;</operator><name>month</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>constraint</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>constified</name> <operator>=</operator> <call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>opfunc</name></expr></argument>, <argument><expr><name><name>c_ts</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>, <argument><expr><name><name>c_int</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Since constifying intervals with day component does depend on the timezone
	 * this can lead to different results around daylight saving time switches.
	 * So we add a safety buffer when the interval has day components to counteract.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>interval</name><operator>-&gt;</operator><name>day</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>add</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TimestampTz</name></type> <name>constified_tstz</name> <init>= <expr><call><name>DatumGetTimestampTz</name><argument_list>(<argument><expr><name>constified</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><name><name>constraint</name><operator>-&gt;</operator><name>opfuncid</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>F_TIMESTAMPTZ_LE</name></expr>:</case>
			<case>case <expr><name>F_TIMESTAMPTZ_LT</name></expr>:</case>
				<expr_stmt><expr><name>add</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>F_TIMESTAMPTZ_GE</name></expr>:</case>
			<case>case <expr><name>F_TIMESTAMPTZ_GT</name></expr>:</case>
				<expr_stmt><expr><name>add</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<return>return <expr><name>constraint</name></expr>;</return>
		</block_content>}</block></switch>
		<comment type="block">/*
		 * If Var is on wrong side reverse the direction.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>var_on_left</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>add</name> <operator>=</operator> <operator>!</operator><name>add</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * The safety buffer is chosen to be 4 hours because daylight saving time
		 * changes seem to be in the range between -1 and 2 hours.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>add</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>constified_tstz</name> <operator>+=</operator> <literal type="number">4</literal> <operator>*</operator> <name>USECS_PER_HOUR</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>constified_tstz</name> <operator>-=</operator> <literal type="number">4</literal> <operator>*</operator> <name>USECS_PER_HOUR</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>constified</name> <operator>=</operator> <call><name>TimestampTzGetDatum</name><argument_list>(<argument><expr><name>constified_tstz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>c_ts</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>c_ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>c_ts</name><operator>-&gt;</operator><name>constvalue</name></name> <operator>=</operator> <name>constified</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>var_on_left</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>right</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>c_ts</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>left</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>c_ts</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <call><name>make_opclause</name><argument_list>(<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>,
									<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>opresulttype</name></name></expr></argument>,
									<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>opretset</name></name></expr></argument>,
									<argument><expr><name>left</name></expr></argument>,
									<argument><expr><name>right</name></expr></argument>,
									<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>opcollid</name></name></expr></argument>,
									<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>inputcollid</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Transform time_bucket calls of the following form in WHERE clause:
 *
 * time_bucket(width, column) OP value
 *
 * Since time_bucket always returns the lower bound of the bucket
 * for lower bound comparisons the width is not relevant and the
 * following transformation can be applied:
 *
 * time_bucket(width, column) &gt; value
 * column &gt; value
 *
 * Example with values:
 *
 * time_bucket(10, column) &gt; 109
 * column &gt; 109
 *
 * For upper bound comparisons width needs to be taken into account
 * and we need to extend the upper bound by width to capture all
 * possible values.
 *
 * time_bucket(width, column) &lt; value
 * column &lt; value + width
 *
 * Example with values:
 *
 * time_bucket(10, column) &lt; 100
 * column &lt; 100 + 10
 *
 * Expressions with value on the left side will be switched around
 * when building the expression for RestrictInfo.
 *
 * Caller must ensure that only 2 argument time_bucket versions
 * are used.
 */</comment>
<function><type><specifier>static</specifier> <name>OpExpr</name> <modifier>*</modifier></type>
<name>transform_time_bucket_comparison</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>op</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>left</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>right</name> <init>= <expr><call><name>lsecond</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>time_bucket</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>FuncExpr</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><call><name>IsA</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>left</name></expr> </then><else>: <expr><name>right</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>value</name> <init>= <expr><ternary><condition><expr><call><name>IsA</name><argument_list>(<argument><expr><name>right</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>right</name></expr> </then><else>: <expr><name>left</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>width</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>time_bucket</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>opno</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>opno</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>tce</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>strategy</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>time_bucket</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>width</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>op</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * if time_bucket call is on wrong side we switch operator
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>right</name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>opno</name> <operator>=</operator> <call><name>get_commutator</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>op</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>tce</name> <operator>=</operator> <call><name>lookup_type_cache</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>time_bucket</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TYPECACHE_BTREE_OPFAMILY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>strategy</name> <operator>=</operator> <call><name>get_op_opfamily_strategy</name><argument_list>(<argument><expr><name>opno</name></expr></argument>, <argument><expr><name><name>tce</name><operator>-&gt;</operator><name>btree_opf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>strategy</name> <operator>==</operator> <name>BTGreaterStrategyNumber</name> <operator>||</operator> <name>strategy</name> <operator>==</operator> <name>BTGreaterEqualStrategyNumber</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* column &gt; value */</comment>
		<expr_stmt><expr><name>op</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><call><name>lsecond</name><argument_list>(<argument><expr><name><name>time_bucket</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * if we switched operator we need to adjust OpExpr as well
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>right</name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>opno</name></name> <operator>=</operator> <name>opno</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>opfuncid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><name>op</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>strategy</name> <operator>==</operator> <name>BTLessStrategyNumber</name> <operator>||</operator> <name>strategy</name> <operator>==</operator> <name>BTLessEqualStrategyNumber</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* column &lt; value + width */</comment>
		<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>subst</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type> <name>datum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int64</name></type> <name>integralValue</name></decl>, <decl><type ref="prev"/><name>integralWidth</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>castNode</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>constisnull</name> <operator>||</operator> <name><name>width</name><operator>-&gt;</operator><name>constisnull</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>op</name></expr>;</return></block_content></block></if></if_stmt>

		<switch>switch <condition>(<expr><name><name>tce</name><operator>-&gt;</operator><name>type_id</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>INT2OID</name></expr>:</case>
				<expr_stmt><expr><name>integralValue</name> <operator>=</operator> <call><name>const_datum_get_int</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>integralWidth</name> <operator>=</operator> <call><name>const_datum_get_int</name><argument_list>(<argument><expr><name>width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>integralValue</name> <operator>&gt;=</operator> <name>PG_INT16_MAX</name> <operator>-</operator> <name>integralWidth</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>op</name></expr>;</return></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>integralValue</name> <operator>+</operator> <name>integralWidth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>subst</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name><name>tce</name><operator>-&gt;</operator><name>type_id</name></name></expr></argument>,
										   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
										   <argument><expr><name>InvalidOid</name></expr></argument>,
										   <argument><expr><name><name>tce</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>,
										   <argument><expr><name>datum</name></expr></argument>,
										   <argument><expr><name>false</name></expr></argument>,
										   <argument><expr><name><name>tce</name><operator>-&gt;</operator><name>typbyval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>INT4OID</name></expr>:</case>
				<expr_stmt><expr><name>integralValue</name> <operator>=</operator> <call><name>const_datum_get_int</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>integralWidth</name> <operator>=</operator> <call><name>const_datum_get_int</name><argument_list>(<argument><expr><name>width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>integralValue</name> <operator>&gt;=</operator> <name>PG_INT32_MAX</name> <operator>-</operator> <name>integralWidth</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>op</name></expr>;</return></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>integralValue</name> <operator>+</operator> <name>integralWidth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>subst</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name><name>tce</name><operator>-&gt;</operator><name>type_id</name></name></expr></argument>,
										   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
										   <argument><expr><name>InvalidOid</name></expr></argument>,
										   <argument><expr><name><name>tce</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>,
										   <argument><expr><name>datum</name></expr></argument>,
										   <argument><expr><name>false</name></expr></argument>,
										   <argument><expr><name><name>tce</name><operator>-&gt;</operator><name>typbyval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>INT8OID</name></expr>:</case>
				<expr_stmt><expr><name>integralValue</name> <operator>=</operator> <call><name>const_datum_get_int</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>integralWidth</name> <operator>=</operator> <call><name>const_datum_get_int</name><argument_list>(<argument><expr><name>width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>integralValue</name> <operator>&gt;=</operator> <name>PG_INT64_MAX</name> <operator>-</operator> <name>integralWidth</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>op</name></expr>;</return></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>integralValue</name> <operator>+</operator> <name>integralWidth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>subst</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name><name>tce</name><operator>-&gt;</operator><name>type_id</name></name></expr></argument>,
										   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
										   <argument><expr><name>InvalidOid</name></expr></argument>,
										   <argument><expr><name><name>tce</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>,
										   <argument><expr><name>datum</name></expr></argument>,
										   <argument><expr><name>false</name></expr></argument>,
										   <argument><expr><name><name>tce</name><operator>-&gt;</operator><name>typbyval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<break>break;</break>
			<case>case <expr><name>DATEOID</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Interval</name> <modifier>*</modifier></type><name>interval</name> <init>= <expr><call><name>DatumGetIntervalP</name><argument_list>(<argument><expr><name><name>width</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * Optimization can't be applied when interval has month component.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>interval</name><operator>-&gt;</operator><name>month</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>op</name></expr>;</return></block_content></block></if></if_stmt>

				<comment type="block">/* bail out if interval-&gt;time can't be exactly represented as a double */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>interval</name><operator>-&gt;</operator><name>time</name></name> <operator>&gt;=</operator> <literal type="number">0x3FFFFFFFFFFFFFll</literal></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>op</name></expr>;</return></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>DatumGetDateADT</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>constvalue</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator>
					<operator>(</operator><name>TS_DATE_END</name> <operator>-</operator> <name><name>interval</name><operator>-&gt;</operator><name>day</name></name> <operator>+</operator>
					 <call><name>ceil</name><argument_list>(<argument><expr><operator>(</operator><name>double</name><operator>)</operator> <name><name>interval</name><operator>-&gt;</operator><name>time</name></name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>USECS_PER_DAY</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>op</name></expr>;</return></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>DateADTGetDatum</name><argument_list>(<argument><expr><call><name>DatumGetDateADT</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>constvalue</name></expr></argument>)</argument_list></call> <operator>+</operator>
										<name><name>interval</name><operator>-&gt;</operator><name>day</name></name> <operator>+</operator>
										<call><name>ceil</name><argument_list>(<argument><expr><operator>(</operator><name>double</name><operator>)</operator> <name><name>interval</name><operator>-&gt;</operator><name>time</name></name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>USECS_PER_DAY</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>subst</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name><name>tce</name><operator>-&gt;</operator><name>type_id</name></name></expr></argument>,
										   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
										   <argument><expr><name>InvalidOid</name></expr></argument>,
										   <argument><expr><name><name>tce</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>,
										   <argument><expr><name>datum</name></expr></argument>,
										   <argument><expr><name>false</name></expr></argument>,
										   <argument><expr><name><name>tce</name><operator>-&gt;</operator><name>typbyval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<break>break;</break>
			</block_content>}</block>
			<case>case <expr><name>TIMESTAMPTZOID</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Interval</name> <modifier>*</modifier></type><name>interval</name> <init>= <expr><call><name>DatumGetIntervalP</name><argument_list>(<argument><expr><name><name>width</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>width</name><operator>-&gt;</operator><name>consttype</name></name> <operator>==</operator> <name>INTERVALOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Optimization can't be applied when interval has month component.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>interval</name><operator>-&gt;</operator><name>month</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>op</name></expr>;</return></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * If width interval has day component we merge it with time component
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>interval</name><operator>-&gt;</operator><name>day</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>width</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>interval</name> <operator>=</operator> <call><name>DatumGetIntervalP</name><argument_list>(<argument><expr><name><name>width</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * if our transformed restriction would overflow we skip adding it
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>interval</name><operator>-&gt;</operator><name>time</name></name> <operator>&gt;=</operator> <name>PG_INT64_MAX</name> <operator>-</operator> <name><name>interval</name><operator>-&gt;</operator><name>day</name></name> <operator>*</operator> <name>USECS_PER_DAY</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>op</name></expr>;</return></block_content></block></if></if_stmt>

					<expr_stmt><expr><name><name>interval</name><operator>-&gt;</operator><name>time</name></name> <operator>+=</operator> <name><name>interval</name><operator>-&gt;</operator><name>day</name></name> <operator>*</operator> <name>USECS_PER_DAY</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>interval</name><operator>-&gt;</operator><name>day</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>DatumGetTimestampTz</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>constvalue</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator>
					<operator>(</operator><name>TS_TIMESTAMP_END</name> <operator>-</operator> <name><name>interval</name><operator>-&gt;</operator><name>time</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>op</name></expr>;</return></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>TimestampTzGetDatum</name><argument_list>(
					<argument><expr><call><name>DatumGetTimestampTz</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>constvalue</name></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>interval</name><operator>-&gt;</operator><name>time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>subst</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name><name>tce</name><operator>-&gt;</operator><name>type_id</name></name></expr></argument>,
										   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
										   <argument><expr><name>InvalidOid</name></expr></argument>,
										   <argument><expr><name><name>tce</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>,
										   <argument><expr><name>datum</name></expr></argument>,
										   <argument><expr><name>false</name></expr></argument>,
										   <argument><expr><name><name>tce</name><operator>-&gt;</operator><name>typbyval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<break>break;</break>
			</block_content>}</block>

			<case>case <expr><name>TIMESTAMPOID</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Interval</name> <modifier>*</modifier></type><name>interval</name> <init>= <expr><call><name>DatumGetIntervalP</name><argument_list>(<argument><expr><name><name>width</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>width</name><operator>-&gt;</operator><name>consttype</name></name> <operator>==</operator> <name>INTERVALOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Optimization can't be applied when interval has month component.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>interval</name><operator>-&gt;</operator><name>month</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>op</name></expr>;</return></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * If width interval has day component we merge it with time component
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>interval</name><operator>-&gt;</operator><name>day</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>width</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>interval</name> <operator>=</operator> <call><name>DatumGetIntervalP</name><argument_list>(<argument><expr><name><name>width</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * if our merged value overflows we skip adding it
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>interval</name><operator>-&gt;</operator><name>time</name></name> <operator>&gt;=</operator> <name>PG_INT64_MAX</name> <operator>-</operator> <name><name>interval</name><operator>-&gt;</operator><name>day</name></name> <operator>*</operator> <name>USECS_PER_DAY</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>op</name></expr>;</return></block_content></block></if></if_stmt>

					<expr_stmt><expr><name><name>interval</name><operator>-&gt;</operator><name>time</name></name> <operator>+=</operator> <name><name>interval</name><operator>-&gt;</operator><name>day</name></name> <operator>*</operator> <name>USECS_PER_DAY</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>interval</name><operator>-&gt;</operator><name>day</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>DatumGetTimestamp</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>constvalue</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator>
					<operator>(</operator><name>TS_TIMESTAMP_END</name> <operator>-</operator> <name><name>interval</name><operator>-&gt;</operator><name>time</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>op</name></expr>;</return></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>TimestampGetDatum</name><argument_list>(<argument><expr><call><name>DatumGetTimestamp</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>constvalue</name></expr></argument>)</argument_list></call> <operator>+</operator>
										  <name><name>interval</name><operator>-&gt;</operator><name>time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>subst</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name><name>tce</name><operator>-&gt;</operator><name>type_id</name></name></expr></argument>,
										   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
										   <argument><expr><name>InvalidOid</name></expr></argument>,
										   <argument><expr><name><name>tce</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>,
										   <argument><expr><name>datum</name></expr></argument>,
										   <argument><expr><name>false</name></expr></argument>,
										   <argument><expr><name><name>tce</name><operator>-&gt;</operator><name>typbyval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<break>break;</break>
			</block_content>}</block>
			<default>default:</default>
				<return>return <expr><name>op</name></expr>;</return>
				<break>break;</break>
		</block_content>}</block></switch>

		<comment type="block">/*
		 * adjust toplevel expression if datatypes changed
		 * this can happen when comparing int4 values against int8 time_bucket
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tce</name><operator>-&gt;</operator><name>type_id</name></name> <operator>!=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>consttype</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>opno</name> <operator>=</operator>
				<call><name>ts_get_operator</name><argument_list>(<argument><expr><call><name>get_opname</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>PG_CATALOG_NAMESPACE</name></expr></argument>, <argument><expr><name><name>tce</name><operator>-&gt;</operator><name>type_id</name></name></expr></argument>, <argument><expr><name><name>tce</name><operator>-&gt;</operator><name>type_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>op</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>op</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * if we changed operator we need to adjust OpExpr as well
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>opno</name></name> <operator>!=</operator> <name>opno</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>opno</name></name> <operator>=</operator> <name>opno</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>opfuncid</name></name> <operator>=</operator> <call><name>get_opcode</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><call><name>lsecond</name><argument_list>(<argument><expr><name><name>time_bucket</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>subst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>op</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Since baserestrictinfo is not yet set by the planner, we have to derive
 * it ourselves. It's safe for us to miss some restrict info clauses (this
 * will just result in more chunks being included) so this does not need
 * to be as comprehensive as the PG native derivation. This is inspired
 * by the derivation in `deconstruct_recurse` in PG
 *
 * When we detect explicit chunk exclusion with the chunks_in function
 * we stop further processing and do an early exit.
 *
 * This function removes chunks_in from the list of quals, because chunks_in is
 * just used as marker function to trigger explicit chunk exclusion and the function
 * will throw an error when executed.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>process_quals</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>quals</name></decl></parameter>, <parameter><decl><type><name>CollectQualCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_outer_join</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<function_decl><type><name>ListCell</name> <modifier>*</modifier><name>prev</name></type> <name>pg_attribute_unused</name><parameter_list>()</parameter_list> <init>= <expr><name>NULL</name></expr></init>;</function_decl>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>additional_quals</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>lc</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name>quals</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>lc</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
		 <incr><expr><name>prev</name> <operator>=</operator> <name>lc</name></expr><operator>,</operator> <expr><name>lc</name> <operator>=</operator> <call><name>lnext_compat</name><argument_list>(<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name>quals</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>qual</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relids</name></type> <name>relids</name> <init>= <expr><call><name>pull_varnos_compat</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>qual</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>num_rels</name> <init>= <expr><call><name>bms_num_members</name><argument_list>(<argument><expr><name>relids</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* stop processing if not for current rel */</comment>
		<if_stmt><if>if <condition>(<expr><name>num_rels</name> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator> <operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>relids</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>is_chunk_exclusion_func</name><argument_list>(<argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>func_expr</name> <init>= <expr><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>qual</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* validation */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>func_expr</name><operator>-&gt;</operator><name>args</name><operator>-&gt;</operator><name>length</name></name> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>func_expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"first parameter for chunks_in function needs to be record"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>chunk_exclusion_func</name></name> <operator>=</operator> <name>func_expr</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>restrictions</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
			<return>return <expr><name>quals</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>qual</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>list_length</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>OpExpr</name></expr></argument>, <argument><expr><name>qual</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>args</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>OpExpr</name></expr></argument>, <argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>left</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>right</name> <init>= <expr><call><name>lsecond</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * check for constraints with TIMESTAMPTZ OP INTERVAL calculations
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>IsA</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>is_timestamptz_op_interval</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
				<operator>(</operator><call><name>IsA</name><argument_list>(<argument><expr><name>right</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>is_timestamptz_op_interval</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>qual</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>constify_timestamptz_op_interval</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * check for time_bucket comparisons
			 * time_bucket(Const, time_colum) &gt; Const
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>IsA</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>right</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				 <call><name>list_length</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>FuncExpr</name></expr></argument>, <argument><expr><name>left</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>args</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
				 <call><name>is_time_bucket_function</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
				<operator>(</operator><call><name>IsA</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>right</name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				 <call><name>list_length</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>FuncExpr</name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>args</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
				 <call><name>is_time_bucket_function</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>qual</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>transform_time_bucket_comparison</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/*
				 * if we could transform the expression we add it to the list of
				 * quals so it can be used as an index condition
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>qual</name> <operator>!=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>op</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>additional_quals</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>additional_quals</name></expr></argument>, <argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Do not include this restriction if this is an outer join. Including
		 * the restriction would exclude chunks and thus rows of the outer
		 * relation when it should show all rows */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_outer_join</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>restrictions</name></name> <operator>=</operator>
				<call><name>lappend</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>restrictions</name></name></expr></argument>, <argument><expr><call><name>make_simple_restrictinfo_compat</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>list_concat</name><argument_list>(<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name>quals</name></expr></argument>, <argument><expr><name>additional_quals</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>remove_exclusion_fns</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>restrictinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG13_LT</name></expr></cpp:if>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>prev</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name> <init>= <expr><call><name>list_head</name><argument_list>(<argument><expr><name>restrictinfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>lc</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>qual</name> <init>= <expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>is_chunk_exclusion_func</name><argument_list>(<argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>func_expr</name> <init>= <expr><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>qual</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* validation */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>func_expr</name><operator>-&gt;</operator><name>args</name><operator>-&gt;</operator><name>length</name></name> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>func_expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"first parameter for chunks_in function needs to be record"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>restrictinfo</name> <operator>=</operator> <call><name>list_delete_cell_compat</name><argument_list>(<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name>restrictinfo</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>restrictinfo</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG13_LT</name></expr></cpp:if>
		<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>lc</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><name>lc</name> <operator>=</operator> <call><name>lnext_compat</name><argument_list>(<argument><expr><name>restrictinfo</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<return>return <expr><name>restrictinfo</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>timebucket_annotate</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>quals</name></decl></parameter>, <parameter><decl><type><name>CollectQualCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>additional_quals</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>castNode(List, quals)</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>qual</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relids</name></type> <name>relids</name> <init>= <expr><call><name>pull_varnos_compat</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>qual</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>num_rels</name> <init>= <expr><call><name>bms_num_members</name><argument_list>(<argument><expr><name>relids</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* stop processing if not for current rel */</comment>
		<if_stmt><if>if <condition>(<expr><name>num_rels</name> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator> <operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>relids</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>qual</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>list_length</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>OpExpr</name></expr></argument>, <argument><expr><name>qual</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>args</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>OpExpr</name></expr></argument>, <argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>left</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>right</name> <init>= <expr><call><name>lsecond</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * check for time_bucket comparisons
			 * time_bucket(Const, time_colum) &gt; Const
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>IsA</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>right</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				 <call><name>list_length</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>FuncExpr</name></expr></argument>, <argument><expr><name>left</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>args</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
				 <call><name>is_time_bucket_function</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
				<operator>(</operator><call><name>IsA</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>right</name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				 <call><name>list_length</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>FuncExpr</name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>args</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
				 <call><name>is_time_bucket_function</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>qual</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>transform_time_bucket_comparison</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/*
				 * if we could transform the expression we add it to the list of
				 * quals so it can be used as an index condition
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>qual</name> <operator>!=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>op</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>additional_quals</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>additional_quals</name></expr></argument>, <argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>restrictions</name></name> <operator>=</operator>
			<call><name>lappend</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>restrictions</name></name></expr></argument>, <argument><expr><call><name>make_simple_restrictinfo_compat</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>list_concat</name><argument_list>(<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name>quals</name></expr></argument>, <argument><expr><name>additional_quals</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * collect JOIN information
 *
 * This function adds information to two lists in the CollectQualCtx
 *
 * join_conditions
 *
 * This list contains all equality join conditions and is used by
 * ChunkAppend to decide whether the ordered append optimization
 * can be applied.
 *
 * propagate_conditions
 *
 * This list contains toplevel or INNER JOIN equality conditions.
 * This list is used for propagating quals to the other side of
 * a JOIN.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>collect_join_quals</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>quals</name></decl></parameter>, <parameter><decl><type><name>CollectQualCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>can_propagate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>(List *) quals</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>qual</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relids</name></type> <name>relids</name> <init>= <expr><call><name>pull_varnos_compat</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>qual</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>num_rels</name> <init>= <expr><call><name>bms_num_members</name><argument_list>(<argument><expr><name>relids</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * collect quals to propagate to join relations
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>num_rels</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>can_propagate</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>qual</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>list_length</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>OpExpr</name></expr></argument>, <argument><expr><name>qual</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>args</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>all_quals</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>all_quals</name></name></expr></argument>, <argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>relids</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* collect equality JOIN conditions for current rel */</comment>
		<if_stmt><if>if <condition>(<expr><name>num_rels</name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>qual</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>list_length</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>OpExpr</name></expr></argument>, <argument><expr><name>qual</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>args</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>OpExpr</name></expr></argument>, <argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>left</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>right</name> <init>= <expr><call><name>lsecond</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>right</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>ht_var</name> <init>=
					<expr><call><name>castNode</name><argument_list>(<argument><expr><name>Var</name></expr></argument>,
							 <argument><expr><ternary><condition><expr><operator>(</operator><name>Index</name><operator>)</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>Var</name></expr></argument>, <argument><expr><name>left</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>varno</name> <operator>==</operator> <name><name>ctx</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr> ?</condition><then> <expr><name>left</name></expr> </then><else>: <expr><name>right</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>tce</name> <init>= <expr><call><name>lookup_type_cache</name><argument_list>(<argument><expr><name><name>ht_var</name><operator>-&gt;</operator><name>vartype</name></name></expr></argument>, <argument><expr><name>TYPECACHE_EQ_OPR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>opno</name></name> <operator>==</operator> <name><name>tce</name><operator>-&gt;</operator><name>eq_opr</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>join_conditions</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>join_conditions</name></name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name>can_propagate</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>propagate_conditions</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>propagate_conditions</name></name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>collect_quals_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>CollectQualCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>FromExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FromExpr</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>FromExpr</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <call><name>process_quals</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* if this is a nested join we don't propagate join quals */</comment>
		<expr_stmt><expr><call><name>collect_join_quals</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>join_level</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>JoinExpr</name> <modifier>*</modifier></type><name>j</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>JoinExpr</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <call><name>process_quals</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><call><name>IS_OUTER_JOIN</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>jointype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>collect_join_quals</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>join_level</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IS_OUTER_JOIN</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>jointype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IS_OUTER_JOIN</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>jointype</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>join_level</name></name><operator>++</operator></expr>;</expr_stmt>
			<decl_stmt><decl><type><name>bool</name></type> <name>result</name> <init>= <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>collect_quals_walker</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>join_level</name></name><operator>--</operator></expr>;</expr_stmt>
			<return>return <expr><name>result</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* skip processing if we found a chunks_in call for current relation */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>chunk_exclusion_func</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>collect_quals_walker</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>chunk_cmp_chunk_reloid</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>c1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>c2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><operator>*</operator><operator>(</operator><name>Chunk</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>c1</name><operator>)</operator><operator>-&gt;</operator><name>table_id</name> <operator>-</operator> <operator>(</operator><operator>*</operator><operator>(</operator><name>Chunk</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>c2</name><operator>)</operator><operator>-&gt;</operator><name>table_id</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Chunk</name> <modifier>*</modifier><modifier>*</modifier></type>
<name>find_children_chunks</name><parameter_list>(<parameter><decl><type><name>HypertableRestrictInfo</name> <modifier>*</modifier></type><name>hri</name></decl></parameter>, <parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>num_chunks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>TS_HYPERTABLE_IS_INTERNAL_COMPRESSION_TABLE</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Chunk lookup doesn't work for internal compression tables, have to
		 * fall back to the regular postgres method.
		 */</comment>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>chunk_oids</name> <init>= <expr><call><name>find_inheritance_children</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>chunk_oids</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>num_chunks</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<return>return <expr><literal type="number">0</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><operator>*</operator><name>num_chunks</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>chunk_oids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier><modifier>*</modifier></type><name>chunks</name> <init>= <expr><operator>(</operator><name>Chunk</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Chunk</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>*</operator><name>num_chunks</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>*</operator><name>num_chunks</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>chunks</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>ts_chunk_get_by_relid</name><argument_list>(<argument><expr><call><name>list_nth_oid</name><argument_list>(<argument><expr><name>chunk_oids</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>,
											  <comment type="block">/* fail_if_not_found = */</comment> <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<return>return <expr><name>chunks</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Unlike find_all_inheritors we do not include parent because if there
	 * are restrictions the parent table cannot fulfill them and since we do
	 * have a trigger blocking inserts on the parent table it cannot contain
	 * any rows.
	 */</comment>
	<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier><modifier>*</modifier></type><name>chunks</name> <init>= <expr><call><name>ts_hypertable_restrict_info_get_chunks</name><argument_list>(<argument><expr><name>hri</name></expr></argument>, <argument><expr><name>ht</name></expr></argument>, <argument><expr><name>num_chunks</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Sort the chunks by oid ascending to roughly match the order provided
	 * by find_inheritance_children. This is mostly needed to avoid test
	 * reference changes.
	 */</comment>
	<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>chunks</name></expr></argument>, <argument><expr><operator>*</operator><name>num_chunks</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Chunk</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>chunk_cmp_chunk_reloid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>chunks</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>should_order_append</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>join_conditions</name></decl></parameter>,
					<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>order_attno</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>reverse</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* check if optimizations are enabled */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ts_guc_enable_optimizations</name> <operator>||</operator> <operator>!</operator><name>ts_guc_enable_ordered_append</name> <operator>||</operator>
		<operator>!</operator><name>ts_guc_enable_chunk_append</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * only do this optimization for hypertables with 1 dimension and queries
	 * with an ORDER BY clause
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>sortClause</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><call><name>ts_ordered_append_should_optimize</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ht</name></expr></argument>, <argument><expr><name>join_conditions</name></expr></argument>, <argument><expr><name>order_attno</name></expr></argument>, <argument><expr><name>reverse</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *  get chunk oids specified by explicit chunk exclusion function
 *
 *  Similar to the regular get_chunk_oids, we also populate the fdw_private
 *  structure appropriately if ordering info is present.
 */</comment>
<function><type><specifier>static</specifier> <name>Chunk</name> <modifier>*</modifier><modifier>*</modifier></type>
<name>get_explicit_chunks</name><parameter_list>(<parameter><decl><type><name>CollectQualCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>,
					<parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>num_chunks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>chunks_arg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayIterator</name></type> <name>chunk_id_iterator</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>chunk_id_arr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>chunk_id_arr_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>elem</name> <init>= <expr><operator>(</operator><name>Datum</name><operator>)</operator> <name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>reverse</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>order_attno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier><modifier>*</modifier></type><name>unlocked_chunks</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier><modifier>*</modifier></type><name>chunks</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>unlocked_chunk_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>prev_chunk_oid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>chunk_sort_needed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>num_chunks</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>chunk_exclusion_func</name><operator>-&gt;</operator><name>args</name><operator>-&gt;</operator><name>length</name></name> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>chunk_exclusion_func</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"second argument to chunk_in should contain only integer consts"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>chunks_arg</name> <operator>=</operator> <operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr>;</expr_stmt>

	<comment type="block">/* function marked as STRICT so argument can't be NULL */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>chunks_arg</name><operator>-&gt;</operator><name>constisnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>chunk_id_arr</name> <operator>=</operator> <call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name><name>chunks_arg</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>chunk_id_arr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid number of array dimensions for chunks_in"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>chunk_id_arr_size</name> <operator>=</operator> <call><name>ArrayGetNItems</name><argument_list>(<argument><expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>chunk_id_arr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>chunk_id_arr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>chunk_id_arr_size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* allocate an array of "Chunk *" and set it up below */</comment>
	<expr_stmt><expr><name>unlocked_chunks</name> <operator>=</operator> <operator>(</operator><name>Chunk</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Chunk</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>chunk_id_arr_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>chunk_id_iterator</name> <operator>=</operator> <call><name>array_create_iterator</name><argument_list>(<argument><expr><name>chunk_id_arr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><call><name>array_iterate</name><argument_list>(<argument><expr><name>chunk_id_iterator</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elem</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int32</name></type> <name>chunk_id</name> <init>= <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name> <init>= <expr><call><name>ts_chunk_get_by_id</name><argument_list>(<argument><expr><name>chunk_id</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>chunk</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"chunk id %d not found"</literal></expr></argument>, <argument><expr><name>chunk_id</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>hypertable_id</name></name> <operator>!=</operator> <name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"chunk id %d does not belong to hypertable \"%s\""</literal></expr></argument>,
								<argument><expr><name>chunk_id</name></expr></argument>,
								<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>prev_chunk_oid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>prev_chunk_oid</name> <operator>&gt;</operator> <name><name>chunk</name><operator>-&gt;</operator><name>table_id</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>chunk_sort_needed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>prev_chunk_oid</name> <operator>=</operator> <name><name>chunk</name><operator>-&gt;</operator><name>table_id</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>unlocked_chunks</name><index>[<expr><name>unlocked_chunk_count</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>chunk</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"chunk id can't be NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>array_free_iterator</name><argument_list>(<argument><expr><name>chunk_id_iterator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Sort chunks if needed for locking in Oid order in order to avoid
	 * deadlocks. In most cases, the access node sends the chunk ID array in
	 * Oid order, so no sorting is needed. (Note that chunk ID and Oid are
	 * different, but often result in the same order.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>unlocked_chunk_count</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>chunk_sort_needed</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>unlocked_chunks</name></expr></argument>, <argument><expr><name>unlocked_chunk_count</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Chunk</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>ts_chunk_oid_cmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>chunks</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Chunk</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>unlocked_chunk_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>unlocked_chunk_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>ts_chunk_lock_if_exists</name><argument_list>(<argument><expr><name><name>unlocked_chunks</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>table_id</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>chunks</name><index>[<expr><operator>(</operator><operator>*</operator><name>num_chunks</name><operator>)</operator><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>unlocked_chunks</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>unlocked_chunks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Chunks could have been concurrently removed or locking was not
	 * successful. If no chunks could be locked, then return.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>num_chunks</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>chunks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If fdw_private has not been setup by caller there is no point checking
	 * for ordered append as we can't pass the required metadata in fdw_private
	 * to signal that this is safe to transform in ordered append plan in
	 * set_rel_pathlist.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>fdw_private</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
		<call><name>should_order_append</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ht</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>join_conditions</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>order_attno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reverse</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TimescaleDBPrivate</name> <modifier>*</modifier></type><name>priv</name> <init>= <expr><call><name>ts_get_private_reloptinfo</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>nested_oids</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>priv</name><operator>-&gt;</operator><name>appends_ordered</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>priv</name><operator>-&gt;</operator><name>order_attno</name></name> <operator>=</operator> <name>order_attno</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * for space partitioning we need extra information about the
		 * time slices of the chunks
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>ht</name><operator>-&gt;</operator><name>space</name><operator>-&gt;</operator><name>num_dimensions</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>nested_oids</name> <operator>=</operator> <operator>&amp;</operator><name><name>priv</name><operator>-&gt;</operator><name>nested_oids</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* we don't need "hri" here since we already have the chunks */</comment>
		<return>return <expr><call><name>ts_hypertable_restrict_info_get_chunks_ordered</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
															  <argument><expr><name>ht</name></expr></argument>,
															  <argument><expr><name>chunks</name></expr></argument>,
															  <argument><expr><name>reverse</name></expr></argument>,
															  <argument><expr><name>nested_oids</name></expr></argument>,
															  <argument><expr><name>num_chunks</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>chunks</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Get chunks from either restrict info or explicit chunk exclusion. Explicit chunk exclusion
 * takes precedence.
 *
 * If appends are returned in order appends_ordered on rel-&gt;fdw_private is set to true.
 * To make verifying pathkeys easier in set_rel_pathlist the attno of the column ordered by
 * is
 * If the hypertable uses space partitioning the nested oids are stored in nested_oids
 * on rel-&gt;fdw_private when appends are ordered.
 */</comment>
<function><type><specifier>static</specifier> <name>Chunk</name> <modifier>*</modifier><modifier>*</modifier></type>
<name>get_chunks</name><parameter_list>(<parameter><decl><type><name>CollectQualCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>,
		   <parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>num_chunks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>reverse</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>order_attno</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>chunk_exclusion_func</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>get_explicit_chunks</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ht</name></expr></argument>, <argument><expr><name>num_chunks</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>HypertableRestrictInfo</name> <modifier>*</modifier></type><name>hri</name> <init>= <expr><call><name>ts_hypertable_restrict_info_create</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * This is where the magic happens: use our HypertableRestrictInfo
	 * infrastructure to deduce the appropriate chunks using our range
	 * exclusion
	 */</comment>
	<expr_stmt><expr><call><name>ts_hypertable_restrict_info_add</name><argument_list>(<argument><expr><name>hri</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>restrictions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If fdw_private has not been setup by caller there is no point checking
	 * for ordered append as we can't pass the required metadata in fdw_private
	 * to signal that this is safe to transform in ordered append plan in
	 * set_rel_pathlist.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>fdw_private</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
		<call><name>should_order_append</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ht</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>join_conditions</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>order_attno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reverse</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TimescaleDBPrivate</name> <modifier>*</modifier></type><name>priv</name> <init>= <expr><call><name>ts_get_private_reloptinfo</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>nested_oids</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>priv</name><operator>-&gt;</operator><name>appends_ordered</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>priv</name><operator>-&gt;</operator><name>order_attno</name></name> <operator>=</operator> <name>order_attno</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * for space partitioning we need extra information about the
		 * time slices of the chunks
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>ht</name><operator>-&gt;</operator><name>space</name><operator>-&gt;</operator><name>num_dimensions</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>nested_oids</name> <operator>=</operator> <operator>&amp;</operator><name><name>priv</name><operator>-&gt;</operator><name>nested_oids</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<return>return <expr><call><name>ts_hypertable_restrict_info_get_chunks_ordered</name><argument_list>(<argument><expr><name>hri</name></expr></argument>,
															  <argument><expr><name>ht</name></expr></argument>,
															  <argument><expr><name>NULL</name></expr></argument>,
															  <argument><expr><name>reverse</name></expr></argument>,
															  <argument><expr><name>nested_oids</name></expr></argument>,
															  <argument><expr><name>num_chunks</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>find_children_chunks</name><argument_list>(<argument><expr><name>hri</name></expr></argument>, <argument><expr><name>ht</name></expr></argument>, <argument><expr><name>num_chunks</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Create partition expressions for a hypertable.
 *
 * Build an array of partition expressions where each element represents valid
 * expressions on a particular partitioning key.
 *
 * The partition expressions are used by, e.g., group_by_has_partkey() to check
 * whether a GROUP BY clause covers all partitioning dimensions.
 *
 * For dimensions with a partitioning function, we can support either
 * expressions on the plain key (column) or the partitioning function applied
 * to the key. For instance, the queries
 *
 * SELECT time, device, avg(temp)
 * FROM hypertable
 * GROUP BY 1, 2;
 *
 * and
 *
 * SELECT time_func(time), device, avg(temp)
 * FROM hypertable
 * GROUP BY 1, 2;
 *
 * are both amenable to aggregate push down if "time" is supported by the
 * partitioning function "time_func" and "device" is also a partitioning
 * dimension.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier><modifier>*</modifier></type>
<name>get_hypertable_partexprs</name><parameter_list>(<parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parse</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>varno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>partexprs</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name><name>ht</name><operator>-&gt;</operator><name>space</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>partexprs</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>ht</name><operator>-&gt;</operator><name>space</name><operator>-&gt;</operator><name>num_dimensions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ht</name><operator>-&gt;</operator><name>space</name><operator>-&gt;</operator><name>num_dimensions</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Dimension</name> <modifier>*</modifier></type><name>dim</name> <init>= <expr><operator>&amp;</operator><name><name>ht</name><operator>-&gt;</operator><name>space</name><operator>-&gt;</operator><name>dimensions</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>partexprs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>ts_dimension_get_partexprs</name><argument_list>(<argument><expr><name>dim</name></expr></argument>, <argument><expr><name>varno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>partexprs</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARTITION_STRATEGY_MULTIDIM</name></cpp:macro> <cpp:value>'m'</cpp:value></cpp:define>

<comment type="block">/*
 * Partition info for hypertables.
 *
 * Build a "fake" partition scheme for a hypertable that makes the planner
 * believe this is a PostgreSQL partitioned table for planning purposes. In
 * particular, this will make the planner consider partitionwise aggregations
 * when applicable.
 *
 * Partitionwise aggregation can either be FULL or PARTIAL. The former means
 * that the aggregation can be performed independently on each partition
 * (chunk) without a finalize step which is needed in PARTIAL. FULL requires
 * that the GROUP BY clause contains all hypertable partitioning
 * dimensions. This requirement is enforced by creating a partitioning scheme
 * that covers multiple attributes, i.e., one per dimension. This works well
 * since the "shallow" (one-level hierarchy) of a multi-dimensional hypertable
 * is similar to a one-level partitioned PostgreSQL table where the
 * partitioning key covers multiple attributes.
 *
 * Note that we use a partition scheme with a strategy that does not exist in
 * PostgreSQL. This makes PostgreSQL raise errors when this partition scheme is
 * used in places that require a valid partition scheme with a supported
 * strategy.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>build_hypertable_partition_info</name><parameter_list>(<parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>hyper_rel</name></decl></parameter>,
								<parameter><decl><type><name>int</name></type> <name>nparts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PartitionScheme</name></type> <name>part_scheme</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PartitionSchemeData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionBoundInfo</name></type> <name>boundinfo</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PartitionBoundInfoData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* We only set the info needed for planning */</comment>
	<expr_stmt><expr><name><name>part_scheme</name><operator>-&gt;</operator><name>partnatts</name></name> <operator>=</operator> <name><name>ht</name><operator>-&gt;</operator><name>space</name><operator>-&gt;</operator><name>num_dimensions</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>part_scheme</name><operator>-&gt;</operator><name>strategy</name></name> <operator>=</operator> <name>PARTITION_STRATEGY_MULTIDIM</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hyper_rel</name><operator>-&gt;</operator><name>nparts</name></name> <operator>=</operator> <name>nparts</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>part_scheme</name><operator>-&gt;</operator><name>partopfamily</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>part_scheme</name><operator>-&gt;</operator><name>partnatts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>part_scheme</name><operator>-&gt;</operator><name>partopcintype</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>part_scheme</name><operator>-&gt;</operator><name>partnatts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>part_scheme</name><operator>-&gt;</operator><name>partcollation</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>part_scheme</name><operator>-&gt;</operator><name>partnatts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hyper_rel</name><operator>-&gt;</operator><name>part_scheme</name></name> <operator>=</operator> <name>part_scheme</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hyper_rel</name><operator>-&gt;</operator><name>partexprs</name></name> <operator>=</operator> <call><name>get_hypertable_partexprs</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></argument>, <argument><expr><name><name>hyper_rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hyper_rel</name><operator>-&gt;</operator><name>nullable_partexprs</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>part_scheme</name><operator>-&gt;</operator><name>partnatts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* PartitionBoundInfo is used for ordered append. We use a strategy that
	 * will avoid triggering an ordered append. */</comment>
	<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>strategy</name></name> <operator>=</operator> <name>PARTITION_STRATEGY_MULTIDIM</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>default_index</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>null_index</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>hyper_rel</name><operator>-&gt;</operator><name>boundinfo</name></name> <operator>=</operator> <name>boundinfo</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hyper_rel</name><operator>-&gt;</operator><name>part_rels</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>hyper_rel</name><operator>-&gt;</operator><name>part_rels</name></name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nparts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>timebucket_annotate_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>CollectQualCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>FromExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FromExpr</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>FromExpr</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <call><name>timebucket_annotate</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>JoinExpr</name> <modifier>*</modifier></type><name>j</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>JoinExpr</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <call><name>timebucket_annotate</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* skip processing if we found a chunks_in call for current relation */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>chunk_exclusion_func</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>timebucket_annotate_walker</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ts_plan_expand_timebucket_annotate</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CollectQualCtx</name></type> <name>ctx</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>root</name> <operator>=</operator> <name>root</name></expr>,
		<expr><operator>.</operator><name>rel</name> <operator>=</operator> <name>rel</name></expr>,
		<expr><operator>.</operator><name>restrictions</name> <operator>=</operator> <name>NIL</name></expr>,
		<expr><operator>.</operator><name>chunk_exclusion_func</name> <operator>=</operator> <name>NULL</name></expr>,
		<expr><operator>.</operator><name>all_quals</name> <operator>=</operator> <name>NIL</name></expr>,
		<expr><operator>.</operator><name>join_conditions</name> <operator>=</operator> <name>NIL</name></expr>,
		<expr><operator>.</operator><name>propagate_conditions</name> <operator>=</operator> <name>NIL</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>init_chunk_exclusion_func</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Walk the tree and find restrictions or chunk exclusion functions */</comment>
	<expr_stmt><expr><call><name>timebucket_annotate_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>.</operator><name>propagate_conditions</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>propagate_join_quals</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Inspired by expand_inherited_rtentry but expands
 * a hypertable chunks into an append relation. */</comment>
<function><type><name>void</name></type>
<name>ts_plan_expand_hypertable_chunks</name><parameter_list>(<parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimescaleDBPrivate</name> <modifier>*</modifier></type><name>priv</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>fdw_private</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>parent_oid</name> <init>= <expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>inh_oids</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>oldrelation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type> <name>rti</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>appinfos</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlanRowMark</name> <modifier>*</modifier></type><name>oldrc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CollectQualCtx</name></type> <name>ctx</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>root</name> <operator>=</operator> <name>root</name></expr>,
		<expr><operator>.</operator><name>rel</name> <operator>=</operator> <name>rel</name></expr>,
		<expr><operator>.</operator><name>restrictions</name> <operator>=</operator> <name>NIL</name></expr>,
		<expr><operator>.</operator><name>chunk_exclusion_func</name> <operator>=</operator> <name>NULL</name></expr>,
		<expr><operator>.</operator><name>all_quals</name> <operator>=</operator> <name>NIL</name></expr>,
		<expr><operator>.</operator><name>join_conditions</name> <operator>=</operator> <name>NIL</name></expr>,
		<expr><operator>.</operator><name>propagate_conditions</name> <operator>=</operator> <name>NIL</name></expr>,
		<expr><operator>.</operator><name>join_level</name> <operator>=</operator> <literal type="number">0</literal></expr>,
	}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type> <name>first_chunk_index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* double check our permissions are valid */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rti</name> <operator>!=</operator> <operator>(</operator><name>Index</name><operator>)</operator> <name><name>parse</name><operator>-&gt;</operator><name>resultRelation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>oldrc</name> <operator>=</operator> <call><name>get_plan_rowmark</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>rowMarks</name></name></expr></argument>, <argument><expr><name>rti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>oldrc</name> <operator>&amp;&amp;</operator> <call><name>RowMarkRequiresRowShareLock</name><argument_list>(<argument><expr><name><name>oldrc</name><operator>-&gt;</operator><name>markType</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected permissions requested"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>init_chunk_exclusion_func</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Walk the tree and find restrictions or chunk exclusion functions */</comment>
	<expr_stmt><expr><call><name>collect_quals_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* check join_level bookkeeping is balanced */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ctx</name><operator>.</operator><name>join_level</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>baserestrictinfo</name></name> <operator>=</operator> <call><name>remove_exclusion_fns</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>baserestrictinfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>.</operator><name>propagate_conditions</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>propagate_join_quals</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier><modifier>*</modifier></type><name>chunks</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>num_chunks</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>chunks</name> <operator>=</operator> <call><name>get_chunks</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ht</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num_chunks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Can have zero chunks. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>num_chunks</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>chunks</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_chunks</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>inh_oids</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>inh_oids</name></expr></argument>, <argument><expr><name><name>chunks</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>table_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Add the information about chunks to the baserel info cache for
		 * classify_relation().
		 */</comment>
		<expr_stmt><expr><call><name>add_baserel_cache_entry_for_chunk</name><argument_list>(<argument><expr><name><name>chunks</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>table_id</name></expr></argument>, <argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* nothing to do here if we have no chunks and no data nodes */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>inh_oids</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>data_nodes</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>oldrelation</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>parent_oid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * the simple_*_array structures have already been set, we need to add the
	 * children to them. We include potential data node rels we might need to
	 * create in case of a distributed hypertable.
	 */</comment>
	<expr_stmt><expr><call><name>expand_planner_arrays</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>inh_oids</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>data_nodes</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Adding partition info will make PostgreSQL consider the inheritance
	 * children as part of a partitioned relation. This will enable
	 * partitionwise aggregation. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>enable_partitionwise_aggregate</name> <operator>&amp;&amp;</operator>
		 <operator>!</operator><call><name>has_partialize_function</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></argument>, <argument><expr><name>TS_DO_NOT_FIX_AGGREF</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
		<call><name>hypertable_is_distributed</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>build_hypertable_partition_info</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>inh_oids</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>l</argument>, <argument>inh_oids</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>child_oid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type> <name>newrelation</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>childrte</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Index</name></type> <name>child_rtindex</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appinfo</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>LOCKMODE</name></type> <name>chunk_lock</name> <init>= <expr><name><name>rte</name><operator>-&gt;</operator><name>rellockmode</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Open rel if needed */</comment>

		<if_stmt><if>if <condition>(<expr><name>child_oid</name> <operator>!=</operator> <name>parent_oid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>newrelation</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>child_oid</name></expr></argument>, <argument><expr><name>chunk_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>newrelation</name> <operator>=</operator> <name>oldrelation</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* chunks cannot be temp tables */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>RELATION_IS_OTHER_TEMP</name><argument_list>(<argument><expr><name>newrelation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Build an RTE for the child, and attach to query's rangetable list.
		 * We copy most fields of the parent's RTE, but replace relation OID
		 * and relkind, and set inh = false.  Also, set requiredPerms to zero
		 * since all required permissions checks are done on the original RTE.
		 * Likewise, set the child's securityQuals to empty, because we only
		 * want to apply the parent's RLS conditions regardless of what RLS
		 * properties individual children may have.  (This is an intentional
		 * choice to make inherited RLS work like regular permissions checks.)
		 * The parent securityQuals will be propagated to children along with
		 * other base restriction clauses, so we don't need to do it here.
		 */</comment>
		<expr_stmt><expr><name>childrte</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>childrte</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <name>child_oid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>childrte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>=</operator> <name><name>newrelation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>childrte</name><operator>-&gt;</operator><name>inh</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<comment type="block">/* clear the magic bit */</comment>
		<expr_stmt><expr><name><name>childrte</name><operator>-&gt;</operator><name>ctename</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>childrte</name><operator>-&gt;</operator><name>requiredPerms</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>childrte</name><operator>-&gt;</operator><name>securityQuals</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>, <argument><expr><name>childrte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>child_rtindex</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>first_chunk_index</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>first_chunk_index</name> <operator>=</operator> <name>child_rtindex</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>simple_rte_array</name><index>[<expr><name>child_rtindex</name></expr>]</index></name> <operator>=</operator> <name>childrte</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>simple_rel_array</name><index>[<expr><name>child_rtindex</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>appinfo</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>AppendRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>appinfo</name><operator>-&gt;</operator><name>parent_relid</name></name> <operator>=</operator> <name>rti</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>appinfo</name><operator>-&gt;</operator><name>child_relid</name></name> <operator>=</operator> <name>child_rtindex</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>appinfo</name><operator>-&gt;</operator><name>parent_reltype</name></name> <operator>=</operator> <name><name>oldrelation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltype</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>appinfo</name><operator>-&gt;</operator><name>child_reltype</name></name> <operator>=</operator> <name><name>newrelation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltype</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ts_make_inh_translation_list</name><argument_list>(<argument><expr><name>oldrelation</name></expr></argument>,
									 <argument><expr><name>newrelation</name></expr></argument>,
									 <argument><expr><name>child_rtindex</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name><name>appinfo</name><operator>-&gt;</operator><name>translated_vars</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>appinfo</name><operator>-&gt;</operator><name>parent_reloid</name></name> <operator>=</operator> <name>parent_oid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>appinfos</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>appinfos</name></expr></argument>, <argument><expr><name>appinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Close child relations, but keep locks */</comment>
		<if_stmt><if>if <condition>(<expr><name>child_oid</name> <operator>!=</operator> <name>parent_oid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>newrelation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>oldrelation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>priv</name><operator>-&gt;</operator><name>serverids</name></name> <operator>=</operator> <call><name>ts_hypertable_get_data_node_serverids_list</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* For distributed hypertables, we'd like to turn per-chunk plans into
	 * per-data_node plans. We proactively add RTEs for the per-data_node rels here
	 * because the PostgreSQL planning code that we call to replan the
	 * per-data_node queries assumes there are RTEs for each rel that is considered
	 * a "partition."
	 *
	 * Note that each per-data_node RTE reuses the relid (OID) of the parent
	 * hypertable relation. This makes sense since each data node's
	 * hypertable is an identical (albeit partial) version of the access node's
	 * hypertable. The upside of this is that the planner can plan remote
	 * queries to take into account the indexes on the hypertable to produce
	 * more efficient remote queries. In contrast, chunks are foreign tables so
	 * they do not have indexes.
	 */</comment>
	<macro><name>foreach</name> <argument_list>(<argument>l</argument>, <argument>priv-&gt;serverids</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>data_node_rte</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>data_node_rte</name><operator>-&gt;</operator><name>inh</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>data_node_rte</name><operator>-&gt;</operator><name>ctename</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>data_node_rte</name><operator>-&gt;</operator><name>requiredPerms</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>data_node_rte</name><operator>-&gt;</operator><name>securityQuals</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>, <argument><expr><name>data_node_rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rti</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>simple_rte_array</name><index>[<expr><name>rti</name></expr>]</index></name> <operator>=</operator> <name>data_node_rte</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>simple_rel_array</name><index>[<expr><name>rti</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>priv</name><operator>-&gt;</operator><name>server_relids</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>priv</name><operator>-&gt;</operator><name>server_relids</name></name></expr></argument>, <argument><expr><name>rti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>ts_add_append_rel_infos</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>appinfos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* In pg12 postgres will not set up the child rels for use, due to the games
	 * we're playing with inheritance, so we must do it ourselves.
	 * build_simple_rel will look things up in the append_rel_array, so we can
	 * only use it after that array has been set up.
	 */</comment>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>inh_oids</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Index</name></type> <name>child_rtindex</name> <init>= <expr><name>first_chunk_index</name> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>
		<comment type="block">/* build_simple_rel will add the child to the relarray */</comment>
		<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>child_rel</name> <init>= <expr><call><name>build_simple_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>child_rtindex</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* if we're performing partitionwise aggregation, we must populate part_rels */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>part_rels</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>part_rels</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>child_rel</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG15_GE</name></expr></cpp:if>
			<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>live_parts</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>live_parts</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ts_get_private_reloptinfo</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>chunk</name> <operator>=</operator> <name><name>chunks</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>chunks</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>table_id</name> <operator>==</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rte_array</name><index>[<expr><name>child_rtindex</name></expr>]</index></name><operator>-&gt;</operator><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>propagate_join_quals</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>CollectQualCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ts_guc_enable_qual_propagation</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* propagate join constraints */</comment>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>ctx-&gt;propagate_conditions</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc_qual</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>rel_var</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>other_var</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * join_conditions only has OpExpr with 2 Var as arguments
		 * this is enforced in process_quals
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>list_length</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>OpExpr</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>args</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><call><name>lsecond</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * check this join condition refers to current hypertable
		 * our Var might be on either side of the expression
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>Index</name><operator>)</operator> <call><name>linitial_node</name><argument_list>(<argument><expr><name>Var</name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>varno</name> <operator>==</operator> <name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>rel_var</name> <operator>=</operator> <call><name>linitial_node</name><argument_list>(<argument><expr><name>Var</name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>other_var</name> <operator>=</operator> <call><name>lsecond_node</name><argument_list>(<argument><expr><name>Var</name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>(</operator><name>Index</name><operator>)</operator> <call><name>lsecond_node</name><argument_list>(<argument><expr><name>Var</name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>varno</name> <operator>==</operator> <name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>rel_var</name> <operator>=</operator> <call><name>lsecond_node</name><argument_list>(<argument><expr><name>Var</name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>other_var</name> <operator>=</operator> <call><name>linitial_node</name><argument_list>(<argument><expr><name>Var</name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></else></if_stmt>

		<macro><name>foreach</name> <argument_list>(<argument>lc_qual</argument>, <argument>ctx-&gt;all_quals</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>qual</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc_qual</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>left</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>qual</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>right</name> <init>= <expr><call><name>lsecond</name><argument_list>(<argument><expr><name><name>qual</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>propagated</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc_ri</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type> <name>new_qual</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * check this is Var OP Expr / Expr OP Var
			 * Var needs to reference the relid of the JOIN condition and
			 * Expr must not contain volatile functions
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>Var</name></expr></argument>, <argument><expr><name>left</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>varno</name> <operator>==</operator> <name><name>other_var</name><operator>-&gt;</operator><name>varno</name></name> <operator>&amp;&amp;</operator>
				<call><name>castNode</name><argument_list>(<argument><expr><name>Var</name></expr></argument>, <argument><expr><name>left</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>varattno</name> <operator>==</operator> <name><name>other_var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>right</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<operator>!</operator><call><name>contain_volatile_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>right</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>propagated</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>propagated</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><name>rel_var</name></expr></argument>, <argument><expr><call><name>lsecond</name><argument_list>(<argument><expr><name><name>propagated</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>right</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>Var</name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>varno</name> <operator>==</operator> <name><name>other_var</name><operator>-&gt;</operator><name>varno</name></name> <operator>&amp;&amp;</operator>
					 <call><name>castNode</name><argument_list>(<argument><expr><name>Var</name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>varattno</name> <operator>==</operator> <name><name>other_var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					 <operator>!</operator><call><name>contain_volatile_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>left</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>propagated</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>propagated</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>propagated</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rel_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></else></if_stmt>

			<comment type="block">/*
			 * check if this is a new qual
			 */</comment>
			<macro><name>foreach</name> <argument_list>(<argument>lc_ri</argument>, <argument>ctx-&gt;restrictions</argument>)</argument_list></macro>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>RestrictInfo</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc_ri</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>clause</name></expr></argument>, <argument><expr><name>propagated</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>new_qual</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>

			<if_stmt><if>if <condition>(<expr><name>new_qual</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Relids</name></type> <name>relids</name> <init>= <expr><call><name>pull_varnos_compat</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>propagated</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>restrictinfo</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>restrictinfo</name> <operator>=</operator> <call><name>make_restrictinfo_compat</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
														<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>propagated</name></expr></argument>,
														<argument><expr><name>true</name></expr></argument>,
														<argument><expr><name>false</name></expr></argument>,
														<argument><expr><name>false</name></expr></argument>,
														<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>root</name><operator>-&gt;</operator><name>qual_security_level</name></name></expr></argument>,
														<argument><expr><name>relids</name></expr></argument>,
														<argument><expr><name>NULL</name></expr></argument>,
														<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>restrictions</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>restrictions</name></name></expr></argument>, <argument><expr><name>restrictinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/*
				 * since hypertable expansion happens later in PG12 the propagated
				 * constraints will not be pushed down to the actual scans but stay
				 * as join filter. So we add them either as join filter or to
				 * baserestrictinfo depending on whether they reference only
				 * the currently processed relation or multiple relations.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>bms_num_members</name><argument_list>(<argument><expr><name>relids</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>relids</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_member</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>baserestrictinfo</name></name></expr></argument>, <argument><expr><name>restrictinfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>baserestrictinfo</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>baserestrictinfo</name></name></expr></argument>, <argument><expr><name>restrictinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator>
						<operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>, <argument><expr><name>propagated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block>
</block_content>}</block></function>
</unit>
