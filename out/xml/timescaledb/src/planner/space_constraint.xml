<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/timescaledb/src/planner/space_constraint.c"><comment type="block">/*
 * This file and its contents are licensed under the Apache License 2.0.
 * Please see the included NOTICE for copyright information and
 * LICENSE-APACHE for a copy of the license.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postgres.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/xact.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;datatype/timestamp.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/makefuncs.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/pg_list.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/optimizer.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;parser/parse_func.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/fmgroids.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/typcache.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dimension.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hypertable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hypertable_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"partitioning.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"planner.h"</cpp:file></cpp:include>

<comment type="block">/*
 * Returns space dimension for a specific column. Returns NULL
 * if the column is not a space dimension.
 */</comment>
<function><type><specifier>static</specifier> <name>Dimension</name> <modifier>*</modifier></type>
<name>get_space_dimension</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>varattno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name> <init>= <expr><call><name>ts_planner_get_hypertable</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>CACHE_FLAG_CHECK</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ht</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<for>for <control>(<init><decl><type><name>uint16</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ht</name><operator>-&gt;</operator><name>space</name><operator>-&gt;</operator><name>num_dimensions</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Dimension</name> <modifier>*</modifier></type><name>dim</name> <init>= <expr><operator>&amp;</operator><name><name>ht</name><operator>-&gt;</operator><name>space</name><operator>-&gt;</operator><name>dimensions</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>dim</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>DIMENSION_TYPE_CLOSED</name> <operator>&amp;&amp;</operator> <name><name>dim</name><operator>-&gt;</operator><name>column_attno</name></name> <operator>==</operator> <name>varattno</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>dim</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check if this operator is compatible with the constraints on
 * the space dimension. This is the equality operator between
 * left and right in the btree operator family.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_valid_space_operator</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opno</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>left</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>right</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>tce</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>left</name> <operator>==</operator> <name>right</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * When left and right match lookup_type_cache can
		 * directly return the equality operator saving us
		 * one roundtrip.
		 */</comment>
		<expr_stmt><expr><name>tce</name> <operator>=</operator> <call><name>lookup_type_cache</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>TYPECACHE_EQ_OPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>tce</name> <operator>&amp;&amp;</operator> <name>opno</name> <operator>==</operator> <name><name>tce</name><operator>-&gt;</operator><name>eq_opr</name></name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * The left and right type might not match when comparing
		 * different integer types eg comparing int2 or int8
		 * columns with integer literals which default to int4.
		 */</comment>
		<expr_stmt><expr><name>tce</name> <operator>=</operator> <call><name>lookup_type_cache</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>TYPECACHE_BTREE_OPFAMILY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tce</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<decl_stmt><decl><type><name>Oid</name></type> <name>eqop</name> <init>= <expr><call><name>get_opfamily_member</name><argument_list>(<argument><expr><name><name>tce</name><operator>-&gt;</operator><name>btree_opf</name></name></expr></argument>, <argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<return>return <expr><name>opno</name> <operator>==</operator> <name>eqop</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Valid constraints are: Var = Const
 * Var has to refer to a space partitioning column
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_valid_space_constraint</name><parameter_list>(<parameter><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rtable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><call><name>lsecond</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><call><name>linitial_node</name><argument_list>(<argument><expr><name>Var</name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>value</name> <init>= <expr><call><name>lsecond_node</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_valid_space_operator</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>vartype</name></name></expr></argument>, <argument><expr><name><name>value</name><operator>-&gt;</operator><name>consttype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Check that the constraint is actually on a partitioning column.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>&lt;=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>rtable</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>list_nth</name><argument_list>(<argument><expr><name>rtable</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Dimension</name> <modifier>*</modifier></type><name>dim</name> <init>= <expr><call><name>get_space_dimension</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dim</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Valid constraints are:
 *   Var = ANY(ARRAY[Const,Const])
 *   Var IN (Const,Const)
 * Var has to refer to a space partitioning column
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_valid_scalar_space_constraint</name><parameter_list>(<parameter><decl><type><name>ScalarArrayOpExpr</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rtable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>ScalarArrayOpExpr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><call><name>lsecond</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ArrayExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><call><name>linitial_node</name><argument_list>(<argument><expr><name>Var</name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayExpr</name> <modifier>*</modifier></type><name>arr</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>ArrayExpr</name></expr></argument>, <argument><expr><call><name>lsecond</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>arr</name><operator>-&gt;</operator><name>multidims</name></name> <operator>||</operator> <operator>!</operator><name><name>op</name><operator>-&gt;</operator><name>useOr</name></name> <operator>||</operator> <name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_valid_space_operator</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>vartype</name></name></expr></argument>, <argument><expr><name><name>arr</name><operator>-&gt;</operator><name>element_typeid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Check that the constraint is actually on a partitioning column.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>&lt;=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>rtable</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>list_nth</name><argument_list>(<argument><expr><name>rtable</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Dimension</name> <modifier>*</modifier></type><name>dim</name> <init>= <expr><call><name>get_space_dimension</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dim</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>arr-&gt;elements</argument>)</argument_list></macro>
	<block>{<block_content>
		<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>T_Const</name></expr>:</case>
				<break>break;</break>
			<case>case <expr><name>T_FuncExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>element</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>FuncExpr</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>element</name><operator>-&gt;</operator><name>funcformat</name></name> <operator>!=</operator> <name>COERCE_IMPLICIT_CAST</name> <operator>||</operator>
					<operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>element</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

				<break>break;</break>
			</block_content>}</block>
			<default>default:</default>
				<return>return <expr><name>false</name></expr>;</return>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>FuncExpr</name> <modifier>*</modifier></type>
<name>make_partfunc_call</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>funcid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>rettype</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>inputcollid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* build FuncExpr to use in eval_const_expressions */</comment>
	<return>return <expr><call><name>makeFuncExpr</name><argument_list>(<argument><expr><name>funcid</name></expr></argument> <comment type="block">/* funcid */</comment>,
						<argument><expr><name>rettype</name></expr></argument> <comment type="block">/* rettype */</comment>,
						<argument><expr><name>args</name></expr></argument> <comment type="block">/* args */</comment>,
						<argument><expr><name>InvalidOid</name></expr></argument> <comment type="block">/* funccollid */</comment>,
						<argument><expr><name>inputcollid</name></expr></argument> <comment type="block">/* inputcollid */</comment>,
						<argument><expr><name>COERCE_EXPLICIT_CALL</name></expr></argument> <comment type="block">/* fformat */</comment>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Transform a constraint like: device_id = 1
 * into
 * ((device_id = 1) AND (_timescaledb_internal.get_partition_hash(device_id) = 242423622))
 */</comment>
<function><type><specifier>static</specifier> <name>OpExpr</name> <modifier>*</modifier></type>
<name>transform_space_constraint</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rtable</name></decl></parameter>, <parameter><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>op</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><call><name>linitial_node</name><argument_list>(<argument><expr><name>Var</name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>value</name> <init>= <expr><call><name>lsecond_node</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>part_value</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>list_nth</name><argument_list>(<argument><expr><name>rtable</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Dimension</name> <modifier>*</modifier></type><name>dim</name> <init>= <expr><call><name>get_space_dimension</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>rettype</name> <init>= <expr><name><name>dim</name><operator>-&gt;</operator><name>partitioning</name><operator>-&gt;</operator><name>partfunc</name><operator>.</operator><name>rettype</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>tce</name> <init>= <expr><call><name>lookup_type_cache</name><argument_list>(<argument><expr><name>rettype</name></expr></argument>, <argument><expr><name>TYPECACHE_EQ_OPR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* build FuncExpr to use in eval_const_expressions */</comment>
	<decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>partcall</name> <init>= <expr><call><name>make_partfunc_call</name><argument_list>(<argument><expr><name><name>dim</name><operator>-&gt;</operator><name>partitioning</name><operator>-&gt;</operator><name>partfunc</name><operator>.</operator><name>func_fmgr</name><operator>.</operator><name>fn_oid</name></name></expr></argument>,
											<argument><expr><name>rettype</name></expr></argument>,
											<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varcollid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We should always be able to constify here
	 */</comment>
	<expr_stmt><expr><name>part_value</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><call><name>eval_const_expressions</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>partcall</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* build FuncExpr with column reference to use in constraint */</comment>
	<expr_stmt><expr><name><name>partcall</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>ret</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <call><name>make_opclause</name><argument_list>(<argument><expr><name><name>tce</name><operator>-&gt;</operator><name>eq_opr</name></name></expr></argument> <comment type="block">/* opno */</comment>,
										   <argument><expr><name>BOOLOID</name></expr></argument> <comment type="block">/*opresulttype */</comment>,
										   <argument><expr><name>false</name></expr></argument> <comment type="block">/* opretset */</comment>,
										   <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>partcall</name></expr></argument> <comment type="block">/* left */</comment>,
										   <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>part_value</name></expr></argument> <comment type="block">/* right */</comment>,
										   <argument><expr><name>InvalidOid</name></expr></argument> <comment type="block">/* opcollid */</comment>,
										   <argument><expr><name>InvalidOid</name></expr></argument> <comment type="block">/* inputcollid */</comment>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>ret</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name>PLANNER_LOCATION_MAGIC</name></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Transforms a constraint like: s1 = ANY ('{s1_2,s1_2}'::text[])
 * into
 * ((s1 = ANY ('{s1_2,s1_2}'::text[])) AND (_timescaledb_internal.get_partition_hash(s1) = ANY
 * ('{1583420735,1583420735}'::integer[])))
 */</comment>
<function><type><specifier>static</specifier> <name>ScalarArrayOpExpr</name> <modifier>*</modifier></type>
<name>transform_scalar_space_constraint</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rtable</name></decl></parameter>, <parameter><decl><type><name>ScalarArrayOpExpr</name> <modifier>*</modifier></type><name>op</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><call><name>linitial_node</name><argument_list>(<argument><expr><name>Var</name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>list_nth</name><argument_list>(<argument><expr><name>rtable</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Dimension</name> <modifier>*</modifier></type><name>dim</name> <init>= <expr><call><name>get_space_dimension</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>rettype</name> <init>= <expr><name><name>dim</name><operator>-&gt;</operator><name>partitioning</name><operator>-&gt;</operator><name>partfunc</name><operator>.</operator><name>rettype</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>tce</name> <init>= <expr><call><name>lookup_type_cache</name><argument_list>(<argument><expr><name>rettype</name></expr></argument>, <argument><expr><name>TYPECACHE_EQ_OPR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>part_values</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* build FuncExpr to use in eval_const_expressions */</comment>
	<decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>partcall</name> <init>= <expr><call><name>make_partfunc_call</name><argument_list>(<argument><expr><name><name>dim</name><operator>-&gt;</operator><name>partitioning</name><operator>-&gt;</operator><name>partfunc</name><operator>.</operator><name>func_fmgr</name><operator>.</operator><name>fn_oid</name></name></expr></argument>,
											<argument><expr><name>rettype</name></expr></argument>,
											<argument><expr><name>NIL</name></expr></argument>,
											<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varcollid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>lsecond_node(ArrayExpr, op-&gt;args)-&gt;elements</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call> <operator>||</operator>
			   <operator>(</operator><call><name>IsA</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<call><name>lfirst_node</name><argument_list>(<argument><expr><name>FuncExpr</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>funcformat</name> <operator>==</operator> <name>COERCE_IMPLICIT_CAST</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We can skip NULL here as elements are ORed and partitioning dimensions
		 * have NOT NULL constraint.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>lfirst_node</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>constisnull</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name> <init>= <expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>partcall</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>args</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>part_values</name> <operator>=</operator>
			<call><name>lappend</name><argument_list>(<argument><expr><name>part_values</name></expr></argument>, <argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><call><name>eval_const_expressions</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>partcall</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<comment type="block">/* build FuncExpr with column reference to use in constraint */</comment>
	<expr_stmt><expr><name><name>partcall</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ArrayExpr</name> <modifier>*</modifier></type><name>arr2</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ArrayExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>arr2</name><operator>-&gt;</operator><name>array_collid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>arr2</name><operator>-&gt;</operator><name>array_typeid</name></name> <operator>=</operator> <call><name>get_array_type</name><argument_list>(<argument><expr><name>rettype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>arr2</name><operator>-&gt;</operator><name>element_typeid</name></name> <operator>=</operator> <name>rettype</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>arr2</name><operator>-&gt;</operator><name>multidims</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>arr2</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>arr2</name><operator>-&gt;</operator><name>elements</name></name> <operator>=</operator> <name>part_values</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ScalarArrayOpExpr</name> <modifier>*</modifier></type><name>op2</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ScalarArrayOpExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>op2</name><operator>-&gt;</operator><name>opno</name></name> <operator>=</operator> <name><name>tce</name><operator>-&gt;</operator><name>eq_opr</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>op2</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><name>partcall</name></expr></argument>, <argument><expr><name>arr2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>op2</name><operator>-&gt;</operator><name>inputcollid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>op2</name><operator>-&gt;</operator><name>useOr</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>op2</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name>PLANNER_LOCATION_MAGIC</name></expr>;</expr_stmt>

	<return>return <expr><name>op2</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Transform constraints for hash-based partitioning columns to make
 * them usable by postgres constraint exclusion.
 *
 * If we have an equality condition on a space partitioning column, we add
 * a corresponding condition on get_partition_hash on this column. These
 * conditions match the constraints on chunks, so postgres' constraint
 * exclusion is able to use them and exclude the chunks.
 *
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>ts_add_space_constraints</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rtable</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_ScalarArrayOpExpr</name></expr>:</case>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>is_valid_scalar_space_constraint</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>ScalarArrayOpExpr</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rtable</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name> <init>=
					<expr><call><name>list_make2</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
							   <argument><expr><call><name>transform_scalar_space_constraint</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
																 <argument><expr><name>rtable</name></expr></argument>,
																 <argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>ScalarArrayOpExpr</name></expr></argument>,
																		  <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>AND_EXPR</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<break>break;</break>
		</block_content>}</block>
		<case>case <expr><name>T_OpExpr</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>is_valid_space_constraint</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>OpExpr</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rtable</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name> <init>=
					<expr><call><name>list_make2</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
							   <argument><expr><call><name>transform_space_constraint</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rtable</name></expr></argument>, <argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>OpExpr</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>AND_EXPR</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_BoolExpr</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>BoolExpr</name> <modifier>*</modifier></type><name>be</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>BoolExpr</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>be</name><operator>-&gt;</operator><name>boolop</name></name> <operator>==</operator> <name>AND_EXPR</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>additions</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
				<comment type="block">/*
				 * If this is a top-level AND we can just append our transformed constraints
				 * to the list of ANDed expressions.
				 */</comment>
				<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>be-&gt;args</argument>)</argument_list></macro>
				<block>{<block_content>
					<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<case>case <expr><name>T_OpExpr</name></expr>:</case>
						<block>{<block_content>
							<decl_stmt><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>OpExpr</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
							<if_stmt><if>if <condition>(<expr><call><name>is_valid_space_constraint</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>rtable</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><name>additions</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>additions</name></expr></argument>,
													<argument><expr><call><name>transform_space_constraint</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rtable</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
							<break>break;</break>
						</block_content>}</block>
						<case>case <expr><name>T_ScalarArrayOpExpr</name></expr>:</case>
						<block>{<block_content>
							<decl_stmt><decl><type><name>ScalarArrayOpExpr</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>ScalarArrayOpExpr</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
							<if_stmt><if>if <condition>(<expr><call><name>is_valid_scalar_space_constraint</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>rtable</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><name>additions</name> <operator>=</operator>
									<call><name>lappend</name><argument_list>(<argument><expr><name>additions</name></expr></argument>,
											<argument><expr><call><name>transform_scalar_space_constraint</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rtable</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
							<break>break;</break>
						</block_content>}</block>
						<default>default:</default>
							<break>break;</break>
					</block_content>}</block></switch>
				</block_content>}</block>

				<if_stmt><if>if <condition>(<expr><name>additions</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>be</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name><name>be</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>additions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		</block_content>}</block>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>
</unit>
