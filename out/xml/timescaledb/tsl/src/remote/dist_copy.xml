<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/timescaledb/tsl/src/remote/dist_copy.c"><comment type="block">/*
 * This file and its contents are licensed under the Timescale License.
 * Please see the included NOTICE for copyright information and
 * LICENSE-TIMESCALE for a copy of the license.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dist_copy.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postgres.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/tupdesc.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/namespace.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;executor/executor.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;libpq-fe.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;miscadmin.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;parser/parse_type.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;port/pg_bswap.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/builtins.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/lsyscache.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compat/compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"chunk.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"copy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"data_node.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dimension.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dimension_slice.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hypercube.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hypertable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/chunk_dispatch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/chunk_insert_state.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"partitioning.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"remote/connection_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"remote/dist_txn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ts_catalog/chunk_data_node.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_PG_DELIMITER</name></cpp:macro> <cpp:value>'\t'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_PG_NULL_VALUE</name></cpp:macro> <cpp:value>"\\N"</cpp:value></cpp:define>

<comment type="block">/*
 * Maximum number of rows in batch for insert. Note that arrays of this size are
 * also allocated on stack.
 * Don't forget to change the broken recv() tests in dist_remote_error that test
 * some boundary conditions around this number.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_BATCH_ROWS</name></cpp:macro> <cpp:value>1024</cpp:value></cpp:define>

<comment type="block">/*
 * Maximum bytes of COPY data in batch. This is also the default size of the
 * output copy data buffer.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_BATCH_BYTES</name></cpp:macro> <cpp:value>(1 * 1024 * 1024)</cpp:value></cpp:define>

<comment type="block">/* This contains the information needed to parse a dimension attribute out of a row of text copy
 * data
 */</comment>
<typedef>typedef <type><struct>struct <name>CopyDimensionInfo</name>
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type><name>dim</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>corresponding_copy_field</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>default_value</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name></type> <name>io_func</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>typioparams</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>atttypmod</name></decl>;</decl_stmt>
}</block></struct></type> <name>CopyDimensionInfo</name>;</typedef>

<typedef>typedef <type><struct>struct <name>DataNodeConnection</name>
<block>{
	<decl_stmt><decl><type><name>TSConnectionId</name></type> <name>id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TSConnection</name> <modifier>*</modifier></type><name>connection</name></decl>;</decl_stmt>
}</block></struct></type> <name>DataNodeConnection</name>;</typedef>

<comment type="block">/* This contains information about connections currently in use by the copy as well as how to create
 * and end the copy command.
 */</comment>
<typedef>typedef <type><struct>struct <name>CopyConnectionState</name>
<block>{
	<comment type="block">/*
	 * Cached connections to data nodes.
	 * Why do we need another layer of caching, when there is dist_txn layer
	 * already? The API it provides is one function that "does everything
	 * automatically", namely it's going to stop the COPY each time we request
	 * the connection. This is not something we want to do for each row when
	 * we're trying to do bulk copy.
	 * We can't use the underlying remote_connection_cache directly, because the
	 * remote chunk creation (chunk_api_create_on_data_nodes) would still use
	 * the dist_txn layer. Chunks are created interleaved with the actual COPY
	 * operation, so we would have to somehow maintain these two layers in sync.
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>data_node_connections</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Connections to which we have written something and have to finalize them.
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>connections_in_use</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>using_binary</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>outgoing_copy_cmd</name></decl>;</decl_stmt>
}</block></struct></type> <name>CopyConnectionState</name>;</typedef>

<comment type="block">/* This contains the state needed by a non-binary copy operation.
 */</comment>
<typedef>typedef <type><struct>struct <name>TextCopyContext</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>ndimensions</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CopyDimensionInfo</name> <modifier>*</modifier></type><name>dimensions</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>out_functions</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name>delimiter</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>null_string</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>fields</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nfields</name></decl>;</decl_stmt>
}</block></struct></type> <name>TextCopyContext</name>;</typedef>

<comment type="block">/* This contains the state needed by a binary copy operation.
 */</comment>
<typedef>typedef <type><struct>struct <name>BinaryCopyContext</name>
<block>{
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>out_functions</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
}</block></struct></type> <name>BinaryCopyContext</name>;</typedef>

<comment type="block">/* This is this high level state needed for an in-progress copy command.
 */</comment>
<typedef>typedef <type><struct>struct <name>RemoteCopyContext</name>
<block>{
	<comment type="block">/* Operation data */</comment>
	<decl_stmt><decl><type><name>CopyConnectionState</name></type> <name>connection_state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>attnums</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>data_context</name></decl>;</decl_stmt> <comment type="block">/* TextCopyContext or BinaryCopyContext */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>binary_operation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>mctx</name></decl>;</decl_stmt> <comment type="block">/* MemoryContext that holds the RemoteCopyContext */</comment>

	<comment type="block">/*
	 * Incoming rows are batched before creating the chunks and sending them to
	 * data nodes. The following fields contain the current batch of rows.
	 */</comment>
	<decl_stmt><decl><type><name>StringInfo</name> <modifier>*</modifier></type><name>batch_row_data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>batch_row_count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>batch_size_bytes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name> <modifier>*</modifier><modifier>*</modifier></type><name>batch_points</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>batch_ordinal</name></decl>;</decl_stmt>
}</block></struct></type> <name>RemoteCopyContext</name>;</typedef>

<comment type="block">/*
 * This will create and populate a CopyDimensionInfo struct from the passed in
 * dimensions and values.
 */</comment>
<function><type><specifier>static</specifier> <name>CopyDimensionInfo</name> <modifier>*</modifier></type>
<name>generate_copy_dimensions</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type><name>dims</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ndimensions</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>attnums</name></decl></parameter>,
						 <parameter><decl><type><specifier>const</specifier> <name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CopyDimensionInfo</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><name>ndimensions</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>CopyDimensionInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>idx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>idx</name> <operator>&lt;</operator> <name>ndimensions</name></expr>;</condition> <incr><expr><operator>++</operator><name>idx</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type><name>d</name> <init>= <expr><operator>&amp;</operator><name><name>dims</name><index>[<expr><name>idx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CopyDimensionInfo</name> <modifier>*</modifier></type><name>target</name> <init>= <expr><operator>&amp;</operator><name><name>result</name><index>[<expr><name>idx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>attnums</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>d</name><operator>-&gt;</operator><name>column_attno</name></name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<expr_stmt><expr><operator>++</operator><name>i</name></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>dim</name></name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name><name>attnums</name><operator>-&gt;</operator><name>length</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unable to use default value for partitioning column \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>column_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name> <init>= <expr><call><name>relation_open</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TupleDesc</name></type> <name>rel_desc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attribute</name> <init>=
				<expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>rel_desc</name></expr></argument>, <argument><expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>column_attno</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type> <name>in_func_oid</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>corresponding_copy_field</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>getTypeInputInfo</name><argument_list>(<argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>in_func_oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>target</name><operator>-&gt;</operator><name>typioparams</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>in_func_oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>target</name><operator>-&gt;</operator><name>io_func</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>atttypmod</name></name> <operator>=</operator> <name><name>attribute</name><operator>-&gt;</operator><name>atttypmod</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>get_copy_dimension_datum</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>fields</name></decl></parameter>, <parameter><decl><type><name>CopyDimensionInfo</name> <modifier>*</modifier></type><name>info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type> <name>d</name></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>corresponding_copy_field</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>fields</name><index>[<expr><name><name>info</name><operator>-&gt;</operator><name>corresponding_copy_field</name></name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NOT_NULL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"NULL value in column \"%s\" violates not-null constraint"</literal></expr></argument>,
							<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>column_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Columns used for partitioning cannot be NULL"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>InputFunctionCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>info</name><operator>-&gt;</operator><name>io_func</name></name></expr></argument>,
							  <argument><expr><name><name>fields</name><index>[<expr><name><name>info</name><operator>-&gt;</operator><name>corresponding_copy_field</name></name></expr>]</index></name></expr></argument>,
							  <argument><expr><name><name>info</name><operator>-&gt;</operator><name>typioparams</name></name></expr></argument>,
							  <argument><expr><name><name>info</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>d</name> <operator>=</operator> <name><name>info</name><operator>-&gt;</operator><name>default_value</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>d</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int64</name></type>
<name>convert_datum_to_dim_idx</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>datum</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type><name>d</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>dimtype</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>partitioning</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>ts_partitioning_func_apply</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>partitioning</name></name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>DIMENSION_TYPE_OPEN</name></expr>:</case>
			<expr_stmt><expr><name>dimtype</name> <operator>=</operator>
				<ternary><condition><expr><operator>(</operator><name><name>d</name><operator>-&gt;</operator><name>partitioning</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>d</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>column_type</name></name></expr> </then><else>: <expr><name><name>d</name><operator>-&gt;</operator><name>partitioning</name><operator>-&gt;</operator><name>partfunc</name><operator>.</operator><name>rettype</name></name></expr></else></ternary></expr>;</expr_stmt>

			<return>return <expr><call><name>ts_time_value_to_internal</name><argument_list>(<argument><expr><name>datum</name></expr></argument>, <argument><expr><name>dimtype</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>DIMENSION_TYPE_CLOSED</name></expr>:</case>
			<return>return <expr><operator>(</operator><name>int64</name><operator>)</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>DIMENSION_TYPE_ANY</name></expr>:</case>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid dimension type when inserting tuple"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Point</name> <modifier>*</modifier></type>
<name>calculate_hyperspace_point_from_fields</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>CopyDimensionInfo</name> <modifier>*</modifier></type><name>dimensions</name></decl></parameter>,
									   <parameter><decl><type><name>int</name></type> <name>num_dimensions</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Point</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><call><name>POINT_SIZE</name><argument_list>(<argument><expr><name>num_dimensions</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>cardinality</name></name> <operator>=</operator> <name>num_dimensions</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>num_coords</name></name> <operator>=</operator> <name>num_dimensions</name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_dimensions</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type> <name>datum</name> <init>= <expr><call><name>get_copy_dimension_datum</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dimensions</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>coordinates</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>convert_datum_to_dim_idx</name><argument_list>(<argument><expr><name>datum</name></expr></argument>, <argument><expr><name><name>dimensions</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Look up or set up a COPY connection to the data node.
 */</comment>
<function><type><specifier>static</specifier> <name>TSConnection</name> <modifier>*</modifier></type>
<name>get_copy_connection_to_data_node</name><parameter_list>(<parameter><decl><type><name>RemoteCopyContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>TSConnectionId</name></type> <name>required_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>mctx</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CopyConnectionState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>connection_state</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TSConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>state-&gt;data_node_connections</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DataNodeConnection</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><operator>(</operator><name>DataNodeConnection</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>required_id</name><operator>.</operator><name>server_id</name></name> <operator>==</operator> <name><name>entry</name><operator>-&gt;</operator><name>id</name><operator>.</operator><name>server_id</name></name> <operator>&amp;&amp;</operator>
			<name><name>required_id</name><operator>.</operator><name>user_id</name></name> <operator>==</operator> <name><name>entry</name><operator>-&gt;</operator><name>id</name><operator>.</operator><name>user_id</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>connection</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>connection</name></name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>connection</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Did not find a cached connection, create a new one and cache it.
		 * The rest of the code using the connection cache in this process has
		 * to take care of exiting the COPY subprotocol if it wants to do
		 * something else like creating a new chunk. Normally this is done under
		 * the hood by the remote connection layer, and the dist_copy layer also
		 * uses faster functions that do this for several connections in
		 * parallel.
		 */</comment>
		<expr_stmt><expr><name>connection</name> <operator>=</operator> <call><name>remote_dist_txn_get_connection</name><argument_list>(<argument><expr><name>required_id</name></expr></argument>, <argument><expr><name>REMOTE_TXN_NO_PREP_STMT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>DataNodeConnection</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DataNodeConnection</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>connection</name></name> <operator>=</operator> <name>connection</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <name>required_id</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>data_node_connections</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>data_node_connections</name></name></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Begin COPY on the connection if needed.
	 */</comment>
	<decl_stmt><decl><type><name>TSConnectionStatus</name></type> <name>status</name> <init>= <expr><call><name>remote_connection_get_status</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>CONN_IDLE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TSConnectionError</name></type> <name>err</name></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>remote_connection_begin_copy</name><argument_list>(<argument><expr><name>connection</name></expr></argument>,
										  <argument><expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s /* batch %d conn %p */"</literal></expr></argument>,
												   <argument><expr><name><name>state</name><operator>-&gt;</operator><name>outgoing_copy_cmd</name></name></expr></argument>,
												   <argument><expr><name><name>context</name><operator>-&gt;</operator><name>batch_ordinal</name></name></expr></argument>,
												   <argument><expr><call><name>remote_connection_get_pg_conn</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><name><name>state</name><operator>-&gt;</operator><name>using_binary</name></name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>err</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>remote_connection_error_elog</name><argument_list>(<argument><expr><operator>&amp;</operator><name>err</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Add the connection to the list of active connections to be
		 * flushed later.
		 * The normal distributed insert path (not dist_copy, but
		 * data_node_copy) doesn't reset the connections when it creates
		 * a new chunk. So the connection status will be idle after we
		 * created a new chunk, but it will still be in the list of
		 * active connections. Don't add duplicates.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_member</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>connections_in_use</name></name></expr></argument>, <argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>connections_in_use</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>connections_in_use</name></name></expr></argument>, <argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>status</name> <operator>==</operator> <name>CONN_COPY_IN</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Ready to use. */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_member</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>connections_in_use</name></name></expr></argument>, <argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			 <argument><expr><literal type="string">"wrong status %d for connection to data node %d when performing "</literal>
			 <literal type="string">"distributed COPY\n"</literal></expr></argument>,
			 <argument><expr><name>status</name></expr></argument>,
			 <argument><expr><name><name>required_id</name><operator>.</operator><name>server_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>connection</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Flush the outgoing buffers on the active data node connections.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>flush_active_connections</name><parameter_list>(<parameter><decl><type><name>CopyConnectionState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * The connections that we are going to flush on the current iteration.
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>to_flush</name> <init>= <expr><call><name>list_copy</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>connections_in_use</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="block">/*
	 * The connections that were busy on the current iteration and that we have
	 * to wait for.
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>busy_connections</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>to_flush_cell</name></decl>;</decl_stmt>
		<macro><name>foreach</name> <argument_list>(<argument>to_flush_cell</argument>, <argument>to_flush</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TSConnection</name> <modifier>*</modifier></type><name>conn</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>to_flush_cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>pg_conn</name> <init>= <expr><call><name>remote_connection_get_pg_conn</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>remote_connection_get_status</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CONN_COPY_IN</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * This functions only makes sense for connections that are
				 * currently doing COPY and therefore are in nonblocking mode.
				 */</comment>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * This function expects that the COPY processing so far was
			 * successful, so the data connections should be in nonblocking
			 * mode.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>PQisnonblocking</name><argument_list>(<argument><expr><name>pg_conn</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Write out all the pending buffers. */</comment>
			<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>PQflush</name><argument_list>(<argument><expr><name>pg_conn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TSConnectionError</name></type> <name>err</name></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>remote_connection_get_error</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>remote_connection_error_elog</name><argument_list>(<argument><expr><operator>&amp;</operator><name>err</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>res</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Flushed. */</comment>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* Busy. */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>res</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>busy_connections</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>busy_connections</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/* Hooray, done with this connection. */</comment>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>busy_connections</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Flushed everything. */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Wait for changes on the busy connections.
		 * Postgres API doesn't allow to remove a socket from the wait event,
		 * and it's level-triggered, so we have to recreate the set each time.
		 */</comment>
		<decl_stmt><decl><type><name>WaitEventSet</name> <modifier>*</modifier></type><name>set</name> <init>=
			<expr><call><name>CreateWaitEventSet</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>, <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>busy_connections</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Postmaster-managed callers must handle postmaster death somehow,
		 * as stated by the comments in WaitLatchOrSocket.
		 */</comment>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>AddWaitEventToSet</name><argument_list>(<argument><expr><name>set</name></expr></argument>, <argument><expr><name>WL_EXIT_ON_PM_DEATH</name></expr></argument>, <argument><expr><name>PGINVALID_SOCKET</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Add wait events for each busy connection.
		 */</comment>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>busy_cell</name></decl>;</decl_stmt>
		<macro><name>foreach</name> <argument_list>(<argument>busy_cell</argument>, <argument>busy_connections</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TSConnection</name> <modifier>*</modifier></type><name>conn</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>busy_cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>pg_conn</name> <init>= <expr><call><name>remote_connection_get_pg_conn</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>AddWaitEventToSet</name><argument_list>(<argument><expr><name>set</name></expr></argument>,
									 <comment type="block">/* events = */</comment> <argument><expr><name>WL_SOCKET_WRITEABLE</name></expr></argument>,
									 <argument><expr><call><name>PQsocket</name><argument_list>(<argument><expr><name>pg_conn</name></expr></argument>)</argument_list></call></expr></argument>,
									 <comment type="block">/* latch = */</comment> <argument><expr><name>NULL</name></expr></argument>,
									 <comment type="block">/* user_data = */</comment> <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/* Wait. */</comment>
		<decl_stmt><decl><type><name>WaitEvent</name></type> <name><name>occurred</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name> <name>wait_result</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name> <init>= <expr><call><name>WaitEventSetWait</name><argument_list>(<argument><expr><name>set</name></expr></argument>,
																	<comment type="block">/* timeout = */</comment> <argument><expr><literal type="number">1000</literal></expr></argument>,
																	<argument><expr><name>occurred</name></expr></argument>,
																	<comment type="block">/* nevents = */</comment> <argument><expr><literal type="number">1</literal></expr></argument>,
																	<argument><expr><name>WAIT_EVENT_COPY_FILE_WRITE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * The possible results are:
		 * `0` -- Timeout. Just retry the flush, it will report errors in case
		 *        there are any.
		 * `1` -- We have successfully waited for something, we don't care,
		 *        just continue flushing the rest of the list.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>wait_result</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>wait_result</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>FreeWaitEventSet</name><argument_list>(<argument><expr><name>set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Repeat the procedure for all the connections that were busy.
		 */</comment>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><name>busy_connections</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>busy_connections</name> <operator>=</operator> <name>to_flush</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>to_flush</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>busy_connections</name> <operator>=</operator> <call><name>list_truncate</name><argument_list>(<argument><expr><name>busy_connections</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Flush all active data node connections and end COPY simultaneously, instead
 * of doing this one-by-one in remote_connection_end_copy(). Implies that there
 * were no errors so far. For error handling, use remote_connection_end_copy().
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>end_copy_on_success</name><parameter_list>(<parameter><decl><type><name>CopyConnectionState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>to_end_copy</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>state-&gt;connections_in_use</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TSConnection</name> <modifier>*</modifier></type><name>conn</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * We expect the connection to be in CONN_COPY_IN status.
		 * What about other statuses?
		 * CONN_IDLE:
		 * The normal distributed insert path (not dist_copy, but
		 * data_node_copy) doesn't reset the connections when it creates
		 * a new chunk. So the connection status will be idle after we
		 * created a new chunk, but it will still be in the list of
		 * active connections. On the other hand, this function isn't called
		 * on the normal insert path, so we shouldn't see this state here.
		 * CONN_PROCESSING:
		 * Not sure what it would mean, probably an internal program error.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>remote_connection_get_status</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CONN_COPY_IN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>pg_conn</name> <init>= <expr><call><name>remote_connection_get_pg_conn</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * This function expects that the COPY processing so far was
		 * successful, so the data connections should be in nonblocking
		 * mode.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>PQisnonblocking</name><argument_list>(<argument><expr><name>pg_conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><call><name>PQgetResult</name><argument_list>(<argument><expr><name>pg_conn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * No activity on the connection while we're expecting COPY. This
			 * is probably an internal program error.
			 */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				 <argument><expr><literal type="string">"the connection is expected to be in PGRES_COPY_IN status, but it has no activity "</literal>
				 <literal type="string">"(when flushing data)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COPY_IN</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sqlstate</name> <init>= <expr><call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>PG_DIAG_SQLSTATE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>sqlstate</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>sqlstate</name></expr></argument>, <argument><expr><literal type="string">"00000"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * An error has occurred.
				 */</comment>
				<decl_stmt><decl><type><name>TSConnectionError</name></type> <name>err</name></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>remote_connection_get_result_error</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>remote_connection_error_elog</name><argument_list>(<argument><expr><operator>&amp;</operator><name>err</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * No erroneous SQLSTATE, but at the same time the connection is
			 * not in PGRES_COPY_IN status. This must be a logic error.
			 */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				 <argument><expr><literal type="string">"the connection is expected to be in PGRES_COPY_IN status, but instead the status "</literal>
				 <literal type="string">"is %d  (when flushing data)"</literal></expr></argument>,
				 <argument><expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* The connection is in PGRES_COPY_IN status, as expected. */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>res</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PGRES_COPY_IN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>to_end_copy</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>to_end_copy</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PQputCopyEnd</name><argument_list>(<argument><expr><name>pg_conn</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not end remote COPY"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>pg_conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>flush_active_connections</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Switch the connections back into blocking mode because that's what the
	 * non-COPY code expects.
	 */</comment>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>to_end_copy</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TSConnection</name> <modifier>*</modifier></type><name>conn</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>pg_conn</name> <init>= <expr><call><name>remote_connection_get_pg_conn</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PQsetnonblocking</name><argument_list>(<argument><expr><name>pg_conn</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"failed to switch the connection into blocking mode"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>pg_conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Verify that the copy has successfully finished on each connection.
	 */</comment>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>to_end_copy</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TSConnection</name> <modifier>*</modifier></type><name>conn</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>pg_conn</name> <init>= <expr><call><name>remote_connection_get_pg_conn</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><call><name>PQgetResult</name><argument_list>(<argument><expr><name>pg_conn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected NULL result when ending remote COPY"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TSConnectionError</name></type> <name>err</name></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>remote_connection_get_result_error</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>remote_connection_error_elog</name><argument_list>(<argument><expr><operator>&amp;</operator><name>err</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQgetResult</name><argument_list>(<argument><expr><name>pg_conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>res</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected non-NULL result %d when ending remote COPY"</literal></expr></argument>,
							<argument><expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>pg_conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Mark the connections as idle. If an error occurs before this, the
	 * connections are going to be still marked as CONN_COPY_IN, and the
	 * remote_connection_end_copy() will bring each connection to a valid state.
	 */</comment>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>to_end_copy</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TSConnection</name> <modifier>*</modifier></type><name>conn</name> <init>= <expr><operator>(</operator><name>TSConnection</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>remote_connection_set_status</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>CONN_IDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>to_end_copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>connections_in_use</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>connections_in_use</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>end_copy_on_failure</name><parameter_list>(<parameter><decl><type><name>CopyConnectionState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Exit the copy subprotocol. */</comment>
	<decl_stmt><decl><type><name>TSConnectionError</name></type> <name>err</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>failure</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>state-&gt;connections_in_use</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TSConnection</name> <modifier>*</modifier></type><name>conn</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>remote_connection_get_status</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CONN_COPY_IN</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>remote_connection_end_copy</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>err</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>failure</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>connections_in_use</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>connections_in_use</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>failure</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>remote_connection_error_elog</name><argument_list>(<argument><expr><operator>&amp;</operator><name>err</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>List</name> <modifier>*</modifier></type>
<name>get_connections_for_chunk</name><parameter_list>(<parameter><decl><type><name>RemoteCopyContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>chunk_id</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>chunk_data_nodes</name></decl></parameter>,
						  <parameter><decl><type><name>Oid</name></type> <name>userid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>conns</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>chunk_data_nodes</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ChunkDataNode</name> <modifier>*</modifier></type><name>cdn</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TSConnectionId</name></type> <name>required_id</name> <init>= <expr><call><name>remote_connection_id</name><argument_list>(<argument><expr><name><name>cdn</name><operator>-&gt;</operator><name>foreign_server_oid</name></name></expr></argument>, <argument><expr><name>userid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>conns</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>conns</name></expr></argument>, <argument><expr><call><name>get_copy_connection_to_data_node</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>required_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>conns</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Extract a quoted list of identifiers from a DefElem with arg type T_list.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>name_list_to_string</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DefElem</name> <modifier>*</modifier></type><name>def</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>string</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>(List *) def-&gt;arg</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>string</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>String</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>string</name></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>A_Star</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>string</name></expr></argument>, <argument><expr><literal type="char">'*'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected node type in name list: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>
	<return>return <expr><name><name>string</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Extract a string value (otherwise uninterpreted) from a DefElem.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>def_get_string</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DefElem</name> <modifier>*</modifier></type><name>def</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>def</name><operator>-&gt;</operator><name>arg</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s requires a parameter"</literal></expr></argument>, <argument><expr><name><name>def</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_Integer</name></expr>:</case>
			<return>return <expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%ld"</literal></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <call><name>intVal</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_Float</name></expr>:</case>

			<comment type="block">/*
			 * T_Float values are kept in string form, so this type cheat
			 * works (and doesn't risk losing precision)
			 */</comment>
			<return>return <expr><call><name>strVal</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_String</name></expr>:</case>
			<return>return <expr><call><name>strVal</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_TypeName</name></expr>:</case>
			<return>return <expr><call><name>TypeNameToString</name><argument_list>(<argument><expr><operator>(</operator><name>TypeName</name> <operator>*</operator><operator>)</operator> <name><name>def</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_List</name></expr>:</case>
			<return>return <expr><call><name>name_list_to_string</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_A_Star</name></expr>:</case>
			<return>return <expr><call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">"*"</literal></expr></argument>)</argument_list></call></expr>;</return>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>, <argument><expr><call><name>nodeTag</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
	<return>return <expr><name>NULL</name></expr>;</return> <comment type="block">/* keep compiler quiet */</comment>
</block_content>}</block></function>

<comment type="block">/* These are the only option available for binary copy operations */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_supported_binary_option</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>option</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><literal type="string">"oids"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><literal type="string">"freeze"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		   <call><name>strcmp</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><literal type="string">"encoding"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Generate a COPY sql command for sending the data being passed in via 'stmt'
 * to a data node.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>deparse_copy_cmd</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CopyStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>binary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>command</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>command</name></expr></argument>,
					 <argument><expr><literal type="string">"COPY %s "</literal></expr></argument>,
					 <argument><expr><call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>schema_name</name></name></expr></argument>)</argument_list></call></expr></argument>,
												<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>attlist</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><literal type="string">"("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>stmt-&gt;attlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><literal type="string">") "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><literal type="string">"FROM STDIN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name> <operator>!=</operator> <name>NIL</name> <operator>||</operator> <name>binary</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>stmt-&gt;options</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>defel</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>DefElem</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>option</name> <init>= <expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* Ignore text only options for binary copy */</comment>
			<if_stmt><if>if <condition>(<expr><name>binary</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>is_supported_binary_option</name><argument_list>(<argument><expr><name>option</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><literal type="string">"delimiter"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><literal type="string">"encoding"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				<call><name>strcmp</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><literal type="string">"escape"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><literal type="string">"force_not_null"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				<call><name>strcmp</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><literal type="string">"force_null"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><literal type="string">"format"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				<call><name>strcmp</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><literal type="string">"header"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><literal type="string">"null"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				<call><name>strcmp</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><literal type="string">"quote"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * These options are fixed as default for transfer to data nodes
				 * in text format, regardless of how they are set in the input
				 * file.
				 */</comment>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><literal type="string">" WITH ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>defel</name><operator>-&gt;</operator><name>arg</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
				<operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><literal type="string">"oids"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><literal type="string">"freeze"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* boolean options don't require an argument to use default setting */</comment>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>option</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* everything else should pass directly through */</comment>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><literal type="string">"%s %s"</literal></expr></argument>, <argument><expr><name>option</name></expr></argument>, <argument><expr><call><name>def_get_string</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><name>binary</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>first</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><literal type="string">" WITH ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><literal type="string">"%sFORMAT binary"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>first</name></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">", "</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>command</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * This function checks the options specified for the copy command and makes
 * sure they're supported.  It also determines what delimiter and null
 * encoding are being specified and will use these values when sending data to
 * the data node as they presumably won't conflict with the values being passed.
 * Note that the CopyBegin call will have such validation as checking for
 * duplicate options, this function just checks added constraints for the
 * distributed copy. This call is only needed when sending data in text format
 * to the data node.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>validate_options</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>copy_options</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>delimiter</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>null_string</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>delimiter_found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Postgres defaults */</comment>
	<expr_stmt><expr><operator>*</operator><name>delimiter</name> <operator>=</operator> <name>DEFAULT_PG_DELIMITER</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>null_string</name> <operator>=</operator> <name>DEFAULT_PG_NULL_VALUE</name></expr>;</expr_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>copy_options</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>DefElem</name> <modifier>*</modifier></type><name>defel</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>DefElem</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"format"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>nodeTag</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_String</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>fmt</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr><literal type="string">"binary"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"remote copy does not support binary input in combination with "</literal>
								<literal type="string">"text transfer to data nodes"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Set timescaledb.enable_connection_binary_data to true and "</literal>
								 <literal type="string">"timescaledb.dist_copy_transfer_format to auto to enable "</literal>
								 <literal type="string">"binary data transfer."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr><literal type="string">"csv"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>delimiter_found</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>delimiter</name> <operator>=</operator> <literal type="char">','</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"delimiter"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>delim_string</name> <init>= <expr><call><name>def_get_string</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>delim_string</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>delimiter</name> <operator>=</operator> <name><name>delim_string</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>delimiter_found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"null"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>null_string</name> <operator>=</operator> <call><name>def_get_string</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>copy_should_send_binary</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CopyStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>input_format_binary</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>stmt-&gt;options</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>DefElem</name> <modifier>*</modifier></type><name>defel</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>DefElem</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"format"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>def_get_string</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"binary"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>input_format_binary</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>ts_guc_dist_copy_transfer_format</name> <operator>==</operator> <name>DCTF_Auto</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>input_format_binary</name> <operator>&amp;&amp;</operator> <name>ts_guc_enable_connection_binary_data</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>ts_guc_dist_copy_transfer_format</name> <operator>==</operator> <name>DCTF_Binary</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ts_guc_enable_connection_binary_data</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"the requested binary format for COPY data transfer is disabled by the "</literal>
							<literal type="string">"settings"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(
						 <argument><expr><literal type="string">"Either enable it by setting timescaledb.enable_connection_binary_data "</literal>
						 <literal type="string">"to true, or use automatic COPY format detection by setting "</literal>
						 <literal type="string">"timescaledb.dist_copy_transfer_format to 'auto'."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Populates the passed in pointer with an array of output functions and returns the array size.
 * Note that we size the array to the number of columns in the hypertable for convenience, but only
 * populate the functions for columns used in the copy command.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>get_copy_conversion_functions</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>copy_attnums</name></decl></parameter>, <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>functions</name></decl></parameter>,
							  <parameter><decl><type><name>bool</name></type> <name>binary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name> <init>= <expr><call><name>relation_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupDesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>functions</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>tupDesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>copy_attnums</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>out_func_oid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>isvarlena</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>binary</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>getTypeBinaryOutputInfo</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>out_func_oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isvarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>out_func_oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isvarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>out_func_oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><operator>*</operator><name>functions</name><operator>)</operator><index>[<expr><name>offset</name></expr>]</index><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>tupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TextCopyContext</name> <modifier>*</modifier></type>
<name>generate_text_copy_context</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CopyStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>attnums</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TextCopyContext</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TextCopyContext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>get_copy_conversion_functions</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>, <argument><expr><name>attnums</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>out_functions</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>ndimensions</name></name> <operator>=</operator> <name><name>ht</name><operator>-&gt;</operator><name>space</name><operator>-&gt;</operator><name>num_dimensions</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>validate_options</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>delimiter</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>null_string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>dimensions</name></name> <operator>=</operator>
		<call><name>generate_copy_dimensions</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>space</name><operator>-&gt;</operator><name>dimensions</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>ndimensions</name></name></expr></argument>, <argument><expr><name>attnums</name></expr></argument>, <argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ctx</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BinaryCopyContext</name> <modifier>*</modifier></type>
<name>generate_binary_copy_context</name><parameter_list>(<parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>attnums</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BinaryCopyContext</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BinaryCopyContext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>columns</name> <init>=
		<expr><call><name>get_copy_conversion_functions</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>, <argument><expr><name>attnums</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>out_functions</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>econtext</name></name> <operator>=</operator> <name>econtext</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>values</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>columns</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>nulls</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>columns</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ctx</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>RemoteCopyContext</name> <modifier>*</modifier></type>
<name>remote_copy_begin</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CopyStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>per_tuple_ctx</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>attnums</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name></type> <name>binary_copy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>mctx</name> <init>=
		<expr><call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>, <argument><expr><literal type="string">"Remote COPY"</literal></expr></argument>, <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RemoteCopyContext</name> <modifier>*</modifier></type><name>context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldmctx</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>oldmctx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>mctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>context</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RemoteCopyContext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>ht</name></name> <operator>=</operator> <name>ht</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>attnums</name></name> <operator>=</operator> <name>attnums</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>mctx</name></name> <operator>=</operator> <name>mctx</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>binary_operation</name></name> <operator>=</operator> <name>binary_copy</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>connection_state</name><operator>.</operator><name>connections_in_use</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>connection_state</name><operator>.</operator><name>data_node_connections</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>connection_state</name><operator>.</operator><name>using_binary</name></name> <operator>=</operator> <name>binary_copy</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>connection_state</name><operator>.</operator><name>outgoing_copy_cmd</name></name> <operator>=</operator> <call><name>deparse_copy_cmd</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>ht</name></expr></argument>, <argument><expr><name>binary_copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>batch_row_data</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>StringInfo</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>MAX_BATCH_ROWS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>batch_points</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Point</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>MAX_BATCH_ROWS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>batch_row_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>batch_size_bytes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>batch_ordinal</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>binary_copy</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>data_context</name></name> <operator>=</operator> <call><name>generate_binary_copy_context</name><argument_list>(<argument><expr><name>per_tuple_ctx</name></expr></argument>, <argument><expr><name>ht</name></expr></argument>, <argument><expr><name>attnums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>data_context</name></name> <operator>=</operator> <call><name>generate_text_copy_context</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>ht</name></expr></argument>, <argument><expr><name>attnums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldmctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>context</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>remote_copy_get_copycmd</name><parameter_list>(<parameter><decl><type><name>RemoteCopyContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>context</name><operator>-&gt;</operator><name>connection_state</name><operator>.</operator><name>outgoing_copy_cmd</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Functions for escaping values for Postgres text format.
 * See CopyAttributeOutText.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_special_character</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name>c</name> <operator>==</operator> <literal type="char">'\b'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'\f'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'\n'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'\r'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'\t'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'\v'</literal> <operator>||</operator>
			<name>c</name> <operator>==</operator> <literal type="char">'\\'</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Generate a text row for sending to data nodes, based on text input.
 *
 * The input fields are already in text format, so instead of converting to
 * internal data format and then back to text for output, we simply use the
 * original text. This saves a lot of CPU by avoiding parsing and re-formatting
 * the column values. However, we still need to escape any special characters
 * since the input is unescaped.
 *
 * One caveat here is that skipping conversion is only possible under the
 * assumption that the text encoding used in the client (from which we received
 * the data) is the same as the destination data node's encoding.
 */</comment>
<function><type><specifier>static</specifier> <name>StringInfo</name></type>
<name>parse_next_text_row</name><parameter_list>(<parameter><decl><type><name>CopyFromState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>attnums</name></decl></parameter>, <parameter><decl><type><name>TextCopyContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>row_data</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NextCopyFromRawFields</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>nfields</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* check for overflowing/missing fields */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>nfields</name></name> <operator>!=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>attnums</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_BAD_COPY_FILE_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"the number of columns doesn't match"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Format the raw unquoted unescaped fields into the Postgres text format.
	 * We only have to escape the special characters, mirroring what
	 * CopyAttributeOutText does. We assume here that the following three
	 * encodings are the same:
	 * 1) database encoding on the access node,
	 * 2) database encoding on the data node,
	 * 3) client encoding used by the access node to connect to the data node.
	 * The encoding of the input file is not relevant here, because the raw
	 * fields are already converted to the server encoding.
	 * All encoding supported by Postgres embed ASCII, so we can get away with
	 * single-byte comparisons.
	 */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>nfields</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>nfields</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier><specifier>restrict</specifier></type> <name>fields</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>fields</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>output</name> <init>= <expr><name><name>row_data</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><name><name>row_data</name><operator>-&gt;</operator><name>len</name></name></expr></init></decl>;</decl_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>field</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>field</name> <operator>&lt;</operator> <name>nfields</name></expr>;</condition> <incr><expr><name>field</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>src</name> <init>= <expr><name><name>fields</name><index>[<expr><name>field</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<comment type="block">/*
		 * The length of the input we'll have to escape is either the length of
		 * the input text, or one for null fields which are written as \N.
		 */</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>input_len</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>src</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>strlen</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
		<comment type="block">/*
		 * Calculate how much bytes we might need for output. Each character
		 * might be replaced with two when escaping, plus the field separator,
		 * terminating newline and terminating zero.
		 */</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>additional_len</name> <init>= <expr><operator>(</operator><name>input_len</name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">3</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>row_data</name><operator>-&gt;</operator><name>maxlen</name></name> <operator>&lt;</operator> <name>len</name> <operator>+</operator> <name>additional_len</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>row_data</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>enlargeStringInfo</name><argument_list>(<argument><expr><name>row_data</name></expr></argument>, <argument><expr><name>additional_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>output</name> <operator>=</operator> <name><name>row_data</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Add separator. */</comment>
		<if_stmt><if>if <condition>(<expr><name>field</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>output</name><index>[<expr><name>len</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'\t'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>len</name> <operator>&lt;=</operator> <name><name>row_data</name><operator>-&gt;</operator><name>maxlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>src</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Null value, encoded as \N */</comment>
			<expr_stmt><expr><name><name>output</name><index>[<expr><name>len</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>output</name><index>[<expr><name>len</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'N'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>len</name> <operator>&lt;=</operator> <name><name>row_data</name><operator>-&gt;</operator><name>maxlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* The field is not null, replace special characters. */</comment>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>pos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>pos</name> <operator>&lt;</operator> <name>input_len</name></expr>;</condition> <incr><expr><name>pos</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><call><name>is_special_character</name><argument_list>(<argument><expr><name><name>src</name><index>[<expr><name>pos</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>output</name><index>[<expr><name>len</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>output</name><index>[<expr><name>len</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>src</name><index>[<expr><name>pos</name></expr>]</index></name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>output</name><index>[<expr><name>len</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>src</name><index>[<expr><name>pos</name></expr>]</index></name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>len</name> <operator>&lt;=</operator> <name><name>row_data</name><operator>-&gt;</operator><name>maxlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>
	<comment type="block">/*
	 * Newline.
	 */</comment>
	<expr_stmt><expr><name><name>output</name><index>[<expr><name>len</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'\n'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>row_data</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>len</name> <operator>&lt;=</operator> <name><name>row_data</name><operator>-&gt;</operator><name>maxlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>row_data</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>StringInfo</name></type>
<name>generate_binary_copy_data</name><parameter_list>(<parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>attnums</name></decl></parameter>, <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>out_functions</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>row_data</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint16</name></type> <name>buf16</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>buf32</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>buf16</name> <operator>=</operator> <call><name>pg_hton16</name><argument_list>(<argument><expr><operator>(</operator><name>uint16</name><operator>)</operator> <name><name>attnums</name><operator>-&gt;</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>row_data</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>buf16</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>attnums</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>nulls</name><index>[<expr><name>offset</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>buf32</name> <operator>=</operator> <call><name>pg_hton32</name><argument_list>(<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>row_data</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>buf32</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type> <name>value</name> <init>= <expr><name><name>values</name><index>[<expr><name>offset</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bytea</name> <modifier>*</modifier></type><name>outputbytes</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>output_length</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>outputbytes</name> <operator>=</operator> <call><name>SendFunctionCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>out_functions</name><index>[<expr><name>offset</name></expr>]</index></name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>output_length</name> <operator>=</operator> <call><name>VARSIZE</name><argument_list>(<argument><expr><name>outputbytes</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>VARHDRSZ</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>buf32</name> <operator>=</operator> <call><name>pg_hton32</name><argument_list>(<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>output_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>row_data</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>buf32</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>row_data</name></expr></argument>, <argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>outputbytes</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>output_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>row_data</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>StringInfo</name></type>
<name>parse_next_binary_row</name><parameter_list>(<parameter><decl><type><name>CopyFromState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>attnums</name></decl></parameter>, <parameter><decl><type><name>BinaryCopyContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>result</name> <init>= <expr><call><name>NextCopyFrom</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>econtext</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>values</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>nulls</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><call><name>generate_binary_copy_data</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>values</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>nulls</name></name></expr></argument>, <argument><expr><name>attnums</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>out_functions</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Point</name> <modifier>*</modifier></type>
<name>get_current_point_for_text_copy</name><parameter_list>(<parameter><decl><type><name>TextCopyContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>calculate_hyperspace_point_from_fields</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>dimensions</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>ndimensions</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Point</name> <modifier>*</modifier></type>
<name>calculate_hyperspace_point_from_binary</name><parameter_list>(<parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Hyperspace</name> <modifier>*</modifier></type><name>space</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Point</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><call><name>POINT_SIZE</name><argument_list>(<argument><expr><name><name>space</name><operator>-&gt;</operator><name>num_dimensions</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>cardinality</name></name> <operator>=</operator> <name><name>space</name><operator>-&gt;</operator><name>num_dimensions</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>num_coords</name></name> <operator>=</operator> <name><name>space</name><operator>-&gt;</operator><name>num_dimensions</name></name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>space</name><operator>-&gt;</operator><name>num_dimensions</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type><name>dim</name> <init>= <expr><operator>&amp;</operator><name><name>space</name><operator>-&gt;</operator><name>dimensions</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type> <name>datum</name> <init>= <expr><name><name>values</name><index>[<expr><name><name>dim</name><operator>-&gt;</operator><name>column_attno</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>nulls</name><index>[<expr><name><name>dim</name><operator>-&gt;</operator><name>column_attno</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"value required for partitioning column %s"</literal></expr></argument>,
							<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>column_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>coordinates</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>convert_datum_to_dim_idx</name><argument_list>(<argument><expr><name>datum</name></expr></argument>, <argument><expr><name>dim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Point</name> <modifier>*</modifier></type>
<name>get_current_point_for_binary_copy</name><parameter_list>(<parameter><decl><type><name>BinaryCopyContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Hyperspace</name> <modifier>*</modifier></type><name>hs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>calculate_hyperspace_point_from_binary</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>values</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>nulls</name></name></expr></argument>, <argument><expr><name>hs</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>read_next_copy_row</name><parameter_list>(<parameter><decl><type><name>RemoteCopyContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>CopyFromState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Point</name> <modifier>*</modifier></type><name>point</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>ht</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>row_data</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>binary_operation</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>row_data</name> <operator>=</operator> <call><name>parse_next_binary_row</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>attnums</name></name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>data_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>row_data</name> <operator>=</operator> <call><name>parse_next_text_row</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>attnums</name></name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>data_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>row_data</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>binary_operation</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>point</name> <operator>=</operator> <call><name>get_current_point_for_binary_copy</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>data_context</name></name></expr></argument>, <argument><expr><name><name>ht</name><operator>-&gt;</operator><name>space</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>point</name> <operator>=</operator> <call><name>get_current_point_for_text_copy</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>data_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>batch_row_count</name></name> <operator>&lt;</operator> <name>MAX_BATCH_ROWS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>batch_row_data</name><index>[<expr><name><name>context</name><operator>-&gt;</operator><name>batch_row_count</name></name></expr>]</index></name> <operator>=</operator> <name>row_data</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>batch_points</name><index>[<expr><name><name>context</name><operator>-&gt;</operator><name>batch_row_count</name></name></expr>]</index></name> <operator>=</operator> <name>point</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>batch_row_count</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>batch_size_bytes</name></name> <operator>+=</operator> <name><name>row_data</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>send_copy_data</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>row_data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>connections</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>connections</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TSConnection</name> <modifier>*</modifier></type><name>conn</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TSConnectionError</name></type> <name>err</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>remote_connection_put_copy_data</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name><name>row_data</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>row_data</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>err</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>remote_connection_error_elog</name><argument_list>(<argument><expr><operator>&amp;</operator><name>err</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Rows for sending to a particular data node.
 */</comment>
<typedef>typedef <type><struct>struct <name>DataNodeRows</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>data_node_id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>server_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TSConnection</name> <modifier>*</modifier></type><name>connection</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rows_total</name></decl>;</decl_stmt>

	<comment type="block">/* Array of indices into the batch row array. */</comment>
	<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>row_indices</name></decl>;</decl_stmt>
}</block></struct></type> <name>DataNodeRows</name>;</typedef>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>remote_copy_process_and_send_data</name><parameter_list>(<parameter><decl><type><name>RemoteCopyContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>ht</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>n</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>batch_row_count</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>n</name> <operator>&lt;=</operator> <name>MAX_BATCH_ROWS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * This list tracks the per-batch insert states of the data nodes
	 * (DataNodeRows).
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>data_nodes</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* For each row, find or create the destination chunk. */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>did_end_copy</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>row_in_batch</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>row_in_batch</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>row_in_batch</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Point</name> <modifier>*</modifier></type><name>point</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>batch_points</name><index>[<expr><name>row_in_batch</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>found</name></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name> <init>= <expr><call><name>ts_hypertable_find_chunk_for_point</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>point</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>chunk</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>did_end_copy</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * The data node connections have to be flushed and the COPY
				 * query ended before creating
				 * a new chunk. They might have outstanding COPY data from the
				 * previous batch.
				 */</comment>
				<expr_stmt><expr><call><name>end_copy_on_success</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>connection_state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>did_end_copy</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>chunk</name> <operator>=</operator> <call><name>ts_hypertable_create_chunk_for_point</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>point</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* get the filtered list of "available" DNs for this chunk but only if it's replicated */</comment>
		<if_stmt><if>if <condition>(<expr><name>found</name> <operator>&amp;&amp;</operator> <name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>replication_factor</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>chunk_data_nodes</name> <init>=
				<expr><call><name>ts_chunk_data_node_scan_by_chunk_id_filter</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>, <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * If the chunk was not created as part of this insert, we need to check whether any
			 * of the chunk's data nodes are currently unavailable and in that case consider the
			 * chunk stale on those data nodes. Do that by removing the AN's chunk-datanode
			 * mapping for the unavailable data nodes.
			 *
			 * Note that the metadata will only get updated once since we assign the chunk's
			 * data_node list to the list of available DNs the first time this
			 * dist_update_stale_chunk_metadata API gets called. So both chunk_data_nodes and
			 * chunk-&gt;data_nodes will point to the same list and no subsequent metadata updates will
			 * occur.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>replication_factor</name></name> <operator>&gt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>chunk_data_nodes</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name><name>ts_cm_functions</name><operator>-&gt;</operator><name>dist_update_stale_chunk_metadata</name></name><argument_list>(<argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>chunk_data_nodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>chunk_data_nodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * For remote copy, we don't use chunk insert states on the AN.
		 * So we need to explicitly set the chunk as unordered when copies
		 * are directed to previously compressed chunks.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>ts_chunk_is_compressed</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name>ts_chunk_is_unordered</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ts_chunk_set_unordered</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Schedule the row for sending to the data nodes containing the chunk.
		 */</comment>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
		<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>chunk-&gt;data_nodes</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ChunkDataNode</name> <modifier>*</modifier></type><name>chunk_data_node</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<comment type="block">/* Find the existing insert state for this data node. */</comment>
			<decl_stmt><decl><type><name>DataNodeRows</name> <modifier>*</modifier></type><name>data_node_rows</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>
			<macro><name>foreach</name> <argument_list>(<argument>lc2</argument>, <argument>data_nodes</argument>)</argument_list></macro>
			<block>{<block_content>
				<expr_stmt><expr><name>data_node_rows</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>chunk_data_node</name><operator>-&gt;</operator><name>foreign_server_oid</name></name> <operator>==</operator> <name><name>data_node_rows</name><operator>-&gt;</operator><name>server_oid</name></name></expr>)</condition>
				<block>{<block_content>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>

			<if_stmt><if>if <condition>(<expr><name>lc2</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* No insert state for this data node yet. Create it. */</comment>
				<expr_stmt><expr><name>data_node_rows</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DataNodeRows</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>data_node_rows</name><operator>-&gt;</operator><name>connection</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>data_node_rows</name><operator>-&gt;</operator><name>server_oid</name></name> <operator>=</operator> <name><name>chunk_data_node</name><operator>-&gt;</operator><name>foreign_server_oid</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>data_node_rows</name><operator>-&gt;</operator><name>rows_total</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<comment type="block">/*
				 * Not every tuple in a batch might be sent to every data node,
				 * but we allocate the maximum possible size to avoid resizing.
				 */</comment>
				<expr_stmt><expr><name><name>data_node_rows</name><operator>-&gt;</operator><name>row_indices</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>context</name><operator>-&gt;</operator><name>batch_row_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>data_nodes</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>data_nodes</name></expr></argument>, <argument><expr><name>data_node_rows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>data_node_rows</name><operator>-&gt;</operator><name>server_oid</name></name> <operator>==</operator> <name><name>chunk_data_node</name><operator>-&gt;</operator><name>foreign_server_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>data_node_rows</name><operator>-&gt;</operator><name>row_indices</name><index>[<expr><name><name>data_node_rows</name><operator>-&gt;</operator><name>rows_total</name></name></expr>]</index></name> <operator>=</operator> <name>row_in_batch</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>data_node_rows</name><operator>-&gt;</operator><name>rows_total</name></name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Flush the previous batch to avoid growing the outgoing buffers
	 * indefinitely if some data node is not keeping up. It would be more
	 * efficient to check for buffer growth and only flush then, but libpq
	 * doesn't provide a way to know the outgoing buffer size. It also doesn't
	 * provide any way to control the outgoing buffer size.
	 * Don't do it if we have ended the COPY above to create new chunks.
	 * The number 11 is an arbitrary prime, growing the output buffer to at
	 * most 11ki rows sounds reasonable.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>did_end_copy</name> <operator>&amp;&amp;</operator> <name><name>context</name><operator>-&gt;</operator><name>batch_ordinal</name></name> <operator>%</operator> <literal type="number">11</literal> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>flush_active_connections</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>connection_state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Actually send the data to the data nodes. We don't interleave the data
	 * nodes here, because the batches are relatively small.
	 */</comment>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>copy_data</name> <init>= <expr><block>{ <expr><operator>.</operator><name>data</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>MAX_BATCH_BYTES</name></expr></argument>)</argument_list></call></expr>, <expr><operator>.</operator><name>maxlen</name> <operator>=</operator> <name>MAX_BATCH_BYTES</name></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>data_nodes</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DataNodeRows</name> <modifier>*</modifier></type><name>dn</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TSConnectionId</name></type> <name>required_id</name> <init>= <expr><call><name>remote_connection_id</name><argument_list>(<argument><expr><name><name>dn</name><operator>-&gt;</operator><name>server_oid</name></name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>dn</name><operator>-&gt;</operator><name>connection</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dn</name><operator>-&gt;</operator><name>connection</name></name> <operator>=</operator> <call><name>get_copy_connection_to_data_node</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>required_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>pg_conn</name> <init>= <expr><call><name>remote_connection_get_pg_conn</name><argument_list>(<argument><expr><name><name>dn</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>copy_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>row</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>row</name> <operator>&lt;</operator> <name><name>dn</name><operator>-&gt;</operator><name>rows_total</name></name></expr>;</condition> <incr><expr><name>row</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>StringInfo</name></type> <name>row_data</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>batch_row_data</name><index>[<expr><name><name>dn</name><operator>-&gt;</operator><name>row_indices</name><index>[<expr><name>row</name></expr>]</index></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>copy_data</name></expr></argument>, <argument><expr><name><name>row_data</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>row_data</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * Send the copy data to the remote server.
		 * It can't really return 0 ("would block") until it runs out
		 * of memory. It just grows the buffer and tries to flush in
		 * pqPutMsgEnd().
		 */</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>PQputCopyData</name><argument_list>(<argument><expr><name>pg_conn</name></expr></argument>, <argument><expr><name><name>copy_data</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>copy_data</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_EXCEPTION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not send COPY data"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>pg_conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * We don't have to specially flush the data here, because the flush is
		 * attempted after finishing each protocol message (pqPutMsgEnd()).
		 */</comment>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * This function is for successfully finishing the COPY: it tries to flush all
 * the outstanding COPY data to the data nodes. It is sensitive to erroneous
 * state of connections and is going to fail if they are in a wrong state due to
 * other errors. Resetting the connections after a known error should be done
 * with remote_connection_end_copy, not this function.
 */</comment>
<function><type><name>void</name></type>
<name>remote_copy_end_on_success</name><parameter_list>(<parameter><decl><type><name>RemoteCopyContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>end_copy_on_success</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>connection_state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>mctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>uint64</name></type>
<name>remote_distributed_copy</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CopyStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>CopyChunkState</name> <modifier>*</modifier></type><name>ccstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>attnums</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldmctx</name> <init>= <expr><name>CurrentMemoryContext</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>ccstate</name><operator>-&gt;</operator><name>estate</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name> <init>= <expr><name><name>ccstate</name><operator>-&gt;</operator><name>dispatch</name><operator>-&gt;</operator><name>hypertable</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RemoteCopyContext</name> <modifier>*</modifier></type><name>context</name> <init>= <expr><call><name>remote_copy_begin</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>,
												   <argument><expr><name>ht</name></expr></argument>,
												   <argument><expr><call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>,
												   <argument><expr><name>attnums</name></expr></argument>,
												   <argument><expr><call><name>copy_should_send_binary</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>processed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>batch_context</name> <init>=
		<expr><call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>, <argument><expr><literal type="string">"Remote COPY batch"</literal></expr></argument>, <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>batch_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>true</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ResetPerTupleExprContext</name><argument_list>(<argument><expr><name><name>ccstate</name><operator>-&gt;</operator><name>estate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Actually process the next row. */</comment>
			<decl_stmt><decl><type><name>bool</name></type> <name>eof</name> <init>= <expr><operator>!</operator><call><name>read_next_copy_row</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>ccstate</name><operator>-&gt;</operator><name>cstate</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>eof</name> <operator>&amp;&amp;</operator> <name><name>context</name><operator>-&gt;</operator><name>batch_row_count</name></name> <operator>&lt;</operator> <name>MAX_BATCH_ROWS</name> <operator>&amp;&amp;</operator>
				<name><name>context</name><operator>-&gt;</operator><name>batch_size_bytes</name></name> <operator>&lt;</operator> <name>MAX_BATCH_BYTES</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Accumulate more rows into the current batch.
				 */</comment>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Send out the current batch.
			 */</comment>
			<expr_stmt><expr><call><name>remote_copy_process_and_send_data</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>processed</name> <operator>+=</operator> <name><name>context</name><operator>-&gt;</operator><name>batch_row_count</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>batch_row_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>batch_size_bytes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>batch_ordinal</name></name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>batch_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>eof</name></expr>)</condition>
			<block>{<block_content>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></while>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<comment type="block">/* If we hit an error, make sure we end our in-progress COPYs */</comment>
		<expr_stmt><expr><call><name>end_copy_on_failure</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>connection_state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>mctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>remote_copy_end_on_success</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldmctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>processed</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Send a tuple/row to data nodes.
 *
 * The slot is serialized in text or binary format, depending on setting. The
 * data is already "routed" to the "right" chunk as indicated by the chunk
 * insert state.
 */</comment>
<function><type><name>bool</name></type>
<name>remote_copy_send_slot</name><parameter_list>(<parameter><decl><type><name>RemoteCopyContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ChunkInsertState</name> <modifier>*</modifier></type><name>cis</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>row_data</name></decl>;</decl_stmt>

	<comment type="block">/* Pre-materialize all attributes since we will access all of them */</comment>
	<expr_stmt><expr><call><name>slot_getallattrs</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>binary_operation</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BinaryCopyContext</name> <modifier>*</modifier></type><name>binctx</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>data_context</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>binctx</name><operator>-&gt;</operator><name>nulls</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>attnums</name></name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>context-&gt;attnums</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AttrNumber</name></type> <name>attnum</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>binctx</name><operator>-&gt;</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>binctx</name><operator>-&gt;</operator><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><name>row_data</name> <operator>=</operator> <call><name>generate_binary_copy_data</name><argument_list>(<argument><expr><name><name>binctx</name><operator>-&gt;</operator><name>values</name></name></expr></argument>,
											 <argument><expr><name><name>binctx</name><operator>-&gt;</operator><name>nulls</name></name></expr></argument>,
											 <argument><expr><name><name>context</name><operator>-&gt;</operator><name>attnums</name></name></expr></argument>,
											 <argument><expr><name><name>binctx</name><operator>-&gt;</operator><name>out_functions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>TextCopyContext</name> <modifier>*</modifier></type><name>textctx</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>data_context</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type> <name>delim</name> <init>= <expr><name><name>textctx</name><operator>-&gt;</operator><name>delimiter</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>row_data</name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>context-&gt;attnums</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AttrNumber</name></type> <name>attnum</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type> <name>isnull</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type> <name>value</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>lc</name> <operator>==</operator> <call><name>list_tail</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>attnums</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>delim</name> <operator>=</operator> <literal type="char">'\n'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>row_data</name></expr></argument>, <argument><expr><literal type="string">"%s%c"</literal></expr></argument>, <argument><expr><name><name>textctx</name><operator>-&gt;</operator><name>null_string</name></name></expr></argument>, <argument><expr><name>delim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type> <name>off</name> <init>= <expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>output</name> <init>= <expr><call><name>OutputFunctionCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>textctx</name><operator>-&gt;</operator><name>out_functions</name><index>[<expr><name>off</name></expr>]</index></name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>row_data</name></expr></argument>, <argument><expr><literal type="string">"%s%c"</literal></expr></argument>, <argument><expr><name>output</name></expr></argument>, <argument><expr><name>delim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>connections</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>connections</name> <operator>=</operator>
			<call><name>get_connections_for_chunk</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>cis</name><operator>-&gt;</operator><name>chunk_id</name></name></expr></argument>, <argument><expr><name><name>cis</name><operator>-&gt;</operator><name>chunk_data_nodes</name></name></expr></argument>, <argument><expr><name><name>cis</name><operator>-&gt;</operator><name>user_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>connections</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>cis</name><operator>-&gt;</operator><name>chunk_data_nodes</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>connections</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>send_copy_data</name><argument_list>(<argument><expr><name>row_data</name></expr></argument>, <argument><expr><name>connections</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<comment type="block">/* If we hit an error, make sure we end our in-progress COPYs */</comment>
		<expr_stmt><expr><call><name>end_copy_on_failure</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>connection_state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>mctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>
</unit>
