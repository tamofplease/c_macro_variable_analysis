<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/timescaledb/tsl/src/remote/tuplefactory.c"><comment type="block">/*
 * This file and its contents are licensed under the Timescale License.
 * Please see the included NOTICE for copyright information and
 * LICENSE-TIMESCALE for a copy of the license.
 */</comment>

<comment type="block">/*
 * This file contains source code that was copied and/or modified from
 * the PostgreSQL database, which is licensed under the open-source
 * PostgreSQL License. Please see the NOTICE at the top level
 * directory for a copy of the PostgreSQL License.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postgres.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/htup_details.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/sysattr.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_type.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;libpq-fe.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;miscadmin.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/restrictinfo.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;parser/parsetree.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/builtins.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/float.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/guc.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/memutils.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/rel.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/syscache.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;guc.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"src/utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compat/compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"remote/data_format.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tuplefactory.h"</cpp:file></cpp:include>

<comment type="block">/*
 * Identify the attribute where data conversion fails.
 */</comment>
<typedef>typedef <type><struct>struct <name>ConversionLocation</name>
<block>{
	<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name></decl>;</decl_stmt>		  <comment type="block">/* foreign table's relcache entry. */</comment>
	<decl_stmt><decl><type><name>AttrNumber</name></type> <name>cur_attno</name></decl>;</decl_stmt> <comment type="block">/* attribute number being processed, or 0 */</comment>

	<comment type="block">/*
	 * In case of foreign join push down, fdw_scan_tlist is used to identify
	 * the Var node corresponding to the error location and
	 * ss-&gt;ps.state gives access to the RTEs of corresponding relation
	 * to get the relation name and attribute name.
	 */</comment>
	<decl_stmt><decl><type><name>ScanState</name> <modifier>*</modifier></type><name>ss</name></decl>;</decl_stmt>
}</block></struct></type> <name>ConversionLocation</name>;</typedef>

<typedef>typedef <type><struct>struct <name>TupleFactory</name>
<block>{
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>temp_mctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>retrieved_attrs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttConvInMetadata</name> <modifier>*</modifier></type><name>attconv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ConversionLocation</name></type> <name>errpos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ErrorContextCallback</name></type> <name>errcallback</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>per_tuple_mctx_reset</name></decl>;</decl_stmt>
}</block></struct></type> <name>TupleFactory</name>;</typedef>

<comment type="block">/*
 * Callback function which is called when error occurs during column value
 * conversion.  Print names of column and relation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>conversion_error_callback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>attname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>is_wholerow</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ConversionLocation</name> <modifier>*</modifier></type><name>errpos</name> <init>= <expr><operator>(</operator><name>ConversionLocation</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>errpos</name><operator>-&gt;</operator><name>rel</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* error occurred in a scan against a foreign table */</comment>
		<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupdesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>errpos</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name><name>errpos</name><operator>-&gt;</operator><name>cur_attno</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>errpos</name><operator>-&gt;</operator><name>cur_attno</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>errpos</name><operator>-&gt;</operator><name>cur_attno</name></name> <operator>&lt;=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>attname</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>errpos</name><operator>-&gt;</operator><name>cur_attno</name></name> <operator>==</operator> <name>SelfItemPointerAttributeNumber</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>attname</name> <operator>=</operator> <literal type="string">"ctid"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>relname</name> <operator>=</operator> <call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>errpos</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* error occurred in a scan against a foreign join */</comment>
		<decl_stmt><decl><type><name>ScanState</name> <modifier>*</modifier></type><name>ss</name> <init>= <expr><name><name>errpos</name><operator>-&gt;</operator><name>ss</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>ss</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>ss</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></argument>, <argument><expr><name>ForeignScan</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ForeignScan</name> <modifier>*</modifier></type><name>fsplan</name> <init>= <expr><operator>(</operator><name>ForeignScan</name> <operator>*</operator><operator>)</operator> <name><name>ss</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>tlist</name> <operator>=</operator> <name><name>fsplan</name><operator>-&gt;</operator><name>fdw_scan_tlist</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>ss</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></argument>, <argument><expr><name>CustomScan</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CustomScan</name> <modifier>*</modifier></type><name>csplan</name> <init>= <expr><operator>(</operator><name>CustomScan</name> <operator>*</operator><operator>)</operator> <name><name>ss</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>tlist</name> <operator>=</operator> <name><name>csplan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>tlist</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				 <argument><expr><literal type="string">"unknown scan node type %s in error callback"</literal></expr></argument>,
				 <argument><expr><call><name>ts_get_node_name</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>ss</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>list_nth_node</name><argument_list>(<argument><expr><name>TargetEntry</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>, <argument><expr><name><name>errpos</name><operator>-&gt;</operator><name>cur_attno</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Target list can have Vars and expressions.  For Vars, we can get
		 * its relation, however for expressions we can't.  Thus for
		 * expressions, just show generic context message.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_range_table</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>is_wholerow</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>attname</name> <operator>=</operator> <call><name>get_attname</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><name>relname</name> <operator>=</operator> <call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"processing expression at position %d in select list"</literal></expr></argument>, <argument><expr><name><name>errpos</name><operator>-&gt;</operator><name>cur_attno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>relname</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>is_wholerow</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"whole-row reference to foreign table \"%s\""</literal></expr></argument>, <argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>attname</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of foreign table \"%s\""</literal></expr></argument>, <argument><expr><name>attname</name></expr></argument>, <argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TupleFactory</name> <modifier>*</modifier></type>
<name>tuplefactory_create_common</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>retrieved_attrs</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>force_text</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleFactory</name> <modifier>*</modifier></type><name>tf</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TupleFactory</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>tf</name><operator>-&gt;</operator><name>temp_mctx</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
										  <argument><expr><literal type="string">"tuple factory temporary data"</literal></expr></argument>,
										  <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>tf</name><operator>-&gt;</operator><name>tupdesc</name></name> <operator>=</operator> <name>tupdesc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tf</name><operator>-&gt;</operator><name>retrieved_attrs</name></name> <operator>=</operator> <name>retrieved_attrs</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tf</name><operator>-&gt;</operator><name>attconv</name></name> <operator>=</operator> <call><name>data_format_create_att_conv_in_metadata</name><argument_list>(<argument><expr><name><name>tf</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>, <argument><expr><name>force_text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tf</name><operator>-&gt;</operator><name>values</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>tf</name><operator>-&gt;</operator><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tf</name><operator>-&gt;</operator><name>nulls</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>tf</name><operator>-&gt;</operator><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize to nulls for any columns not present in result */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>tf</name><operator>-&gt;</operator><name>nulls</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name><name>tf</name><operator>-&gt;</operator><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>tf</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>TupleFactory</name> <modifier>*</modifier></type>
<name>tuplefactory_create_for_tupdesc</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>force_text</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>retrieved_attrs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attisdropped</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>retrieved_attrs</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>retrieved_attrs</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><call><name>tuplefactory_create_common</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>retrieved_attrs</name></expr></argument>, <argument><expr><name>force_text</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TupleFactory</name> <modifier>*</modifier></type>
<name>tuplefactory_create</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ScanState</name> <modifier>*</modifier></type><name>ss</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>retrieved_attrs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleFactory</name> <modifier>*</modifier></type><name>tf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>rel</name> <operator>&amp;&amp;</operator> <name>ss</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>rel</name> <operator>||</operator> <name>ss</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>rel</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <name><name>ss</name><operator>-&gt;</operator><name>ss_ScanTupleSlot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>tf</name> <operator>=</operator>
		<call><name>tuplefactory_create_common</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>retrieved_attrs</name></expr></argument>, <argument><expr><operator>!</operator><name>ts_guc_enable_connection_binary_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tf</name><operator>-&gt;</operator><name>errpos</name><operator>.</operator><name>rel</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tf</name><operator>-&gt;</operator><name>errpos</name><operator>.</operator><name>cur_attno</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tf</name><operator>-&gt;</operator><name>errpos</name><operator>.</operator><name>ss</name></name> <operator>=</operator> <name>ss</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tf</name><operator>-&gt;</operator><name>errcallback</name><operator>.</operator><name>callback</name></name> <operator>=</operator> <name>conversion_error_callback</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tf</name><operator>-&gt;</operator><name>errcallback</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>tf</name><operator>-&gt;</operator><name>errpos</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tf</name><operator>-&gt;</operator><name>errcallback</name><operator>.</operator><name>previous</name></name> <operator>=</operator> <name>error_context_stack</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tf</name><operator>-&gt;</operator><name>per_tuple_mctx_reset</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<return>return <expr><name>tf</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>TupleFactory</name> <modifier>*</modifier></type>
<name>tuplefactory_create_for_rel</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>retrieved_attrs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>tuplefactory_create</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>retrieved_attrs</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>TupleFactory</name> <modifier>*</modifier></type>
<name>tuplefactory_create_for_scan</name><parameter_list>(<parameter><decl><type><name>ScanState</name> <modifier>*</modifier></type><name>ss</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>retrieved_attrs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>tuplefactory_create</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>ss</name></expr></argument>, <argument><expr><name>retrieved_attrs</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>tuplefactory_is_binary</name><parameter_list>(<parameter><decl><type><name>TupleFactory</name> <modifier>*</modifier></type><name>tf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>tf</name><operator>-&gt;</operator><name>attconv</name><operator>-&gt;</operator><name>binary</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>tuplefactory_set_per_tuple_mctx_reset</name><parameter_list>(<parameter><decl><type><name>TupleFactory</name> <modifier>*</modifier></type><name>tf</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>reset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>tf</name><operator>-&gt;</operator><name>per_tuple_mctx_reset</name></name> <operator>=</operator> <name>reset</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>tuplefactory_reset_mctx</name><parameter_list>(<parameter><decl><type><name>TupleFactory</name> <modifier>*</modifier></type><name>tf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>tf</name><operator>-&gt;</operator><name>temp_mctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>tuplefactory_get_nattrs</name><parameter_list>(<parameter><decl><type><name>TupleFactory</name> <modifier>*</modifier></type><name>tf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>tf</name><operator>-&gt;</operator><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>ItemPointer</name></type>
<name>tuplefactory_make_virtual_tuple</name><parameter_list>(<parameter><decl><type><name>TupleFactory</name> <modifier>*</modifier></type><name>tf</name></decl></parameter>, <parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>row</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>format</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>,
								<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ItemPointer</name></type> <name>ctid</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>row</name> <operator>&lt;</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Install error callback */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tf</name><operator>-&gt;</operator><name>errcallback</name><operator>.</operator><name>callback</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>tf</name><operator>-&gt;</operator><name>errcallback</name><operator>.</operator><name>previous</name></name> <operator>=</operator> <name>error_context_stack</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <operator>&amp;</operator><name><name>tf</name><operator>-&gt;</operator><name>errcallback</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * i indexes columns in the relation, j indexes columns in the PGresult.
	 */</comment>
	<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>tf-&gt;retrieved_attrs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>valstr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>len</name> <init>= <expr><call><name>PQgetlength</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>row</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="block">/* check via PGgetisnull to see if the attr is null */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>row</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>valstr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>valstr</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>row</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * Note that this attno is an index inside fdw_scan_tlist, not inside
		 * tupdesc.
		 */</comment>
		<expr_stmt><expr><name><name>tf</name><operator>-&gt;</operator><name>errpos</name><operator>.</operator><name>cur_attno</name></name> <operator>=</operator> <name>j</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

		<comment type="block">/*
		 * convert value to internal representation
		 *
		 * Note: we ignore system columns other than ctid and oid in result
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* ordinary column */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>i</name> <operator>&lt;=</operator> <name><name>tf</name><operator>-&gt;</operator><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>valstr</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>format</name> <operator>==</operator> <name>FORMAT_TEXT</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>tf</name><operator>-&gt;</operator><name>attconv</name><operator>-&gt;</operator><name>binary</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Apply the input function even to nulls, to support domains */</comment>
				<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>InputFunctionCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tf</name><operator>-&gt;</operator><name>attconv</name><operator>-&gt;</operator><name>conv_funcs</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
												  <argument><expr><name>valstr</name></expr></argument>,
												  <argument><expr><name><name>tf</name><operator>-&gt;</operator><name>attconv</name><operator>-&gt;</operator><name>ioparams</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
												  <argument><expr><name><name>tf</name><operator>-&gt;</operator><name>attconv</name><operator>-&gt;</operator><name>typmods</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tf</name><operator>-&gt;</operator><name>attconv</name><operator>-&gt;</operator><name>binary</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>valstr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>StringInfoData</name></type> <name>si</name> <init>= <expr><block>{ <expr><operator>.</operator><name>data</name> <operator>=</operator> <name>valstr</name></expr>, <expr><operator>.</operator><name>len</name> <operator>=</operator> <name>len</name></expr> }</block></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ReceiveFunctionCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tf</name><operator>-&gt;</operator><name>attconv</name><operator>-&gt;</operator><name>conv_funcs</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
														<argument><expr><operator>&amp;</operator><name>si</name></expr></argument>,
														<argument><expr><name><name>tf</name><operator>-&gt;</operator><name>attconv</name><operator>-&gt;</operator><name>ioparams</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
														<argument><expr><name><name>tf</name><operator>-&gt;</operator><name>attconv</name><operator>-&gt;</operator><name>typmods</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>i</name> <operator>==</operator> <name>SelfItemPointerAttributeNumber</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* ctid */</comment>
			<if_stmt><if>if <condition>(<expr><name>valstr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Datum</name></type> <name>datum</name></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><name>format</name> <operator>==</operator> <name>FORMAT_TEXT</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>tidin</name></expr></argument>, <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>valstr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else
				<block>{<block_content>
					<decl_stmt><decl><type><name>StringInfoData</name></type> <name>si</name> <init>= <expr><block>{ <expr><operator>.</operator><name>data</name> <operator>=</operator> <name>valstr</name></expr>, <expr><operator>.</operator><name>len</name> <operator>=</operator> <name>len</name></expr> }</block></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>tidrecv</name></expr></argument>, <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>si</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
				<expr_stmt><expr><name>ctid</name> <operator>=</operator> <operator>(</operator><name>ItemPointer</name><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>tf</name><operator>-&gt;</operator><name>errpos</name><operator>.</operator><name>cur_attno</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Uninstall error context callback. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tf</name><operator>-&gt;</operator><name>errcallback</name><operator>.</operator><name>callback</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <name><name>tf</name><operator>-&gt;</operator><name>errcallback</name><operator>.</operator><name>previous</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Check we got the expected number of columns.  Note: j == 0 and
	 * PQnfields == 1 is expected, since deparse emits a NULL if no columns.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>j</name> <operator>!=</operator> <call><name>PQnfields</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"remote query result does not match the foreign table"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>ctid</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>HeapTuple</name></type>
<name>tuplefactory_make_tuple</name><parameter_list>(<parameter><decl><type><name>TupleFactory</name> <modifier>*</modifier></type><name>tf</name></decl></parameter>, <parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>row</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>format</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Do the following work in a temp context that we reset after each tuple.
	 * This cleans up not only the data we have direct access to, but any
	 * cruft the I/O functions might leak.
	 */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>tf</name><operator>-&gt;</operator><name>temp_mctx</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ItemPointer</name></type> <name>ctid</name> <init>= <expr><call><name>tuplefactory_make_virtual_tuple</name><argument_list>(<argument><expr><name>tf</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name>row</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name><name>tf</name><operator>-&gt;</operator><name>values</name></name></expr></argument>, <argument><expr><name><name>tf</name><operator>-&gt;</operator><name>nulls</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Build the result tuple in caller's memory context.
	 */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name> <init>= <expr><call><name>heap_form_tuple</name><argument_list>(<argument><expr><name><name>tf</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>, <argument><expr><name><name>tf</name><operator>-&gt;</operator><name>values</name></name></expr></argument>, <argument><expr><name><name>tf</name><operator>-&gt;</operator><name>nulls</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If we have a CTID to return, install it in both t_self and t_ctid.
	 * t_self is the normal place, but if the tuple is converted to a
	 * composite Datum, t_self will be lost; setting t_ctid allows CTID to be
	 * preserved during EvalPlanQual re-evaluations (see ROW_MARK_COPY code).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>ctid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name> <operator>=</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_ctid</name></name> <operator>=</operator> <operator>*</operator><name>ctid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Stomp on the xmin, xmax, and cmin fields from the tuple created by
	 * heap_form_tuple.  heap_form_tuple actually creates the tuple with
	 * DatumTupleFields, not HeapTupleFields, but the executor expects
	 * HeapTupleFields and will happily extract system columns on that
	 * assumption.  If we don't do this then, for example, the tuple length
	 * ends up in the xmin field, which isn't what we want.
	 */</comment>
	<expr_stmt><expr><call><name>HeapTupleHeaderSetXmax</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>, <argument><expr><name>InvalidTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>HeapTupleHeaderSetXmin</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>, <argument><expr><name>InvalidTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>HeapTupleHeaderSetCmin</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>, <argument><expr><name>InvalidTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Clean up */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tf</name><operator>-&gt;</operator><name>per_tuple_mctx_reset</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>tuplefactory_reset_mctx</name><argument_list>(<argument><expr><name>tf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>tuple</name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>AttConvInMetadata</name></name> <modifier>*</modifier></type>
<name>tuplefactory_get_attconv</name><parameter_list>(<parameter><decl><type><name>TupleFactory</name> <modifier>*</modifier></type><name>tf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>tf</name><operator>-&gt;</operator><name>attconv</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>TupleDesc</name></type>
<name>tuplefactory_get_tupdesc</name><parameter_list>(<parameter><decl><type><name>TupleFactory</name> <modifier>*</modifier></type><name>tf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>tf</name><operator>-&gt;</operator><name>tupdesc</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>List</name> <modifier>*</modifier></type>
<name>tuplefactory_get_retrieved_attrs</name><parameter_list>(<parameter><decl><type><name>TupleFactory</name> <modifier>*</modifier></type><name>tf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>tf</name><operator>-&gt;</operator><name>retrieved_attrs</name></name></expr>;</return>
</block_content>}</block></function>
</unit>
