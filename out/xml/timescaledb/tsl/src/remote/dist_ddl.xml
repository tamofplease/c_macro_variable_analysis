<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/timescaledb/tsl/src/remote/dist_ddl.c"><comment type="block">/*
 * This file and its contents are licensed under the Timescale License.
 * Please see the included NOTICE for copyright information and
 * LICENSE-TIMESCALE for a copy of the license.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postgres.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;miscadmin.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_trigger.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/namespace.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;commands/event_trigger.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;commands/dbcommands.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;commands/extension.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/parsenodes.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;parser/parse_func.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/builtins.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/fmgrprotos.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/guc.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;annotations.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;guc.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compat/compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"data_node.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ts_catalog/hypertable_data_node.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"chunk_index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"chunk_api.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"process_utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"event_trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"remote/dist_commands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"remote/dist_ddl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"remote/connection_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"scan_iterator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dist_util.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"deparse.h"</cpp:file></cpp:include>

<comment type="block">/* DDL Query execution type */</comment>
<typedef>typedef <type><enum>enum
<block>{
	<comment type="block">/* Do not execute */</comment>
	<decl><name>DIST_DDL_EXEC_NONE</name></decl>,
	<comment type="block">/* Execute on start hook */</comment>
	<decl><name>DIST_DDL_EXEC_ON_START</name></decl>,
	<comment type="block">/* Execute on start hook without using a transactions */</comment>
	<decl><name>DIST_DDL_EXEC_ON_START_NO_2PC</name></decl>,
	<comment type="block">/* Execute on end hook */</comment>
	<decl><name>DIST_DDL_EXEC_ON_END</name></decl>
}</block></enum></type> <name>DistDDLExecType</name>;</typedef>

<comment type="block">/* Per-command DDL query state */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<comment type="block">/* Chosen query execution type */</comment>
	<decl_stmt><decl><type><name>DistDDLExecType</name></type> <name>exec_type</name></decl>;</decl_stmt>
	<comment type="block">/* Saved SQL commands to execute on the remote data nodes */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>remote_commands</name></decl>;</decl_stmt>
	<comment type="block">/* Saved oid for delayed resolving */</comment>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relid</name></decl>;</decl_stmt>
	<comment type="block">/* List of data nodes to send query to */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>data_node_list</name></decl>;</decl_stmt>
	<comment type="block">/* Memory context used for data_node_list */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>mctx</name></decl>;</decl_stmt>
}</block></struct></type> <name>DistDDLState</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>DistDDLState</name></type> <name>dist_ddl_state</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dist_ddl_scheduled_for_execution</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>(dist_ddl_state.exec_type != DIST_DDL_EXEC_NONE)</cpp:value></cpp:define>

<function><type><name>void</name></type>
<name>dist_ddl_state_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dist_ddl_state</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DistDDLState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dist_ddl_state</name><operator>.</operator><name>exec_type</name></name> <operator>=</operator> <name>DIST_DDL_EXEC_NONE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dist_ddl_state</name><operator>.</operator><name>remote_commands</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dist_ddl_state</name><operator>.</operator><name>relid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dist_ddl_state</name><operator>.</operator><name>data_node_list</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dist_ddl_state</name><operator>.</operator><name>mctx</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>dist_ddl_state_reset</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>dist_ddl_state_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dist_ddl_error_raise_unsupported</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"operation not supported on distributed hypertable"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dist_ddl_error_raise_blocked</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"operation is blocked on a distributed hypertable member"</literal></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"This operation should be executed on the access node."</literal></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Set timescaledb.enable_client_ddl_on_data_nodes to TRUE, if you know what "</literal>
					 <literal type="string">"you are doing."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Ensure that DDL operation is executed from the access node session on
 * data node or explicitly allowed by the guc.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dist_ddl_error_if_not_allowed_data_node_session</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>dist_util_is_access_node_session_on_data_node</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>ts_guc_enable_client_ddl_on_data_nodes</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>dist_ddl_error_raise_blocked</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dist_ddl_error_if_multi_command</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>parsetree_list</name></decl>;</decl_stmt>

	<comment type="block">/* Parse the SQL string into a list of raw parse trees */</comment>
	<expr_stmt><expr><name>parsetree_list</name> <operator>=</operator> <call><name>pg_parse_query</name><argument_list>(<argument><expr><name><name>args</name><operator>-&gt;</operator><name>query_string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Prevent 'command;command' execution */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>parsetree_list</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"nested commands are not supported on distributed hypertable"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dist_ddl_state_add_remote_command</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>mctx</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>dist_ddl_state</name><operator>.</operator><name>mctx</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>dist_ddl_state</name><operator>.</operator><name>remote_commands</name></name> <operator>=</operator>
		<call><name>lappend</name><argument_list>(<argument><expr><name><name>dist_ddl_state</name><operator>.</operator><name>remote_commands</name></name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>mctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dist_ddl_state_add_remote_command_list</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>mctx</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>dist_ddl_state</name><operator>.</operator><name>mctx</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>dist_ddl_state</name><operator>.</operator><name>remote_commands</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>dist_ddl_state</name><operator>.</operator><name>remote_commands</name></name></expr></argument>, <argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>mctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Set the exec type for a distributed command, i.e., whether to forward the
 * DDL statement before or after PostgreSQL has processed it locally.
 *
 * There are two ways to execute distributed DDL query: START and END.
 * START executes inside the process utility hook right after the processing is done.
 * END is execution is delayed, and done from ddl_command_start hook invokation.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>dist_ddl_state_set_exec_type</name><parameter_list>(<parameter><decl><type><name>DistDDLExecType</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>dist_ddl_state</name><operator>.</operator><name>exec_type</name></name> <operator>==</operator> <name>DIST_DDL_EXEC_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dist_ddl_state</name><operator>.</operator><name>exec_type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Set an execution type and add current query string as the command for
 * execution on data nodes.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>dist_ddl_state_schedule</name><parameter_list>(<parameter><decl><type><name>DistDDLExecType</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>dist_ddl_state</name><operator>.</operator><name>exec_type</name></name> <operator>==</operator> <name>DIST_DDL_EXEC_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>type</name> <operator>!=</operator> <name>DIST_DDL_EXEC_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dist_ddl_state</name><operator>.</operator><name>exec_type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>dist_ddl_state_add_remote_command</name><argument_list>(<argument><expr><name><name>args</name><operator>-&gt;</operator><name>query_string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>dist_ddl_state_has_data_node</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>dist_ddl_state.data_node_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>data_node_name</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>data_node_name</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dist_ddl_state_add_data_node_list</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>data_node_list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>data_node_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HypertableDataNode</name> <modifier>*</modifier></type><name>hypertable_data_node</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>node_name</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>hypertable_data_node</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>node_name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>dist_ddl_state_has_data_node</name><argument_list>(<argument><expr><name>node_name</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>dist_ddl_state</name><operator>.</operator><name>data_node_list</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>dist_ddl_state</name><operator>.</operator><name>data_node_list</name></name></expr></argument>, <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>node_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dist_ddl_state_add_data_node_list_from_table</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>schema</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FormData_hypertable</name></type> <name>form</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>data_node_list</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>mctx</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ts_hypertable_get_attributes_by_name</name><argument_list>(<argument><expr><name>schema</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>form</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* If hypertable is marked as distributed member then ensure this operation is
	 * executed by the access node session. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>form</name><operator>.</operator><name>replication_factor</name></name> <operator>==</operator> <name>HYPERTABLE_DISTRIBUTED_MEMBER</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dist_ddl_error_if_not_allowed_data_node_session</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>data_node_list</name> <operator>=</operator> <call><name>ts_hypertable_data_node_scan</name><argument_list>(<argument><expr><name><name>form</name><operator>.</operator><name>id</name></name></expr></argument>, <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>data_node_list</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>mctx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>dist_ddl_state</name><operator>.</operator><name>mctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>dist_ddl_state_add_data_node_list</name><argument_list>(<argument><expr><name>data_node_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>mctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>data_node_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dist_ddl_state_add_data_node_list_from_ht</name><parameter_list>(<parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>dist_ddl_state</name><operator>.</operator><name>data_node_list</name></name> <operator>=</operator> <call><name>ts_hypertable_get_data_node_name_list</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check that all DNs are "available" for this DDL operation, fail otherwise */</comment>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>dist_ddl_state.data_node_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>data_node_name</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ForeignServer</name> <modifier>*</modifier></type><name>server</name> <init>= <expr><call><name>GetForeignServerByName</name><argument_list>(<argument><expr><name>data_node_name</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ts_data_node_is_available_by_server</name><argument_list>(<argument><expr><name>server</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"some data nodes are not available for DDL commands"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dist_ddl_state_add_current_data_node_list</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>dist_ddl_state</name><operator>.</operator><name>data_node_list</name></name> <operator>=</operator> <call><name>data_node_get_node_name_list</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dist_ddl_inspect_hypertable_list</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><name>Cache</name> <modifier>*</modifier></type><name>hcache</name></decl></parameter>,
								 <parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>num_hypertables</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>num_dist_hypertables</name></decl></parameter>,
								 <parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>num_dist_hypertable_members</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>num_hypertables</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>num_hypertables</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>num_dist_hypertables</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>num_dist_hypertables</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>num_dist_hypertable_members</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>num_dist_hypertable_members</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>args-&gt;hypertable_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>ht</name> <operator>=</operator> <call><name>ts_hypertable_cache_get_entry</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>, <argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>CACHE_FLAG_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ht</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<switch>switch <condition>(<expr><call><name>ts_hypertable_get_type</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>HYPERTABLE_REGULAR</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>num_hypertables</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>(</operator><operator>*</operator><name>num_hypertables</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><name>HYPERTABLE_DISTRIBUTED</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>num_dist_hypertables</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>(</operator><operator>*</operator><name>num_dist_hypertables</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><name>HYPERTABLE_DISTRIBUTED_MEMBER</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>num_dist_hypertable_members</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>(</operator><operator>*</operator><name>num_dist_hypertable_members</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Validate hypertable list and set a distributed hypertable, update
 * the data node list accordingly.
 *
 * Return false, if no distributed hypertables found.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>dist_ddl_state_set_hypertable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>num_hypertables</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>args</name><operator>-&gt;</operator><name>hypertable_list</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>num_dist_hypertables</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>num_dist_hypertable_members</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cache</name> <modifier>*</modifier></type><name>hcache</name> <init>= <expr><call><name>ts_hypertable_cache_pin</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>dist_ddl_inspect_hypertable_list</name><argument_list>(<argument><expr><name>args</name></expr></argument>,
									 <argument><expr><name>hcache</name></expr></argument>,
									 <argument><expr><name>NULL</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>num_dist_hypertables</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>num_dist_hypertable_members</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Allow DDL operations on data nodes executed only from connection
	 * made by the access node.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>num_dist_hypertable_members</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dist_ddl_error_if_not_allowed_data_node_session</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>num_dist_hypertables</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Raise an error only if at least one of hypertables is
	 * distributed. Otherwise this makes query_string unusable for remote
	 * execution without deparsing.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>num_hypertables</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dist_ddl_error_raise_unsupported</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Prevent execution of several commands in one query string */</comment>
	<expr_stmt><expr><call><name>dist_ddl_error_if_multi_command</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get the distributed hypertable */</comment>
	<expr_stmt><expr><name>ht</name> <operator>=</operator>
		<call><name>ts_hypertable_cache_get_entry</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>, <argument><expr><call><name>linitial_oid</name><argument_list>(<argument><expr><name><name>args</name><operator>-&gt;</operator><name>hypertable_list</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>CACHE_FLAG_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ht</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>hypertable_is_distributed</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Get a list of associated data nodes. This is done here and also can be done later
	 * during sql_drop and command_end triggers execution.
	 */</comment>
	<expr_stmt><expr><call><name>dist_ddl_state_add_data_node_list_from_ht</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dist_ddl_process_create_schema</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>dist_ddl_state_add_current_data_node_list</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>dist_ddl_state_schedule</name><argument_list>(<argument><expr><name>DIST_DDL_EXEC_ON_START</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dist_ddl_process_drop_role</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DropRoleStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>DropRoleStmt</name></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>parsetree</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>stmt-&gt;roles</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RoleSpec</name> <modifier>*</modifier></type><name>rolspec</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RoleSpec</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>remote_connection_cache_dropped_role_callback</name><argument_list>(<argument><expr><name><name>rolspec</name><operator>-&gt;</operator><name>rolename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dist_ddl_process_drop</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DropStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>DropStmt</name></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>parsetree</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* For DROP TABLE and DROP SCHEMA operations hypertable_list will be empty */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>args</name><operator>-&gt;</operator><name>hypertable_list</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>removeType</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>OBJECT_TABLE</name></expr>:</case>
				<comment type="block">/* Wait for further sql_drop events  */</comment>
				<expr_stmt><expr><call><name>dist_ddl_state_schedule</name><argument_list>(<argument><expr><name>DIST_DDL_EXEC_ON_END</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>OBJECT_SCHEMA</name></expr>:</case>
				<comment type="block">/* Forward DROP SCHEMA command to all data nodes, following
				 * sql_drop events will be ignored */</comment>
				<expr_stmt><expr><call><name>dist_ddl_state_schedule</name><argument_list>(<argument><expr><name>DIST_DDL_EXEC_ON_START</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>dist_ddl_state_add_current_data_node_list</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<break>break;</break>
		</block_content>}</block></switch>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>dist_ddl_state_set_hypertable</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>removeType</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>OBJECT_INDEX</name></expr>:</case>
			<comment type="block">/*
			 * Need to handle drop index here because otherwise
			 * information about the related hypertable will be missed
			 * during sql_drop hook execution. Also expect cascade index
			 * drop to be handled in combination with table or schema
			 * drop.
			 */</comment>
			<expr_stmt><expr><call><name>dist_ddl_state_schedule</name><argument_list>(<argument><expr><name>DIST_DDL_EXEC_ON_END</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>OBJECT_TRIGGER</name></expr>:</case>
			<expr_stmt><expr><call><name>dist_ddl_state_schedule</name><argument_list>(<argument><expr><name>DIST_DDL_EXEC_ON_START</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<comment type="block">/* Only the object types above are forwarded from
			 * process_utility processing */</comment>
			<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pg_unreachable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dist_ddl_process_alter_object_schema</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlterObjectSchemaStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>AlterObjectSchemaStmt</name></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>parsetree</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>objectType</name></name> <operator>==</operator> <name>OBJECT_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* ALTER object SET SCHEMA */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>args</name><operator>-&gt;</operator><name>hypertable_list</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Hypertable oid is available in hypertable_list but
		 * cannot be resolved here until standard utility hook will synchronize new
		 * relation name and schema.
		 *
		 * Save oid for dist_ddl_end execution.
		 */</comment>
		<expr_stmt><expr><name><name>dist_ddl_state</name><operator>.</operator><name>relid</name></name> <operator>=</operator> <call><name>linitial_oid</name><argument_list>(<argument><expr><name><name>args</name><operator>-&gt;</operator><name>hypertable_list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>dist_ddl_state_schedule</name><argument_list>(<argument><expr><name>DIST_DDL_EXEC_ON_END</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dist_ddl_process_alter_owner_stmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlterOwnerStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>AlterOwnerStmt</name></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>parsetree</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>objectType</name></name> <operator>==</operator> <name>OBJECT_SCHEMA</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* ALTER SCHEMA OWNER TO */</comment>
		<expr_stmt><expr><call><name>dist_ddl_state_add_current_data_node_list</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>dist_ddl_state_schedule</name><argument_list>(<argument><expr><name>DIST_DDL_EXEC_ON_START</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dist_ddl_process_rename</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RenameStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>RenameStmt</name></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>parsetree</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>renameType</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>OBJECT_SCHEMA</name></expr>:</case>

			<comment type="block">/* ALTER SCHEMA RENAME TO */</comment>
			<expr_stmt><expr><call><name>dist_ddl_state_add_current_data_node_list</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>dist_ddl_state_schedule</name><argument_list>(<argument><expr><name>DIST_DDL_EXEC_ON_START</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>OBJECT_TABLE</name></expr>:</case>

			<comment type="block">/* ALTER TABLE RENAME TO */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>args</name><operator>-&gt;</operator><name>hypertable_list</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<comment type="block">/*
			 * Hypertable oid is available in hypertable_list but
			 * cannot be resolved here until standard utility hook will synchronize new
			 * relation name and schema.
			 *
			 * Save oid for dist_ddl_end execution.
			 */</comment>
			<expr_stmt><expr><name><name>dist_ddl_state</name><operator>.</operator><name>relid</name></name> <operator>=</operator> <call><name>linitial_oid</name><argument_list>(<argument><expr><name><name>args</name><operator>-&gt;</operator><name>hypertable_list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>dist_ddl_state_schedule</name><argument_list>(<argument><expr><name>DIST_DDL_EXEC_ON_END</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<comment type="block">/* Only handles other renamings here (e.g., triggers) */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>dist_ddl_state_set_hypertable</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>dist_ddl_state_schedule</name><argument_list>(<argument><expr><name>DIST_DDL_EXEC_ON_START</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dist_ddl_process_grant_on_database</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>GrantStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dbname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>dbmatch</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>cmd_descriptors</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>i</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>j</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>dist_util_membership</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>DIST_MEMBER_ACCESS_NODE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Check if the GRANT statement targets the current database.
	 *
	 * If the current database being used and it is distributed we
	 * rewrite and execute GRANT ON DATABASE statement for each data
	 * node specifically.
	 *
	 * If there are multiple databases in the list, we can't determine
	 * whether they are disributed or not, so we prevent this
	 * operation.
	 */</comment>
	<expr_stmt><expr><name>dbname</name> <operator>=</operator> <call><name>get_database_name</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dbmatch</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>i</argument>, <argument>stmt-&gt;objects</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>dbname</name></expr></argument>, <argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>dbmatch</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dbmatch</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Prevent using and mixing several databases in the statement */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objects</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot change privileges on multiple databases"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"It is not possible to grant privileges on multiple "</literal>
						   <literal type="string">"databases in a single statement when one of them is a distributed "</literal>
						   <literal type="string">"database."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Rewrite GRANT/REVOKE ON DATABASE query per each data node, since
	 * each data node might have different database name */</comment>
	<expr_stmt><expr><call><name>dist_ddl_state_add_current_data_node_list</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>i</argument>, <argument>dist_ddl_state.data_node_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>data_node_name</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>data_node_dbname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ForeignServer</name> <modifier>*</modifier></type><name>server</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DistCmdDescr</name> <modifier>*</modifier></type><name>cmd_desc</name></decl>;</decl_stmt>

		<comment type="block">/* Get data node database name from foreign server options */</comment>
		<expr_stmt><expr><name>server</name> <operator>=</operator> <call><name>GetForeignServerByName</name><argument_list>(<argument><expr><name>data_node_name</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>foreach</name> <argument_list>(<argument>j</argument>, <argument>server-&gt;options</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>opt</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"dbname"</literal></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>data_node_dbname</name> <operator>=</operator> <call><name>defGetString</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<comment type="block">/* Create a query using data node's database name */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>data_node_dbname</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cmd_desc</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DistCmdDescr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cmd_desc</name><operator>-&gt;</operator><name>sql</name></name> <operator>=</operator> <call><name>deparse_grant_revoke_on_database</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>data_node_dbname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cmd_descriptors</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>cmd_descriptors</name></expr></argument>, <argument><expr><name>cmd_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"[%s]: %s"</literal></expr></argument>, <argument><expr><name>data_node_name</name></expr></argument>, <argument><expr><name><name>cmd_desc</name><operator>-&gt;</operator><name>sql</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>dist_ddl_state_set_exec_type</name><argument_list>(<argument><expr><name>DIST_DDL_EXEC_ON_START</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>dist_ddl_state_add_remote_command_list</name><argument_list>(<argument><expr><name>cmd_descriptors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dist_ddl_process_grant_on_tables_in_schema</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GrantStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>GrantStmt</name></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>parsetree</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>exec_on_datanodes</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Check if there are any distributed hypertables in the schemas.
	 * Otherwise no need to execute the query on the datanodes
	 *
	 * If more than one schemas are specified, then we ship the query
	 * if any of the schemas contain distributed hypertables. It will
	 * be the onus of the user to ensure that all schemas exist on the
	 * datanodes as required. They can always call on an individual
	 * schema one by one in that case.
	 */</comment>
	<macro><name>foreach</name> <argument_list>(<argument>cell</argument>, <argument>stmt-&gt;objects</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nspname</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>LookupExplicitNamespace</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>ScanIterator</name></type> <name>iterator</name> <init>=
			<expr><call><name>ts_scan_iterator_create</name><argument_list>(<argument><expr><name>HYPERTABLE</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>, <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ts_hypertable_scan_by_name</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>, <argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>ts_scanner_foreach</name><argument_list>(<argument>&amp;iterator</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>FormData_hypertable</name></type> <name>fd</name></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name> <init>= <expr><call><name>ts_scan_iterator_tuple_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>ts_hypertable_formdata_fill</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fd</name></expr></argument>, <argument><expr><name>ti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>fd</name><operator>.</operator><name>replication_factor</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>exec_on_datanodes</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>ts_scan_iterator_close</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>exec_on_datanodes</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>exec_on_datanodes</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>dist_ddl_state_schedule</name><argument_list>(<argument><expr><name>DIST_DDL_EXEC_ON_START</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>dist_ddl_state_add_current_data_node_list</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dist_ddl_process_grant_on_table</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>dist_ddl_state_set_hypertable</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>dist_ddl_state_schedule</name><argument_list>(<argument><expr><name>DIST_DDL_EXEC_ON_START</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dist_ddl_process_grant_on_schema</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>dist_ddl_state_add_current_data_node_list</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>dist_ddl_state_schedule</name><argument_list>(<argument><expr><name>DIST_DDL_EXEC_ON_START</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dist_ddl_process_grant_object</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>GrantStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>GrantStmt</name></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>parsetree</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>objtype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>OBJECT_DATABASE</name></expr>:</case>
			<expr_stmt><expr><call><name>dist_ddl_process_grant_on_database</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_TABLE</name></expr>:</case>
			<expr_stmt><expr><call><name>dist_ddl_process_grant_on_table</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_SCHEMA</name></expr>:</case>
			<expr_stmt><expr><call><name>dist_ddl_process_grant_on_schema</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dist_ddl_process_grant_all_in_schema</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>GrantStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>GrantStmt</name></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>parsetree</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>objtype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>OBJECT_TABLE</name></expr>:</case>
			<expr_stmt><expr><call><name>dist_ddl_process_grant_on_tables_in_schema</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dist_ddl_process_grant</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>GrantStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>GrantStmt</name></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>parsetree</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>targtype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>ACL_TARGET_OBJECT</name></expr>:</case>
			<expr_stmt><expr><call><name>dist_ddl_process_grant_object</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>ACL_TARGET_ALL_IN_SCHEMA</name></expr>:</case>
			<expr_stmt><expr><call><name>dist_ddl_process_grant_all_in_schema</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>ACL_TARGET_DEFAULTS</name></expr>:</case>
			<comment type="block">/* Not handled on a per-grant statement. The entire ALTER DEFAULT
			 * PRIVILEGES is forwarded and handled below. */</comment>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * "DROP OWNED BY" and "REASSIGN OWNED BY" commands need to be shipped to the
 * datanodes as is.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dist_ddl_process_drop_reassign</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>dist_ddl_state_schedule</name><argument_list>(<argument><expr><name>DIST_DDL_EXEC_ON_START</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>dist_ddl_state_add_current_data_node_list</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Alter default privileges.
 *
 * Commands for altering default privileges are sent as is to data nodes. It
 * is assumed that any roles or schemas involved exist also on the data nodes.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dist_ddl_process_alter_default_privileges</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>dist_ddl_state_schedule</name><argument_list>(<argument><expr><name>DIST_DDL_EXEC_ON_START</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>dist_ddl_state_add_current_data_node_list</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * In multi-command statements (e.g., ALTER), it should not be possible to
 * have a mix of sub-commands that require both START and END processing.
 * Such mixing would require splitting the original ALTER across both START and END
 * processing, which would prevent simply forwarding the original statement to
 * the data nodes. For instance, consider:
 *
 * ALTER TABLE foo SET (newoption = true), ADD CONSTRAINT mycheck CHECK (count &gt; 0);
 *
 * which contains two sub-commands (SET and ADD CONSTRAINT), where the first
 * command (SET) is handled at START, while the latter is handled at
 * END. While we could always distribute commands at START, this would prevent
 * local validation by PostgreSQL.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>DistDDLExecType</name></type>
<name>set_alter_table_exec_type</name><parameter_list>(<parameter><decl><type><name>DistDDLExecType</name></type> <name>prev_type</name></decl></parameter>, <parameter><decl><type><name>DistDDLExecType</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>prev_type</name> <operator>!=</operator> <name>DIST_DDL_EXEC_NONE</name> <operator>&amp;&amp;</operator> <name>prev_type</name> <operator>!=</operator> <name>type</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"incompatible sub-commands in single statement"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The statement contains sub-commands that require different "</literal>
						   <literal type="string">"handling to distribute to data nodes and can therefore not "</literal>
						   <literal type="string">"be mixed in a single statement."</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Try executing the sub-commands in separate statements."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>type</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dist_ddl_process_alter_table</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>AlterTableStmt</name></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>parsetree</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DistDDLExecType</name></type> <name>exec_type</name> <init>= <expr><name>DIST_DDL_EXEC_NONE</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>dist_ddl_state_set_hypertable</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>stmt-&gt;cmds</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>AlterTableCmd</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>AT_AddColumn</name></expr>:</case>
			<case>case <expr><name>AT_AddColumnRecurse</name></expr>:</case>
			<case>case <expr><name>AT_DropColumn</name></expr>:</case>
			<case>case <expr><name>AT_DropColumnRecurse</name></expr>:</case>
			<case>case <expr><name>AT_AddConstraint</name></expr>:</case>
			<case>case <expr><name>AT_AddConstraintRecurse</name></expr>:</case>
			<case>case <expr><name>AT_DropConstraint</name></expr>:</case>
			<case>case <expr><name>AT_DropConstraintRecurse</name></expr>:</case>
			<case>case <expr><name>AT_SetNotNull</name></expr>:</case>
			<case>case <expr><name>AT_DropNotNull</name></expr>:</case>
			<case>case <expr><name>AT_AddIndex</name></expr>:</case>
			<case>case <expr><name>AT_AlterColumnType</name></expr>:</case>
				<expr_stmt><expr><name>exec_type</name> <operator>=</operator> <call><name>set_alter_table_exec_type</name><argument_list>(<argument><expr><name>exec_type</name></expr></argument>, <argument><expr><name>DIST_DDL_EXEC_ON_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>AT_ChangeOwner</name></expr>:</case>
			<case>case <expr><name>AT_ReplaceRelOptions</name></expr>:</case>
			<case>case <expr><name>AT_ResetRelOptions</name></expr>:</case>
			<case>case <expr><name>AT_SetRelOptions</name></expr>:</case>
			<case>case <expr><name>AT_DropOids</name></expr>:</case>
				<comment type="block">/* Custom TimescaleDB options (e.g.,
				 * compression-related options) are not recognized by
				 * PostgreSQL and thus cannot mix with other (PG)
				 * options. As a consequence, custom reloptions are
				 * not forwarded/handled by PostgreSQL and thus never
				 * reach END processing. Therefore, to distributed
				 * SetRelOptions to other nodes, it needs to happen at
				 * START. */</comment>
				<expr_stmt><expr><name>exec_type</name> <operator>=</operator> <call><name>set_alter_table_exec_type</name><argument_list>(<argument><expr><name>exec_type</name></expr></argument>, <argument><expr><name>DIST_DDL_EXEC_ON_START</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>dist_ddl_error_raise_unsupported</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block>

	<expr_stmt><expr><call><name>dist_ddl_state_schedule</name><argument_list>(<argument><expr><name>exec_type</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dist_ddl_process_index</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>dist_ddl_state_set_hypertable</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Since we have custom CREATE INDEX implementation, currently it
	 * does not support ddl_command_end trigger. */</comment>
	<expr_stmt><expr><call><name>dist_ddl_state_schedule</name><argument_list>(<argument><expr><name>DIST_DDL_EXEC_ON_START</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dist_ddl_process_reindex</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>dist_ddl_state_set_hypertable</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>dist_ddl_state_schedule</name><argument_list>(<argument><expr><name>DIST_DDL_EXEC_ON_START</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dist_ddl_process_create_trigger</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CreateTrigStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>CreateTrigStmt</name></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>parsetree</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>dist_ddl_state_set_hypertable</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>funcname</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name><name>funcargtypes</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>funcid</name> <init>= <expr><call><name>LookupFuncName</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>funcname</name></name></expr></argument>,
									<argument><expr><literal type="number">0</literal></expr></argument> <comment type="block">/* nargs */</comment>,
									<argument><expr><name>funcargtypes</name></expr></argument> <comment type="block">/* passing NULL is not allowed in PG12 */</comment>,
									<argument><expr><name>false</name></expr></argument> <comment type="block">/* missing ok */</comment>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type> <name>datum</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>pg_get_functiondef</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>dist_ddl_state_add_remote_command</name><argument_list>(<argument><expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>dist_ddl_state_schedule</name><argument_list>(<argument><expr><name>DIST_DDL_EXEC_ON_START</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dist_ddl_process_vacuum</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>VacuumStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>VacuumStmt</name></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>parsetree</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Allow execution of VACUUM/ANALYZE commands on a data node without
	 * enabling timescaledb.enable_client_ddl_on_data_nodes GUC */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>dist_util_membership</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>DIST_MEMBER_ACCESS_NODE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>dist_ddl_state_set_hypertable</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* We do not support VERBOSE flag since it will require to print data
	 * returned from the data nodes */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>get_vacuum_options</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>VACOPT_VERBOSE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dist_ddl_error_raise_unsupported</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>dist_ddl_state_schedule</name><argument_list>(<argument><expr><name>DIST_DDL_EXEC_ON_START_NO_2PC</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dist_ddl_process_truncate</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TruncateStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>TruncateStmt</name> <operator>*</operator><operator>)</operator> <name><name>args</name><operator>-&gt;</operator><name>parsetree</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>dist_ddl_state_set_hypertable</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We only support TRUNCATE on single distributed hypertables
	 * since other tables might not exist on data nodes and multiple
	 * distributed hypertables might be distributed across different
	 * sets of nodes.
	 *
	 * Note that distributed hypertables are filtered from the relations list in
	 * process_utility.c, so the list might actually be empty.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relations</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dist_ddl_error_raise_unsupported</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>dist_ddl_state_schedule</name><argument_list>(<argument><expr><name>DIST_DDL_EXEC_ON_START</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dist_ddl_process_unsupported</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>dist_ddl_state_set_hypertable</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>dist_ddl_error_raise_unsupported</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Process DDL operations on distributed hypertables.
 *
 * This function is executed for any Utility/DDL operation and for any
 * PostgreSQL tables been involved in the query.
 *
 * We are particulary interested in distributed hypertables and distributed
 * hypertable members (regular hypertables created on a data nodes).
 *
 * In most cases expect and allow only one distributed hypertable per
 * operation to avoid query deparsing, but do not restrict the number of
 * other hypertable types involved.
 *
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dist_ddl_process</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NodeTag</name></type> <name>tag</name> <init>= <expr><call><name>nodeTag</name><argument_list>(<argument><expr><name><name>args</name><operator>-&gt;</operator><name>parsetree</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Block unsupported operations on distributed hypertables and
	 * decide on how to execute it. */</comment>
	<switch>switch <condition>(<expr><name>tag</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_CreateSchemaStmt</name></expr>:</case>
			<expr_stmt><expr><call><name>dist_ddl_process_create_schema</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DropRoleStmt</name></expr>:</case>
			<expr_stmt><expr><call><name>dist_ddl_process_drop_role</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DropStmt</name></expr>:</case>
			<expr_stmt><expr><call><name>dist_ddl_process_drop</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterObjectSchemaStmt</name></expr>:</case>
			<expr_stmt><expr><call><name>dist_ddl_process_alter_object_schema</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterOwnerStmt</name></expr>:</case>
			<expr_stmt><expr><call><name>dist_ddl_process_alter_owner_stmt</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_RenameStmt</name></expr>:</case>
			<expr_stmt><expr><call><name>dist_ddl_process_rename</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_GrantStmt</name></expr>:</case>
			<expr_stmt><expr><call><name>dist_ddl_process_grant</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DropOwnedStmt</name></expr>:</case>
		<case>case <expr><name>T_ReassignOwnedStmt</name></expr>:</case>
			<expr_stmt><expr><call><name>dist_ddl_process_drop_reassign</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterTableStmt</name></expr>:</case>
			<expr_stmt><expr><call><name>dist_ddl_process_alter_table</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterDefaultPrivilegesStmt</name></expr>:</case>
			<expr_stmt><expr><call><name>dist_ddl_process_alter_default_privileges</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_IndexStmt</name></expr>:</case>
			<expr_stmt><expr><call><name>dist_ddl_process_index</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ReindexStmt</name></expr>:</case>
			<expr_stmt><expr><call><name>dist_ddl_process_reindex</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateTrigStmt</name></expr>:</case>
			<expr_stmt><expr><call><name>dist_ddl_process_create_trigger</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_VacuumStmt</name></expr>:</case>
			<expr_stmt><expr><call><name>dist_ddl_process_vacuum</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_TruncateStmt</name></expr>:</case>
			<expr_stmt><expr><call><name>dist_ddl_process_truncate</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<comment type="block">/* currently unsupported commands */</comment>
			<expr_stmt><expr><call><name>dist_ddl_process_unsupported</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dist_ddl_execute</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>transactional</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>search_path</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* Execute command on data nodes using local search_path. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>dist_ddl_state</name><operator>.</operator><name>data_node_list</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>dist_ddl_state_reset</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>search_path</name> <operator>=</operator> <call><name>GetConfigOption</name><argument_list>(<argument><expr><literal type="string">"search_path"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>dist_ddl_state.remote_commands</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>command</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>NodeTag</name></type> <name>command_tag</name> <init>= <expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DistCmdResult</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><name>command_tag</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>T_String</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/* Execute single SQL command on each data node from the list */</comment>
				<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sql</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ts_dist_cmd_invoke_on_data_nodes_using_search_path</name><argument_list>(<argument><expr><name>sql</name></expr></argument>,
																			<argument><expr><name>search_path</name></expr></argument>,
																			<argument><expr><name><name>dist_ddl_state</name>
																				<operator>.</operator><name>data_node_list</name></name></expr></argument>,
																			<argument><expr><name>transactional</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>
			<case>case <expr><name>T_List</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/* Execute separate SQL command on each data node from the list */</comment>
				<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>cmd_descriptors</name> <init>= <expr><name>command</name></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>dist_ddl_state</name><operator>.</operator><name>data_node_list</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>cmd_descriptors</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>result</name> <operator>=</operator>
					<call><name>ts_dist_multi_cmds_invoke_on_data_nodes_using_search_path</name><argument_list>(<argument><expr><name>cmd_descriptors</name></expr></argument>,
																			  <argument><expr><name>search_path</name></expr></argument>,
																			  <argument><expr><name><name>dist_ddl_state</name>
																				  <operator>.</operator><name>data_node_list</name></name></expr></argument>,
																			  <argument><expr><name>transactional</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>
			<default>default:</default>
				<expr_stmt><expr><call><name>pg_unreachable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>

		<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ts_dist_cmd_close_response</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>dist_ddl_state_reset</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Update stats after ANALYZE execution */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dist_ddl_get_analyze_stats</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>VacuumStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>VacuumStmt</name></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>parsetree</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relid</name> <init>= <expr><call><name>linitial_oid</name><argument_list>(<argument><expr><name><name>args</name><operator>-&gt;</operator><name>hypertable_list</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>get_vacuum_options</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>VACOPT_ANALYZE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Refresh the local chunk stats by fetching stats
	 * from remote data nodes. */</comment>
	<expr_stmt><expr><call><name>chunk_api_update_distributed_hypertable_stats</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>dist_ddl_enable_distributed_ddl</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>enable_distributed_ddl</name> <init>=
		<expr><call><name>GetConfigOption</name><argument_list>(<argument><expr><literal type="string">"timescaledb_experimental.enable_distributed_ddl"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Default to disabled */</comment>
	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>enable_distributed_ddl</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>enable_distributed_ddl</name></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>enable_distributed_ddl</name></expr></argument>, <argument><expr><literal type="string">"on"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check if it is allowed to execute distributed DDL operation on a
 * database objects such as SCHEMA, DATABASE, etc.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>dist_ddl_process_database_object</name><parameter_list>(<parameter><decl><type><name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* disable this functionality while any extension being
	 * created or upgraded */</comment>
	<if_stmt><if>if <condition>(<expr><name>creating_extension</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>dist_ddl_enable_distributed_ddl</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name><name>args</name><operator>-&gt;</operator><name>parsetree</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_CreateSchemaStmt</name></expr>:</case>
		<case>case <expr><name>T_DropOwnedStmt</name></expr>:</case>
		<case>case <expr><name>T_ReassignOwnedStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterDefaultPrivilegesStmt</name></expr>:</case>
			<return>return <expr><name>false</name></expr>;</return>

		<case>case <expr><name>T_DropStmt</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>DropStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>DropStmt</name></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>parsetree</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>removeType</name></name> <operator>==</operator> <name>OBJECT_SCHEMA</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>T_RenameStmt</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>RenameStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>RenameStmt</name></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>parsetree</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>renameType</name></name> <operator>==</operator> <name>OBJECT_SCHEMA</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>T_AlterOwnerStmt</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>AlterOwnerStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>AlterOwnerStmt</name></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>parsetree</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>objectType</name></name> <operator>==</operator> <name>OBJECT_SCHEMA</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>T_GrantStmt</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>GrantStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>GrantStmt</name></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>parsetree</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>targtype</name></name> <operator>==</operator> <name>ACL_TARGET_ALL_IN_SCHEMA</name> <operator>||</operator> <name><name>stmt</name><operator>-&gt;</operator><name>targtype</name></name> <operator>==</operator> <name>ACL_TARGET_DEFAULTS</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>objtype</name></name> <operator>==</operator> <name>OBJECT_DATABASE</name> <operator>||</operator> <name><name>stmt</name><operator>-&gt;</operator><name>objtype</name></name> <operator>==</operator> <name>OBJECT_SCHEMA</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>
		</block_content>}</block>

		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>dist_ddl_start</name><parameter_list>(<parameter><decl><type><name>ProcessUtilityArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Certain utility commands we know to not process here */</comment>
	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name><name>args</name><operator>-&gt;</operator><name>parsetree</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_CopyStmt</name></expr>:</case>
		<case>case <expr><name>T_CallStmt</name></expr>:</case>
			<return>return;</return>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* Do not process nested DDL operations */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>dist_ddl_scheduled_for_execution</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Process remote DDL only on the distributed database
	 *
	 * Since the dist ddl code executed after being already executed from main process
	 * utility hook in src/process_utility.c we could end in state, when transaction
	 * is already completed by ROLLBACK statement. Since dist_util_membership() function
	 * reads meta data catalog, it is required to have an active transaction there
	 * otherwise it will hit an assert.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsTransactionState</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>dist_util_membership</name><argument_list>()</argument_list></call> <operator>==</operator> <name>DIST_MEMBER_NONE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Do not process DDL command on a database object, unless it is
	 * allowed by a session variable */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>dist_ddl_process_database_object</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"skipping dist DDL on object: %s"</literal></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>query_string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Save origin query and memory context used to save information in
	 * data_node_list since it will differ during event hooks execution. */</comment>
	<expr_stmt><expr><name><name>dist_ddl_state</name><operator>.</operator><name>mctx</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>

	<comment type="block">/* Decide if this is a distributed DDL operation and when it
	 * should be executed. */</comment>
	<expr_stmt><expr><call><name>dist_ddl_process</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>dist_ddl_state</name><operator>.</operator><name>exec_type</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>DIST_DDL_EXEC_ON_START</name></expr>:</case>
			<expr_stmt><expr><call><name>dist_ddl_execute</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DIST_DDL_EXEC_ON_START_NO_2PC</name></expr>:</case>
			<expr_stmt><expr><call><name>dist_ddl_execute</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Import distributed hypertable stats after executing
			 * ANALYZE command. */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>args</name><operator>-&gt;</operator><name>parsetree</name></name></expr></argument>, <argument><expr><name>VacuumStmt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>dist_ddl_get_analyze_stats</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>DIST_DDL_EXEC_ON_END</name></expr>:</case>
		<case>case <expr><name>DIST_DDL_EXEC_NONE</name></expr>:</case>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>dist_ddl_end</name><parameter_list>(<parameter><decl><type><name>EventTriggerData</name> <modifier>*</modifier></type><name>command</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>dist_ddl_state</name><operator>.</operator><name>exec_type</name></name> <operator>!=</operator> <name>DIST_DDL_EXEC_ON_END</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>dist_ddl_state_reset</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Do delayed block of SET SCHEMA and RENAME commands */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>dist_ddl_state</name><operator>.</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Get hypertable type and update data node list */</comment>
		<decl_stmt><decl><type><name>Cache</name> <modifier>*</modifier></type><name>hcache</name> <init>= <expr><call><name>ts_hypertable_cache_pin</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name> <init>=
			<expr><call><name>ts_hypertable_cache_get_entry</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>, <argument><expr><name><name>dist_ddl_state</name><operator>.</operator><name>relid</name></name></expr></argument>, <argument><expr><name>CACHE_FLAG_NONE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ht</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>HypertableType</name></type> <name>type</name> <init>= <expr><call><name>ts_hypertable_get_type</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>dist_ddl_state_add_data_node_list_from_ht</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Ensure this operation is executed by the access node session. */</comment>
		<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>HYPERTABLE_DISTRIBUTED_MEMBER</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>dist_ddl_error_if_not_allowed_data_node_session</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Execute command on remote data nodes. */</comment>
	<expr_stmt><expr><call><name>dist_ddl_execute</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>dist_ddl_drop</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>dropped_objects</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>dist_ddl_scheduled_for_execution</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>dropped_objects</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>EventTriggerDropObject</name> <modifier>*</modifier></type><name>obj</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>EVENT_TRIGGER_DROP_FOREIGN_TABLE</name></expr>:</case>
			<case>case <expr><name>EVENT_TRIGGER_DROP_TABLE</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>EventTriggerDropRelation</name> <modifier>*</modifier></type><name>event</name> <init>= <expr><operator>(</operator><name>EventTriggerDropRelation</name> <operator>*</operator><operator>)</operator> <name>obj</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>dist_ddl_state_add_data_node_list_from_table</name><argument_list>(<argument><expr><name><name>event</name><operator>-&gt;</operator><name>schema</name></name></expr></argument>, <argument><expr><name><name>event</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

			<case>case <expr><name>EVENT_TRIGGER_DROP_INDEX</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * Skip here, bacause we expect CASCADE case to be handled in
				 * combination with DROP TABLE.
				 */</comment>
				<break>break;</break>
			</block_content>}</block>

			<case>case <expr><name>EVENT_TRIGGER_DROP_TABLE_CONSTRAINT</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>EventTriggerDropTableConstraint</name> <modifier>*</modifier></type><name>event</name> <init>= <expr><operator>(</operator><name>EventTriggerDropTableConstraint</name> <operator>*</operator><operator>)</operator> <name>obj</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>dist_ddl_state_add_data_node_list_from_table</name><argument_list>(<argument><expr><name><name>event</name><operator>-&gt;</operator><name>schema</name></name></expr></argument>, <argument><expr><name><name>event</name><operator>-&gt;</operator><name>table</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

			<case>case <expr><name>EVENT_TRIGGER_DROP_TRIGGER</name></expr>:</case>
			<case>case <expr><name>EVENT_TRIGGER_DROP_FOREIGN_SERVER</name></expr>:</case>
			<case>case <expr><name>EVENT_TRIGGER_DROP_SCHEMA</name></expr>:</case>
			<case>case <expr><name>EVENT_TRIGGER_DROP_VIEW</name></expr>:</case>
				<comment type="block">/* Skip */</comment>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block>
</block_content>}</block></function>
</unit>
