<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/timescaledb/tsl/src/remote/async.c"><comment type="block">/*
 * This file and its contents are licensed under the Timescale License.
 * Please see the included NOTICE for copyright information and
 * LICENSE-TIMESCALE for a copy of the license.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postgres.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/pg_list.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;libpq-fe.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;storage/latch.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;miscadmin.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pgstat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fmgr.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/lsyscache.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_type.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/pathnodes.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postmaster/postmaster.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;annotations.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"async.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"connection.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils.h"</cpp:file></cpp:include>

<comment type="block" format="doxygen">/**
 * State machine for AsyncRequest:
 *
 *   +-------------+           +--------------+        +--------------+
 *   |             |           |              |        |              |
 *   |  DEFERRED   +----------&gt;+  EXECUTING   +-------&gt;+   COMPLETED  |
 *   |             |           |              |        |              |
 *   +-------------+           +--------------+        +--------------+
 *
 **/</comment>

<typedef>typedef <type><enum>enum <name>AsyncRequestState</name>
<block>{
	<decl><name>DEFERRED</name></decl>,
	<decl><name>EXECUTING</name></decl>,
	<decl><name>COMPLETED</name></decl>,
}</block></enum></type> <name>AsyncRequestState</name>;</typedef>

<typedef>typedef <type><struct>struct <name>AsyncRequest</name>
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sql</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TSConnection</name> <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AsyncRequestState</name></type> <name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>stmt_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>prep_stmt_params</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>async_response_callback</name></type> <name>response_cb</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>user_data</name></decl>;</decl_stmt> <comment type="block">/* custom data saved with the request */</comment>
	<decl_stmt><decl><type><name>StmtParams</name> <modifier>*</modifier></type><name>params</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>res_format</name></decl>;</decl_stmt> <comment type="block">/* text or binary */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>is_xact_transition</name></decl>;</decl_stmt>
}</block></struct></type> <name>AsyncRequest</name>;</typedef>

<typedef>typedef <type><struct>struct <name>PreparedStmt</name>
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sql</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TSConnection</name> <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>stmt_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>n_params</name></decl>;</decl_stmt>
}</block></struct></type> <name>PreparedStmt</name>;</typedef>

<comment type="block">/* It is often useful to get the request along with the result in the response */</comment>

<typedef>typedef <type><struct>struct <name>AsyncResponse</name>
<block>{
	<decl_stmt><decl><type><name>AsyncResponseType</name></type> <name>type</name></decl>;</decl_stmt>
}</block></struct></type> <name>AsyncResponse</name>;</typedef>

<typedef>typedef <type><struct>struct <name>AsyncResponseResult</name>
<block>{
	<decl_stmt><decl><type><name>AsyncResponse</name></type> <name>base</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AsyncRequest</name> <modifier>*</modifier></type><name>request</name></decl>;</decl_stmt>
}</block></struct></type> <name>AsyncResponseResult</name>;</typedef>

<typedef>typedef <type><struct>struct <name>AsyncResponseCommunicationError</name>
<block>{
	<decl_stmt><decl><type><name>AsyncResponse</name></type> <name>base</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AsyncRequest</name> <modifier>*</modifier></type><name>request</name></decl>;</decl_stmt>
}</block></struct></type> <name>AsyncResponseCommunicationError</name>;</typedef>

<typedef>typedef <type><struct>struct <name>AsyncResponseError</name>
<block>{
	<decl_stmt><decl><type><name>AsyncResponse</name></type> <name>base</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>errmsg</name></decl>;</decl_stmt>
}</block></struct></type> <name>AsyncResponseError</name>;</typedef>

<typedef>typedef <type><struct>struct <name>AsyncRequestSet</name>
<block>{
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>requests</name></decl>;</decl_stmt>
}</block></struct></type> <name>AsyncRequestSet</name>;</typedef>

<function><type><specifier>static</specifier> <name>AsyncRequest</name> <modifier>*</modifier></type>
<name>async_request_create</name><parameter_list>(<parameter><decl><type><name>TSConnection</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sql</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>stmt_name</name></decl></parameter>,
					 <parameter><decl><type><name>int</name></type> <name>prep_stmt_params</name></decl></parameter>, <parameter><decl><type><name>StmtParams</name> <modifier>*</modifier></type><name>stmt_params</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>res_format</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AsyncRequest</name> <modifier>*</modifier></type><name>req</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>conn</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"can't create AsyncRequest with NULL connection"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>req</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AsyncRequest</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>req</name> <operator>=</operator> <operator>(</operator><name>AsyncRequest</name><operator>)</operator><block>{ <expr><operator>.</operator><name>conn</name> <operator>=</operator> <name>conn</name></expr>,
						   <expr><operator>.</operator><name>state</name> <operator>=</operator> <name>DEFERRED</name></expr>,
						   <expr><operator>.</operator><name>sql</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr>,
						   <expr><operator>.</operator><name>stmt_name</name> <operator>=</operator> <name>stmt_name</name></expr>,
						   <expr><operator>.</operator><name>params</name> <operator>=</operator> <name>stmt_params</name></expr>,
						   <expr><operator>.</operator><name>prep_stmt_params</name> <operator>=</operator> <name>prep_stmt_params</name></expr>,
						   <expr><operator>.</operator><name>res_format</name> <operator>=</operator> <name>res_format</name></expr> }</block></expr>;</expr_stmt>

	<return>return <expr><name>req</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>async_request_set_state</name><parameter_list>(<parameter><decl><type><name>AsyncRequest</name> <modifier>*</modifier></type><name>req</name></decl></parameter>, <parameter><decl><type><name>AsyncRequestState</name></type> <name>new_state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>req</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>DEFERRED</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>req</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>new_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
	<switch>switch <condition>(<expr><name>new_state</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>DEFERRED</name></expr>:</case>
			<comment type="block">/* initial state */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>req</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>DEFERRED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EXECUTING</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>req</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>DEFERRED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>COMPLETED</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>req</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>EXECUTING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name><name>req</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>new_state</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Send a request. In case there is an ongoing request for the connection,
   we will not send the request but set its status to DEFERRED.
   Getting a response from DEFERRED AsyncRequest will try sending it if
   the connection is not in use.

   Note that we can only send one sql statement per request.
   This is because we use `PQsendQueryParams` which uses the extended query protocol
   instead of the simple one. The extended protocol does not support multiple
   statements. In the future we can use a `PQsendQuery` variant for queries without parameters,
   which can support multiple statements because it uses the simple protocol. But this is
   an optimization for another time.
*/</comment>
<function><type><specifier>static</specifier> <name>AsyncRequest</name> <modifier>*</modifier></type>
<name>async_request_send_internal</name><parameter_list>(<parameter><decl><type><name>AsyncRequest</name> <modifier>*</modifier></type><name>req</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>req</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>DEFERRED</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>, <argument><expr><literal type="string">"can't send async request in state \"%d\""</literal></expr></argument>, <argument><expr><name><name>req</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>remote_connection_is_processing</name><argument_list>(<argument><expr><name><name>req</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>req</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Send configuration parameters if necessary */</comment>
	<expr_stmt><expr><call><name>remote_connection_configure_if_changed</name><argument_list>(<argument><expr><name><name>req</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>req</name><operator>-&gt;</operator><name>stmt_name</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We intentionally do not specify parameter types here, but leave the
		 * data node to derive them by default.  This avoids possible problems
		 * with the data node using different type OIDs than we do.  All of
		 * the prepared statements we use in this module are simple enough that
		 * the data node will make the right choices.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <call><name>PQsendPrepare</name><argument_list>(<argument><expr><call><name>remote_connection_get_pg_conn</name><argument_list>(<argument><expr><name><name>req</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><name><name>req</name><operator>-&gt;</operator><name>stmt_name</name></name></expr></argument>,
							   <argument><expr><name><name>req</name><operator>-&gt;</operator><name>sql</name></name></expr></argument>,
							   <argument><expr><name><name>req</name><operator>-&gt;</operator><name>prep_stmt_params</name></name></expr></argument>,
							   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * null is fine to pass down as the res, the connection error message
			 * will get through
			 */</comment>
			<expr_stmt><expr><call><name>remote_connection_elog</name><argument_list>(<argument><expr><name><name>req</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <call><name>PQsendQueryParams</name><argument_list>(<argument><expr><call><name>remote_connection_get_pg_conn</name><argument_list>(<argument><expr><name><name>req</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name><name>req</name><operator>-&gt;</operator><name>sql</name></name></expr></argument>,
								   <argument><expr><call><name>stmt_params_total_values</name><argument_list>(<argument><expr><name><name>req</name><operator>-&gt;</operator><name>params</name></name></expr></argument>)</argument_list></call></expr></argument>,
								   <comment type="block">/* param types - see note above */</comment> <argument><expr><name>NULL</name></expr></argument>,
								   <argument><expr><call><name>stmt_params_values</name><argument_list>(<argument><expr><name><name>req</name><operator>-&gt;</operator><name>params</name></name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><call><name>stmt_params_lengths</name><argument_list>(<argument><expr><name><name>req</name><operator>-&gt;</operator><name>params</name></name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><call><name>stmt_params_formats</name><argument_list>(<argument><expr><name><name>req</name><operator>-&gt;</operator><name>params</name></name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name><name>req</name><operator>-&gt;</operator><name>res_format</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * null is fine to pass down as the res, the connection error message
			 * will get through
			 */</comment>
			<expr_stmt><expr><call><name>remote_connection_elog</name><argument_list>(<argument><expr><name><name>req</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>async_request_set_state</name><argument_list>(<argument><expr><name>req</name></expr></argument>, <argument><expr><name>EXECUTING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>remote_connection_set_status</name><argument_list>(<argument><expr><name><name>req</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><name>CONN_PROCESSING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>req</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>AsyncRequest</name> <modifier>*</modifier></type>
<name>async_request_send_with_stmt_params_elevel_res_format</name><parameter_list>(<parameter><decl><type><name>TSConnection</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sql_statement</name></decl></parameter>,
													  <parameter><decl><type><name>StmtParams</name> <modifier>*</modifier></type><name>params</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>,
													  <parameter><decl><type><name>int</name></type> <name>res_format</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AsyncRequest</name> <modifier>*</modifier></type><name>req</name> <init>= <expr><call><name>async_request_create</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>sql_statement</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>res_format</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>req</name> <operator>=</operator> <call><name>async_request_send_internal</name><argument_list>(<argument><expr><name>req</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>req</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>AsyncRequest</name> <modifier>*</modifier></type>
<name>async_request_send_prepare</name><parameter_list>(<parameter><decl><type><name>TSConnection</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sql</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n_params</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AsyncRequest</name> <modifier>*</modifier></type><name>req</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>stmt_name_len</name> <init>= <expr><name>NAMEDATALEN</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>stmt_name</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>stmt_name_len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>written</name></decl>;</decl_stmt>

	<comment type="block">/* Construct name we'll use for the prepared statement. */</comment>
	<expr_stmt><expr><name>written</name> <operator>=</operator>
		<call><name>snprintf</name><argument_list>(<argument><expr><name>stmt_name</name></expr></argument>, <argument><expr><name>stmt_name_len</name></expr></argument>, <argument><expr><literal type="string">"ts_prep_%u"</literal></expr></argument>, <argument><expr><call><name>remote_connection_get_prep_stmt_number</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>written</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <name>written</name> <operator>&gt;=</operator> <name>stmt_name_len</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot create prepared statement name"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>req</name> <operator>=</operator> <call><name>async_request_create</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>sql</name></expr></argument>, <argument><expr><name>stmt_name</name></expr></argument>, <argument><expr><name>n_params</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>FORMAT_TEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>req</name> <operator>=</operator> <call><name>async_request_send_internal</name><argument_list>(<argument><expr><name>req</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>req</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>extern</specifier> <name>AsyncRequest</name> <modifier>*</modifier></type>
<name>async_request_send_prepared_stmt</name><parameter_list>(<parameter><decl><type><name>PreparedStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>param_values</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AsyncRequest</name> <modifier>*</modifier></type><name>req</name> <init>=
		<expr><call><name>async_request_create</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>,
							 <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>sql</name></name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>n_params</name></name></expr></argument>,
							 <argument><expr><call><name>stmt_params_create_from_values</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>param_values</name></expr></argument>,
															<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>n_params</name></name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name>FORMAT_TEXT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>async_request_send_internal</name><argument_list>(<argument><expr><name>req</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>AsyncRequest</name> <modifier>*</modifier></type>
<name>async_request_send_prepared_stmt_with_params</name><parameter_list>(<parameter><decl><type><name>PreparedStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>StmtParams</name> <modifier>*</modifier></type><name>params</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>res_format</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AsyncRequest</name> <modifier>*</modifier></type><name>req</name> <init>=
		<expr><call><name>async_request_create</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>sql</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>n_params</name></name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>res_format</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>async_request_send_internal</name><argument_list>(<argument><expr><name>req</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Set user data. Often it is useful to attach data with a request so
   that it can later be fetched from the response. */</comment>
<function><type><name>void</name></type>
<name>async_request_attach_user_data</name><parameter_list>(<parameter><decl><type><name>AsyncRequest</name> <modifier>*</modifier></type><name>req</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>user_data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>req</name><operator>-&gt;</operator><name>user_data</name></name> <operator>=</operator> <name>user_data</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>async_request_set_response_callback</name><parameter_list>(<parameter><decl><type><name>AsyncRequest</name> <modifier>*</modifier></type><name>req</name></decl></parameter>, <parameter><decl><type><name>async_response_callback</name></type> <name>cb</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>user_data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>req</name><operator>-&gt;</operator><name>response_cb</name></name> <operator>=</operator> <name>cb</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>req</name><operator>-&gt;</operator><name>user_data</name></name> <operator>=</operator> <name>user_data</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AsyncResponseResult</name> <modifier>*</modifier></type>
<name>async_response_result_create</name><parameter_list>(<parameter><decl><type><name>AsyncRequest</name> <modifier>*</modifier></type><name>req</name></decl></parameter>, <parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AsyncResponseResult</name> <modifier>*</modifier></type><name>ares</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AsyncResponseType</name></type> <name>type</name> <init>= <expr><name>RESPONSE_RESULT</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PGRES_SINGLE_TUPLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>type</name> <operator>=</operator> <name>RESPONSE_ROW</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>ares</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AsyncResponseResult</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>ares</name> <operator>=</operator> <operator>(</operator><name>AsyncResponseResult</name><operator>)</operator><block>{
		<expr><operator>.</operator><name>base</name> <operator>=</operator> <block>{ <expr><operator>.</operator><name>type</name> <operator>=</operator> <name>type</name></expr> }</block></expr>,
		<expr><operator>.</operator><name>request</name> <operator>=</operator> <name>req</name></expr>,
		<expr><operator>.</operator><name>result</name> <operator>=</operator> <name>res</name></expr>,
	}</block></expr>;</expr_stmt>

	<return>return <expr><name>ares</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AsyncResponseCommunicationError</name> <modifier>*</modifier></type>
<name>async_response_communication_error_create</name><parameter_list>(<parameter><decl><type><name>AsyncRequest</name> <modifier>*</modifier></type><name>req</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AsyncResponseCommunicationError</name> <modifier>*</modifier></type><name>ares</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AsyncResponseCommunicationError</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>ares</name> <operator>=</operator> <operator>(</operator><name>AsyncResponseCommunicationError</name><operator>)</operator><block>{
		<expr><operator>.</operator><name>base</name> <operator>=</operator> <block>{ <expr><operator>.</operator><name>type</name> <operator>=</operator> <name>RESPONSE_COMMUNICATION_ERROR</name></expr> }</block></expr>,
		<expr><operator>.</operator><name>request</name> <operator>=</operator> <name>req</name></expr>,
	}</block></expr>;</expr_stmt>

	<return>return <expr><name>ares</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AsyncResponse</name> <modifier>*</modifier></type>
<name>async_response_timeout_create</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AsyncResponse</name> <modifier>*</modifier></type><name>ares</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AsyncResponse</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>ares</name> <operator>=</operator> <operator>(</operator><name>AsyncResponse</name><operator>)</operator><block>{
		<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>RESPONSE_TIMEOUT</name></expr>,
	}</block></expr>;</expr_stmt>

	<return>return <expr><name>ares</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AsyncResponse</name> <modifier>*</modifier></type>
<name>async_response_error_create</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>errmsg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AsyncResponseError</name> <modifier>*</modifier></type><name>ares</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AsyncResponseError</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>ares</name> <operator>=</operator> <operator>(</operator><name>AsyncResponseError</name><operator>)</operator><block>{
		<expr><operator>.</operator><name>base</name> <operator>=</operator> <block>{ <expr><operator>.</operator><name>type</name> <operator>=</operator> <name>RESPONSE_ERROR</name></expr> }</block></expr>,
		<expr><operator>.</operator><name>errmsg</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>errmsg</name></expr></argument>)</argument_list></call></expr>,
	}</block></expr>;</expr_stmt>

	<return>return <expr><operator>&amp;</operator><name><name>ares</name><operator>-&gt;</operator><name>base</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>async_response_result_close</name><parameter_list>(<parameter><decl><type><name>AsyncResponseResult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name><name>res</name><operator>-&gt;</operator><name>result</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Closes the async response. Note that `async_response_report_error` does this automatically. */</comment>
<function><type><name>void</name></type>
<name>async_response_close</name><parameter_list>(<parameter><decl><type><name>AsyncResponse</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name><name>res</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>RESPONSE_RESULT</name></expr>:</case>
		<case>case <expr><name>RESPONSE_ROW</name></expr>:</case>
			<expr_stmt><expr><call><name>async_response_result_close</name><argument_list>(<argument><expr><operator>(</operator><name>AsyncResponseResult</name> <operator>*</operator><operator>)</operator> <name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>AsyncResponseType</name></type>
<name>async_response_get_type</name><parameter_list>(<parameter><decl><type><name>AsyncResponse</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>res</name><operator>-&gt;</operator><name>type</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* get the user data attached to the corresponding request */</comment>
<function><type><name>void</name> <modifier>*</modifier></type>
<name>async_response_result_get_user_data</name><parameter_list>(<parameter><decl><type><name>AsyncResponseResult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>res</name><operator>-&gt;</operator><name>request</name><operator>-&gt;</operator><name>user_data</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>PGresult</name> <modifier>*</modifier></type>
<name>async_response_result_get_pg_result</name><parameter_list>(<parameter><decl><type><name>AsyncResponseResult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>res</name><operator>-&gt;</operator><name>result</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>AsyncRequest</name> <modifier>*</modifier></type>
<name>async_response_result_get_request</name><parameter_list>(<parameter><decl><type><name>AsyncResponseResult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>res</name><operator>-&gt;</operator><name>request</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>async_request_set_single_row_mode</name><parameter_list>(<parameter><decl><type><name>AsyncRequest</name> <modifier>*</modifier></type><name>req</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>remote_connection_set_single_row_mode</name><argument_list>(<argument><expr><name><name>req</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>TSConnection</name> <modifier>*</modifier></type>
<name>async_request_get_connection</name><parameter_list>(<parameter><decl><type><name>AsyncRequest</name> <modifier>*</modifier></type><name>req</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>req</name><operator>-&gt;</operator><name>conn</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>async_response_report_error</name><parameter_list>(<parameter><decl><type><name>AsyncResponse</name> <modifier>*</modifier></type><name>res</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name><name>res</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>RESPONSE_RESULT</name></expr>:</case>
		<case>case <expr><name>RESPONSE_ROW</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AsyncResponseResult</name> <modifier>*</modifier></type><name>aresult</name> <init>= <expr><operator>(</operator><name>AsyncResponseResult</name> <operator>*</operator><operator>)</operator> <name>res</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ExecStatusType</name></type> <name>status</name> <init>= <expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name><name>aresult</name><operator>-&gt;</operator><name>result</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<switch>switch <condition>(<expr><name>status</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>PGRES_COMMAND_OK</name></expr>:</case>
				<case>case <expr><name>PGRES_TUPLES_OK</name></expr>:</case>
				<case>case <expr><name>PGRES_SINGLE_TUPLE</name></expr>:</case>
					<break>break;</break>
				<case>case <expr><name>PGRES_NONFATAL_ERROR</name></expr>:</case>
				<case>case <expr><name>PGRES_FATAL_ERROR</name></expr>:</case>
					<comment type="block">/* result is closed by remote_result_elog in case it throws
					 * error */</comment>
					<expr_stmt><expr><call><name>remote_result_elog</name><argument_list>(<argument><expr><name><name>aresult</name><operator>-&gt;</operator><name>result</name></name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<default>default:</default>
				<block>{<block_content>
					<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					<block>{<block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>, <argument><expr><literal type="string">"unexpected response status %u"</literal></expr></argument>, <argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block>
					<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					<block>{<block_content>
						<expr_stmt><expr><call><name>async_response_close</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block>
					<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
			</block_content>}</block></switch>
			<break>break;</break>
		</block_content>}</block>
		<case>case <expr><name>RESPONSE_COMMUNICATION_ERROR</name></expr>:</case>
			<expr_stmt><expr><call><name>remote_connection_elog</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>AsyncResponseCommunicationError</name> <operator>*</operator><operator>)</operator> <name>res</name><operator>)</operator><operator>-&gt;</operator><name><name>request</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>,
								   <argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RESPONSE_ERROR</name></expr>:</case>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>AsyncResponseError</name> <operator>*</operator><operator>)</operator> <name>res</name><operator>)</operator><operator>-&gt;</operator><name>errmsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RESPONSE_TIMEOUT</name></expr>:</case>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>, <argument><expr><literal type="string">"async operation timed out"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>async_response_report_error_or_close</name><parameter_list>(<parameter><decl><type><name>AsyncResponse</name> <modifier>*</modifier></type><name>res</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>async_response_report_error</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>async_response_close</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * This is a convenience function to wait for a single result from a request.
 * This function requires that the request is for a single SQL statement.
 */</comment>
<function><type><name>AsyncResponseResult</name> <modifier>*</modifier></type>
<name>async_request_wait_any_result</name><parameter_list>(<parameter><decl><type><name>AsyncRequest</name> <modifier>*</modifier></type><name>req</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AsyncRequestSet</name></type> <name>set</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AsyncResponseResult</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>async_request_set_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>set</name></expr></argument>, <argument><expr><name>req</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>async_request_set_wait_any_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Should expect exactly one response */</comment>
	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>result</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"expected response for the remote tuple request, but received none"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Make sure to drain the connection only if we've retrieved complete result set */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>RESPONSE_RESULT</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AsyncResponseResult</name> <modifier>*</modifier></type><name>extra</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>got_extra</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Must drain any remaining result until NULL */</comment>
		<while>while <condition>(<expr><operator>(</operator><name>extra</name> <operator>=</operator> <call><name>async_request_set_wait_any_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>set</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>async_response_result_close</name><argument_list>(<argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>got_extra</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></while>

		<if_stmt><if>if <condition>(<expr><name>got_extra</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>async_response_result_close</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"request must be for one sql statement"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>AsyncResponseResult</name> <modifier>*</modifier></type>
<name>async_request_wait_ok_result</name><parameter_list>(<parameter><decl><type><name>AsyncRequest</name> <modifier>*</modifier></type><name>req</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AsyncResponseResult</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><call><name>async_request_wait_any_result</name><argument_list>(<argument><expr><name>req</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name><name>res</name><operator>-&gt;</operator><name>result</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COMMAND_OK</name> <operator>&amp;&amp;</operator>
		<call><name>PQresultStatus</name><argument_list>(<argument><expr><name><name>res</name><operator>-&gt;</operator><name>result</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_TUPLES_OK</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>async_response_report_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>res</name><operator>-&gt;</operator><name>base</name></name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get the result of an async request during cleanup.
 *
 * Cleanup is typically necessary for a query that is being interrupted by
 * transaction abort, or a query that was initiated as part of transaction
 * abort to get the remote side back to the appropriate state.
 *
 * endtime is the time at which we should give up and assume the remote
 * side is dead.
 *
 * An AsyncReponse is always returned, indicating last PGresult received,
 * a timeout, or error.
 */</comment>
<function><type><name>AsyncResponse</name> <modifier>*</modifier></type>
<name>async_request_cleanup_result</name><parameter_list>(<parameter><decl><type><name>AsyncRequest</name> <modifier>*</modifier></type><name>req</name></decl></parameter>, <parameter><decl><type><name>TimestampTz</name></type> <name>endtime</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TSConnection</name> <modifier>*</modifier></type><name>conn</name> <init>= <expr><call><name>async_request_get_connection</name><argument_list>(<argument><expr><name>req</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>last_res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AsyncResponse</name> <modifier>*</modifier></type><name>rsp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>req</name><operator>-&gt;</operator><name>state</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>DEFERRED</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>remote_connection_is_processing</name><argument_list>(<argument><expr><name><name>req</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><call><name>async_response_error_create</name><argument_list>(
					<argument><expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"request already in progress on port %d"</literal></expr></argument>, <argument><expr><name>PostPortNumber</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>req</name> <operator>=</operator> <call><name>async_request_send_internal</name><argument_list>(<argument><expr><name>req</name></expr></argument>, <argument><expr><name>WARNING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>req</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><call><name>async_response_error_create</name><argument_list>(<argument><expr><literal type="string">"failed to send deferred request"</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>req</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>EXECUTING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EXECUTING</name></expr>:</case>
			<break>break;</break>
		<case>case <expr><name>COMPLETED</name></expr>:</case>
			<return>return <expr><call><name>async_response_error_create</name><argument_list>(<argument><expr><literal type="string">"request already completed"</literal></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></switch>

	<switch>switch <condition>(<expr><call><name>remote_connection_drain</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>endtime</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>last_res</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>CONN_TIMEOUT</name></expr>:</case>
			<expr_stmt><expr><name>rsp</name> <operator>=</operator> <call><name>async_response_timeout_create</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>CONN_DISCONNECT</name></expr>:</case>
			<expr_stmt><expr><name>rsp</name> <operator>=</operator> <operator>&amp;</operator><call><name>async_response_communication_error_create</name><argument_list>(<argument><expr><name>req</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>base</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>CONN_NO_RESPONSE</name></expr>:</case>
			<expr_stmt><expr><name>rsp</name> <operator>=</operator> <call><name>async_response_error_create</name><argument_list>(<argument><expr><literal type="string">"no response during cleanup"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>CONN_OK</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>last_res</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>rsp</name> <operator>=</operator> <operator>&amp;</operator><call><name>async_response_result_create</name><argument_list>(<argument><expr><name>req</name></expr></argument>, <argument><expr><name>last_res</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>base</name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rsp</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>rsp</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>async_request_wait_ok_command</name><parameter_list>(<parameter><decl><type><name>AsyncRequest</name> <modifier>*</modifier></type><name>req</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AsyncResponseResult</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><call><name>async_request_wait_any_result</name><argument_list>(<argument><expr><name>req</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name><name>res</name><operator>-&gt;</operator><name>result</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>async_response_report_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>res</name><operator>-&gt;</operator><name>base</name></name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>async_response_result_close</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>PreparedStmt</name> <modifier>*</modifier></type>
<name>async_request_wait_prepared_statement</name><parameter_list>(<parameter><decl><type><name>AsyncRequest</name> <modifier>*</modifier></type><name>request</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AsyncResponseResult</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PreparedStmt</name> <modifier>*</modifier></type><name>prep</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>request</name><operator>-&gt;</operator><name>stmt_name</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>async_request_wait_ok_result</name><argument_list>(<argument><expr><name>request</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>prep</name> <operator>=</operator> <call><name>async_response_result_generate_prepared_stmt</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>async_response_result_close</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>prep</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>AsyncRequestSet</name> <modifier>*</modifier></type>
<name>async_request_set_create</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AsyncRequestSet</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>async_request_set_add</name><parameter_list>(<parameter><decl><type><name>AsyncRequestSet</name> <modifier>*</modifier></type><name>set</name></decl></parameter>, <parameter><decl><type><name>AsyncRequest</name> <modifier>*</modifier></type><name>req</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>set</name><operator>-&gt;</operator><name>requests</name></name> <operator>=</operator> <call><name>list_append_unique_ptr</name><argument_list>(<argument><expr><name><name>set</name><operator>-&gt;</operator><name>requests</name></name></expr></argument>, <argument><expr><name>req</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AsyncResponse</name> <modifier>*</modifier></type>
<name>get_single_response_nonblocking</name><parameter_list>(<parameter><decl><type><name>AsyncRequestSet</name> <modifier>*</modifier></type><name>set</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>set-&gt;requests</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AsyncRequest</name> <modifier>*</modifier></type><name>req</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>pg_conn</name> <init>= <expr><call><name>remote_connection_get_pg_conn</name><argument_list>(<argument><expr><name><name>req</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><name><name>req</name><operator>-&gt;</operator><name>state</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>DEFERRED</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>remote_connection_is_processing</name><argument_list>(<argument><expr><name><name>req</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<return>return <expr><call><name>async_response_error_create</name><argument_list>(
						<argument><expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"request already in progress on port %d"</literal></expr></argument>, <argument><expr><name>PostPortNumber</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name>req</name> <operator>=</operator> <call><name>async_request_send_internal</name><argument_list>(<argument><expr><name>req</name></expr></argument>, <argument><expr><name>WARNING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>req</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><call><name>async_response_error_create</name><argument_list>(<argument><expr><literal type="string">"failed to send deferred request"</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>req</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>EXECUTING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>TS_FALLTHROUGH</name></expr>;</expr_stmt>
			<case>case <expr><name>EXECUTING</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <call><name>PQisBusy</name><argument_list>(<argument><expr><name>pg_conn</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><call><name>PQgetResult</name><argument_list>(<argument><expr><name>pg_conn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>res</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * NULL return means query is complete
						 */</comment>
						<expr_stmt><expr><name><name>set</name><operator>-&gt;</operator><name>requests</name></name> <operator>=</operator> <call><name>list_delete_ptr</name><argument_list>(<argument><expr><name><name>set</name><operator>-&gt;</operator><name>requests</name></name></expr></argument>, <argument><expr><name>req</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>remote_connection_set_status</name><argument_list>(<argument><expr><name><name>req</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><name>CONN_IDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>async_request_set_state</name><argument_list>(<argument><expr><name>req</name></expr></argument>, <argument><expr><name>COMPLETED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<comment type="block">/* set changed so rerun function */</comment>
						<return>return <expr><call><name>get_single_response_nonblocking</name><argument_list>(<argument><expr><name>set</name></expr></argument>)</argument_list></call></expr>;</return>
					</block_content>}</block></if></if_stmt>
					<return>return <expr><operator>&amp;</operator><call><name>async_response_result_create</name><argument_list>(<argument><expr><name>req</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>base</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><name>COMPLETED</name></expr>:</case>
				<return>return <expr><call><name>async_response_error_create</name><argument_list>(<argument><expr><literal type="string">"request already completed"</literal></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></switch>
	</block_content>}</block>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * wait_to_consume_data waits until data is recieved and put into buffers
 * so that it can be recieved without blocking by `get_single_response_nonblocking`
 * or similar.
 *
 * Returns NULL on success or an "error" AsyncResponse
 */</comment>
<function><type><specifier>static</specifier> <name>AsyncResponse</name> <modifier>*</modifier></type>
<name>wait_to_consume_data</name><parameter_list>(<parameter><decl><type><name>AsyncRequestSet</name> <modifier>*</modifier></type><name>set</name></decl></parameter>, <parameter><decl><type><name>TimestampTz</name></type> <name>end_time</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Looks like there is no good way to modify a WaitEventSet so we have to
	 * make a new one, otherwise we can't turn off wait events
	 */</comment>
	<decl_stmt><decl><type><name>WaitEventSet</name> <modifier>*</modifier></type><name>we_set</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WaitEvent</name></type> <name>event</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>wait_event_info</name> <init>= <expr><name>PG_WAIT_EXTENSION</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AsyncRequest</name> <modifier>*</modifier></type><name>wait_req</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AsyncResponse</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type> <name>timeout_ms</name> <init>= <expr><operator>-</operator><literal type="number">1L</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>set</name><operator>-&gt;</operator><name>requests</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>end_time</name> <operator>!=</operator> <name>TS_NO_TIMEOUT</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TimestampTz</name></type> <name>now</name> <init>= <expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>long</name></type> <name>secs</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>microsecs</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>now</name> <operator>&gt;=</operator> <name>end_time</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>async_response_timeout_create</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>TimestampDifference</name><argument_list>(<argument><expr><name>now</name></expr></argument>, <argument><expr><name>end_time</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>secs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>microsecs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>timeout_ms</name> <operator>=</operator> <name>secs</name> <operator>*</operator> <literal type="number">1000</literal> <operator>+</operator> <operator>(</operator><name>microsecs</name> <operator>/</operator> <literal type="number">1000</literal><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>we_set</name> <operator>=</operator> <call><name>CreateWaitEventSet</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>, <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>set</name><operator>-&gt;</operator><name>requests</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* always wait for my latch */</comment>
	<expr_stmt><expr><call><name>AddWaitEventToSet</name><argument_list>(<argument><expr><name>we_set</name></expr></argument>, <argument><expr><name>WL_LATCH_SET</name></expr></argument>, <argument><expr><name>PGINVALID_SOCKET</name></expr></argument>, <argument><expr><operator>(</operator><name>Latch</name> <operator>*</operator><operator>)</operator> <name>MyLatch</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>set-&gt;requests</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AsyncRequest</name> <modifier>*</modifier></type><name>req</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>AddWaitEventToSet</name><argument_list>(<argument><expr><name>we_set</name></expr></argument>,
						  <argument><expr><name>WL_SOCKET_READABLE</name></expr></argument>,
						  <argument><expr><call><name>PQsocket</name><argument_list>(<argument><expr><call><name>remote_connection_get_pg_conn</name><argument_list>(<argument><expr><name><name>req</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name>NULL</name></expr></argument>,
						  <argument><expr><name>req</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>wait_req</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>WaitEventSetWait</name><argument_list>(<argument><expr><name>we_set</name></expr></argument>, <argument><expr><name>timeout_ms</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>event</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>wait_event_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>async_response_timeout_create</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>event</name><operator>.</operator><name>events</name></name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name>WL_SOCKET_READABLE</name> <operator>|</operator> <name>WL_LATCH_SET</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Sanity check on the wait result: we haven't requested anything
			 * other than my latch or the socket becoming readable.
			 */</comment>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>async_response_error_create</name><argument_list>(
				<argument><expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"Unexpected event 0x%X while waiting for async request result"</literal></expr></argument>,
						 <argument><expr><name><name>event</name><operator>.</operator><name>events</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>event</name><operator>.</operator><name>events</name></name> <operator>&amp;</operator> <name>WL_LATCH_SET</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>event</name><operator>.</operator><name>events</name></name> <operator>&amp;</operator> <name>WL_SOCKET_READABLE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>wait_req</name> <operator>=</operator> <name><name>event</name><operator>.</operator><name>user_data</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>wait_req</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<decl_stmt><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>pg_conn</name> <init>= <expr><call><name>remote_connection_get_pg_conn</name><argument_list>(<argument><expr><name><name>wait_req</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <call><name>PQconsumeInput</name><argument_list>(<argument><expr><name>pg_conn</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* An error has occurred, remove connection from set. */</comment>
				<expr_stmt><expr><name><name>set</name><operator>-&gt;</operator><name>requests</name></name> <operator>=</operator> <call><name>list_delete_ptr</name><argument_list>(<argument><expr><name><name>set</name><operator>-&gt;</operator><name>requests</name></name></expr></argument>, <argument><expr><name>wait_req</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>&amp;</operator><call><name>async_response_communication_error_create</name><argument_list>(<argument><expr><name>wait_req</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>base</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * From postgres docs on PQConsumeInput():
			 * Note that the result does not say whether any input data was
			 * actually collected. After calling PQconsumeInput, the
			 * application can check PQisBusy and/or PQnotifies to see if their
			 * state has changed.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>PQisBusy</name><argument_list>(<argument><expr><name>pg_conn</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>FreeWaitEventSet</name><argument_list>(<argument><expr><name>we_set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return NULL when nothing more to do in set */</comment>
<function><type><name>AsyncResponse</name> <modifier>*</modifier></type>
<name>async_request_set_wait_any_response_deadline</name><parameter_list>(<parameter><decl><type><name>AsyncRequestSet</name> <modifier>*</modifier></type><name>set</name></decl></parameter>, <parameter><decl><type><name>TimestampTz</name></type> <name>endtime</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AsyncResponse</name> <modifier>*</modifier></type><name>response</name></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>response</name> <operator>=</operator> <call><name>get_single_response_nonblocking</name><argument_list>(<argument><expr><name>set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>response</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>set</name><operator>-&gt;</operator><name>requests</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<comment type="block">/* nothing to wait on anymore */</comment>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>response</name> <operator>=</operator> <call><name>wait_to_consume_data</name><argument_list>(<argument><expr><name>set</name></expr></argument>, <argument><expr><name>endtime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>response</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/* Make sure callbacks are run when a response is received. For a timeout,
	 * we run the callbacks on all the requests the user has been waiting
	 * on. */</comment>
	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>response</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>requests</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><name><name>response</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>RESPONSE_RESULT</name></expr>:</case>
			<case>case <expr><name>RESPONSE_ROW</name></expr>:</case>
				<expr_stmt><expr><name>requests</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>AsyncResponseResult</name> <operator>*</operator><operator>)</operator> <name>response</name><operator>)</operator><operator>-&gt;</operator><name>request</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>RESPONSE_COMMUNICATION_ERROR</name></expr>:</case>
				<expr_stmt><expr><name>requests</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>AsyncResponseCommunicationError</name> <operator>*</operator><operator>)</operator> <name>response</name><operator>)</operator><operator>-&gt;</operator><name>request</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>RESPONSE_ERROR</name></expr>:</case>
			<case>case <expr><name>RESPONSE_TIMEOUT</name></expr>:</case>
				<expr_stmt><expr><name>requests</name> <operator>=</operator> <name><name>set</name><operator>-&gt;</operator><name>requests</name></name></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>

		<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>requests</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AsyncRequest</name> <modifier>*</modifier></type><name>req</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>req</name><operator>-&gt;</operator><name>response_cb</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name><name>req</name><operator>-&gt;</operator><name>response_cb</name></name><argument_list>(<argument><expr><name>req</name></expr></argument>, <argument><expr><name>response</name></expr></argument>, <argument><expr><name><name>req</name><operator>-&gt;</operator><name>user_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>response</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>AsyncResponseResult</name> <modifier>*</modifier></type>
<name>async_request_set_wait_any_result</name><parameter_list>(<parameter><decl><type><name>AsyncRequestSet</name> <modifier>*</modifier></type><name>set</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AsyncResponse</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><call><name>async_request_set_wait_any_response</name><argument_list>(<argument><expr><name>set</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>RESPONSE_RESULT</name> <operator>==</operator> <name><name>res</name><operator>-&gt;</operator><name>type</name></name> <operator>||</operator> <name>RESPONSE_ROW</name> <operator>==</operator> <name><name>res</name><operator>-&gt;</operator><name>type</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>async_response_report_error</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><operator>(</operator><name>AsyncResponseResult</name> <operator>*</operator><operator>)</operator> <name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>AsyncResponseResult</name> <modifier>*</modifier></type>
<name>async_request_set_wait_ok_result</name><parameter_list>(<parameter><decl><type><name>AsyncRequestSet</name> <modifier>*</modifier></type><name>set</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AsyncResponseResult</name> <modifier>*</modifier></type><name>response_result</name> <init>= <expr><call><name>async_request_set_wait_any_result</name><argument_list>(<argument><expr><name>set</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExecStatusType</name></type> <name>status</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>response_result</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>PQresultStatus</name><argument_list>(<argument><expr><name><name>response_result</name><operator>-&gt;</operator><name>result</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <name>PGRES_TUPLES_OK</name> <operator>&amp;&amp;</operator> <name>status</name> <operator>!=</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>async_response_report_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>response_result</name><operator>-&gt;</operator><name>base</name></name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>response_result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>async_request_set_wait_all_ok_commands</name><parameter_list>(<parameter><decl><type><name>AsyncRequestSet</name> <modifier>*</modifier></type><name>set</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AsyncResponse</name> <modifier>*</modifier></type><name>rsp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AsyncResponse</name> <modifier>*</modifier></type><name>bad_rsp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Drain all responses and record the first error */</comment>
	<while>while <condition>(<expr><operator>(</operator><name>rsp</name> <operator>=</operator> <call><name>async_request_set_wait_any_response</name><argument_list>(<argument><expr><name>set</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<switch>switch <condition>(<expr><call><name>async_response_get_type</name><argument_list>(<argument><expr><name>rsp</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>RESPONSE_RESULT</name></expr>:</case>
			<case>case <expr><name>RESPONSE_ROW</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>AsyncResponseResult</name> <modifier>*</modifier></type><name>ar</name> <init>= <expr><operator>(</operator><name>AsyncResponseResult</name> <operator>*</operator><operator>)</operator> <name>rsp</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ExecStatusType</name></type> <name>status</name> <init>= <expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><call><name>async_response_result_get_pg_result</name><argument_list>(<argument><expr><name>ar</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <name>PGRES_COMMAND_OK</name> <operator>&amp;&amp;</operator> <name>bad_rsp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>bad_rsp</name> <operator>=</operator> <name>rsp</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>async_response_result_close</name><argument_list>(<argument><expr><name>ar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>
			</block_content>}</block>
			<default>default:</default>
				<if_stmt><if>if <condition>(<expr><name>bad_rsp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>bad_rsp</name> <operator>=</operator> <name>rsp</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></while>

	<comment type="block">/* Throw error once request set is drained */</comment>
	<if_stmt><if>if <condition>(<expr><name>bad_rsp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>async_response_report_error</name><argument_list>(<argument><expr><name>bad_rsp</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>async_request_discard_response</name><parameter_list>(<parameter><decl><type><name>AsyncRequest</name> <modifier>*</modifier></type><name>req</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>req</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>AsyncRequestSet</name></type> <name>set</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>async_request_set_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>set</name></expr></argument>, <argument><expr><name>req</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>AsyncResponseResult</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<do>do
	<block>{<block_content>
		<comment type="block">/* for COPY fetching we need to loop until we consume the whole response */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>async_request_set_wait_any_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>async_response_result_close</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block> while <condition>(<expr><name>result</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>req</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>COMPLETED</name></expr>)</condition>;</do>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>prepared_stmt_close</name><parameter_list>(<parameter><decl><type><name>PreparedStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type> <name><name>sql</name><index>[<expr><literal type="number">64</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="char">'\0'</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sql</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"DEALLOCATE %s"</literal></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>stmt_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <name>ret</name> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sql</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not create deallocate statement"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>async_request_wait_ok_command</name><argument_list>(<argument><expr><call><name>async_request_send</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Request must have been generated by async_request_send_prepare() */</comment>
<function><type><name>PreparedStmt</name> <modifier>*</modifier></type>
<name>async_response_result_generate_prepared_stmt</name><parameter_list>(<parameter><decl><type><name>AsyncResponseResult</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PreparedStmt</name> <modifier>*</modifier></type><name>prep</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>result</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>async_response_report_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>base</name></name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>prep</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PreparedStmt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>prep</name> <operator>=</operator> <operator>(</operator><name>PreparedStmt</name><operator>)</operator><block>{
		<expr><operator>.</operator><name>conn</name> <operator>=</operator> <name><name>result</name><operator>-&gt;</operator><name>request</name><operator>-&gt;</operator><name>conn</name></name></expr>,
		<expr><operator>.</operator><name>sql</name> <operator>=</operator> <name><name>result</name><operator>-&gt;</operator><name>request</name><operator>-&gt;</operator><name>sql</name></name></expr>,
		<expr><operator>.</operator><name>stmt_name</name> <operator>=</operator> <name><name>result</name><operator>-&gt;</operator><name>request</name><operator>-&gt;</operator><name>stmt_name</name></name></expr>,
		<expr><operator>.</operator><name>n_params</name> <operator>=</operator> <name><name>result</name><operator>-&gt;</operator><name>request</name><operator>-&gt;</operator><name>prep_stmt_params</name></name></expr>,
	}</block></expr>;</expr_stmt>

	<return>return <expr><name>prep</name></expr>;</return>
</block_content>}</block></function>
</unit>
