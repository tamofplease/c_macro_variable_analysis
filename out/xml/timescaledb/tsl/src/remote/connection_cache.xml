<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/timescaledb/tsl/src/remote/connection_cache.c"><comment type="block">/*
 * This file and its contents are licensed under the Timescale License.
 * Please see the included NOTICE for copyright information and
 * LICENSE-TIMESCALE for a copy of the license.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postgres.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/tupdesc.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/htup_details.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/xact.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postmaster/postmaster.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/builtins.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/syscache.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/guc.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/acl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fmgr.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;funcapi.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;miscadmin.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;libpq-fe.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;remote/connection.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cache.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;compat/compat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"connection_cache.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>static</specifier> <name>Cache</name> <modifier>*</modifier></type><name>connection_cache</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>ignore_connection_invalidation</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<typedef>typedef <type><struct>struct <name>ConnectionCacheEntry</name>
<block>{
	<decl_stmt><decl><type><name>TSConnectionId</name></type> <name>id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TSConnection</name> <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>foreign_server_hashvalue</name></decl>;</decl_stmt> <comment type="block">/* Hash of server OID for cache invalidation */</comment>
	<decl_stmt><decl><type><name>uint32</name></type> <name>role_hashvalue</name></decl>;</decl_stmt>			 <comment type="block">/* Hash of role OID for cache invalidation */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>invalidated</name></decl>;</decl_stmt>
}</block></struct></type> <name>ConnectionCacheEntry</name>;</typedef>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>connection_cache_entry_free</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>gen_entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ConnectionCacheEntry</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><name>gen_entry</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>conn</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Cannot directly read the Log_connections boolean since it is not
		 * exported on Windows */</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>log_conns</name> <init>= <expr><call><name>GetConfigOption</name><argument_list>(<argument><expr><literal type="string">"log_connections"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>log_conns</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>log_conns</name></expr></argument>, <argument><expr><literal type="string">"on"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Log the connection closing if requested. Only log the
			 * associated user ID since cannot lookup the user name here due
			 * to, potentially, not being in a proper transaction state where
			 * it is possible to use the syscache. */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				 <argument><expr><literal type="string">"closing cached connection to \"%s\" [UserId: %d]"</literal></expr></argument>,
				 <argument><expr><call><name>remote_connection_node_name</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr></argument>,
				 <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>id</name><operator>.</operator><name>user_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>remote_connection_close</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>conn</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>connection_cache_pre_destroy_hook</name><parameter_list>(<parameter><decl><type><name>Cache</name> <modifier>*</modifier></type><name>cache</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ConnectionCacheEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scan</name></expr></argument>, <argument><expr><name><name>cache</name><operator>-&gt;</operator><name>htab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>entry</name> <operator>=</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scan</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If we don't do this we will have a memory leak because connections
		 * are allocated using malloc
		 */</comment>
		<expr_stmt><expr><call><name>connection_cache_entry_free</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>connection_cache_valid_result</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><operator>(</operator><operator>(</operator><name>ConnectionCacheEntry</name> <operator>*</operator><operator>)</operator> <name>result</name><operator>)</operator><operator>-&gt;</operator><name>conn</name> <operator>!=</operator> <name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>connection_cache_get_key</name><parameter_list>(<parameter><decl><type><name>CacheQuery</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name>TSConnectionId</name> <operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>remote_connection_cache_invalidation_ignore</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>ignore_connection_invalidation</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Check if a connection needs to be remade.
 *
 * A connection can be in a bad state, in which case we need to
 * fail. Otherwise, the connection could be invalidated and needs to be remade
 * to apply new options. But a connection can only be remade if we are not
 * currently processing a transaction on the connection.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>connection_should_be_remade</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ConnectionCacheEntry</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>invalidated</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>entry</name><operator>-&gt;</operator><name>conn</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>remote_connection_xact_is_transitioning</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>NameData</name></type> <name>nodename</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nodename</name></expr></argument>, <argument><expr><call><name>remote_connection_node_name</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* The connection is marked as being in the middle of transaction
		 * state change, which means the transaction was aborted in the middle
		 * of a transition and now we don't know the state of the remote
		 * endpoint. It is not safe to continue on such a connection, so we
		 * remove (and close) the connection and raise an error. */</comment>
		<expr_stmt><expr><call><name>remote_connection_cache_remove</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_EXCEPTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"connection to data node \"%s\" was lost"</literal></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name>nodename</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Check if the connection has to be refreshed. If processing is set, then
	 * an async call was aborted. The connection could also have been
	 * invalidated, but we only care if we aren't still processing a
	 * transaction. */</comment>

	<expr_stmt><expr><name>invalidated</name> <operator>=</operator> <operator>!</operator><name>ignore_connection_invalidation</name> <operator>&amp;&amp;</operator> <name><name>entry</name><operator>-&gt;</operator><name>invalidated</name></name> <operator>&amp;&amp;</operator>
				  <call><name>remote_connection_xact_depth_get</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>remote_connection_get_status</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CONN_PROCESSING</name> <operator>||</operator> <name>invalidated</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>connection_cache_create_entry</name><parameter_list>(<parameter><decl><type><name>Cache</name> <modifier>*</modifier></type><name>cache</name></decl></parameter>, <parameter><decl><type><name>CacheQuery</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TSConnectionId</name> <modifier>*</modifier></type><name>id</name> <init>= <expr><operator>(</operator><name>TSConnectionId</name> <operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ConnectionCacheEntry</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><name><name>query</name><operator>-&gt;</operator><name>result</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Protects against errors in remote_connection_open, necessary since this
	 * entry is already in hashtable.
	 */</comment>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>conn</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Note: we do not use the cache memory context here to allocate a PGconn
	 * because PGconn allocation happens using malloc. Which is why calling
	 * remote_connection_close at cleanup is critical.
	 */</comment>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>conn</name></name> <operator>=</operator> <call><name>remote_connection_open_by_id</name><argument_list>(<argument><expr><operator>*</operator><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Since this connection is managed by the cache, it should not auto-close
	 * at the end of the transaction */</comment>
	<expr_stmt><expr><call><name>remote_connection_set_autoclose</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set the hash values of the foreign server and role for cache
	 * invalidation purposes */</comment>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>foreign_server_hashvalue</name></name> <operator>=</operator>
		<call><name>GetSysCacheHashValue1</name><argument_list>(<argument><expr><name>FOREIGNSERVEROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>id</name><operator>-&gt;</operator><name>server_id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>role_hashvalue</name></name> <operator>=</operator> <call><name>GetSysCacheHashValue1</name><argument_list>(<argument><expr><name>AUTHOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>id</name><operator>-&gt;</operator><name>user_id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>invalidated</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<return>return <expr><name>entry</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * This is called when the connection cache entry is found in the cache and
 * before it is returned. The connection can either be bad, in which case it
 * needs to be recreated, or the settings for the local session might have
 * changed since it was last used. In the latter case, we need to configure
 * the remote session again to ensure that it has the same configuration as
 * the local session.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>connection_cache_update_entry</name><parameter_list>(<parameter><decl><type><name>Cache</name> <modifier>*</modifier></type><name>cache</name></decl></parameter>, <parameter><decl><type><name>CacheQuery</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ConnectionCacheEntry</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><name><name>query</name><operator>-&gt;</operator><name>result</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TSConnectionStatus</name></type> <name>status</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>connection_should_be_remade</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>remote_connection_close</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>connection_cache_create_entry</name><argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>remote_connection_get_status</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>status</name> <operator>==</operator> <name>CONN_IDLE</name> <operator>||</operator> <name>status</name> <operator>==</operator> <name>CONN_COPY_IN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>CONN_IDLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>remote_connection_configure_if_changed</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>entry</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Cache</name> <modifier>*</modifier></type>
<name>connection_cache_create</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>ctx</name> <init>=
		<expr><call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CacheMemoryContext</name></expr></argument>, <argument><expr><literal type="string">"Connection cache"</literal></expr></argument>, <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cache</name> <modifier>*</modifier></type><name>cache</name> <init>= <expr><call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Cache</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>cache</name> <operator>=</operator> <operator>(</operator><name>Cache</name><operator>)</operator>
	<block>{
		<expr><operator>.</operator><name>hctl</name> <operator>=</operator> <block>{
			<expr><operator>.</operator><name>keysize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TSConnectionId</name></expr></argument>)</argument_list></sizeof></expr>,
			<expr><operator>.</operator><name>entrysize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ConnectionCacheEntry</name></expr></argument>)</argument_list></sizeof></expr>,
			<expr><operator>.</operator><name>hcxt</name> <operator>=</operator> <name>ctx</name></expr>,
		}</block></expr>,
		<expr><operator>.</operator><name>name</name> <operator>=</operator> <literal type="string">"connection_cache"</literal></expr>,
		<expr><operator>.</operator><name>numelements</name> <operator>=</operator> <literal type="number">16</literal></expr>,
		<expr><operator>.</operator><name>flags</name> <operator>=</operator> <name>HASH_ELEM</name> <operator>|</operator> <name>HASH_CONTEXT</name> <operator>|</operator> <name>HASH_BLOBS</name></expr>,
		<expr><operator>.</operator><name>valid_result</name> <operator>=</operator> <name>connection_cache_valid_result</name></expr>,
		<expr><operator>.</operator><name>get_key</name> <operator>=</operator> <name>connection_cache_get_key</name></expr>,
		<expr><operator>.</operator><name>create_entry</name> <operator>=</operator> <name>connection_cache_create_entry</name></expr>,
		<expr><operator>.</operator><name>remove_entry</name> <operator>=</operator> <name>connection_cache_entry_free</name></expr>,
		<expr><operator>.</operator><name>update_entry</name> <operator>=</operator> <name>connection_cache_update_entry</name></expr>,
		<expr><operator>.</operator><name>pre_destroy_hook</name> <operator>=</operator> <name>connection_cache_pre_destroy_hook</name></expr>,
	}</block></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ts_cache_init</name><argument_list>(<argument><expr><name>cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cache</name><operator>-&gt;</operator><name>handle_txn_callbacks</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<return>return <expr><name>cache</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>TSConnection</name> <modifier>*</modifier></type>
<name>remote_connection_cache_get_connection</name><parameter_list>(<parameter><decl><type><name>TSConnectionId</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CacheQuery</name></type> <name>query</name> <init>= <expr><block>{ <expr><operator>.</operator><name>data</name> <operator>=</operator> <operator>&amp;</operator><name>id</name></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ConnectionCacheEntry</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><call><name>ts_cache_fetch</name><argument_list>(<argument><expr><name>connection_cache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>query</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name><name>entry</name><operator>-&gt;</operator><name>conn</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>remote_connection_cache_remove</name><parameter_list>(<parameter><decl><type><name>TSConnectionId</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>ts_cache_remove</name><argument_list>(<argument><expr><name>connection_cache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>id</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Connection invalidation callback function
 *
 * After a change to a pg_foreign_server catalog entry,
 * mark the cache entry as invalid.
 */</comment>
<function><type><name>void</name></type>
<name>remote_connection_cache_invalidate_callback</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cacheid</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>hashvalue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ConnectionCacheEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cacheid</name> <operator>==</operator> <name>FOREIGNSERVEROID</name> <operator>||</operator> <name>cacheid</name> <operator>==</operator> <name>AUTHOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scan</name></expr></argument>, <argument><expr><name><name>connection_cache</name><operator>-&gt;</operator><name>htab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>entry</name> <operator>=</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scan</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* hashvalue == 0 means cache reset, so invalidate entire cache */</comment>
		<if_stmt><if>if <condition>(<expr><name>hashvalue</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>cacheid</name> <operator>==</operator> <name>AUTHOID</name> <operator>&amp;&amp;</operator> <name>hashvalue</name> <operator>==</operator> <name><name>entry</name><operator>-&gt;</operator><name>role_hashvalue</name></name><operator>)</operator> <operator>||</operator>
			<operator>(</operator><name>cacheid</name> <operator>==</operator> <name>FOREIGNSERVEROID</name> <operator>&amp;&amp;</operator> <name><name>entry</name><operator>-&gt;</operator><name>foreign_server_hashvalue</name></name> <operator>==</operator> <name>hashvalue</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>invalidated</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_loopback_host_or_addr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hostaddr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Use strncmp with length to succesfully compare against host address
	 * strings like "127.0.0.1/32" */</comment>
	<return>return <expr><call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"localhost"</literal></expr></argument>, <argument><expr><name>hostaddr</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strncmp</name><argument_list>(<argument><expr><literal type="string">"127.0.0.1"</literal></expr></argument>, <argument><expr><name>hostaddr</name></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		   <call><name>strncmp</name><argument_list>(<argument><expr><literal type="string">"::1"</literal></expr></argument>, <argument><expr><name>hostaddr</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check if a connection is local.
 *
 * This is an imperfect check, but should work for common cases.
 *
 * It currently doesn't capture being connected on a local network interface
 * address. That would require a platform-independent way to lookup local
 * interface addresses (on UNIX one could use getifaddrs, for instance).
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_local_connection</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>host</name> <init>= <expr><call><name>PQhost</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>port</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>host</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal></expr> <comment type="block">/* unix domain socket starts with a slash */</comment>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* A TCP connection must match both the port and localhost address */</comment>
	<expr_stmt><expr><name>port</name> <operator>=</operator> <call><name>pg_strtoint32</name><argument_list>(<argument><expr><call><name>PQport</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>port</name> <operator>==</operator> <name>PostPortNumber</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>is_loopback_host_or_addr</name><argument_list>(<argument><expr><name>host</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Remove connections that connect to a local DB, which is being dropped.
 *
 * This function is called when a database is dropped on the local instance
 * and is needed to prevent errors when the database serves as a
 * "same-instance" data node (common in tests). When a data node exists on the
 * local instance (i.e., in a separate local database), we need to close all
 * connections to the data node database in order to drop it. Otherwise, the
 * drop database will fail since the database is being used by the connections
 * in the cache.
 */</comment>
<function><type><name>void</name></type>
<name>remote_connection_cache_dropped_db_callback</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dbname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ConnectionCacheEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scan</name></expr></argument>, <argument><expr><name><name>connection_cache</name><operator>-&gt;</operator><name>htab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>entry</name> <operator>=</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scan</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>pgconn</name> <init>= <expr><call><name>remote_connection_get_pg_conn</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Remove the connection if it is local and connects to a DB with the
		 * same name as the one being dropped. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>dbname</name></expr></argument>, <argument><expr><call><name>PQdb</name><argument_list>(<argument><expr><name>pgconn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>is_local_connection</name><argument_list>(<argument><expr><name>pgconn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>remote_connection_cache_remove</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * Remove and close connections that belong to roles that are dropped.
 *
 * Immediately purging such connections should be safe since the DROP command
 * must be executed by different user than the one being dropped.
 */</comment>
<function><type><name>void</name></type>
<name>remote_connection_cache_dropped_role_callback</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>rolename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ConnectionCacheEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>roleid</name> <init>= <expr><call><name>get_role_oid</name><argument_list>(<argument><expr><name>rolename</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scan</name></expr></argument>, <argument><expr><name><name>connection_cache</name><operator>-&gt;</operator><name>htab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>entry</name> <operator>=</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scan</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>id</name><operator>.</operator><name>user_id</name></name> <operator>==</operator> <name>roleid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>remote_connection_cache_remove</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>
<comment type="block">/*
 * Functions and data structures for printing the connection cache.
 */</comment>
<enum>enum <name>Anum_show_conn</name>
<block>{
	<decl><name>Anum_show_conn_node_name</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,
	<decl><name>Anum_show_conn_user_name</name></decl>,
	<decl><name>Anum_show_conn_host</name></decl>,
	<decl><name>Anum_show_conn_port</name></decl>,
	<decl><name>Anum_show_conn_db</name></decl>,
	<decl><name>Anum_show_conn_backend_pid</name></decl>,
	<decl><name>Anum_show_conn_status</name></decl>,
	<decl><name>Anum_show_conn_txn_status</name></decl>,
	<decl><name>Anum_show_conn_txn_depth</name></decl>,
	<decl><name>Anum_show_conn_processing</name></decl>,
	<decl><name>Anum_show_conn_invalidated</name></decl>,
	<decl><name>_Anum_show_conn_max</name></decl>,
}</block>;</enum>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Natts_show_conn</name></cpp:macro> <cpp:value>(_Anum_show_conn_max - 1)</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>conn_status_str</name><index>[]</index></name> <init>= <expr><block>{
	<expr><index>[<expr><name>CONNECTION_OK</name></expr>]</index> <operator>=</operator> <literal type="string">"OK"</literal></expr>,
	<expr><index>[<expr><name>CONNECTION_BAD</name></expr>]</index> <operator>=</operator> <literal type="string">"BAD"</literal></expr>,
	<expr><index>[<expr><name>CONNECTION_STARTED</name></expr>]</index> <operator>=</operator> <literal type="string">"STARTED"</literal></expr>,
	<expr><index>[<expr><name>CONNECTION_MADE</name></expr>]</index> <operator>=</operator> <literal type="string">"MADE"</literal></expr>,
	<expr><index>[<expr><name>CONNECTION_AWAITING_RESPONSE</name></expr>]</index> <operator>=</operator> <literal type="string">"AWAITING RESPONSE"</literal></expr>,
	<expr><index>[<expr><name>CONNECTION_AUTH_OK</name></expr>]</index> <operator>=</operator> <literal type="string">"AUTH_OK"</literal></expr>,
	<expr><index>[<expr><name>CONNECTION_SETENV</name></expr>]</index> <operator>=</operator> <literal type="string">"SETENV"</literal></expr>,
	<expr><index>[<expr><name>CONNECTION_SSL_STARTUP</name></expr>]</index> <operator>=</operator> <literal type="string">"SSL STARTUP"</literal></expr>,
	<expr><index>[<expr><name>CONNECTION_NEEDED</name></expr>]</index> <operator>=</operator> <literal type="string">"CONNECTION NEEDED"</literal></expr>,
	<expr><index>[<expr><name>CONNECTION_CHECK_WRITABLE</name></expr>]</index> <operator>=</operator> <literal type="string">"CHECK WRITABLE"</literal></expr>,
	<expr><index>[<expr><name>CONNECTION_CONSUME</name></expr>]</index> <operator>=</operator> <literal type="string">"CONSUME"</literal></expr>,
	<expr><index>[<expr><name>CONNECTION_GSS_STARTUP</name></expr>]</index> <operator>=</operator> <literal type="string">"GSS STARTUP"</literal></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG13_GE</name></expr></cpp:if>
	<expr><index>[<expr><name>CONNECTION_CHECK_TARGET</name></expr>]</index> <operator>=</operator> <literal type="string">"CHECK TARGET"</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>conn_txn_status_str</name><index>[]</index></name> <init>= <expr><block>{
	<expr><index>[<expr><name>PQTRANS_IDLE</name></expr>]</index> <operator>=</operator> <literal type="string">"IDLE"</literal></expr>,	   <expr><index>[<expr><name>PQTRANS_ACTIVE</name></expr>]</index> <operator>=</operator> <literal type="string">"ACTIVE"</literal></expr>,	  <expr><index>[<expr><name>PQTRANS_INTRANS</name></expr>]</index> <operator>=</operator> <literal type="string">"INTRANS"</literal></expr>,
	<expr><index>[<expr><name>PQTRANS_INERROR</name></expr>]</index> <operator>=</operator> <literal type="string">"INERROR"</literal></expr>, <expr><index>[<expr><name>PQTRANS_UNKNOWN</name></expr>]</index> <operator>=</operator> <literal type="string">"UNKNOWN"</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>HeapTuple</name></type>
<name>create_tuple_from_conn_entry</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ConnectionCacheEntry</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type> <name><name>values</name><index>[<expr><name>Natts_show_conn</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name><name>nulls</name><index>[<expr><name>Natts_show_conn</name></expr>]</index></name> <init>= <expr><block>{ <expr><name>false</name></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>pgconn</name> <init>= <expr><call><name>remote_connection_get_pg_conn</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NameData</name></type> <name>conn_node_name</name></decl>, <decl><type ref="prev"/><name>conn_user_name</name></decl>, <decl><type ref="prev"/><name>conn_db</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>username</name> <init>= <expr><call><name>GetUserNameFromId</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>id</name><operator>.</operator><name>user_id</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>conn_node_name</name></expr></argument>, <argument><expr><call><name>remote_connection_node_name</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>username</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_snprintf</name><argument_list>(<argument><expr><name><name>conn_user_name</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>, <argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>id</name><operator>.</operator><name>user_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>conn_user_name</name></expr></argument>, <argument><expr><name>username</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>conn_db</name></expr></argument>, <argument><expr><call><name>PQdb</name><argument_list>(<argument><expr><name>pgconn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_show_conn_node_name</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <call><name>NameGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>conn_node_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_show_conn_user_name</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <call><name>NameGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>conn_user_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_show_conn_host</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><call><name>PQhost</name><argument_list>(<argument><expr><name>pgconn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_show_conn_port</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
		<call><name>Int32GetDatum</name><argument_list>(<argument><expr><call><name>pg_strtoint32</name><argument_list>(<argument><expr><call><name>PQport</name><argument_list>(<argument><expr><name>pgconn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_show_conn_db</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <call><name>NameGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>conn_db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_show_conn_backend_pid</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
		<call><name>Int32GetDatum</name><argument_list>(<argument><expr><call><name>PQbackendPID</name><argument_list>(<argument><expr><name>pgconn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_show_conn_status</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
		<call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>conn_status_str</name><index>[<expr><call><name>PQstatus</name><argument_list>(<argument><expr><name>pgconn</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_show_conn_txn_status</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
		<call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>conn_txn_status_str</name><index>[<expr><call><name>PQtransactionStatus</name><argument_list>(<argument><expr><name>pgconn</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_show_conn_txn_depth</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
		<call><name>Int32GetDatum</name><argument_list>(<argument><expr><call><name>remote_connection_xact_depth_get</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_show_conn_processing</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
		<call><name>BoolGetDatum</name><argument_list>(<argument><expr><call><name>remote_connection_is_processing</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_show_conn_invalidated</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>invalidated</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <name>ConnCacheShowState</name>
<block>{
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cache</name> <modifier>*</modifier></type><name>cache</name></decl>;</decl_stmt>
}</block></struct></type> <name>ConnCacheShowState</name>;</typedef>

<function><type><name>Datum</name></type>
<name>remote_connection_cache_show</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FuncCallContext</name> <modifier>*</modifier></type><name>funcctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ConnCacheShowState</name> <modifier>*</modifier></type><name>info</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ConnectionCacheEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>SRF_IS_FIRSTCALL</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_FIRSTCALL_INIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>multi_call_memory_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>get_call_result_type</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupdesc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TYPEFUNC_COMPOSITE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function returning record called in context "</literal>
							<literal type="string">"that cannot accept type record"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ConnCacheShowState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>cache</name></name> <operator>=</operator> <call><name>ts_cache_pin</name><argument_list>(<argument><expr><name>connection_cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>info</name><operator>-&gt;</operator><name>scan</name></name></expr></argument>, <argument><expr><name><name>info</name><operator>-&gt;</operator><name>cache</name><operator>-&gt;</operator><name>htab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name> <operator>=</operator> <name>info</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>tuple_desc</name></name> <operator>=</operator> <call><name>BlessTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_PERCALL_SETUP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>info</name> <operator>=</operator> <name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>info</name><operator>-&gt;</operator><name>scan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>entry</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>cache</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>create_tuple_from_conn_entry</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>tuple_desc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SRF_RETURN_NEXT</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>, <argument><expr><call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>connection_cache_xact_callback</name><parameter_list>(<parameter><decl><type><name>XactEvent</name></type> <name>event</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Reset ignore_connection_invalidation to default value */</comment>
	<expr_stmt><expr><call><name>remote_connection_cache_invalidation_ignore</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>_remote_connection_cache_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>connection_cache</name> <operator>=</operator> <call><name>connection_cache_create</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RegisterXactCallback</name><argument_list>(<argument><expr><name>connection_cache_xact_callback</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>_remote_connection_cache_fini</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ts_cache_invalidate</name><argument_list>(<argument><expr><name>connection_cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>connection_cache</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
