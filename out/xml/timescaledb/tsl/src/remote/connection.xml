<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/timescaledb/tsl/src/remote/connection.c"><comment type="block">/*
 * This file and its contents are licensed under the Timescale License.
 * Please see the included NOTICE for copyright information and
 * LICENSE-TIMESCALE for a copy of the license.
 */</comment>

<comment type="block">/*
 * This file contains source code that was copied and/or modified from the
 * PostgreSQL database, which is licensed under the open-source PostgreSQL
 * License. Please see the NOTICE at the top level directory for a copy of
 * the PostgreSQL License.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postgres.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/xact.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/reloptions.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_foreign_server.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_user_mapping.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;commands/defrem.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;foreign/foreign.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;libpq-events.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;libpq/libpq.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;mb/pg_wchar.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;miscadmin.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/makefuncs.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;port.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postmaster/postmaster.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/builtins.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/fmgrprotos.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/inval.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/guc.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/syscache.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;annotations.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dist_util.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errors.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;extension_constants.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;guc.h&gt;</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_TELEMETRY</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;telemetry/telemetry_metadata.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"connection.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"data_node.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"debug_point.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ts_catalog/metadata.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config.h"</cpp:file></cpp:include>

<comment type="block">/*
 * Connection library for TimescaleDB.
 *
 * This library file contains convenience functionality around the libpq
 * API. The major additional functionality offered includes:
 *
 * - libpq object lifecycles are tied to transactions (connections and
 *   results). This ensures that there are no memory leaks caused by libpq
 *   objects after a transaction completes.
 * - connection configuration suitable for TimescaleDB.
 *
 * NOTE that it is strongly adviced that connection-related functions do not
 * throw exceptions with, e.g., elog(ERROR). While exceptions can be caught
 * with PG_TRY-CATCH for cleanup, it is not possible to safely continue the
 * transaction that threw the exception as if no error occurred (see the
 * following post if unconvinced:
 * https://www.postgresql.org/message-id/27190.1508727890%40sss.pgh.pa.us).
 *
 * In some cases, we need to be able to continue a transaction even if a
 * connection fails. One example is the removal of a data node, which must be
 * able to proceed even if the node is no longer available to respond to a
 * connection. Another example is performing a liveness check for node status.
 *
 * Therefore, it is best that defer throwing exceptions to high-level
 * functions that know when it is appropriate.
 */</comment>

<comment type="block">/* for assigning cursor numbers and prepared statement numbers */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>cursor_number</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>prep_stmt_number</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>RemoteConnectionStats</name></type> <name>connstats</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>eventproc</name><parameter_list>(<parameter><decl><type><name>PGEventId</name></type> <name>eventid</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>eventinfo</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>TSConnectionId</name></type>
<name>remote_connection_id</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Oid</name></type> <name>server_oid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Oid</name></type> <name>user_oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TSConnectionId</name></type> <name>id</name> <init>= <expr><block>{ <expr><operator>.</operator><name>server_id</name> <operator>=</operator> <name>server_oid</name></expr>, <expr><operator>.</operator><name>user_id</name> <operator>=</operator> <name>user_oid</name></expr> }</block></expr></init></decl>;</decl_stmt>
	<return>return <expr><name>id</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>remote_connection_id_set</name><parameter_list>(<parameter><decl><type><name>TSConnectionId</name> <modifier>*</modifier><specifier>const</specifier></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <specifier>const</specifier></type> <name>server_oid</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <specifier>const</specifier></type> <name>user_oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>id</name><operator>-&gt;</operator><name>server_id</name></name> <operator>=</operator> <name>server_oid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>id</name><operator>-&gt;</operator><name>user_id</name></name> <operator>=</operator> <name>user_oid</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * A simple circular list implementation for tracking libpq connection and
 * result objects. We can't use pg_list here since it is bound to PostgreSQL's
 * memory management system, while libpq is not.
 */</comment>
<typedef>typedef <type><struct>struct <name>ListNode</name>
<block>{
	<decl_stmt><decl><type><name><name>struct</name> <name>ListNode</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>ListNode</name></name> <modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>
}</block></struct></type> <name>ListNode</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_DETACHED_ENTRY</name><parameter_list>(<parameter><type><name>entry</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((entry)-&gt;next == NULL &amp;&amp; (entry)-&gt;prev == NULL)</cpp:value></cpp:define>

<comment type="block">/*
 * Detach a list node.
 *
 * Detaches a list node from the list, unless it is the anchor/head (which is
 * a no-op).
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>list_detach</name><parameter_list>(<parameter><decl><type><name>ListNode</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListNode</name> <modifier>*</modifier></type><name>prev</name> <init>= <expr><name><name>entry</name><operator>-&gt;</operator><name>prev</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListNode</name> <modifier>*</modifier></type><name>next</name> <init>= <expr><name><name>entry</name><operator>-&gt;</operator><name>next</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>next</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>prev</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>prev</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
	<comment type="block">/* Clear entry fields */</comment>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Insert a list node entry after the prev node.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>list_insert_after</name><parameter_list>(<parameter><decl><type><name>ListNode</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>, <parameter><decl><type><name>ListNode</name> <modifier>*</modifier></type><name>prev</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListNode</name> <modifier>*</modifier></type><name>next</name> <init>= <expr><name><name>prev</name><operator>-&gt;</operator><name>next</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>next</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>entry</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>prev</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>prev</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>entry</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * List entry that holds a PGresult object.
 */</comment>
<typedef>typedef <type><struct>struct <name>ResultEntry</name>
<block>{
	<decl_stmt><decl><type><name><name>struct</name> <name>ListNode</name></name></type> <name>ln</name></decl>;</decl_stmt>		  <comment type="block">/* Must be first entry */</comment>
	<decl_stmt><decl><type><name>TSConnection</name> <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>		  <comment type="block">/* The connection the result was created on */</comment>
	<decl_stmt><decl><type><name>SubTransactionId</name></type> <name>subtxid</name></decl>;</decl_stmt> <comment type="block">/* The subtransaction ID that created this result, if any. */</comment>
	<decl_stmt><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
}</block></struct></type> <name>ResultEntry</name>;</typedef>

<typedef>typedef <type><struct>struct <name>TSConnection</name>
<block>{
	<decl_stmt><decl><type><name>ListNode</name></type> <name>ln</name></decl>;</decl_stmt>		<comment type="block">/* Must be first entry */</comment>
	<decl_stmt><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>pg_conn</name></decl>;</decl_stmt>	<comment type="block">/* PostgreSQL connection */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>closing_guard</name></decl>;</decl_stmt> <comment type="block">/* Guard against calling PQfinish() directly on PGconn */</comment>
	<decl_stmt><decl><type><name>TSConnectionStatus</name></type> <name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NameData</name></type> <name>node_name</name></decl>;</decl_stmt>		  <comment type="block">/* Associated data node name */</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tz_name</name></decl>;</decl_stmt>			  <comment type="block">/* Timezone name last sent over connection */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>autoclose</name></decl>;</decl_stmt>			  <comment type="block">/* Set if this connection should automatically
							   * close at the end of the (sub-)transaction */</comment>
	<decl_stmt><decl><type><name>SubTransactionId</name></type> <name>subtxid</name></decl>;</decl_stmt> <comment type="block">/* The subtransaction ID that created this connection, if any. */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>xact_depth</name></decl>;</decl_stmt>			  <comment type="block">/* 0 =&gt; no transaction, 1 =&gt; main transaction, &gt; 1 =&gt;
							   * levels of subtransactions */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>xact_transitioning</name></decl>;</decl_stmt>  <comment type="block">/* TRUE if connection is transitioning to
							   * another transaction state */</comment>
	<decl_stmt><decl><type><name>ListNode</name></type> <name>results</name></decl>;</decl_stmt>		  <comment type="block">/* Head of PGresult list */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>binary_copy</name></decl>;</decl_stmt>
}</block></struct></type> <name>TSConnection</name>;</typedef>

<comment type="block">/*
 * List of all connections we create. Used to auto-free connections and/or
 * PGresults at transaction end.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>ListNode</name></type> <name>connections</name> <init>= <expr><block>{ <expr><operator>&amp;</operator><name>connections</name></expr>, <expr><operator>&amp;</operator><name>connections</name></expr> }</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>fill_simple_error</name><parameter_list>(<parameter><decl><type><name>TSConnectionError</name> <modifier>*</modifier></type><name>err</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>errcode</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>errmsg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TSConnection</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>err</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>err</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>err</name><operator>-&gt;</operator><name>errcode</name></name> <operator>=</operator> <name>errcode</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>err</name><operator>-&gt;</operator><name>msg</name></name> <operator>=</operator> <name>errmsg</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>err</name><operator>-&gt;</operator><name>host</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>PQhost</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pg_conn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>err</name><operator>-&gt;</operator><name>nodename</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>remote_connection_node_name</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>fill_connection_error</name><parameter_list>(<parameter><decl><type><name>TSConnectionError</name> <modifier>*</modifier></type><name>err</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>errcode</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>errmsg</name></decl></parameter>,
					  <parameter><decl><type><specifier>const</specifier> <name>TSConnection</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>err</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>fill_simple_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>errcode</name></expr></argument>, <argument><expr><name>errmsg</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* The connection error from the remote side contains its own ERROR prefix
	 * and is ended by a newline. Make sure to strip that before emitting a
	 * local error. */</comment>
	<expr_stmt><expr><name><name>err</name><operator>-&gt;</operator><name>connmsg</name></name> <operator>=</operator> <call><name>pchomp</name><argument_list>(<argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pg_conn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><literal type="string">"ERROR:  "</literal></expr></argument>, <argument><expr><name><name>err</name><operator>-&gt;</operator><name>connmsg</name></name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>err</name><operator>-&gt;</operator><name>connmsg</name></name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_error_field_copy</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fieldcode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name> <init>= <expr><call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>fieldcode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>msg</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><call><name>pchomp</name><argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Convert libpq error severity to local error level.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>severity_to_elevel</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>severity</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* According to https://www.postgresql.org/docs/current/libpq-exec.html,
	 * libpq only returns the severity levels listed below. */</comment>
	<struct><specifier>static</specifier> <specifier>const</specifier> struct
	<block>{
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>severity</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>elevel</name></decl>;</decl_stmt>
	}</block> <decl><name><name>severity_levels</name><index>[]</index></name> <init>= <expr><block>{ <expr><block>{
								<expr><operator>.</operator><name>severity</name> <operator>=</operator> <literal type="string">"ERROR"</literal></expr>,
								<expr><operator>.</operator><name>elevel</name> <operator>=</operator> <name>ERROR</name></expr>,
							}</block></expr>,
							<expr><block>{
								<expr><operator>.</operator><name>severity</name> <operator>=</operator> <literal type="string">"FATAL"</literal></expr>,
								<expr><operator>.</operator><name>elevel</name> <operator>=</operator> <name>FATAL</name></expr>,
							}</block></expr>,
							<expr><block>{
								<expr><operator>.</operator><name>severity</name> <operator>=</operator> <literal type="string">"PANIC"</literal></expr>,
								<expr><operator>.</operator><name>elevel</name> <operator>=</operator> <name>PANIC</name></expr>,
							}</block></expr>,
							<expr><block>{
								<expr><operator>.</operator><name>severity</name> <operator>=</operator> <literal type="string">"WARNING"</literal></expr>,
								<expr><operator>.</operator><name>elevel</name> <operator>=</operator> <name>WARNING</name></expr>,
							}</block></expr>,
							<expr><block>{
								<expr><operator>.</operator><name>severity</name> <operator>=</operator> <literal type="string">"NOTICE"</literal></expr>,
								<expr><operator>.</operator><name>elevel</name> <operator>=</operator> <name>NOTICE</name></expr>,
							}</block></expr>,
							<expr><block>{
								<expr><operator>.</operator><name>severity</name> <operator>=</operator> <literal type="string">"DEBUG"</literal></expr>,
								<expr><operator>.</operator><name>elevel</name> <operator>=</operator> <name>DEBUG1</name></expr>,
							}</block></expr>,
							<expr><block>{
								<expr><operator>.</operator><name>severity</name> <operator>=</operator> <literal type="string">"INFO"</literal></expr>,
								<expr><operator>.</operator><name>elevel</name> <operator>=</operator> <name>INFO</name></expr>,
							}</block></expr>,
							<expr><block>{
								<expr><operator>.</operator><name>severity</name> <operator>=</operator> <literal type="string">"LOG"</literal></expr>,
								<expr><operator>.</operator><name>elevel</name> <operator>=</operator> <name>LOG</name></expr>,
							}</block></expr>,
							<comment type="block">/* End marker */</comment>
							<expr><block>{
								<expr><operator>.</operator><name>severity</name> <operator>=</operator> <name>NULL</name></expr>,
								<expr><operator>.</operator><name>elevel</name> <operator>=</operator> <literal type="number">0</literal></expr>,
							}</block></expr> }</block></expr></init></decl>;</struct>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>severity</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>severity_levels</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>severity</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>severity_levels</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>severity</name></expr></argument>, <argument><expr><name>severity</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name><name>severity_levels</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>elevel</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>pg_unreachable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ERROR</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Fill a connection error based on the result of a remote query.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>fill_result_error</name><parameter_list>(<parameter><decl><type><name>TSConnectionError</name> <modifier>*</modifier></type><name>err</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>errcode</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>errmsg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ResultEntry</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><call><name>PQresultInstanceData</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>eventproc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sqlstate</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>err</name> <operator>||</operator> <name>NULL</name> <operator>==</operator> <name>res</name> <operator>||</operator> <name>NULL</name> <operator>==</operator> <name>entry</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>err</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>err</name><operator>-&gt;</operator><name>errcode</name></name> <operator>=</operator> <name>errcode</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>err</name><operator>-&gt;</operator><name>msg</name></name> <operator>=</operator> <name>errmsg</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>err</name><operator>-&gt;</operator><name>nodename</name></name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>fill_simple_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>errcode</name></expr></argument>, <argument><expr><name>errmsg</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>err</name><operator>-&gt;</operator><name>remote</name><operator>.</operator><name>elevel</name></name> <operator>=</operator> <call><name>severity_to_elevel</name><argument_list>(<argument><expr><call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>PG_DIAG_SEVERITY_NONLOCALIZED</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>err</name><operator>-&gt;</operator><name>remote</name><operator>.</operator><name>sqlstate</name></name> <operator>=</operator> <call><name>get_error_field_copy</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>PG_DIAG_SQLSTATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>err</name><operator>-&gt;</operator><name>remote</name><operator>.</operator><name>msg</name></name> <operator>=</operator> <call><name>get_error_field_copy</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>PG_DIAG_MESSAGE_PRIMARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>err</name><operator>-&gt;</operator><name>remote</name><operator>.</operator><name>detail</name></name> <operator>=</operator> <call><name>get_error_field_copy</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>PG_DIAG_MESSAGE_DETAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>err</name><operator>-&gt;</operator><name>remote</name><operator>.</operator><name>hint</name></name> <operator>=</operator> <call><name>get_error_field_copy</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>PG_DIAG_MESSAGE_HINT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>err</name><operator>-&gt;</operator><name>remote</name><operator>.</operator><name>context</name></name> <operator>=</operator> <call><name>get_error_field_copy</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>PG_DIAG_CONTEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>err</name><operator>-&gt;</operator><name>remote</name><operator>.</operator><name>stmtpos</name></name> <operator>=</operator> <call><name>get_error_field_copy</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>PG_DIAG_STATEMENT_POSITION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>err</name><operator>-&gt;</operator><name>remote</name><operator>.</operator><name>msg</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>err</name><operator>-&gt;</operator><name>remote</name><operator>.</operator><name>msg</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>PQresultErrorMessage</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>sqlstate</name> <operator>=</operator> <name><name>err</name><operator>-&gt;</operator><name>remote</name><operator>.</operator><name>sqlstate</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>sqlstate</name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>sqlstate</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">5</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>err</name><operator>-&gt;</operator><name>remote</name><operator>.</operator><name>errcode</name></name> <operator>=</operator>
			<call><name>MAKE_SQLSTATE</name><argument_list>(<argument><expr><name><name>sqlstate</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>sqlstate</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>sqlstate</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>sqlstate</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>sqlstate</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>err</name><operator>-&gt;</operator><name>remote</name><operator>.</operator><name>errcode</name></name> <operator>=</operator> <name>ERRCODE_INTERNAL_ERROR</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * The following event handlers make sure all PGresult are freed with
 * PQClear() when its parent connection is closed.
 *
 * It is still recommended to explicitly call PGclear() or
 * remote_connection_result_close(), however, especially when PGresults are
 * created in a tight loop (e.g., when scanning many tuples on a remote
 * table).
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EVENTPROC_FAILURE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EVENTPROC_SUCCESS</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>remote_connection_free</name><parameter_list>(<parameter><decl><type><name>TSConnection</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>conn</name><operator>-&gt;</operator><name>tz_name</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>tz_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Invoked on PQfinish(conn). Frees all PGresult objects created on the
 * connection, apart from those already freed with PQclear().
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>handle_conn_destroy</name><parameter_list>(<parameter><decl><type><name>PGEventConnDestroy</name> <modifier>*</modifier></type><name>event</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TSConnection</name> <modifier>*</modifier></type><name>conn</name> <init>= <expr><call><name>PQinstanceData</name><argument_list>(<argument><expr><name><name>event</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><name>eventproc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>results_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListNode</name> <modifier>*</modifier></type><name>curr</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>closing_guard</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>curr</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>results</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>curr</name> <operator>!=</operator> <operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>results</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ResultEntry</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><operator>(</operator><name>ResultEntry</name> <operator>*</operator><operator>)</operator> <name>curr</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name><name>entry</name><operator>-&gt;</operator><name>result</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>curr</name> <operator>=</operator> <name><name>curr</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* No need to free curr here since PQclear will invoke
		 * handle_result_destroy() which will free it */</comment>
		<expr_stmt><expr><name>results_count</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>pg_conn</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>list_detach</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>ln</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>results_count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"cleared %u result objects on connection %p"</literal></expr></argument>, <argument><expr><name>results_count</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>connstats</name><operator>.</operator><name>connections_closed</name></name><operator>++</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>closing_guard</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_EXCEPTION</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid closing of connection"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>remote_connection_free</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>EVENTPROC_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Invoked on PQgetResult(conn). Adds the PGresult to the list in the parent
 * TSConnection.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>handle_result_create</name><parameter_list>(<parameter><decl><type><name>PGEventResultCreate</name> <modifier>*</modifier></type><name>event</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TSConnection</name> <modifier>*</modifier></type><name>conn</name> <init>= <expr><call><name>PQinstanceData</name><argument_list>(<argument><expr><name><name>event</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><name>eventproc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We malloc this (instead of palloc) since bound PGresult, which also
	 * lives outside PostgreSQL's memory management. */</comment>
	<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ResultEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>entry</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>EVENTPROC_FAILURE</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ResultEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>ln</name><operator>.</operator><name>next</name></name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>ln</name><operator>.</operator><name>prev</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>conn</name></name> <operator>=</operator> <name>conn</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>result</name></name> <operator>=</operator> <name><name>event</name><operator>-&gt;</operator><name>result</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>subtxid</name></name> <operator>=</operator> <call><name>GetCurrentSubTransactionId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Add entry as new head and set instance data */</comment>
	<expr_stmt><expr><call><name>list_insert_after</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>ln</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>results</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PQresultSetInstanceData</name><argument_list>(<argument><expr><name><name>event</name><operator>-&gt;</operator><name>result</name></name></expr></argument>, <argument><expr><name>eventproc</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>,
		 <argument><expr><literal type="string">"created result %p on connection %p subtxid %u"</literal></expr></argument>,
		 <argument><expr><name><name>event</name><operator>-&gt;</operator><name>result</name></name></expr></argument>,
		 <argument><expr><name>conn</name></expr></argument>,
		 <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>subtxid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>connstats</name><operator>.</operator><name>results_created</name></name><operator>++</operator></expr>;</expr_stmt>

	<return>return <expr><name>EVENTPROC_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Invoked on PQclear(result). Removes the PGresult from the list in the
 * parent TSConnection.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>handle_result_destroy</name><parameter_list>(<parameter><decl><type><name>PGEventResultDestroy</name> <modifier>*</modifier></type><name>event</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResultEntry</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><call><name>PQresultInstanceData</name><argument_list>(<argument><expr><name><name>event</name><operator>-&gt;</operator><name>result</name></name></expr></argument>, <argument><expr><name>eventproc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Detach entry */</comment>
	<expr_stmt><expr><call><name>list_detach</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>ln</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"destroyed result %p for subtxnid %u"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>result</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>subtxid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>connstats</name><operator>.</operator><name>results_cleared</name></name><operator>++</operator></expr>;</expr_stmt>

	<return>return <expr><name>EVENTPROC_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Main event handler invoked when events happen on a PGconn.
 *
 * According to the libpq API, the function should return a non-zero value if
 * it succeeds and zero if it fails. We use EVENTPROC_SUCCESS and
 * EVENTPROC_FAILURE in place of these two options.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>eventproc</name><parameter_list>(<parameter><decl><type><name>PGEventId</name></type> <name>eventid</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>eventinfo</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><name>EVENTPROC_SUCCESS</name></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>eventid</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PGEVT_CONNDESTROY</name></expr>:</case>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>handle_conn_destroy</name><argument_list>(<argument><expr><operator>(</operator><name>PGEventConnDestroy</name> <operator>*</operator><operator>)</operator> <name>eventinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>PGEVT_RESULTCREATE</name></expr>:</case>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>handle_result_create</name><argument_list>(<argument><expr><operator>(</operator><name>PGEventResultCreate</name> <operator>*</operator><operator>)</operator> <name>eventinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>PGEVT_RESULTDESTROY</name></expr>:</case>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>handle_result_destroy</name><argument_list>(<argument><expr><operator>(</operator><name>PGEventResultDestroy</name> <operator>*</operator><operator>)</operator> <name>eventinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<comment type="block">/* Not of interest, so return success */</comment>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>PQconninfoOption</name> <modifier>*</modifier></type>
<name>get_libpq_options</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<comment type="block">/* make static to fetch once per backend */</comment>
	<decl_stmt><decl><type><specifier>static</specifier> <name>PQconninfoOption</name> <modifier>*</modifier></type><name>libpq_options</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>libpq_options</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Note that the options array is Malloc'ed */</comment>
		<expr_stmt><expr><name>libpq_options</name> <operator>=</operator> <call><name>PQconndefaults</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>libpq_options</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* probably OOM */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not get default libpq options"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>libpq_options</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>unset_libpq_envvar</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQconninfoOption</name> <modifier>*</modifier></type><name>lopt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQconninfoOption</name> <modifier>*</modifier></type><name>options</name> <init>= <expr><call><name>PQconndefaults</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>options</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Explicitly unset all libpq environment variables.
	 *
	 * By default libpq uses environment variables as a fallback
	 * to specify connection options, potentially they could be in
	 * a conflict with PostgreSQL variables and introduce
	 * security risks.
	 */</comment>
	<for>for <control>(<init><expr><name>lopt</name> <operator>=</operator> <name>options</name></expr>;</init> <condition><expr><name><name>lopt</name><operator>-&gt;</operator><name>keyword</name></name></expr>;</condition> <incr><expr><name>lopt</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>lopt</name><operator>-&gt;</operator><name>envvar</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>unsetenv</name><argument_list>(<argument><expr><name><name>lopt</name><operator>-&gt;</operator><name>envvar</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQconninfoFree</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_libpq_option</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>keyword</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>display_option</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQconninfoOption</name> <modifier>*</modifier></type><name>lopt</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>lopt</name> <operator>=</operator> <call><name>get_libpq_options</name><argument_list>()</argument_list></call></expr>;</init> <condition><expr><name><name>lopt</name><operator>-&gt;</operator><name>keyword</name></name></expr>;</condition> <incr><expr><name>lopt</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>lopt</name><operator>-&gt;</operator><name>keyword</name></name></expr></argument>, <argument><expr><name>keyword</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>display_option</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>display_option</name> <operator>=</operator> <name><name>lopt</name><operator>-&gt;</operator><name>dispchar</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>ConnOptionType</name></type>
<name>remote_connection_option_type</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>keyword</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>display_option</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_libpq_option</name><argument_list>(<argument><expr><name>keyword</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>display_option</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>CONN_OPTION_TYPE_NONE</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Hide debug options, as well as settings we override internally. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>display_option</name></expr></argument>, <argument><expr><literal type="char">'D'</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>keyword</name></expr></argument>, <argument><expr><literal type="string">"fallback_application_name"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name>keyword</name></expr></argument>, <argument><expr><literal type="string">"client_encoding"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>CONN_OPTION_TYPE_NONE</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * "user" and any secret options are allowed only on user mappings.
	 * Everything else is a data node option.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>display_option</name></expr></argument>, <argument><expr><literal type="char">'*'</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>keyword</name></expr></argument>, <argument><expr><literal type="string">"user"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>CONN_OPTION_TYPE_USER</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>CONN_OPTION_TYPE_NODE</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>remote_connection_valid_user_option</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>keyword</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>remote_connection_option_type</name><argument_list>(<argument><expr><name>keyword</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CONN_OPTION_TYPE_USER</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>remote_connection_valid_node_option</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>keyword</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>remote_connection_option_type</name><argument_list>(<argument><expr><name>keyword</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CONN_OPTION_TYPE_NODE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>extract_connection_options</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>defelems</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>keywords</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>values</name></decl></parameter>,
						   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>user</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>option_pos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>keywords</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>values</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>user</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>user</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>defelems</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>d</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>is_libpq_option</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>keywords</name><index>[<expr><name>option_pos</name></expr>]</index></name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>defname</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>option_pos</name></expr>]</index></name> <operator>=</operator> <call><name>defGetString</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"user"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>user</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>user</name> <operator>=</operator> <name><name>values</name><index>[<expr><name>option_pos</name></expr>]</index></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>option_pos</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>option_pos</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Internal connection configure.
 *
 * This function will send internal configuration settings if they have
 * changed. It is used to pass on configuration settings before executing a
 * command requested by module users.
 *
 * ATTENTION! This function should *not* use
 * `remote_connection_exec_ok_command` since this function is called
 * indirectly whenever a remote command is executed, which would lead to
 * infinite recursion. Stick to `PQ*` functions.
 *
 * Returns true if the current configuration is OK (no change) or was
 * successfully applied, otherwise false.
 */</comment>
<function><type><name>bool</name></type>
<name>remote_connection_configure_if_changed</name><parameter_list>(<parameter><decl><type><name>TSConnection</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>local_tz_name</name> <init>= <expr><call><name>pg_get_timezone_name</name><argument_list>(<argument><expr><name>session_timezone</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>success</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We need to enforce the same timezone setting across nodes. Otherwise,
	 * we might get the wrong result when we push down things like
	 * date_trunc(text, timestamptz). To safely do that, we also need the
	 * timezone databases to be the same on all data nodes.
	 *
	 * We save away the timezone name so that we know what we last sent over
	 * the connection. If the time zone changed since last time we sent a
	 * command, we will send a SET TIMEZONE command with the new timezone
	 * first.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>tz_name</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
		<operator>(</operator><name>local_tz_name</name> <operator>&amp;&amp;</operator> <call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>tz_name</name></name></expr></argument>, <argument><expr><name>local_tz_name</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>set_timezone_cmd</name> <init>= <expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"SET TIMEZONE = '%s'"</literal></expr></argument>, <argument><expr><name>local_tz_name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>PQexec</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pg_conn</name></name></expr></argument>, <argument><expr><name>set_timezone_cmd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>PQresultStatus</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PGRES_COMMAND_OK</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>set_timezone_cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>tz_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>tz_name</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>local_tz_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>success</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Default options/commands to set on every new connection.
 *
 * Timezone is indirectly set with the first command executed.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>default_connection_options</name><index>[]</index></name> <init>= <expr><block>{
	<comment type="block">/*
	 * Force the search path to contain only pg_catalog, which will force
	 * functions to output fully qualified identifier names (i.e., they will
	 * include the schema).
	 */</comment>
	<expr><literal type="string">"SET search_path = pg_catalog"</literal></expr>,
	<comment type="block">/*
	 * Set values needed to ensure unambiguous data output from remote.  (This
	 * logic should match what pg_dump does.  See also set_transmission_modes
	 * in fdw.c.)
	 */</comment>
	<expr><literal type="string">"SET datestyle = ISO"</literal></expr>,
	<expr><literal type="string">"SET intervalstyle = postgres"</literal></expr>,
	<expr><literal type="string">"SET extra_float_digits = 3"</literal></expr>,
	<expr><name>NULL</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Issue SET commands to make sure remote session is configured properly.
 *
 * We do this just once at connection, assuming nothing will change the
 * values later.  Since we'll never send volatile function calls to the
 * remote, there shouldn't be any way to break this assumption from our end.
 * It's possible to think of ways to break it at the remote end, eg making a
 * foreign table point to a view that includes a set_config call --- but once
 * you admit the possibility of a malicious view definition, there are any
 * number of ways to break things.
 */</comment>
<function><type><name>bool</name></type>
<name>remote_connection_configure</name><parameter_list>(<parameter><decl><type><name>TSConnection</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>sql</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>success</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>cmd</name> <operator>=</operator> <name><name>default_connection_options</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"%s;"</literal></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PQexec</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pg_conn</name></name></expr></argument>, <argument><expr><name><name>sql</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>PQresultStatus</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PGRES_COMMAND_OK</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>success</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TSConnection</name> <modifier>*</modifier></type>
<name>remote_connection_create</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>pg_conn</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>processing</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>node_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TSConnection</name> <modifier>*</modifier></type><name>conn</name> <init>= <expr><call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TSConnection</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>conn</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TSConnection</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Must register the event procedure before attaching any instance data */</comment>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>PQregisterEventProc</name><argument_list>(<argument><expr><name>pg_conn</name></expr></argument>, <argument><expr><name>eventproc</name></expr></argument>, <argument><expr><literal type="string">"remote connection"</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>PQsetInstanceData</name><argument_list>(<argument><expr><name>pg_conn</name></expr></argument>, <argument><expr><name>eventproc</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ret</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>ln</name><operator>.</operator><name>next</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>ln</name><operator>.</operator><name>prev</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>pg_conn</name></name> <operator>=</operator> <name>pg_conn</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>closing_guard</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>remote_connection_set_status</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><ternary><condition><expr><name>processing</name></expr> ?</condition><then> <expr><name>CONN_PROCESSING</name></expr> </then><else>: <expr><name>CONN_IDLE</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>node_name</name></name></expr></argument>, <argument><expr><name>node_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>tz_name</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>autoclose</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>subtxid</name></name> <operator>=</operator> <call><name>GetCurrentSubTransactionId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>xact_depth</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>xact_transitioning</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<comment type="block">/* Initialize results head */</comment>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>results</name><operator>.</operator><name>next</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>results</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>results</name><operator>.</operator><name>prev</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>results</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>binary_copy</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>list_insert_after</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>ln</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>connections</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"created connection %p"</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>connstats</name><operator>.</operator><name>connections_created</name></name><operator>++</operator></expr>;</expr_stmt>

	<return>return <expr><name>conn</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Set the auto-close behavior.
 *
 * If set, the connection will be closed at the end of the (sub-)transaction
 * it was created on.
 *
 * The default value is on (true).
 *
 * Returns the previous setting.
 */</comment>
<function><type><name>bool</name></type>
<name>remote_connection_set_autoclose</name><parameter_list>(<parameter><decl><type><name>TSConnection</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>autoclose</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>old</name> <init>= <expr><name><name>conn</name><operator>-&gt;</operator><name>autoclose</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>autoclose</name></name> <operator>=</operator> <name>autoclose</name></expr>;</expr_stmt>
	<return>return <expr><name>old</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>remote_connection_xact_depth_get</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TSConnection</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>xact_depth</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>conn</name><operator>-&gt;</operator><name>xact_depth</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>remote_connection_xact_depth_inc</name><parameter_list>(<parameter><decl><type><name>TSConnection</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>xact_depth</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>++</operator><name><name>conn</name><operator>-&gt;</operator><name>xact_depth</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>remote_connection_xact_depth_dec</name><parameter_list>(<parameter><decl><type><name>TSConnection</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>xact_depth</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>--</operator><name><name>conn</name><operator>-&gt;</operator><name>xact_depth</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>remote_connection_xact_transition_begin</name><parameter_list>(<parameter><decl><type><name>TSConnection</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>xact_transitioning</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>xact_transitioning</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>remote_connection_xact_transition_end</name><parameter_list>(<parameter><decl><type><name>TSConnection</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>xact_transitioning</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>xact_transitioning</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>remote_connection_xact_is_transitioning</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TSConnection</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>conn</name><operator>-&gt;</operator><name>xact_transitioning</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>PGconn</name> <modifier>*</modifier></type>
<name>remote_connection_get_pg_conn</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TSConnection</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>conn</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>conn</name><operator>-&gt;</operator><name>pg_conn</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>remote_connection_is_processing</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TSConnection</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>conn</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <name>CONN_IDLE</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>remote_connection_set_status</name><parameter_list>(<parameter><decl><type><name>TSConnection</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>TSConnectionStatus</name></type> <name>status</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>conn</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>status</name></expr>;</expr_stmt>

	<comment type="block">/* Should be blocking except when doing COPY. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>PQisnonblocking</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pg_conn</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>(</operator><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>CONN_COPY_IN</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>TSConnectionStatus</name></type>
<name>remote_connection_get_status</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TSConnection</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>remote_connection_node_name</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TSConnection</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hide_node_name</name> <init>=
		<expr><call><name>GetConfigOption</name><argument_list>(<argument><expr><literal type="string">"timescaledb.hide_data_node_name_in_errors"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>hide_node_name</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>hide_node_name</name></expr></argument>, <argument><expr><literal type="string">"on"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><literal type="string">"&lt;hidden node name&gt;"</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<return>return <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>node_name</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>remote_connection_get_error</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TSConnection</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>TSConnectionError</name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>fill_connection_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>ERRCODE_CONNECTION_FAILURE</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>remote_connection_get_result_error</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>, <parameter><decl><type><name>TSConnectionError</name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>fill_result_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>ERRCODE_CONNECTION_EXCEPTION</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Execute a remote command.
 *
 * Like PQexec, which this functions uses internally, the PGresult returned
 * describes only the last command executed in a multi-command string.
 */</comment>
<function><type><name>PGresult</name> <modifier>*</modifier></type>
<name>remote_connection_exec</name><parameter_list>(<parameter><decl><type><name>TSConnection</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>remote_connection_configure_if_changed</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQmakeEmptyPGresult</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pg_conn</name></name></expr></argument>, <argument><expr><name>PGRES_FATAL_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PQfireResultCreateEvents</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pg_conn</name></name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>res</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQexec</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pg_conn</name></name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Workaround for the libpq disconnect case.
	 *
	 * libpq disconnect will create an result object without creating
	 * events, which is usually done for a regular errors.
	 *
	 * In order to be compatible with our error handling code, force
	 * create result event, if the result object does not have
	 * it already.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ExecStatusType</name></type> <name>status</name> <init>= <expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ResultEntry</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><call><name>PQresultInstanceData</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>eventproc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>PGRES_FATAL_ERROR</name> <operator>&amp;&amp;</operator> <name>entry</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQmakeEmptyPGresult</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pg_conn</name></name></expr></argument>, <argument><expr><name>PGRES_FATAL_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PQfireResultCreateEvents</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pg_conn</name></name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Must be a macro since va_start() must be called in the function that takes
 * a variable number of arguments.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>stringinfo_va</name><parameter_list>(<parameter><type><name>fmt</name></type></parameter>, <parameter><type><name>sql</name></type></parameter>)</parameter_list></cpp:macro>                                                                    \
	<cpp:value>do                                                                                             \
	{                                                                                              \
		initStringInfo((sql));                                                                     \
		for (;;)                                                                                   \
		{                                                                                          \
			va_list args;                                                                          \
			int needed;                                                                            \
			va_start(args, fmt);                                                                   \
			needed = appendStringInfoVA((sql), fmt, args);                                         \
			va_end(args);                                                                          \
			if (needed == 0)                                                                       \
				break;                                                                             \
			<comment type="block">/* Increase the buffer size and try again. */</comment>                                          \
			enlargeStringInfo((sql), needed);                                                      \
		}                                                                                          \
	} while (0);</cpp:value></cpp:define>

<comment type="block">/*
 * Execute a remote command.
 *
 * Like remote_connection_exec but takes a variable number of arguments.
 */</comment>
<function><type><name>PGresult</name> <modifier>*</modifier></type>
<name>remote_connection_execf</name><parameter_list>(<parameter><decl><type><name>TSConnection</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>sql</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>stringinfo_va</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>remote_connection_exec</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name><name>sql</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>sql</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>PGresult</name> <modifier>*</modifier></type>
<name>remote_connection_queryf_ok</name><parameter_list>(<parameter><decl><type><name>TSConnection</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>sql</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>stringinfo_va</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>remote_result_query_ok</name><argument_list>(<argument><expr><call><name>remote_connection_exec</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name><name>sql</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>sql</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>PGresult</name> <modifier>*</modifier></type>
<name>remote_connection_query_ok</name><parameter_list>(<parameter><decl><type><name>TSConnection</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>remote_result_query_ok</name><argument_list>(<argument><expr><call><name>remote_connection_exec</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>remote_connection_cmd_ok</name><parameter_list>(<parameter><decl><type><name>TSConnection</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>remote_result_cmd_ok</name><argument_list>(<argument><expr><call><name>remote_connection_exec</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>remote_connection_cmdf_ok</name><parameter_list>(<parameter><decl><type><name>TSConnection</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>sql</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>stringinfo_va</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>remote_result_cmd_ok</name><argument_list>(<argument><expr><call><name>remote_connection_exec</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name><name>sql</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>sql</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>PGresult</name> <modifier>*</modifier></type>
<name>remote_result_ok</name><parameter_list>(<parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>, <parameter><decl><type><name>ExecStatusType</name></type> <name>expected</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>expected</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>remote_result_elog</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>remote_result_cmd_ok</name><parameter_list>(<parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><call><name>remote_result_ok</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>PGRES_COMMAND_OK</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>PGresult</name> <modifier>*</modifier></type>
<name>remote_result_query_ok</name><parameter_list>(<parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>remote_result_ok</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Validate extension version.
 */</comment>
<function><type><name>void</name></type>
<name>remote_validate_extension_version</name><parameter_list>(<parameter><decl><type><name>TSConnection</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>data_node_version</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>dist_util_is_compatible_version</name><argument_list>(<argument><expr><name>data_node_version</name></expr></argument>, <argument><expr><name>TIMESCALEDB_VERSION</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TS_DATA_NODE_INVALID_CONFIG</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"remote PostgreSQL instance has an incompatible timescaledb extension "</literal>
						<literal type="string">"version"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"Access node version: %s, remote version: %s."</literal></expr></argument>,
									<argument><expr><name>TIMESCALEDB_VERSION_MOD</name></expr></argument>,
									<argument><expr><name>data_node_version</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Check timescaledb extension version on a data node.
 *
 * Compare remote connection extension version with the one installed
 * locally on the access node.
 *
 * Return false if extension is not found, true otherwise.
 */</comment>
<function><type><name>bool</name></type>
<name>remote_connection_check_extension</name><parameter_list>(<parameter><decl><type><name>TSConnection</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>remote_connection_execf</name><argument_list>(<argument><expr><name>conn</name></expr></argument>,
								  <argument><expr><literal type="string">"SELECT extversion FROM pg_extension WHERE extname = %s"</literal></expr></argument>,
								  <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>EXTENSION_NAME</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Just to capture any bugs in the SELECT above */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>PQnfields</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><literal type="number">0</literal></expr>:</case> <comment type="block">/* extension does not exists */</comment>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>

		<case>case <expr><literal type="number">1</literal></expr>:</case>
			<break>break;</break>

		<default>default:</default> <comment type="block">/* something strange happend */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TS_DATA_NODE_INVALID_CONFIG</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"more than one TimescaleDB extension loaded"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* validate extension version on data node and make sure that it is
	 * compatible */</comment>
	<expr_stmt><expr><call><name>remote_validate_extension_version</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Configure remote connection using current instance UUID.
 *
 * This allows remote side to reason about whether this connection has been
 * originated by access node.
 *
 * Returns true on success and false on error, in which case the optional
 * errmsg parameter can be used to retrieve an error message.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>remote_connection_set_peer_dist_id</name><parameter_list>(<parameter><decl><type><name>TSConnection</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>uuid</name> <init>= <expr><call><name>ts_metadata_get_value</name><argument_list>(<argument><expr><name>METADATA_UUID_KEY_NAME</name></expr></argument>, <argument><expr><name>UUIDOID</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>id_string</name> <init>= <expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>uuid_out</name></expr></argument>, <argument><expr><name>uuid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>success</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>remote_connection_execf</name><argument_list>(<argument><expr><name>conn</name></expr></argument>,
								  <argument><expr><literal type="string">"SELECT * FROM _timescaledb_internal.set_peer_dist_id('%s')"</literal></expr></argument>,
								  <argument><expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><name>id_string</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PGRES_TUPLES_OK</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>success</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* fallback_application_name, client_encoding, end marker */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REMOTE_CONNECTION_SESSION_OPTIONS_N</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>

<comment type="block">/* passfile */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REMOTE_CONNECTION_PASSWORD_OPTIONS_N</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<comment type="block">/* sslmode, sslrootcert, sslcert, sslkey */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REMOTE_CONNECTION_SSL_OPTIONS_N</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REMOTE_CONNECTION_OPTIONS_TOTAL_N</name></cpp:macro>                                                          \
	<cpp:value>(REMOTE_CONNECTION_SESSION_OPTIONS_N + REMOTE_CONNECTION_PASSWORD_OPTIONS_N +                  \
	 REMOTE_CONNECTION_SSL_OPTIONS_N)</cpp:value></cpp:define>

<comment type="block">/* default password file basename */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_PASSFILE_NAME</name></cpp:macro> <cpp:value>"passfile"</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_password_options</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>keywords</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>option_start</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>option_pos</name> <init>= <expr><operator>*</operator><name>option_start</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Set user specified password file path using timescaledb.passfile or
	 * use default path assuming that the file is stored in the
	 * data directory */</comment>
	<expr_stmt><expr><name><name>keywords</name><index>[<expr><name>option_pos</name></expr>]</index></name> <operator>=</operator> <literal type="string">"passfile"</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ts_guc_passfile</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>option_pos</name></expr>]</index></name> <operator>=</operator> <name>ts_guc_passfile</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>option_pos</name></expr>]</index></name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s/"</literal> <name>DEFAULT_PASSFILE_NAME</name></expr></argument>, <argument><expr><name>DataDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name>option_pos</name><operator>++</operator></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>option_start</name> <operator>=</operator> <name>option_pos</name></expr>;</expr_stmt>
</block_content>}</block></function>

<typedef>typedef <type><enum>enum <name>PathKind</name>
<block>{
	<decl><name>PATH_KIND_CRT</name></decl>,
	<decl><name>PATH_KIND_KEY</name></decl>
}</block></enum></type> <name>PathKind</name>;</typedef>

<comment type="block">/* Path description for human consumption */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>path_kind_text</name><index>[<expr><name>PATH_KIND_KEY</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{
	<expr><index>[<expr><name>PATH_KIND_CRT</name></expr>]</index> <operator>=</operator> <literal type="string">"certificate"</literal></expr>,
	<expr><index>[<expr><name>PATH_KIND_KEY</name></expr>]</index> <operator>=</operator> <literal type="string">"private key"</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Path extension string for file system */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>path_kind_ext</name><index>[<expr><name>PATH_KIND_KEY</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{
	<expr><index>[<expr><name>PATH_KIND_CRT</name></expr>]</index> <operator>=</operator> <literal type="string">"crt"</literal></expr>,
	<expr><index>[<expr><name>PATH_KIND_KEY</name></expr>]</index> <operator>=</operator> <literal type="string">"key"</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Helper function to report error.
 *
 * This is needed to avoid code coverage reporting low coverage for error
 * cases in `make_user_path` that cannot be reached in normal situations.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>report_path_error</name><parameter_list>(<parameter><decl><type><name>PathKind</name></type> <name>path_kind</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>user_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
		 <argument><expr><literal type="string">"cannot write %s for user \"%s\": path too long"</literal></expr></argument>,
		 <argument><expr><name><name>path_kind_text</name><index>[<expr><name>path_kind</name></expr>]</index></name></expr></argument>,
		 <argument><expr><name>user_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Make a user path with the given extension and user name in a portable and
 * safe manner.
 *
 * We use MD5 to compute a filename for the user name, which allows all forms
 * of user names. It is not necessary for the function to be cryptographically
 * secure, only to have a low risk of collisions, and MD5 is fast and with a
 * low risk of collisions.
 *
 * Will return the resulting path, or abort with an error.
 */</comment>
<function><type><specifier>static</specifier> <name>StringInfo</name></type>
<name>make_user_path</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>user_name</name></decl></parameter>, <parameter><decl><type><name>PathKind</name></type> <name>path_kind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type> <name><name>ret_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>hexsum</name><index>[<expr><literal type="number">33</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>errstr</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pg_md5_hash_compat</name><argument_list>(<argument><expr><name>user_name</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>user_name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>hexsum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>errstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>ret_path</name></expr></argument>, <argument><expr><ternary><condition><expr><name>ts_guc_ssl_dir</name></expr> ?</condition><then> <expr><name>ts_guc_ssl_dir</name></expr> </then><else>: <expr><name>DataDir</name></expr></else></ternary></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>MAXPGPATH</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>report_path_error</name><argument_list>(<argument><expr><name>path_kind</name></expr></argument>, <argument><expr><name>user_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>canonicalize_path</name><argument_list>(<argument><expr><name>ret_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ts_guc_ssl_dir</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>join_path_components</name><argument_list>(<argument><expr><name>ret_path</name></expr></argument>, <argument><expr><name>ret_path</name></expr></argument>, <argument><expr><name>EXTENSION_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>join_path_components</name><argument_list>(<argument><expr><name>ret_path</name></expr></argument>, <argument><expr><name>ret_path</name></expr></argument>, <argument><expr><literal type="string">"certs"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>join_path_components</name><argument_list>(<argument><expr><name>ret_path</name></expr></argument>, <argument><expr><name>ret_path</name></expr></argument>, <argument><expr><name>hexsum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"%s.%s"</literal></expr></argument>, <argument><expr><name>ret_path</name></expr></argument>, <argument><expr><name><name>path_kind_ext</name><index>[<expr><name>path_kind</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_ssl_options</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>user_name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>keywords</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>values</name></decl></parameter>,
				<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>option_start</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>option_pos</name> <init>= <expr><operator>*</operator><name>option_start</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ssl_enabled</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ssl_ca_file</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ssl_enabled</name> <operator>=</operator> <call><name>GetConfigOption</name><argument_list>(<argument><expr><literal type="string">"ssl"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ssl_enabled</name> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>ssl_enabled</name></expr></argument>, <argument><expr><literal type="string">"on"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
	<expr_stmt><expr><name>ssl_enabled</name> <operator>=</operator> <call><name>GetConfigOption</name><argument_list>(<argument><expr><literal type="string">"timescaledb.debug_enable_ssl"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ssl_enabled</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>ssl_enabled</name></expr></argument>, <argument><expr><literal type="string">"on"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>keywords</name><index>[<expr><name>option_pos</name></expr>]</index></name> <operator>=</operator> <literal type="string">"sslmode"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>option_pos</name></expr>]</index></name> <operator>=</operator> <literal type="string">"disable"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>option_pos</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>option_start</name> <operator>=</operator> <name>option_pos</name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* If SSL is enabled on AN then we assume it is also should be used for DN
	 * connections as well, otherwise we need to introduce some other way to
	 * control it */</comment>
	<expr_stmt><expr><name><name>keywords</name><index>[<expr><name>option_pos</name></expr>]</index></name> <operator>=</operator> <literal type="string">"sslmode"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>option_pos</name></expr>]</index></name> <operator>=</operator> <literal type="string">"require"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>option_pos</name><operator>++</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name>ssl_ca_file</name> <operator>=</operator> <call><name>GetConfigOption</name><argument_list>(<argument><expr><literal type="string">"ssl_ca_file"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Use ssl_ca_file as the root certificate when verifying the
	 * data node we connect to */</comment>
	<if_stmt><if>if <condition>(<expr><name>ssl_ca_file</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>keywords</name><index>[<expr><name>option_pos</name></expr>]</index></name> <operator>=</operator> <literal type="string">"sslrootcert"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>option_pos</name></expr>]</index></name> <operator>=</operator> <name>ssl_ca_file</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>option_pos</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Search for the user certificate in the user subdirectory of either
	 * timescaledb.ssl_dir or data directory. The user subdirectory is
	 * currently hardcoded. */</comment>

	<expr_stmt><expr><name><name>keywords</name><index>[<expr><name>option_pos</name></expr>]</index></name> <operator>=</operator> <literal type="string">"sslcert"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>option_pos</name></expr>]</index></name> <operator>=</operator> <call><name>make_user_path</name><argument_list>(<argument><expr><name>user_name</name></expr></argument>, <argument><expr><name>PATH_KIND_CRT</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>data</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>option_pos</name><operator>++</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>keywords</name><index>[<expr><name>option_pos</name></expr>]</index></name> <operator>=</operator> <literal type="string">"sslkey"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>option_pos</name></expr>]</index></name> <operator>=</operator> <call><name>make_user_path</name><argument_list>(<argument><expr><name>user_name</name></expr></argument>, <argument><expr><name>PATH_KIND_KEY</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>data</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>option_pos</name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block">/* if ts_set_ssl_options_hook is enabled then invoke that hook */</comment>
	<if_stmt><if>if <condition>(<expr><name>ts_set_ssl_options_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ts_set_ssl_options_hook</name><argument_list>(<argument><expr><name>user_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>option_start</name> <operator>=</operator> <name>option_pos</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Finish the connection and, optionally, save the connection error.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>finish_connection</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>errmsg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>errmsg</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>conn</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>errmsg</name> <operator>=</operator> <literal type="string">"invalid connection"</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>errmsg</name> <operator>=</operator> <call><name>pchomp</name><argument_list>(<argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Take options belonging to a foreign server and add additional default and
 * other user/ssl related options as appropriate
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>setup_full_connection_options</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>connection_options</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>all_keywords</name></decl></parameter>,
							  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>all_values</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>user_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>keywords</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>option_count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>option_pos</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Construct connection params from generic options of ForeignServer
	 * and user. (Some of them might not be libpq options, in
	 * which case we'll just waste a few array slots.)  Add 3 extra slots
	 * for fallback_application_name, client_encoding, end marker.
	 * One additional slot to set passfile and 4 slots for ssl options.
	 */</comment>
	<expr_stmt><expr><name>option_count</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>connection_options</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>REMOTE_CONNECTION_OPTIONS_TOTAL_N</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>keywords</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>option_count</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>values</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>option_count</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>option_pos</name> <operator>=</operator> <call><name>extract_connection_options</name><argument_list>(<argument><expr><name>connection_options</name></expr></argument>, <argument><expr><name>keywords</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>user_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>user_name</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>user_name</name> <operator>=</operator> <call><name>GetUserNameFromId</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Use the extension name as fallback_application_name. */</comment>
	<expr_stmt><expr><name><name>keywords</name><index>[<expr><name>option_pos</name></expr>]</index></name> <operator>=</operator> <literal type="string">"fallback_application_name"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>option_pos</name></expr>]</index></name> <operator>=</operator> <name>EXTENSION_NAME</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>option_pos</name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block">/* Set client_encoding so that libpq can convert encoding properly. */</comment>
	<expr_stmt><expr><name><name>keywords</name><index>[<expr><name>option_pos</name></expr>]</index></name> <operator>=</operator> <literal type="string">"client_encoding"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>option_pos</name></expr>]</index></name> <operator>=</operator> <call><name>GetDatabaseEncodingName</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>option_pos</name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block">/* Set passfile options */</comment>
	<expr_stmt><expr><call><name>set_password_options</name><argument_list>(<argument><expr><name>keywords</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>option_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set client specific SSL connection options */</comment>
	<expr_stmt><expr><call><name>set_ssl_options</name><argument_list>(<argument><expr><name>user_name</name></expr></argument>, <argument><expr><name>keywords</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>option_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set end marker */</comment>
	<expr_stmt><expr><name><name>keywords</name><index>[<expr><name>option_pos</name></expr>]</index></name> <operator>=</operator> <name><name>values</name><index>[<expr><name>option_pos</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>option_pos</name> <operator>&lt;=</operator> <name>option_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>all_keywords</name> <operator>=</operator> <name>keywords</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>all_values</name> <operator>=</operator> <name>values</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * This will only open a connection to a specific node, but not do anything
 * else. In particular, it will not perform any validation nor configure the
 * connection since it cannot know that it connects to a data node database or
 * not. For that, please use the `remote_connection_open_with_options`
 * function.
 */</comment>
<function><type><name>TSConnection</name> <modifier>*</modifier></type>
<name>remote_connection_open_with_options_nothrow</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>node_name</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>connection_options</name></decl></parameter>,
											<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>errmsg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGconn</name> <modifier>*</modifier><specifier>volatile</specifier></type> <name>pg_conn</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TSConnection</name> <modifier>*</modifier></type><name>ts_conn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>keywords</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>errmsg</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>errmsg</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>setup_full_connection_options</name><argument_list>(<argument><expr><name>connection_options</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>keywords</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>pg_conn</name> <operator>=</operator> <call><name>PQconnectdbParams</name><argument_list>(<argument><expr><name>keywords</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> <comment type="block">/* Do not expand dbname param */</comment>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Cast to (char **) to silence warning with MSVC compiler */</comment>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>keywords</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pg_conn</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PQstatus</name><argument_list>(<argument><expr><name>pg_conn</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CONNECTION_OK</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>finish_connection</name><argument_list>(<argument><expr><name>pg_conn</name></expr></argument>, <argument><expr><name>errmsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>ts_conn</name> <operator>=</operator> <call><name>remote_connection_create</name><argument_list>(<argument><expr><name>pg_conn</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>node_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>ts_conn</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>finish_connection</name><argument_list>(<argument><expr><name>pg_conn</name></expr></argument>, <argument><expr><name>errmsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>ts_conn</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Opens a connection.
 *
 * Raw connections are not part of the transaction and do not have transactions
 * auto-started. They must be explicitly closed by
 * remote_connection_close. Note that connections are allocated using malloc
 * and so if you do not call remote_connection_close, you'll have a memory
 * leak. Note that the connection cache handles all of this for you so use
 * that if you can.
 */</comment>
<function><type><name>TSConnection</name> <modifier>*</modifier></type>
<name>remote_connection_open_with_options</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>node_name</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>connection_options</name></decl></parameter>,
									<parameter><decl><type><name>bool</name></type> <name>set_dist_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>err</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TSConnection</name> <modifier>*</modifier></type><name>conn</name> <init>=
		<expr><call><name>remote_connection_open_with_options_nothrow</name><argument_list>(<argument><expr><name>node_name</name></expr></argument>, <argument><expr><name>connection_options</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>err</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>conn</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SQLCLIENT_UNABLE_TO_ESTABLISH_SQLCONNECTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not connect to \"%s\""</literal></expr></argument>, <argument><expr><name>node_name</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <ternary><condition><expr><name>err</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Use PG_TRY block to ensure closing connection on error.
	 */</comment>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name><name>conn</name><operator>-&gt;</operator><name>pg_conn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PQstatus</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pg_conn</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CONNECTION_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SQLCLIENT_UNABLE_TO_ESTABLISH_SQLCONNECTION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not connect to \"%s\""</literal></expr></argument>, <argument><expr><name>node_name</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>pchomp</name><argument_list>(<argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pg_conn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Prepare new session for use */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>remote_connection_configure</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SQLCLIENT_UNABLE_TO_ESTABLISH_SQLCONNECTION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not configure remote connection to \"%s\""</literal></expr></argument>, <argument><expr><name>node_name</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pg_conn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Check a data node extension version and show a warning
		 * message if it differs */</comment>
		<expr_stmt><expr><call><name>remote_connection_check_extension</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>set_dist_id</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Inform remote node about instance UUID */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>remote_connection_set_peer_dist_id</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SQLCLIENT_UNABLE_TO_ESTABLISH_SQLCONNECTION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not set distributed ID for \"%s\""</literal></expr></argument>, <argument><expr><name>node_name</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pg_conn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<comment type="block">/* Release PGconn data structure if we managed to create one */</comment>
		<expr_stmt><expr><call><name>remote_connection_close</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>conn</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Based on PG's GetUserMapping, but this version does not fail when a user
 * mapping is not found.
 */</comment>
<function><type><specifier>static</specifier> <name>UserMapping</name> <modifier>*</modifier></type>
<name>get_user_mapping</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>userid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>serverid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type> <name>datum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UserMapping</name> <modifier>*</modifier></type><name>um</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache2</name><argument_list>(<argument><expr><name>USERMAPPINGUSERSERVER</name></expr></argument>,
						 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>userid</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>serverid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Not found for the specific user -- try PUBLIC */</comment>
		<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache2</name><argument_list>(<argument><expr><name>USERMAPPINGUSERSERVER</name></expr></argument>,
							 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>serverid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>um</name> <operator>=</operator> <operator>(</operator><name>UserMapping</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>UserMapping</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>um</name><operator>-&gt;</operator><name>umid</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_user_mapping</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>oid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>um</name><operator>-&gt;</operator><name>userid</name></name> <operator>=</operator> <name>userid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>um</name><operator>-&gt;</operator><name>serverid</name></name> <operator>=</operator> <name>serverid</name></expr>;</expr_stmt>

	<comment type="block">/* Extract the umoptions */</comment>
	<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>USERMAPPINGUSERSERVER</name></expr></argument>, <argument><expr><name>tp</name></expr></argument>, <argument><expr><name>Anum_pg_user_mapping_umoptions</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>um</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>um</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <call><name>untransformRelOptions</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>um</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>options_contain</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>options</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>options</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>d</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Add athentication info (username and optionally password) to the connection
 * options).
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>remote_connection_prepare_auth_options</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ForeignServer</name> <modifier>*</modifier></type><name>server</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>user_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>UserMapping</name> <modifier>*</modifier></type><name>um</name> <init>= <expr><call><name>get_user_mapping</name><argument_list>(<argument><expr><name>user_id</name></expr></argument>, <argument><expr><name><name>server</name><operator>-&gt;</operator><name>serverid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>options</name> <init>= <expr><call><name>list_copy</name><argument_list>(<argument><expr><name><name>server</name><operator>-&gt;</operator><name>options</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* If a user mapping exists, then use the "user" and "password" options
	 * from the user mapping (we assume that these options exist, or the
	 * connection will later fail). Otherwise, just add the "user" and rely on
	 * other authentication mechanisms. */</comment>
	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>um</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><name><name>um</name><operator>-&gt;</operator><name>options</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>options_contain</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><literal type="string">"user"</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>user_name</name> <init>= <expr><call><name>GetUserNameFromId</name><argument_list>(<argument><expr><name>user_id</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"user"</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeString</name><argument_list>(<argument><expr><name>user_name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>options</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Append the given string to the buffer, with suitable quoting for passing
 * the string as a value in a keyword/value pair in a libpq connection string.
 *
 * The implementation is based on libpq appendConnStrVal().
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>remote_connection_append_connstr_value</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>needquotes</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the string is one or more plain ASCII characters, no need to quote
	 * it. This is quite conservative, but better safe than sorry.
	 */</comment>
	<expr_stmt><expr><name>needquotes</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name>str</name></expr>;</init> <condition><expr><operator>*</operator><name>s</name></expr>;</condition> <incr><expr><name>s</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>(</operator><operator>*</operator><name>s</name> <operator>&gt;=</operator> <literal type="char">'a'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>s</name> <operator>&lt;=</operator> <literal type="char">'z'</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><operator>*</operator><name>s</name> <operator>&gt;=</operator> <literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>s</name> <operator>&lt;=</operator> <literal type="char">'Z'</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><operator>*</operator><name>s</name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>s</name> <operator>&lt;=</operator> <literal type="char">'9'</literal><operator>)</operator> <operator>||</operator>
			  <operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'_'</literal> <operator>||</operator> <operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'.'</literal><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>needquotes</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>needquotes</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>needquotes</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\''</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><operator>*</operator><name>str</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* ' and \ must be escaped by to \' and \\ */</comment>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>str</name> <operator>==</operator> <literal type="char">'\''</literal> <operator>||</operator> <operator>*</operator><name>str</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\\'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>*</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></while>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\''</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>remote_connection_get_connstr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>node_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ForeignServer</name> <modifier>*</modifier></type><name>server</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>connection_options</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>keywords</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>connstr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>connstr_escape</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>server</name> <operator>=</operator> <call><name>data_node_get_foreign_server</name><argument_list>(<argument><expr><name>node_name</name></expr></argument>, <argument><expr><name>ACL_NO_CHECK</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>connection_options</name> <operator>=</operator> <call><name>remote_connection_prepare_auth_options</name><argument_list>(<argument><expr><name>server</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>setup_full_connection_options</name><argument_list>(<argument><expr><name>connection_options</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>keywords</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Cycle through the options and create the connection string */</comment>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>connstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><name><name>keywords</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>connstr</name></expr></argument>, <argument><expr><literal type="string">" %s="</literal></expr></argument>, <argument><expr><name><name>keywords</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>remote_connection_append_connstr_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>connstr</name></expr></argument>, <argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>keywords</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>connstr_escape</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>enlargeStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>connstr_escape</name></expr></argument>, <argument><expr><name><name>connstr</name><operator>.</operator><name>len</name></name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>connstr_escape</name><operator>.</operator><name>len</name></name> <operator>+=</operator> <call><name>PQescapeString</name><argument_list>(<argument><expr><name><name>connstr_escape</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>connstr</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>connstr</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Cast to (char **) to silence warning with MSVC compiler */</comment>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>keywords</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>connstr</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>connstr_escape</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>TSConnection</name> <modifier>*</modifier></type>
<name>remote_connection_open_by_id</name><parameter_list>(<parameter><decl><type><name>TSConnectionId</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ForeignServer</name> <modifier>*</modifier></type><name>server</name> <init>= <expr><call><name>GetForeignServer</name><argument_list>(<argument><expr><name><name>id</name><operator>.</operator><name>server_id</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>connection_options</name> <init>= <expr><call><name>remote_connection_prepare_auth_options</name><argument_list>(<argument><expr><name>server</name></expr></argument>, <argument><expr><name><name>id</name><operator>.</operator><name>user_id</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>remote_connection_open_with_options</name><argument_list>(<argument><expr><name><name>server</name><operator>-&gt;</operator><name>servername</name></name></expr></argument>, <argument><expr><name>connection_options</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>TSConnection</name> <modifier>*</modifier></type>
<name>remote_connection_open</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>server_id</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>user_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TSConnectionId</name></type> <name>id</name> <init>= <expr><call><name>remote_connection_id</name><argument_list>(<argument><expr><name>server_id</name></expr></argument>, <argument><expr><name>user_id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>remote_connection_open_by_id</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Open a connection without throwing and error.
 *
 * Returns the connection pointer on success. On failure NULL is returned and
 * the errmsg (if given) is used to return an error message.
 */</comment>
<function><type><name>TSConnection</name> <modifier>*</modifier></type>
<name>remote_connection_open_nothrow</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>server_id</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>user_id</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>errmsg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ForeignServer</name> <modifier>*</modifier></type><name>server</name> <init>= <expr><call><name>GetForeignServer</name><argument_list>(<argument><expr><name>server_id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>fdwid</name> <init>= <expr><call><name>get_foreign_data_wrapper_oid</name><argument_list>(<argument><expr><name>EXTENSION_FDW_NAME</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>connection_options</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TSConnection</name> <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>server</name><operator>-&gt;</operator><name>fdwid</name></name> <operator>!=</operator> <name>fdwid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"invalid node type for \"%s\""</literal></expr></argument>, <argument><expr><name><name>server</name><operator>-&gt;</operator><name>servername</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>connection_options</name> <operator>=</operator> <call><name>remote_connection_prepare_auth_options</name><argument_list>(<argument><expr><name>server</name></expr></argument>, <argument><expr><name>user_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>conn</name> <operator>=</operator>
		<call><name>remote_connection_open_with_options_nothrow</name><argument_list>(<argument><expr><name><name>server</name><operator>-&gt;</operator><name>servername</name></name></expr></argument>, <argument><expr><name>connection_options</name></expr></argument>, <argument><expr><name>errmsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>conn</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>errmsg</name> <operator>&amp;&amp;</operator> <name>NULL</name> <operator>==</operator> <operator>*</operator><name>errmsg</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>errmsg</name> <operator>=</operator> <literal type="string">"internal connection error"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PQstatus</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pg_conn</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CONNECTION_OK</name> <operator>||</operator> <operator>!</operator><call><name>remote_connection_set_peer_dist_id</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>errmsg</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>errmsg</name> <operator>=</operator> <call><name>pchomp</name><argument_list>(<argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pg_conn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>remote_connection_close</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>conn</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PING_QUERY</name></cpp:macro> <cpp:value>"SELECT 1"</cpp:value></cpp:define>

<function><type><name>bool</name></type>
<name>remote_connection_ping</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>node_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>server_id</name> <init>= <expr><call><name>get_foreign_server_oid</name><argument_list>(<argument><expr><name>node_name</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TSConnection</name> <modifier>*</modifier></type><name>conn</name> <init>= <expr><call><name>remote_connection_open_nothrow</name><argument_list>(<argument><expr><name>server_id</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>success</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>conn</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PQstatus</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pg_conn</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CONNECTION_OK</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><literal type="number">1</literal> <operator>==</operator> <call><name>PQsendQuery</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pg_conn</name></name></expr></argument>, <argument><expr><name>PING_QUERY</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><call><name>PQgetResult</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pg_conn</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>success</name> <operator>=</operator> <operator>(</operator><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PGRES_TUPLES_OK</name><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>remote_connection_close</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>success</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>remote_connection_close</name><parameter_list>(<parameter><decl><type><name>TSConnection</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>conn</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>closing_guard</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>conn</name><operator>-&gt;</operator><name>pg_conn</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pg_conn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Assert that PQfinish detached this connection from the global list of
	 * connections */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IS_DETACHED_ENTRY</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>ln</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>remote_connection_free</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Assign a "unique" number for a cursor.
 *
 * TODO should this be moved into the session?
 *
 * These really only need to be unique per connection within a transaction.
 * For the moment we ignore the per-connection point and assign them across
 * all connections in the transaction, but we ask for the connection to be
 * supplied in case we want to refine that.
 *
 * Note that even if wraparound happens in a very long transaction, actual
 * collisions are highly improbable; just be sure to use %u not %d to print.
 */</comment>
<function><type><name>unsigned</name> <name>int</name></type>
<name>remote_connection_get_cursor_number</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>++</operator><name>cursor_number</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>remote_connection_reset_cursor_number</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>cursor_number</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Assign a "unique" number for a prepared statement.
 *
 * This works much like remote_connection_get_cursor_number, except that we never reset the counter
 * within a session.  That's because we can't be 100% sure we've gotten rid
 * of all prepared statements on all connections, and it's not really worth
 * increasing the risk of prepared-statement name collisions by resetting.
 */</comment>
<function><type><name>unsigned</name> <name>int</name></type>
<name>remote_connection_get_prep_stmt_number</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>++</operator><name>prep_stmt_number</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_CONN_WAIT_TIMEOUT_MS</name></cpp:macro> <cpp:value>60000</cpp:value></cpp:define>

<comment type="block">/*
 * Drain a connection of all data coming in and discard the results. Return
 * CONN_OK if all data is drained before the deadline expires.
 *
 * This is mainly used in abort processing. This result being returned
 * might be for a query that is being interrupted by transaction abort, or it might
 * be a query that was initiated as part of transaction abort to get the remote
 * side back to the appropriate state.
 *
 * It's not a huge problem if we throw an ERROR here, but if we get into error
 * recursion trouble, we'll end up slamming the connection shut, which will
 * necessitate failing the entire toplevel transaction even if subtransactions
 * were used.  Try to use WARNING where we can.
 *
 * end_time is the time at which we should give up and assume the remote
 * side is dead.
 */</comment>
<function><type><name>TSConnectionResult</name></type>
<name>remote_connection_drain</name><parameter_list>(<parameter><decl><type><name>TSConnection</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>TimestampTz</name></type> <name>endtime</name></decl></parameter>, <parameter><decl><type><name>PGresult</name> <modifier>*</modifier><modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>TSConnectionResult</name></type> <name>connresult</name> <init>= <expr><name>CONN_OK</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name> <modifier>*</modifier><specifier>volatile</specifier></type> <name>last_res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>pg_conn</name> <init>= <expr><call><name>remote_connection_get_pg_conn</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* In what follows, do not leak any PGresults on an error. */</comment>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

			<while>while <condition>(<expr><call><name>PQisBusy</name><argument_list>(<argument><expr><name>pg_conn</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type> <name>wc</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>TimestampTz</name></type> <name>now</name> <init>= <expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>long</name></type> <name>remaining_secs</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type> <name>remaining_usecs</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>long</name></type> <name>cur_timeout_ms</name></decl>;</decl_stmt>

				<comment type="block">/* If timeout has expired, give up, else get sleep time. */</comment>
				<if_stmt><if>if <condition>(<expr><name>now</name> <operator>&gt;=</operator> <name>endtime</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>connresult</name> <operator>=</operator> <name>CONN_TIMEOUT</name></expr>;</expr_stmt>
					<goto>goto <name>exit</name>;</goto>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><call><name>TimestampDifference</name><argument_list>(<argument><expr><name>now</name></expr></argument>, <argument><expr><name>endtime</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>remaining_secs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>remaining_usecs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* To protect against clock skew, limit sleep to one minute. */</comment>
				<expr_stmt><expr><name>cur_timeout_ms</name> <operator>=</operator>
					<call><name>Min</name><argument_list>(<argument><expr><name>MAX_CONN_WAIT_TIMEOUT_MS</name></expr></argument>, <argument><expr><name>remaining_secs</name> <operator>*</operator> <name>USECS_PER_SEC</name> <operator>+</operator> <name>remaining_usecs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Sleep until there's something to do */</comment>
				<expr_stmt><expr><name>wc</name> <operator>=</operator> <call><name>WaitLatchOrSocket</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>,
									   <argument><expr><name>WL_LATCH_SET</name> <operator>|</operator> <name>WL_SOCKET_READABLE</name> <operator>|</operator> <name>WL_EXIT_ON_PM_DEATH</name> <operator>|</operator>
										   <name>WL_TIMEOUT</name></expr></argument>,
									   <argument><expr><call><name>PQsocket</name><argument_list>(<argument><expr><name>pg_conn</name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><name>cur_timeout_ms</name></expr></argument>,
									   <argument><expr><name>PG_WAIT_EXTENSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Data available in socket? */</comment>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><name>wc</name> <operator>&amp;</operator> <name>WL_SOCKET_READABLE</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><literal type="number">0</literal> <operator>==</operator> <call><name>PQconsumeInput</name><argument_list>(<argument><expr><name>pg_conn</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>connresult</name> <operator>=</operator> <name>CONN_DISCONNECT</name></expr>;</expr_stmt>
					<goto>goto <name>exit</name>;</goto>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></while>

			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQgetResult</name><argument_list>(<argument><expr><name>pg_conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* query is complete */</comment>
				<expr_stmt><expr><call><name>remote_connection_set_status</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>CONN_IDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>connresult</name> <operator>=</operator> <name>CONN_OK</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PGRES_COPY_OUT</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * We are inside the COPY subprotocol, need to sychronize with
				 * the server.
				 */</comment>
				<decl_stmt><decl><type><name>int</name></type> <name>end_res</name> <init>= <expr><call><name>PQendcopy</name><argument_list>(<argument><expr><name>pg_conn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><name>end_res</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>TSConnectionError</name></type> <name>err</name></decl>;</decl_stmt>
					<expr_stmt><expr><call><name>remote_connection_get_error</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>remote_connection_error_elog</name><argument_list>(<argument><expr><operator>&amp;</operator><name>err</name></expr></argument>, <argument><expr><name>WARNING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>last_res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>last_res</name> <operator>=</operator> <name>res</name></expr>;</expr_stmt>
		</block_content>}</block></for>
	<label><name>exit</name>:</label><empty_stmt>;</empty_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>last_res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name>connresult</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>CONN_OK</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>last_res</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>connresult</name> <operator>=</operator> <name>CONN_NO_RESPONSE</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name>result</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>last_res</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>last_res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>
		<case>case <expr><name>CONN_TIMEOUT</name></expr>:</case>
		<case>case <expr><name>CONN_DISCONNECT</name></expr>:</case>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>last_res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>CONN_NO_RESPONSE</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>last_res</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>connresult</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Cancel the currently-in-progress query and ignore the result.  Returns true if we successfully
 * cancel the query and discard any pending result, and false if not.
 */</comment>
<function><type><name>bool</name></type>
<name>remote_connection_cancel_query</name><parameter_list>(<parameter><decl><type><name>TSConnection</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGcancel</name> <modifier>*</modifier></type><name>cancel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>errbuf</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>endtime</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TSConnectionError</name></type> <name>err</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>success</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>conn</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>err</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TSConnectionError</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Catch exceptions so that we can ensure the status is IDLE after the
	 * cancel operation even in case of errors being thrown. Note that we
	 * cannot set the status before we drain, since the drain function needs
	 * to know the status (e.g., if the connection is in COPY_IN mode).
	 */</comment>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>CONN_COPY_IN</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>remote_connection_end_copy</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>err</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>remote_connection_error_elog</name><argument_list>(<argument><expr><operator>&amp;</operator><name>err</name></expr></argument>, <argument><expr><name>WARNING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If it takes too long to cancel the query and discard the result, assume
		 * the connection is dead.
		 */</comment>
		<expr_stmt><expr><name>endtime</name> <operator>=</operator> <call><name>TimestampTzPlusMilliseconds</name><argument_list>(<argument><expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">30000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Issue cancel request.  Unfortunately, there's no good way to limit the
		 * amount of time that we might block inside PQcancel().
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>cancel</name> <operator>=</operator> <call><name>PQgetCancel</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pg_conn</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQcancel</name><argument_list>(<argument><expr><name>cancel</name></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not send cancel request: %s"</literal></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PQfreeCancel</name><argument_list>(<argument><expr><name>cancel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>remote_connection_set_status</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>CONN_IDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>PQfreeCancel</name><argument_list>(<argument><expr><name>cancel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<switch>switch <condition>(<expr><call><name>remote_connection_drain</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>endtime</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>CONN_OK</name></expr>:</case>
				<comment type="block">/* Successfully, drained */</comment>
			<case>case <expr><name>CONN_NO_RESPONSE</name></expr>:</case>
				<comment type="block">/* No response, likely beceause there was nothing to cancel */</comment>
				<expr_stmt><expr><name>success</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><name>success</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>remote_connection_set_status</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>CONN_IDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>remote_connection_set_status</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>CONN_IDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>success</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>remote_result_close</name><parameter_list>(<parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Cleanup connections and results at the end of a (sub-)transaction.
 *
 * This function is called at the end of transactions and sub-transactions to
 * auto-cleanup connections and result objects.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>remote_connections_cleanup</name><parameter_list>(<parameter><decl><type><name>SubTransactionId</name></type> <name>subtxid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isabort</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListNode</name> <modifier>*</modifier></type><name>curr</name> <init>= <expr><name><name>connections</name><operator>.</operator><name>next</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>num_connections</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>num_results</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>curr</name> <operator>!=</operator> <operator>&amp;</operator><name>connections</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TSConnection</name> <modifier>*</modifier></type><name>conn</name> <init>= <expr><operator>(</operator><name>TSConnection</name> <operator>*</operator><operator>)</operator> <name>curr</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Move to next connection since closing the current one might
		 * otherwise make the curr pointer invalid. */</comment>
		<expr_stmt><expr><name>curr</name> <operator>=</operator> <name><name>curr</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>autoclose</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>subtxid</name> <operator>==</operator> <name>InvalidSubTransactionId</name> <operator>||</operator> <name>subtxid</name> <operator>==</operator> <name><name>conn</name><operator>-&gt;</operator><name>subtxid</name></name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Closes the connection and frees all its PGresult objects */</comment>
			<expr_stmt><expr><call><name>remote_connection_close</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>num_connections</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* We're not closing the connection, but we should clean up any
			 * lingering results */</comment>
			<decl_stmt><decl><type><name>ListNode</name> <modifier>*</modifier></type><name>curr_result</name> <init>= <expr><name><name>conn</name><operator>-&gt;</operator><name>results</name><operator>.</operator><name>next</name></name></expr></init></decl>;</decl_stmt>

			<while>while <condition>(<expr><name>curr_result</name> <operator>!=</operator> <operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>results</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ResultEntry</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><operator>(</operator><name>ResultEntry</name> <operator>*</operator><operator>)</operator> <name>curr_result</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>curr_result</name> <operator>=</operator> <name><name>curr_result</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>subtxid</name> <operator>==</operator> <name>InvalidSubTransactionId</name> <operator>||</operator> <name>subtxid</name> <operator>==</operator> <name><name>entry</name><operator>-&gt;</operator><name>subtxid</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>result</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>num_results</name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></while>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name>subtxid</name> <operator>==</operator> <name>InvalidSubTransactionId</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>,
			 <argument><expr><literal type="string">"cleaned up %u connections and %u results at %s of transaction"</literal></expr></argument>,
			 <argument><expr><name>num_connections</name></expr></argument>,
			 <argument><expr><name>num_results</name></expr></argument>,
			 <argument><expr><ternary><condition><expr><name>isabort</name></expr> ?</condition><then> <expr><literal type="string">"abort"</literal></expr> </then><else>: <expr><literal type="string">"commit"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>,
			 <argument><expr><literal type="string">"cleaned up %u connections and %u results at %s of sub-transaction %u"</literal></expr></argument>,
			 <argument><expr><name>num_connections</name></expr></argument>,
			 <argument><expr><name>num_results</name></expr></argument>,
			 <argument><expr><ternary><condition><expr><name>isabort</name></expr> ?</condition><then> <expr><literal type="string">"abort"</literal></expr> </then><else>: <expr><literal type="string">"commit"</literal></expr></else></ternary></expr></argument>,
			 <argument><expr><name>subtxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>remote_connection_xact_end</name><parameter_list>(<parameter><decl><type><name>XactEvent</name></type> <name>event</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>unused_arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We are deep down in CommitTransaction code path. We do not want our
	 * emit_log_hook_callback to interfere since it uses its own transaction
	 */</comment>
	<decl_stmt><decl><type><name>emit_log_hook_type</name></type> <name>prev_emit_log_hook</name> <init>= <expr><name>emit_log_hook</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>emit_log_hook</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name>event</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>XACT_EVENT_ABORT</name></expr>:</case>
		<case>case <expr><name>XACT_EVENT_PARALLEL_ABORT</name></expr>:</case>
			<comment type="block">/*
			 * We expect that the waitpoint will be retried and then we
			 * will return due to the process receiving a SIGTERM if
			 * the advisory lock is exclusively held by a user call
			 */</comment>
			<expr_stmt><expr><call><name>DEBUG_RETRY_WAITPOINT</name><argument_list>(<argument><expr><literal type="string">"remote_conn_xact_end"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>remote_connections_cleanup</name><argument_list>(<argument><expr><name>InvalidSubTransactionId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>XACT_EVENT_COMMIT</name></expr>:</case>
		<case>case <expr><name>XACT_EVENT_PARALLEL_COMMIT</name></expr>:</case>
			<comment type="block">/* Same retry behavior as above */</comment>
			<expr_stmt><expr><call><name>DEBUG_RETRY_WAITPOINT</name><argument_list>(<argument><expr><literal type="string">"remote_conn_xact_end"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>remote_connections_cleanup</name><argument_list>(<argument><expr><name>InvalidSubTransactionId</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>XACT_EVENT_PREPARE</name></expr>:</case>
			<comment type="block">/*
			 * We expect that the waitpoint will be retried and then we
			 * will return with a warning on crossing the retry count if
			 * the advisory lock is exclusively held by a user call
			 */</comment>
			<expr_stmt><expr><call><name>DEBUG_RETRY_WAITPOINT</name><argument_list>(<argument><expr><literal type="string">"remote_conn_xact_end"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<comment type="block">/* other events are too early to use DEBUG_WAITPOINT.. */</comment>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* re-enable the emit_log_hook */</comment>
	<expr_stmt><expr><name>emit_log_hook</name> <operator>=</operator> <name>prev_emit_log_hook</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>remote_connection_subxact_end</name><parameter_list>(<parameter><decl><type><name>SubXactEvent</name></type> <name>event</name></decl></parameter>, <parameter><decl><type><name>SubTransactionId</name></type> <name>subtxid</name></decl></parameter>,
							  <parameter><decl><type><name>SubTransactionId</name></type> <name>parent_subtxid</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>unused_arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We are deep down in CommitTransaction code path. We do not want our
	 * emit_log_hook_callback to interfere since it uses its own transaction
	 */</comment>
	<decl_stmt><decl><type><name>emit_log_hook_type</name></type> <name>prev_emit_log_hook</name> <init>= <expr><name>emit_log_hook</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>emit_log_hook</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name>event</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>SUBXACT_EVENT_ABORT_SUB</name></expr>:</case>
			<expr_stmt><expr><call><name>remote_connections_cleanup</name><argument_list>(<argument><expr><name>subtxid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SUBXACT_EVENT_COMMIT_SUB</name></expr>:</case>
			<expr_stmt><expr><call><name>remote_connections_cleanup</name><argument_list>(<argument><expr><name>subtxid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* re-enable the emit_log_hook */</comment>
	<expr_stmt><expr><name>emit_log_hook</name> <operator>=</operator> <name>prev_emit_log_hook</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>remote_connection_set_single_row_mode</name><parameter_list>(<parameter><decl><type><name>TSConnection</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>PQsetSingleRowMode</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pg_conn</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>send_binary_copy_header</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TSConnection</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>TSConnectionError</name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* File header for binary format */</comment>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>file_header</name><index>[]</index></name> <init>= <expr><block>{
		<expr><literal type="char">'P'</literal></expr>, <expr><literal type="char">'G'</literal></expr>, <expr><literal type="char">'C'</literal></expr>, <expr><literal type="char">'O'</literal></expr>, <expr><literal type="char">'P'</literal></expr>, <expr><literal type="char">'Y'</literal></expr>, <expr><literal type="char">'\n'</literal></expr>, <expr><literal type="char">'\377'</literal></expr>, <expr><literal type="char">'\r'</literal></expr>, <expr><literal type="char">'\n'</literal></expr>, <expr><literal type="char">'\0'</literal></expr>, <comment type="block">/* Signature */</comment>
		<expr><literal type="number">0</literal></expr>,	 <expr><literal type="number">0</literal></expr>,	  <expr><literal type="number">0</literal></expr>,   <expr><literal type="number">0</literal></expr>,											  <comment type="block">/* 4 bytes flags */</comment>
		<expr><literal type="number">0</literal></expr>,	 <expr><literal type="number">0</literal></expr>,	  <expr><literal type="number">0</literal></expr>,   <expr><literal type="number">0</literal></expr> <comment type="block">/* 4 bytes header extension length (unused) */</comment>
	}</block></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>PQputCopyData</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pg_conn</name></name></expr></argument>, <argument><expr><name>file_header</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>file_header</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>fill_connection_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>,
									 <argument><expr><name>ERRCODE_CONNECTION_FAILURE</name></expr></argument>,
									 <argument><expr><literal type="string">"could not set binary COPY mode"</literal></expr></argument>,
									 <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>remote_connection_begin_copy</name><parameter_list>(<parameter><decl><type><name>TSConnection</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>copycmd</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>binary</name></decl></parameter>,
							 <parameter><decl><type><name>TSConnectionError</name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>pg_conn</name> <init>= <expr><call><name>remote_connection_get_pg_conn</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name> <modifier>*</modifier><specifier>volatile</specifier></type> <name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PQisnonblocking</name><argument_list>(<argument><expr><name>pg_conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>fill_simple_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>,
								 <argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
								 <argument><expr><literal type="string">"distributed copy doesn't support non-blocking connections"</literal></expr></argument>,
								 <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <name>CONN_IDLE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>fill_simple_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>,
								 <argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>,
								 <argument><expr><literal type="string">"connection not IDLE when beginning COPY"</literal></expr></argument>,
								 <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
	<comment type="block">/* Set some variables for testing. */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>throw_after_option</name> <init>=
		<expr><call><name>GetConfigOption</name><argument_list>(<argument><expr><literal type="string">"timescaledb.debug_broken_sendrecv_throw_after"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>throw_after_option</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQexec</name><argument_list>(<argument><expr><name>pg_conn</name></expr></argument>,
					 <argument><expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"set timescaledb.debug_broken_sendrecv_throw_after = '%s';"</literal></expr></argument>,
							  <argument><expr><name>throw_after_option</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>remote_connection_get_result_error</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* Run the COPY query. */</comment>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQexec</name><argument_list>(<argument><expr><name>pg_conn</name></expr></argument>, <argument><expr><name>copycmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COPY_IN</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fill_result_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>,
						  <argument><expr><name>ERRCODE_CONNECTION_FAILURE</name></expr></argument>,
						  <argument><expr><literal type="string">"unable to start remote COPY on data node"</literal></expr></argument>,
						  <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>binary</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>send_binary_copy_header</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>err_end_copy</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/* Switch the connection into nonblocking mode for the duration of COPY. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PQsetnonblocking</name><argument_list>(<argument><expr><name>pg_conn</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fill_simple_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>,
								 <argument><expr><name>ERRCODE_CONNECTION_EXCEPTION</name></expr></argument>,
								 <argument><expr><literal type="string">"failed to set the connection into nonblocking mode"</literal></expr></argument>,
								 <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>err_end_copy</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>binary_copy</name></name> <operator>=</operator> <name>binary</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>remote_connection_set_status</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>CONN_COPY_IN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
<label><name>err_end_copy</name>:</label>
	<expr_stmt><expr><call><name>PQputCopyEnd</name><argument_list>(<argument><expr><name>pg_conn</name></expr></argument>, <argument><expr><name><name>err</name><operator>-&gt;</operator><name>msg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>remote_connection_put_copy_data</name><parameter_list>(<parameter><decl><type><name>TSConnection</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>,
								<parameter><decl><type><name>TSConnectionError</name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQputCopyData</name><argument_list>(<argument><expr><call><name>remote_connection_get_pg_conn</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>fill_connection_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>,
									 <argument><expr><name>ERRCODE_CONNECTION_EXCEPTION</name></expr></argument>,
									 <argument><expr><literal type="string">"could not send COPY data"</literal></expr></argument>,
									 <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>send_end_binary_copy_data</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TSConnection</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>TSConnectionError</name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>uint16</name></type> <name>buf</name> <init>= <expr><call><name>pg_hton16</name><argument_list>(<argument><expr><operator>(</operator><name>uint16</name><operator>)</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PQputCopyData</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pg_conn</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>fill_simple_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not end binary COPY"</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * End COPY on the remote connection.
 * This function is used to clean up after errors as well, so it works in a
 * recovery fashion: it tries to bring the connection into predictable and
 * usable state, even if there are some errors or discrepancies between its
 * actual and expected state.
 */</comment>
<function><type><name>bool</name></type>
<name>remote_connection_end_copy</name><parameter_list>(<parameter><decl><type><name>TSConnection</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>TSConnectionError</name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * In any case, try to switch the connection into the blocking mode, because
	 * that's what the non-COPY code expects.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PQisnonblocking</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pg_conn</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We have to flush the connection before we can switch it into blocking
		 * mode.
		 */</comment>
		<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<decl_stmt><decl><type><name>int</name></type> <name>flush_result</name> <init>= <expr><call><name>PQflush</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pg_conn</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>flush_result</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * In some rare cases, flush might report that it's busy, but
				 * actually there was an error and the socket became invalid.
				 * Check for it. This is something we have observed in COPY
				 * queries used for performance testing with tsbench, but not
				 * sure how it happens exactly, must be in the depths of
				 * pqReadData called by pqFlush.
				 */</comment>
				<decl_stmt><decl><type><name>int</name></type> <name>socket</name> <init>= <expr><call><name>PQsocket</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pg_conn</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><name>socket</name> <operator>==</operator> <name>PGINVALID_SOCKET</name></expr>)</condition>
				<block>{<block_content>
					<return>return <expr><call><name>fill_connection_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>,
												 <argument><expr><name>ERRCODE_CONNECTION_EXCEPTION</name></expr></argument>,
												 <argument><expr><literal type="string">"failed to flush the COPY connection"</literal></expr></argument>,
												 <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * The socket is busy, wait. We don't care about the wait result
				 * here, because whether it is a timeout or the socket became
				 * writeable, we just retry.
				 */</comment>
				<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>WaitLatchOrSocket</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>,
										 <argument><expr><name>WL_TIMEOUT</name> <operator>|</operator> <name>WL_SOCKET_WRITEABLE</name> <operator>|</operator> <name>WL_EXIT_ON_PM_DEATH</name></expr></argument>,
										 <argument><expr><name>socket</name></expr></argument>,
										 <comment type="block">/* timeout = */</comment> <argument><expr><literal type="number">1000</literal></expr></argument>,
										 <comment type="block">/* wait_event_info = */</comment> <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>flush_result</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Flushed all. */</comment>
				<break>break;</break>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* Error. */</comment>
				<return>return <expr><call><name>fill_connection_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>,
											 <argument><expr><name>ERRCODE_CONNECTION_EXCEPTION</name></expr></argument>,
											 <argument><expr><literal type="string">"failed to flush the COPY connection"</literal></expr></argument>,
											 <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/* Switch the connection into blocking mode. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PQsetnonblocking</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pg_conn</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><call><name>fill_connection_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>,
										 <argument><expr><name>ERRCODE_CONNECTION_EXCEPTION</name></expr></argument>,
										 <argument><expr><literal type="string">"failed to set the connection into blocking mode"</literal></expr></argument>,
										 <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Shouldn't have been called for a connection we know is not in COPY mode.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <name>CONN_COPY_IN</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>fill_simple_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>,
								 <argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>,
								 <argument><expr><literal type="string">"connection not in COPY_IN state when ending COPY"</literal></expr></argument>,
								 <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Check whether it's still in COPY mode. The dist_copy manages COPY
	 * protocol itself because it needs to work with multiple connections
	 * concurrently. The remote server might leave the COPY mode for own
	 * reasons, as well. If we discover this, update our info with the actual
	 * status, but still report the error.
	 */</comment>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQgetResult</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pg_conn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COPY_IN</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>remote_connection_set_status</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><ternary><condition><expr><name>res</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><name>CONN_IDLE</name></expr> </then><else>: <expr><name>CONN_PROCESSING</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Finish the COPY if needed.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>remote_connection_get_status</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CONN_COPY_IN</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>binary_copy</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>send_end_binary_copy_data</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PQputCopyEnd</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pg_conn</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>fill_connection_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>,
										 <argument><expr><name>ERRCODE_CONNECTION_EXCEPTION</name></expr></argument>,
										 <argument><expr><literal type="string">"could not end remote COPY"</literal></expr></argument>,
										 <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>remote_connection_set_status</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>CONN_PROCESSING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>success</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>PQgetResult</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pg_conn</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ExecStatusType</name></type> <name>status</name> <init>= <expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>success</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>remote_connection_get_result_error</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>res</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>remote_connection_set_status</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>CONN_IDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>success</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TS_DEBUG</name></cpp:ifdef>
<comment type="block">/*
 * Reset the current connection stats.
 */</comment>
<function><type><name>void</name></type>
<name>remote_connection_stats_reset</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>connstats</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RemoteConnectionStats</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get the current connection stats.
 */</comment>
<function><type><name>RemoteConnectionStats</name> <modifier>*</modifier></type>
<name>remote_connection_stats_get</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>&amp;</operator><name>connstats</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type>
<name>_remote_connection_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>RegisterXactCallback</name><argument_list>(<argument><expr><name>remote_connection_xact_end</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RegisterSubXactCallback</name><argument_list>(<argument><expr><name>remote_connection_subxact_end</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>unset_libpq_envvar</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>_remote_connection_fini</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>UnregisterXactCallback</name><argument_list>(<argument><expr><name>remote_connection_xact_end</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UnregisterSubXactCallback</name><argument_list>(<argument><expr><name>remote_connection_subxact_end</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
