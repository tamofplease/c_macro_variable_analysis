<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/timescaledb/tsl/src/deparse.c"><comment type="block">/*
 * This file and its contents are licensed under the Timescale License.
 * Please see the included NOTICE for copyright information and
 * LICENSE-TIMESCALE for a copy of the license.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postgres.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/rel.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;lib/stringinfo.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/acl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/builtins.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/lsyscache.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/relcache.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/ruleutils.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/syscache.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/fmgroids.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/rel.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;commands/tablespace.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;commands/defrem.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/relscan.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_class.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/indexing.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_constraint.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_index.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_authid.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_proc.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/namespace.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/pg_list.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;funcapi.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fmgr.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;constraint.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;extension.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;export.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;compat/compat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;trigger.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"deparse.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils.h"</cpp:file></cpp:include>

<comment type="block">/*
 * Deparse a table into a set of SQL commands that can be used to recreate it.
 * Together with column definition it deparses constraints, indexes, triggers
 * and rules as well.  There are some table types that are not supported:
 * temporary, partitioned, foreign, inherited and a table that uses
 * options. Row security is also not supported.
 */</comment>
<typedef>typedef <function_decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>GetCmdFunc</name>)<parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_index_cmd</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>pg_get_indexdef_string</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_constraint_cmd</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>pg_get_constraintdef_command</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>FunctionCallInfo</name></type>
<name>build_fcinfo_data</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><call><name>SizeForFunctionCallInfo</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><operator>*</operator><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FC_ARG</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FC_NULL</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<return>return <expr><name>fcinfo</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_trigger_cmd</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><call><name>pg_get_triggerdef</name><argument_list>(<argument><expr><call><name>build_fcinfo_data</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_function_cmd</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><call><name>pg_get_functiondef</name><argument_list>(<argument><expr><call><name>build_fcinfo_data</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_rule_cmd</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><call><name>pg_get_ruledef</name><argument_list>(<argument><expr><call><name>build_fcinfo_data</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>get_cmds</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>oids</name></decl></parameter>, <parameter><decl><type><name>GetCmdFunc</name></type> <name>get_cmd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>cmds</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>cell</argument>, <argument>oids</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>StringInfo</name></type> <name>cmd</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="string">"%s;"</literal></expr></argument>, <argument><expr><call><name>get_cmd</name><argument_list>(<argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cmds</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>cmds</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<return>return <expr><name>cmds</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>get_constraint_cmds</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>constraint_oids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>get_cmds</name><argument_list>(<argument><expr><name>constraint_oids</name></expr></argument>, <argument><expr><name>get_constraint_cmd</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>get_index_cmds</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>index_oids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>get_cmds</name><argument_list>(<argument><expr><name>index_oids</name></expr></argument>, <argument><expr><name>get_index_cmd</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>get_trigger_cmds</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>trigger_oids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>get_cmds</name><argument_list>(<argument><expr><name>trigger_oids</name></expr></argument>, <argument><expr><name>get_trigger_cmd</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>get_function_cmds</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>function_oids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>get_cmds</name><argument_list>(<argument><expr><name>function_oids</name></expr></argument>, <argument><expr><name>get_function_cmd</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>get_rule_cmds</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rule_oids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>get_cmds</name><argument_list>(<argument><expr><name>rule_oids</name></expr></argument>, <argument><expr><name>get_rule_cmd</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>column_is_serial</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Name</name></type> <name>column</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relation_name</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>LOCAL_FCINFO</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Prepare call to pg_get_serial_sequence() function.
	 *
	 * We have to manually prepare the function call context here instead
	 * of using the DirectFunctionCall2() because we expect to get
	 * NULL return value. */</comment>
	<expr_stmt><expr><name>relation_name</name> <operator>=</operator> <call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>)</argument_list></call></expr></argument>,
											   <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><operator>*</operator><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FC_ARG</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>relation_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FC_ARG</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>column</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FC_NULL</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FC_NULL</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_get_serial_sequence</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>!</operator><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>deparse_columns</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>stmt</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>att_idx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>rel_desc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleConstr</name> <modifier>*</modifier></type><name>constraints</name> <init>= <expr><name><name>rel_desc</name><operator>-&gt;</operator><name>constr</name></name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>att_idx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>att_idx</name> <operator>&lt;</operator> <name><name>rel_desc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>att_idx</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>dim_idx</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>rel_desc</name></expr></argument>, <argument><expr><name>att_idx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bits16</name></type> <name>flags</name> <init>= <expr><name>FORMAT_TYPE_TYPEMOD_GIVEN</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * if it's not a builtin type then schema qualify the same. There's a function
		 * deparse_type_name in fdw, but we don't want cross linking unnecessarily
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>&gt;=</operator> <name>FirstBootstrapObjectIdCompat</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>FORMAT_TYPE_FORCE_QUALIFY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>,
						 <argument><expr><literal type="string">"\"%s\" %s"</literal></expr></argument>,
						 <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>format_type_extended</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>, <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attnotnull</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><literal type="string">" NOT NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attcollation</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><literal type="string">" COLLATE \"%s\""</literal></expr></argument>, <argument><expr><call><name>get_collation_name</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attcollation</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>atthasdef</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>co_idx</name></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>co_idx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>co_idx</name> <operator>&lt;</operator> <name><name>constraints</name><operator>-&gt;</operator><name>num_defval</name></name></expr>;</condition> <incr><expr><name>co_idx</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>AttrDefault</name></type> <name>attr_def</name> <init>= <expr><name><name>constraints</name><operator>-&gt;</operator><name>defval</name><index>[<expr><name>co_idx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attnum</name></name> <operator>==</operator> <name><name>attr_def</name><operator>.</operator><name>adnum</name></name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>attr_default</name></decl>;</decl_stmt>

					<comment type="block">/* Skip default expression in case if column is serial
					 * (has dependant sequence object) */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>column_is_serial</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt>

					<expr_stmt><expr><name>attr_default</name> <operator>=</operator>
						<call><name>TextDatumGetCString</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>pg_get_expr</name></expr></argument>,
																<argument><expr><call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>attr_def</name><operator>.</operator><name>adbin</name></name></expr></argument>)</argument_list></call></expr></argument>,
																<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attgenerated</name></name> <operator>==</operator> <name>ATTRIBUTE_GENERATED_STORED</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><literal type="string">" GENERATED ALWAYS AS %s STORED"</literal></expr></argument>, <argument><expr><name>attr_default</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><literal type="string">" DEFAULT %s"</literal></expr></argument>, <argument><expr><name>attr_default</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>

		<for>for <control>(<init><expr><name>dim_idx</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>dim_idx</name> <operator>&lt;</operator> <name><name>attr</name><operator>-&gt;</operator><name>attndims</name></name></expr>;</condition> <incr><expr><name>dim_idx</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><literal type="string">"[]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

		<if_stmt><if>if <condition>(<expr><name>att_idx</name> <operator>!=</operator> <operator>(</operator><name><name>rel_desc</name><operator>-&gt;</operator><name>natts</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <name>ConstraintContext</name>
<block>{
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>constraints</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>constraint_indexes</name></decl>;</decl_stmt>
}</block></struct></type> <name>ConstraintContext</name>;</typedef>

<function><type><specifier>static</specifier> <name>ConstraintProcessStatus</name></type>
<name>add_constraint</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>constraint_tuple</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ConstraintContext</name> <modifier>*</modifier></type><name>cc</name> <init>= <expr><name>ctx</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>constraint</name> <init>= <expr><operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>constraint_tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>constroid</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>conindid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name><name>cc</name><operator>-&gt;</operator><name>constraint_indexes</name></name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><operator>*</operator><name><name>cc</name><operator>-&gt;</operator><name>constraint_indexes</name></name></expr></argument>, <argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>conindid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>constroid</name> <operator>=</operator> <name><name>constraint</name><operator>-&gt;</operator><name>oid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>constraints</name></name></expr></argument>, <argument><expr><name>constroid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>CONSTR_PROCESSED</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>get_constraint_oids</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>constraint_indexes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ConstraintContext</name></type> <name>cc</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>constraints</name> <operator>=</operator> <name>NIL</name></expr>,
		<expr><operator>.</operator><name>constraint_indexes</name> <operator>=</operator> <name>constraint_indexes</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ts_constraint_process</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>add_constraint</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>cc</name><operator>.</operator><name>constraints</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>get_index_oids</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>exclude_indexes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>indexes</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>cell</argument>, <argument>RelationGetIndexList(rel)</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>indexid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_member_oid</name><argument_list>(<argument><expr><name>exclude_indexes</name></expr></argument>, <argument><expr><name>indexid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>indexes</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>indexes</name></expr></argument>, <argument><expr><name>indexid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>indexes</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *  Specifically exclude the hypertable insert blocker from this list.  A table which was recreated
 * with that trigger present would not be able to made into a hypertable.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>get_trigger_oids</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>triggers</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>trigdesc</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>rel</name><operator>-&gt;</operator><name>trigdesc</name><operator>-&gt;</operator><name>numtriggers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>Trigger</name></type> <name>trigger</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>trigdesc</name><operator>-&gt;</operator><name>triggers</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>trigger</name><operator>.</operator><name>tgisinternal</name></name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>trigger</name><operator>.</operator><name>tgname</name></name></expr></argument>, <argument><expr><name>INSERT_BLOCKER_NAME</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>triggers</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>triggers</name></expr></argument>, <argument><expr><name><name>trigger</name><operator>.</operator><name>tgoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>triggers</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>get_trigger_function_oids</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>functions</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>trigdesc</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>rel</name><operator>-&gt;</operator><name>trigdesc</name><operator>-&gt;</operator><name>numtriggers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>Trigger</name></type> <name>trigger</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>trigdesc</name><operator>-&gt;</operator><name>triggers</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>trigger</name><operator>.</operator><name>tgisinternal</name></name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>trigger</name><operator>.</operator><name>tgname</name></name></expr></argument>, <argument><expr><name>INSERT_BLOCKER_NAME</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>functions</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>functions</name></expr></argument>, <argument><expr><name><name>trigger</name><operator>.</operator><name>tgfoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>functions</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>get_rule_oids</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>rules</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rules</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rules</name><operator>-&gt;</operator><name>numLocks</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>RewriteRule</name> <modifier>*</modifier></type><name>rule</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rules</name><operator>-&gt;</operator><name>rules</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>rules</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>rules</name></expr></argument>, <argument><expr><name><name>rule</name><operator>-&gt;</operator><name>ruleId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>rules</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>validate_relation</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"given relation is not an ordinary table"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_TEMP</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"temporary table is not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relrowsecurity</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"row security is not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>TableInfo</name> <modifier>*</modifier></type>
<name>deparse_create_table_info</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>exclude_indexes</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TableInfo</name> <modifier>*</modifier></type><name>table_info</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TableInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>rel</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation with id %u not found"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>validate_relation</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>table_info</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <name>relid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>table_info</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <call><name>get_constraint_oids</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>exclude_indexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>table_info</name><operator>-&gt;</operator><name>indexes</name></name> <operator>=</operator> <call><name>get_index_oids</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>exclude_indexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>table_info</name><operator>-&gt;</operator><name>triggers</name></name> <operator>=</operator> <call><name>get_trigger_oids</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>table_info</name><operator>-&gt;</operator><name>functions</name></name> <operator>=</operator> <call><name>get_trigger_function_oids</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>table_info</name><operator>-&gt;</operator><name>rules</name></name> <operator>=</operator> <call><name>get_rule_oids</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>table_info</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>deparse_get_tabledef_with</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TableInfo</name> <modifier>*</modifier></type><name>table_info</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>create_table</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>opts</name> <init>= <expr><call><name>ts_get_reloptions</name><argument_list>(<argument><expr><name><name>table_info</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>opts</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>create_table</name></expr></argument>, <argument><expr><literal type="string">" WITH ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>cell</argument>, <argument>opts</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>def</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>create_table</name></expr></argument>,
						 <argument><expr><literal type="string">"%s%s=%s"</literal></expr></argument>,
						 <argument><expr><ternary><condition><expr><name>cell</name> <operator>!=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>opts</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">","</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
						 <argument><expr><name><name>def</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>,
						 <argument><expr><call><name>defGetString</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>create_table</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>TableDef</name> <modifier>*</modifier></type>
<name>deparse_get_tabledef</name><parameter_list>(<parameter><decl><type><name>TableInfo</name> <modifier>*</modifier></type><name>table_info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>create_table</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>set_schema</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TableDef</name> <modifier>*</modifier></type><name>table_def</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TableDef</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name><name>table_info</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>set_schema</name></expr></argument>,
					 <argument><expr><literal type="string">"SET SCHEMA %s;"</literal></expr></argument>,
					 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>table_def</name><operator>-&gt;</operator><name>schema_cmd</name></name> <operator>=</operator> <name><name>set_schema</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>create_table</name></expr></argument>, <argument><expr><literal type="string">"CREATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_UNLOGGED</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>create_table</name></expr></argument>, <argument><expr><literal type="string">" UNLOGGED"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>create_table</name></expr></argument>, <argument><expr><literal type="string">" TABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>create_table</name></expr></argument>,
					 <argument><expr><literal type="string">" \"%s\".\"%s\" ("</literal></expr></argument>,
					 <argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>deparse_columns</name><argument_list>(<argument><expr><name>create_table</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>create_table</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>create_table</name></expr></argument>, <argument><expr><literal type="string">" USING \"%s\" "</literal></expr></argument>, <argument><expr><call><name>get_am_name</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relam</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>deparse_get_tabledef_with</name><argument_list>(<argument><expr><name>table_info</name></expr></argument>, <argument><expr><name>create_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>create_table</name></expr></argument>, <argument><expr><literal type="char">';'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>table_def</name><operator>-&gt;</operator><name>create_cmd</name></name> <operator>=</operator> <name><name>create_table</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>table_def</name><operator>-&gt;</operator><name>constraint_cmds</name></name> <operator>=</operator> <call><name>get_constraint_cmds</name><argument_list>(<argument><expr><name><name>table_info</name><operator>-&gt;</operator><name>constraints</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>table_def</name><operator>-&gt;</operator><name>index_cmds</name></name> <operator>=</operator> <call><name>get_index_cmds</name><argument_list>(<argument><expr><name><name>table_info</name><operator>-&gt;</operator><name>indexes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>table_def</name><operator>-&gt;</operator><name>trigger_cmds</name></name> <operator>=</operator> <call><name>get_trigger_cmds</name><argument_list>(<argument><expr><name><name>table_info</name><operator>-&gt;</operator><name>triggers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>table_def</name><operator>-&gt;</operator><name>function_cmds</name></name> <operator>=</operator> <call><name>get_function_cmds</name><argument_list>(<argument><expr><name><name>table_info</name><operator>-&gt;</operator><name>functions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>table_def</name><operator>-&gt;</operator><name>rule_cmds</name></name> <operator>=</operator> <call><name>get_rule_cmds</name><argument_list>(<argument><expr><name><name>table_info</name><operator>-&gt;</operator><name>rules</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>table_def</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Append a privilege name to a string if the privilege is set.
 *
 * Parameters:
 *    buf: Buffer to append to.
 *    pfirst: Pointer to variable to remember if elements are already added.
 *    privs: Bitmap of privilege flags.
 *    mask: Mask for privilege to check.
 *    priv_name: String with name of privilege to add.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>append_priv_if_set</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>priv_added</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>privs</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>mask</name></decl></parameter>,
				   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>priv_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>privs</name> <operator>&amp;</operator> <name>mask</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>priv_added</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>priv_added</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>priv_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>append_privs_as_text</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>privs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>priv_added</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>append_priv_if_set</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>priv_added</name></expr></argument>, <argument><expr><name>privs</name></expr></argument>, <argument><expr><name>ACL_INSERT</name></expr></argument>, <argument><expr><literal type="string">"INSERT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>append_priv_if_set</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>priv_added</name></expr></argument>, <argument><expr><name>privs</name></expr></argument>, <argument><expr><name>ACL_SELECT</name></expr></argument>, <argument><expr><literal type="string">"SELECT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>append_priv_if_set</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>priv_added</name></expr></argument>, <argument><expr><name>privs</name></expr></argument>, <argument><expr><name>ACL_UPDATE</name></expr></argument>, <argument><expr><literal type="string">"UPDATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>append_priv_if_set</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>priv_added</name></expr></argument>, <argument><expr><name>privs</name></expr></argument>, <argument><expr><name>ACL_DELETE</name></expr></argument>, <argument><expr><literal type="string">"DELETE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>append_priv_if_set</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>priv_added</name></expr></argument>, <argument><expr><name>privs</name></expr></argument>, <argument><expr><name>ACL_TRUNCATE</name></expr></argument>, <argument><expr><literal type="string">"TRUNCATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>append_priv_if_set</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>priv_added</name></expr></argument>, <argument><expr><name>privs</name></expr></argument>, <argument><expr><name>ACL_REFERENCES</name></expr></argument>, <argument><expr><literal type="string">"REFERENCES"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>append_priv_if_set</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>priv_added</name></expr></argument>, <argument><expr><name>privs</name></expr></argument>, <argument><expr><name>ACL_TRIGGER</name></expr></argument>, <argument><expr><literal type="string">"TRIGGER"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Create grant statements for a relation.
 *
 * This will create a list of grant statements, one for each role.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>deparse_grant_commands_for_relid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>reltup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>pg_class_tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>cmds</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>acl_datum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>is_null</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>owner_id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Acl</name> <modifier>*</modifier></type><name>acl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>AclItem</name> <modifier>*</modifier></type><name>acldat</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>reltup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>pg_class_tuple</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pg_class_tuple</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not an ordinary table"</literal></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>pg_class_tuple</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>owner_id</name> <operator>=</operator> <name><name>pg_class_tuple</name><operator>-&gt;</operator><name>relowner</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>acl_datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><name>reltup</name></expr></argument>, <argument><expr><name>Anum_pg_class_relacl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_null</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>acl</name> <operator>=</operator> <call><name>acldefault</name><argument_list>(<argument><expr><name>OBJECT_TABLE</name></expr></argument>, <argument><expr><name>owner_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>acl</name> <operator>=</operator> <call><name>DatumGetAclP</name><argument_list>(<argument><expr><name>acl_datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>acldat</name> <operator>=</operator> <call><name>ACL_DAT</name><argument_list>(<argument><expr><name>acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>ACL_NUM</name><argument_list>(<argument><expr><name>acl</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>AclItem</name> <modifier>*</modifier></type><name>aclitem</name> <init>= <expr><operator>&amp;</operator><name><name>acldat</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>role_id</name> <init>= <expr><name><name>aclitem</name><operator>-&gt;</operator><name>ai_grantee</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StringInfo</name></type> <name>grant_cmd</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type> <name>utup</name></decl>;</decl_stmt>

		<comment type="block">/* We skip the owner of the table since she automatically have all
		 * privileges on the table. */</comment>
		<if_stmt><if>if <condition>(<expr><name>role_id</name> <operator>==</operator> <name>owner_id</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>grant_cmd</name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>utup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>AUTHOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>role_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>utup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>grant_cmd</name></expr></argument>, <argument><expr><literal type="string">"GRANT "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>append_privs_as_text</name><argument_list>(<argument><expr><name>grant_cmd</name></expr></argument>, <argument><expr><name><name>aclitem</name><operator>-&gt;</operator><name>ai_privs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>grant_cmd</name></expr></argument>,
						 <argument><expr><literal type="string">" ON TABLE %s.%s TO %s"</literal></expr></argument>,
						 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>pg_class_tuple</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>pg_class_tuple</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Form_pg_authid</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>utup</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>rolname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>utup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cmds</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>cmds</name></expr></argument>, <argument><expr><name><name>grant_cmd</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>cmds</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>List</name> <modifier>*</modifier></type>
<name>deparse_get_tabledef_commands</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TableInfo</name> <modifier>*</modifier></type><name>table_info</name> <init>= <expr><call><name>deparse_create_table_info</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TableDef</name> <modifier>*</modifier></type><name>table_def</name> <init>= <expr><call><name>deparse_get_tabledef</name><argument_list>(<argument><expr><name>table_info</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>deparse_get_tabledef_commands_from_tabledef</name><argument_list>(<argument><expr><name>table_def</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>List</name> <modifier>*</modifier></type>
<name>deparse_get_tabledef_commands_from_tabledef</name><parameter_list>(<parameter><decl><type><name>TableDef</name> <modifier>*</modifier></type><name>table_def</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>cmds</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>cmds</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>cmds</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>table_def</name><operator>-&gt;</operator><name>schema_cmd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cmds</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>cmds</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>table_def</name><operator>-&gt;</operator><name>create_cmd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cmds</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>cmds</name></expr></argument>, <argument><expr><name><name>table_def</name><operator>-&gt;</operator><name>constraint_cmds</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cmds</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>cmds</name></expr></argument>, <argument><expr><name><name>table_def</name><operator>-&gt;</operator><name>index_cmds</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cmds</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>cmds</name></expr></argument>, <argument><expr><name><name>table_def</name><operator>-&gt;</operator><name>function_cmds</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cmds</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>cmds</name></expr></argument>, <argument><expr><name><name>table_def</name><operator>-&gt;</operator><name>trigger_cmds</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cmds</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>cmds</name></expr></argument>, <argument><expr><name><name>table_def</name><operator>-&gt;</operator><name>rule_cmds</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>cmds</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>deparse_get_tabledef_commands_concat</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>tabledef</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>cell</argument>, <argument>deparse_get_tabledef_commands(relid)</argument>)</argument_list></macro>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>tabledef</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>tabledef</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>deparse_get_add_dimension_command</name><parameter_list>(<parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>Dimension</name> <modifier>*</modifier></type><name>dimension</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>dim_cmd</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>dim_cmd</name></expr></argument>,
					 <argument><expr><literal type="string">"SELECT * FROM %s.add_dimension(%s, %s, "</literal></expr></argument>,
					 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>ts_extension_schema_name</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(
						 <argument><expr><call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><call><name>get_namespace_name</name><argument_list>(
														<argument><expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
													<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>dimension</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>column_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dimension</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>DIMENSION_TYPE_CLOSED</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>dim_cmd</name></expr></argument>,
						 <argument><expr><literal type="string">"number_partitions =&gt; %d, partitioning_func =&gt; %s);"</literal></expr></argument>,
						 <argument><expr><name><name>dimension</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>num_slices</name></name></expr></argument>,
						 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(
							 <argument><expr><call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(
															<argument><expr><name><name>dimension</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>partitioning_func_schema</name></name></expr></argument>)</argument_list></call></expr></argument>,
														<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>dimension</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>partitioning_func</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>dim_cmd</name></expr></argument>,
						 <argument><expr><literal type="string">"chunk_time_interval =&gt; "</literal> <name>INT64_FORMAT</name> <literal type="string">");"</literal></expr></argument>,
						 <argument><expr><name><name>dimension</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>interval_length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name><name>dim_cmd</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>DeparsedHypertableCommands</name> <modifier>*</modifier></type>
<name>deparse_get_distributed_hypertable_create_command</name><parameter_list>(<parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Hyperspace</name> <modifier>*</modifier></type><name>space</name> <init>= <expr><name><name>ht</name><operator>-&gt;</operator><name>space</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Dimension</name> <modifier>*</modifier></type><name>time_dim</name> <init>= <expr><operator>&amp;</operator><name><name>space</name><operator>-&gt;</operator><name>dimensions</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>hypertable_cmd</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DeparsedHypertableCommands</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DeparsedHypertableCommands</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>hypertable_cmd</name></expr></argument>,
					 <argument><expr><literal type="string">"SELECT * FROM %s.create_hypertable(%s"</literal></expr></argument>,
					 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>ts_extension_schema_name</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(
						 <argument><expr><call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><call><name>get_namespace_name</name><argument_list>(
														<argument><expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
													<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>hypertable_cmd</name></expr></argument>,
					 <argument><expr><literal type="string">", time_column_name =&gt; %s"</literal></expr></argument>,
					 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>time_dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>column_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>time_dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>partitioning_func</name><operator>.</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>hypertable_cmd</name></expr></argument>,
						 <argument><expr><literal type="string">", time_partitioning_func =&gt; %s"</literal></expr></argument>,
						 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(
							 <argument><expr><call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(
															<argument><expr><name><name>time_dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>partitioning_func_schema</name></name></expr></argument>)</argument_list></call></expr></argument>,
														<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>time_dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>partitioning_func</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>hypertable_cmd</name></expr></argument>,
					 <argument><expr><literal type="string">", associated_schema_name =&gt; %s"</literal></expr></argument>,
					 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>associated_schema_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>hypertable_cmd</name></expr></argument>,
					 <argument><expr><literal type="string">", associated_table_prefix =&gt; %s"</literal></expr></argument>,
					 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>associated_table_prefix</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>hypertable_cmd</name></expr></argument>,
					 <argument><expr><literal type="string">", chunk_time_interval =&gt; "</literal> <name>INT64_FORMAT</name> <literal type="string">""</literal></expr></argument>,
					 <argument><expr><name><name>time_dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>interval_length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>chunk_sizing_func</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>hypertable_cmd</name></expr></argument>,
						 <argument><expr><literal type="string">", chunk_sizing_func =&gt; %s"</literal></expr></argument>,
						 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(
							 <argument><expr><call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>chunk_sizing_func_schema</name></name></expr></argument>)</argument_list></call></expr></argument>,
														<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>chunk_sizing_func_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>hypertable_cmd</name></expr></argument>,
						 <argument><expr><literal type="string">", chunk_target_size =&gt; '"</literal> <name>INT64_FORMAT</name> <literal type="string">"'"</literal></expr></argument>,
						 <argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>chunk_target_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Data node is assumed to not have any preexisting conflicting table or hypertable.
	 * Any default indices will have already been created by the access node.
	 */</comment>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>hypertable_cmd</name></expr></argument>, <argument><expr><literal type="string">", if_not_exists =&gt; FALSE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>hypertable_cmd</name></expr></argument>, <argument><expr><literal type="string">", migrate_data =&gt; FALSE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>hypertable_cmd</name></expr></argument>, <argument><expr><literal type="string">", create_default_indexes =&gt; FALSE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>hypertable_cmd</name></expr></argument>, <argument><expr><literal type="string">", replication_factor =&gt; %d"</literal></expr></argument>, <argument><expr><name>HYPERTABLE_DISTRIBUTED_MEMBER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>hypertable_cmd</name></expr></argument>, <argument><expr><literal type="string">");"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>table_create_command</name></name> <operator>=</operator> <name><name>hypertable_cmd</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>dimension_add_commands</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>space</name><operator>-&gt;</operator><name>num_dimensions</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>space</name><operator>-&gt;</operator><name>num_dimensions</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>dimension_add_commands</name></name> <operator>=</operator>
				<call><name>lappend</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>dimension_add_commands</name></name></expr></argument>,
						<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>deparse_get_add_dimension_command</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>space</name><operator>-&gt;</operator><name>dimensions</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>grant_commands</name></name> <operator>=</operator> <call><name>deparse_grant_commands_for_relid</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_SCALAR_RESULT_NAME</name></cpp:macro> <cpp:value>"*"</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>deparse_result_type</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>sql</name></decl></parameter>, <parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>scalarname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>resulttypeid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><call><name>get_call_result_type</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>resulttypeid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupdesc</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>TYPEFUNC_SCALAR</name></expr>:</case>
			<comment type="block">/* scalar result type */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>==</operator> <name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>resulttypeid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Check if the function has a named OUT parameter */</comment>
			<expr_stmt><expr><name>scalarname</name> <operator>=</operator> <call><name>get_func_result_name</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* If there is no named OUT parameter, use the default name */</comment>
			<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>scalarname</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><name>scalarname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>scalarname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><name>DEFAULT_SCALAR_RESULT_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>
		<case>case <expr><name>TYPEFUNC_COMPOSITE</name></expr>:</case>
			<comment type="block">/* determinable rowtype result */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tupdesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>attisdropped</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>attname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
			<break>break;</break>
		<case>case <expr><name>TYPEFUNC_RECORD</name></expr>:</case>
			<comment type="block">/* indeterminate rowtype result */</comment>
		<case>case <expr><name>TYPEFUNC_COMPOSITE_DOMAIN</name></expr>:</case>
			<comment type="block">/* domain over determinable rowtype result */</comment>
		<case>case <expr><name>TYPEFUNC_OTHER</name></expr>:</case>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unsupported result type for deparsing"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Deparse a function call.
 *
 * Turn a function call back into a string. In theory, we could just call
 * deparse_expression() (ruleutils.c) on the original function expression (as
 * given by fcinfo-&gt;flinfo-&gt;fn_expr), but we'd like to support deparsing also
 * when the expression is not available (e.g., when invoking by OID from C
 * code). Further, deparse_expression() doesn't explicitly give the parameter
 * names, which is important in order to maintain forward-compatibility with
 * the remote version of the function in case it has reordered the parameters.
 */</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>deparse_func_call</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>ftup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>procform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>sql</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>funcnamespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OverrideSearchPath</name></type> <name>search_path</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>schemas</name> <operator>=</operator> <name>NIL</name></expr>,
		<expr><operator>.</operator><name>addCatalog</name> <operator>=</operator> <name>false</name></expr>,
		<expr><operator>.</operator><name>addTemp</name> <operator>=</operator> <name>false</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>funcid</name> <init>= <expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_oid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>argtypes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argnames</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>argmodes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"SELECT "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>deparse_result_type</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* First fetch the function's pg_proc row to inspect its rettype */</comment>
	<expr_stmt><expr><name>ftup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>ftup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>procform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>ftup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>funcnamespace</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>procform</name><operator>-&gt;</operator><name>pronamespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If the function has named OUT-only parameters, then number of arguments
	 * returned by this get_func_arg_info can be greater than
	 * fcinfo-&gt;nargs. But we don't care about OUT-only arguements here. */</comment>
	<expr_stmt><expr><call><name>get_func_arg_info</name><argument_list>(<argument><expr><name>ftup</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>argtypes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>argnames</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>argmodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>,
					 <argument><expr><literal type="string">" FROM %s("</literal></expr></argument>,
					 <argument><expr><call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name>funcnamespace</name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>procform</name><operator>-&gt;</operator><name>proname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>ftup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Temporarily set a NULL search path. This makes identifier types (e.g.,
	 * regclass / tables) be fully qualified, which is needed since the search
	 * path on a remote node is not guaranteed to be the same. */</comment>
	<expr_stmt><expr><call><name>PushOverrideSearchPath</name><argument_list>(<argument><expr><operator>&amp;</operator><name>search_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>nargs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>argvalstr</name> <init>= <expr><literal type="string">"NULL"</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>add_type_cast</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><name><name>argtypes</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>ANYOID</name></expr>:</case>
			<case>case <expr><name>ANYELEMENTOID</name></expr>:</case>
				<comment type="block">/* For pseudo types, try to resolve the "real" argument type
				 * from the function expression, if present */</comment>
				<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name></name> <operator>&amp;&amp;</operator> <name>NULL</name> <operator>!=</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_expr</name></name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Oid</name></type> <name>expr_argtype</name> <init>= <expr><call><name>get_fn_expr_argtype</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<comment type="block">/* Function parameters that aren't typed need type casts,
					 * but only add a cast if the expr contained a "real" type
					 * and not an unknown or pseudo type. */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>expr_argtype</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>expr_argtype</name> <operator>!=</operator> <name>UNKNOWNOID</name> <operator>&amp;&amp;</operator>
						<name>expr_argtype</name> <operator>!=</operator> <name><name>argtypes</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>add_type_cast</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<expr_stmt><expr><name><name>argtypes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>expr_argtype</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			<default>default:</default>
				<break>break;</break>
		</block_content>}</block></switch>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>FC_NULL</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type> <name>isvarlena</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type> <name>outfuncid</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>argtypes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid type for argument %d"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name><name>argtypes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>outfuncid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isvarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>outfuncid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>argvalstr</name> <operator>=</operator> <call><name>quote_literal_cstr</name><argument_list>(<argument><expr><call><name>OidOutputFunctionCall</name><argument_list>(<argument><expr><name>outfuncid</name></expr></argument>, <argument><expr><call><name>FC_ARG</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"%s =&gt; %s"</literal></expr></argument>, <argument><expr><name><name>argnames</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>argvalstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>add_type_cast</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"::%s"</literal></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>argtypes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><name><name>fcinfo</name><operator>-&gt;</operator><name>nargs</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PopOverrideSearchPath</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>argtypes</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>argtypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>argnames</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>argnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>argmodes</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>argmodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>sql</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Deparse a function by OID.
 *
 * The function arguments should be given as datums in the vararg list and
 * need to be specified in the order given by the (OID) function's signature.
 */</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>deparse_oid_function_call_coll</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>funcid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>num_args</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><call><name>SizeForFunctionCallInfo</name><argument_list>(<argument><expr><name>num_args</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name></type> <name>flinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>va_list</name></type> <name>args</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><operator>*</operator><name>fcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flinfo</name></expr></argument>, <argument><expr><name>num_args</name></expr></argument>, <argument><expr><name>collation</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>num_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_args</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>FC_ARG</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>Datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FC_NULL</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>deparse_func_call</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check for null result, since caller is clearly not expecting one */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"function %u returned NULL"</literal></expr></argument>, <argument><expr><name><name>flinfo</name><operator>.</operator><name>fn_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>deparse_grant_revoke_on_database</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>GrantStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dbname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/*
	   GRANT { { CREATE | CONNECT | TEMPORARY | TEMP } [, ...] | ALL [ PRIVILEGES ] }
	   ON DATABASE database_name [, ...]
	   TO role_specification [, ...] [ WITH GRANT OPTION ]
	   [ GRANTED BY role_specification ]

	   REVOKE [ GRANT OPTION FOR ]
	   { { CREATE | CONNECT | TEMPORARY | TEMP } [, ...] | ALL [ PRIVILEGES ] }
	   ON DATABASE database_name [, ...]
	   FROM role_specification [, ...]
	   [ GRANTED BY role_specification ]
	   [ CASCADE | RESTRICT ]
	*/</comment>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>command</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* GRANT/REVOKE */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>is_grant</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><literal type="string">"GRANT "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><literal type="string">"REVOKE "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* privileges [, ...] | ALL */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>privileges</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* ALL */</comment>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><literal type="string">"ALL "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>stmt-&gt;privileges</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AccessPriv</name> <modifier>*</modifier></type><name>priv</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>command</name></expr></argument>,
							 <argument><expr><literal type="string">"%s%s "</literal></expr></argument>,
							 <argument><expr><name><name>priv</name><operator>-&gt;</operator><name>priv_name</name></name></expr></argument>,
							 <argument><expr><ternary><condition><expr><call><name>lnext_compat</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>privileges</name></name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><literal type="string">","</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Set database name of the data node */</comment>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><literal type="string">"ON DATABASE %s "</literal></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>dbname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* TO/FROM role_spec [, ...] */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>is_grant</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><literal type="string">"TO "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><literal type="string">"FROM "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>stmt-&gt;grantees</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RoleSpec</name> <modifier>*</modifier></type><name>role_spec</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>role_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<switch>switch <condition>(<expr><name><name>role_spec</name><operator>-&gt;</operator><name>roletype</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>ROLESPEC_CSTRING</name></expr>:</case>
				<expr_stmt><expr><name>role_name</name> <operator>=</operator> <name><name>role_spec</name><operator>-&gt;</operator><name>rolename</name></name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>ROLESPEC_PUBLIC</name></expr>:</case>
				<expr_stmt><expr><name>role_name</name> <operator>=</operator> <literal type="string">"PUBLIC"</literal></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>ROLESPEC_SESSION_USER</name></expr>:</case>
				<expr_stmt><expr><name>role_name</name> <operator>=</operator> <literal type="string">"SESSION_USER"</literal></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>ROLESPEC_CURRENT_USER</name></expr>:</case>
				<expr_stmt><expr><name>role_name</name> <operator>=</operator> <literal type="string">"CURRENT_USER"</literal></expr>;</expr_stmt>
				<break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_GE</name></expr></cpp:if>
			<case>case <expr><name>ROLESPEC_CURRENT_ROLE</name></expr>:</case>
				<expr_stmt><expr><name>role_name</name> <operator>=</operator> <literal type="string">"CURRENT_ROLE"</literal></expr>;</expr_stmt>
				<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		</block_content>}</block></switch>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>command</name></expr></argument>,
						 <argument><expr><literal type="string">"%s%s "</literal></expr></argument>,
						 <argument><expr><name>role_name</name></expr></argument>,
						 <argument><expr><ternary><condition><expr><call><name>lnext_compat</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>grantees</name></name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><literal type="string">","</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>grant_option</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><literal type="string">"WITH GRANT OPTION "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_GE</name></expr></cpp:if>
	<comment type="block">/* [ GRANTED BY role_specification ] */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>grantor</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><literal type="string">"GRANTED BY %s "</literal></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>grantor</name><operator>-&gt;</operator><name>rolename</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* CASCADE | RESTRICT */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>is_grant</name></name> <operator>&amp;&amp;</operator> <name><name>stmt</name><operator>-&gt;</operator><name>behavior</name></name> <operator>==</operator> <name>DROP_CASCADE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><literal type="string">"CASCADE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name><name>command</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Deparse user-defined trigger */</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>deparse_create_trigger</name><parameter_list>(<parameter><decl><type><name>CreateTrigStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>found_event</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>found_first_arg</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	CREATE [ CONSTRAINT ] TRIGGER name { BEFORE | AFTER | INSTEAD OF } { event [ OR ... ] }
		ON table_name
		[ FROM referenced_table_name ]
		[ NOT DEFERRABLE | [ DEFERRABLE ] [ INITIALLY IMMEDIATE | INITIALLY DEFERRED ] ]
		[ REFERENCING { { OLD | NEW } TABLE [ AS ] transition_relation_name } [ ... ] ]
		[ FOR [ EACH ] { ROW | STATEMENT } ]
		[ WHEN ( condition ) ]
		EXECUTE { FUNCTION | PROCEDURE } function_name ( arguments )
	*/</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>isconstraint</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"deparsing constraint triggers is not supported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>StringInfo</name></type> <name>command</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><literal type="string">"CREATE TRIGGER %s "</literal></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>trigname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TRIGGER_FOR_BEFORE</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>timing</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><literal type="string">"BEFORE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>TRIGGER_FOR_AFTER</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>timing</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><literal type="string">"AFTER"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>TRIGGER_FOR_INSTEAD</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>timing</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><literal type="string">"INSTEAD OF"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected timing value: %d"</literal></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>timing</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TRIGGER_FOR_INSERT</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>events</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><literal type="string">" INSERT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>found_event</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>TRIGGER_FOR_DELETE</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>events</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>found_event</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><literal type="string">" OR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><literal type="string">" DELETE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>found_event</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>TRIGGER_FOR_UPDATE</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>events</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>found_event</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><literal type="string">" OR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><literal type="string">" UPDATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>found_event</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>TRIGGER_FOR_TRUNCATE</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>events</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>found_event</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><literal type="string">" OR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><literal type="string">" TRUNCATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>command</name></expr></argument>,
					 <argument><expr><literal type="string">" ON %s.%s"</literal></expr></argument>,
					 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>row</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><literal type="string">" FOR EACH ROW"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><literal type="string">" FOR EACH STATEMENT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>whenClause</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"deparsing trigger WHEN clause is not supported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><literal type="string">" EXECUTE FUNCTION %s("</literal></expr></argument>, <argument><expr><call><name>NameListToQuotedString</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>funcname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>stmt-&gt;args</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>found_first_arg</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>found_first_arg</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>command</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>
</unit>
