<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/timescaledb/tsl/src/compression/compression.c"><comment type="block">/*
 * This file and its contents are licensed under the Timescale License.
 * Please see the included NOTICE for copyright information and
 * LICENSE-TIMESCALE for a copy of the license.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compression/compression.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/heapam.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/htup_details.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/multixact.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/xact.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/namespace.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_attribute.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_type.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/index.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/heap.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;common/base64.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;executor/tuptable.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;funcapi.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;libpq/pqformat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;miscadmin.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/pg_list.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;storage/lmgr.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;storage/predicate.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/builtins.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/datum.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/lsyscache.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/memutils.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/rel.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/snapmgr.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/syscache.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/tuplesort.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/typcache.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compat/compat.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"array.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"chunk.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"debug_point.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"deltadelta.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dictionary.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gorilla.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ts_catalog/compression_chunk_size.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"create.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"custom_type_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"segment_meta.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ts_catalog/hypertable_compression.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ts_catalog/catalog.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/print.h&gt;</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_ROWS_PER_COMPRESSION</name></cpp:macro> <cpp:value>1000</cpp:value></cpp:define>
<comment type="block">/* gap in sequence id between rows, potential for adding rows in gap later */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SEQUENCE_NUM_GAP</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPRESSIONCOL_IS_SEGMENT_BY</name><parameter_list>(<parameter><type><name>col</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((col)-&gt;segmentby_column_index &gt; 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPRESSIONCOL_IS_ORDER_BY</name><parameter_list>(<parameter><type><name>col</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((col)-&gt;orderby_column_index &gt; 0)</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>CompressionAlgorithmDefinition</name></type> <name><name>definitions</name><index>[<expr><name>_END_COMPRESSION_ALGORITHMS</name></expr>]</index></name> <init>= <expr><block>{
	<expr><index>[<expr><name>COMPRESSION_ALGORITHM_ARRAY</name></expr>]</index> <operator>=</operator> <name>ARRAY_ALGORITHM_DEFINITION</name></expr>,
	<expr><index>[<expr><name>COMPRESSION_ALGORITHM_DICTIONARY</name></expr>]</index> <operator>=</operator> <name>DICTIONARY_ALGORITHM_DEFINITION</name></expr>,
	<expr><index>[<expr><name>COMPRESSION_ALGORITHM_GORILLA</name></expr>]</index> <operator>=</operator> <name>GORILLA_ALGORITHM_DEFINITION</name></expr>,
	<expr><index>[<expr><name>COMPRESSION_ALGORITHM_DELTADELTA</name></expr>]</index> <operator>=</operator> <name>DELTA_DELTA_ALGORITHM_DEFINITION</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>Compressor</name> <modifier>*</modifier></type>
<name>compressor_for_algorithm_and_type</name><parameter_list>(<parameter><decl><type><name>CompressionAlgorithms</name></type> <name>algorithm</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>algorithm</name> <operator>&gt;=</operator> <name>_END_COMPRESSION_ALGORITHMS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid compression algorithm %d"</literal></expr></argument>, <argument><expr><name>algorithm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name><name>definitions</name><index>[<expr><name>algorithm</name></expr>]</index></name><operator>.</operator><call><name>compressor_for_type</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<macro><name>DecompressionIterator</name></macro> <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>*</operator><macro><name>tsl_get_decompression_iterator_init</name><argument_list>(<argument>CompressionAlgorithms algorithm</argument>,
															 <argument>bool reverse</argument>)</argument_list></macro><operator>)</operator><operator>(</operator><name>Datum</name><operator>,</operator> <name>Oid</name><operator>)</operator>
<block>{
	<if_stmt><if>if <condition>(<expr><name>algorithm</name> <operator>&gt;=</operator> <name>_END_COMPRESSION_ALGORITHMS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid compression algorithm %d"</literal></expr></argument>, <argument><expr><name>algorithm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block></expr></expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>reverse</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>definitions</name><index>[<expr><name>algorithm</name></expr>]</index></name><operator>.</operator><name>iterator_init_reverse</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name><name>definitions</name><index>[<expr><name>algorithm</name></expr>]</index></name><operator>.</operator><name>iterator_init_forward</name></expr>;</return></block_content></block></else></if_stmt>
}

typedef <struct>struct <name>SegmentInfo</name>
<block>{
	<decl_stmt><decl><type><name>Datum</name></type> <name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name></type> <name>eq_fn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FunctionCallInfo</name></type> <name>eq_fcinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type> <name>typlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>is_null</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>typ_by_val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>collation</name></decl>;</decl_stmt>
}</block> <decl><name>SegmentInfo</name></decl>;</struct>

<typedef>typedef <type><struct>struct <name>PerColumn</name>
<block>{
	<comment type="block">/* the compressor to use for regular columns, NULL for segmenters */</comment>
	<decl_stmt><decl><type><name>Compressor</name> <modifier>*</modifier></type><name>compressor</name></decl>;</decl_stmt>
	<comment type="block">/*
	 * Information on the metadata we'll store for this column (currently only min/max).
	 * Only used for order-by columns right now, will be {-1, NULL} for others.
	 */</comment>
	<decl_stmt><decl><type><name>int16</name></type> <name>min_metadata_attr_offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type> <name>max_metadata_attr_offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SegmentMetaMinMaxBuilder</name> <modifier>*</modifier></type><name>min_max_metadata_builder</name></decl>;</decl_stmt>

	<comment type="block">/* segment info; only used if compressor is NULL */</comment>
	<decl_stmt><decl><type><name>SegmentInfo</name> <modifier>*</modifier></type><name>segment_info</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type> <name>segmentby_column_index</name></decl>;</decl_stmt>
}</block></struct></type> <name>PerColumn</name>;</typedef>

<typedef>typedef <type><struct>struct <name>RowCompressor</name>
<block>{
	<comment type="block">/* memory context reset per-row is stored */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>per_row_ctx</name></decl>;</decl_stmt>

	<comment type="block">/* the table we're writing the compressed data to */</comment>
	<decl_stmt><decl><type><name>Relation</name></type> <name>compressed_table</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BulkInsertState</name></type> <name>bistate</name></decl>;</decl_stmt>
	<comment type="block">/* segment by index Oid if any */</comment>
	<decl_stmt><decl><type><name>Oid</name></type> <name>index_oid</name></decl>;</decl_stmt>

	<comment type="block">/* in theory we could have more input columns than outputted ones, so we
	   store the number of inputs/compressors seperately*/</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>n_input_columns</name></decl>;</decl_stmt>

	<comment type="block">/* info about each column */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>PerColumn</name></name> <modifier>*</modifier></type><name>per_column</name></decl>;</decl_stmt>

	<comment type="block">/* the order of columns in the compressed data need not match the order in the
	 * uncompressed. This array maps each attribute offset in the uncompressed
	 * data to the corresponding one in the compressed
	 */</comment>
	<decl_stmt><decl><type><name>int16</name> <modifier>*</modifier></type><name>uncompressed_col_to_compressed_col</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type> <name>count_metadata_column_offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type> <name>sequence_num_metadata_column_offset</name></decl>;</decl_stmt>

	<comment type="block">/* the number of uncompressed rows compressed into the current compressed row */</comment>
	<decl_stmt><decl><type><name>uint32</name></type> <name>rows_compressed_into_current_value</name></decl>;</decl_stmt>
	<comment type="block">/* a unique monotonically increasing (according to order by) id for each compressed row */</comment>
	<decl_stmt><decl><type><name>int32</name></type> <name>sequence_num</name></decl>;</decl_stmt>

	<comment type="block">/* cached arrays used to build the HeapTuple */</comment>
	<decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>compressed_values</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>compressed_is_null</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>rowcnt_pre_compression</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>num_compressed_rows</name></decl>;</decl_stmt>
}</block></struct></type> <name>RowCompressor</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>int16</name> <modifier>*</modifier></type><name>compress_chunk_populate_keys</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>in_table</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ColumnCompressionInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>columns</name></decl></parameter>,
										   <parameter><decl><type><name>int</name></type> <name>n_columns</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>n_keys_out</name></decl></parameter>,
										   <parameter><decl><type><specifier>const</specifier> <name>ColumnCompressionInfo</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>keys_out</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Tuplesortstate</name> <modifier>*</modifier></type><name>compress_chunk_sort_relation</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>in_rel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n_keys</name></decl></parameter>,
													<parameter><decl><type><specifier>const</specifier> <name>ColumnCompressionInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>keys</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>row_compressor_init</name><parameter_list>(<parameter><decl><type><name>RowCompressor</name> <modifier>*</modifier></type><name>row_compressor</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>uncompressed_tuple_desc</name></decl></parameter>,
								<parameter><decl><type><name>Relation</name></type> <name>compressed_table</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>num_compression_infos</name></decl></parameter>,
								<parameter><decl><type><specifier>const</specifier> <name>ColumnCompressionInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>column_compression_info</name></decl></parameter>,
								<parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>column_offsets</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>num_columns_in_compressed_table</name></decl></parameter>,
								<parameter><decl><type><name>bool</name></type> <name>need_bistate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>row_compressor_append_sorted_rows</name><parameter_list>(<parameter><decl><type><name>RowCompressor</name> <modifier>*</modifier></type><name>row_compressor</name></decl></parameter>,
											  <parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>sorted_rel</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>sorted_desc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>row_compressor_finish</name><parameter_list>(<parameter><decl><type><name>RowCompressor</name> <modifier>*</modifier></type><name>row_compressor</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block" format="doxygen">/********************
 ** compress_chunk **
 ********************/</comment>

<function><type><specifier>static</specifier> <name>CompressedDataHeader</name> <modifier>*</modifier></type>
<name>get_compressed_data_header</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CompressedDataHeader</name> <modifier>*</modifier></type><name>header</name> <init>= <expr><operator>(</operator><name>CompressedDataHeader</name> <operator>*</operator><operator>)</operator> <call><name>PG_DETOAST_DATUM</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>header</name><operator>-&gt;</operator><name>compression_algorithm</name></name> <operator>&gt;=</operator> <name>_END_COMPRESSION_ALGORITHMS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid compression algorithm %d"</literal></expr></argument>, <argument><expr><name><name>header</name><operator>-&gt;</operator><name>compression_algorithm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>header</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>capture_pgclass_stats</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>table_oid</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>out_pages</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>out_visible</name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>out_tuples</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type> <name>pg_class</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name> <init>= <expr><call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>table_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>classform</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find tuple for relation %u"</literal></expr></argument>, <argument><expr><name>table_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>classform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>out_pages</name> <operator>=</operator> <name><name>classform</name><operator>-&gt;</operator><name>relpages</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>out_visible</name> <operator>=</operator> <name><name>classform</name><operator>-&gt;</operator><name>relallvisible</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>out_tuples</name> <operator>=</operator> <name><name>classform</name><operator>-&gt;</operator><name>reltuples</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pg_class</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>restore_pgclass_stats</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>table_oid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pages</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>visible</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>tuples</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type> <name>pg_class</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>classform</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>pg_class</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>table_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find tuple for relation %u"</literal></expr></argument>, <argument><expr><name>table_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>classform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>classform</name><operator>-&gt;</operator><name>relpages</name></name> <operator>=</operator> <name>pages</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>classform</name><operator>-&gt;</operator><name>relallvisible</name></name> <operator>=</operator> <name>visible</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>classform</name><operator>-&gt;</operator><name>reltuples</name></name> <operator>=</operator> <name>tuples</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>pg_class</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pg_class</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Merge the relstats when merging chunks while compressing them.
 * We need to do this in order to update the relstats of the chunk
 * that is merged into since the compressed one will be dropped by
 * the merge.
 */</comment>
<function><type><specifier>extern</specifier> <name>void</name></type>
<name>merge_chunk_relstats</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>merged_relid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>compressed_relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>comp_pages</name></decl>, <decl><type ref="prev"/><name>merged_pages</name></decl>, <decl><type ref="prev"/><name>comp_visible</name></decl>, <decl><type ref="prev"/><name>merged_visible</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float</name></type> <name>comp_tuples</name></decl>, <decl><type ref="prev"/><name>merged_tuples</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>capture_pgclass_stats</name><argument_list>(<argument><expr><name>compressed_relid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>comp_pages</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>comp_visible</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>comp_tuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>capture_pgclass_stats</name><argument_list>(<argument><expr><name>merged_relid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>merged_pages</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>merged_visible</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>merged_tuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>merged_pages</name> <operator>+=</operator> <name>comp_pages</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>merged_visible</name> <operator>+=</operator> <name>comp_visible</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>merged_tuples</name> <operator>+=</operator> <name>comp_tuples</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>restore_pgclass_stats</name><argument_list>(<argument><expr><name>merged_relid</name></expr></argument>, <argument><expr><name>merged_pages</name></expr></argument>, <argument><expr><name>merged_visible</name></expr></argument>, <argument><expr><name>merged_tuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Truncate the relation WITHOUT applying triggers. This is the
 * main difference with ExecuteTruncate. Triggers aren't applied
 * because the data remains, just in compressed form. Also don't
 * restart sequences. Use the transactional branch through ExecuteTruncate.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>truncate_relation</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>table_oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>fks</name> <init>= <expr><call><name>heap_truncate_find_FKs</name><argument_list>(<argument><expr><call><name>list_make1_oid</name><argument_list>(<argument><expr><name>table_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="block">/* Take an access exclusive lock now. Note that this may very well
	 *  be a lock upgrade. */</comment>
	<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>table_oid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>toast_relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>pages</name></decl>, <decl><type ref="prev"/><name>visible</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float</name></type> <name>tuples</name></decl>;</decl_stmt>

	<comment type="block">/* Chunks should never have fks into them, but double check */</comment>
	<if_stmt><if>if <condition>(<expr><name>fks</name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"found a FK into a chunk while truncating"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>CheckTableForSerializableConflictIn</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>capture_pgclass_stats</name><argument_list>(<argument><expr><name>table_oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pages</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>visible</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RelationSetNewRelfilenode</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>toast_relid</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>toast_relid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>toast_relid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>RelationSetNewRelfilenode</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>!=</operator> <name>RELPERSISTENCE_UNLOGGED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_LT</name></expr></cpp:if>
	<decl_stmt><decl><type><name>int</name></type> <name>options</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<decl_stmt><decl><type><name>ReindexParams</name></type> <name>params</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ReindexParams</name> <modifier>*</modifier></type><name>options</name> <init>= <expr><operator>&amp;</operator><name>params</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>reindex_relation</name><argument_list>(<argument><expr><name>table_oid</name></expr></argument>, <argument><expr><name>REINDEX_REL_PROCESS_TOAST</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>table_oid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>restore_pgclass_stats</name><argument_list>(<argument><expr><name>table_oid</name></expr></argument>, <argument><expr><name>pages</name></expr></argument>, <argument><expr><name>visible</name></expr></argument>, <argument><expr><name>tuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>CompressionStats</name></type>
<name>compress_chunk</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>in_table</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>out_table</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ColumnCompressionInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>column_compression_info</name></decl></parameter>,
			   <parameter><decl><type><name>int</name></type> <name>num_compression_infos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>n_keys</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ColumnCompressionInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>keys</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CompressionStats</name></type> <name>cstat</name></decl>;</decl_stmt>

	<comment type="block">/* We want to prevent other compressors from compressing this table,
	 * and we want to prevent INSERTs or UPDATEs which could mess up our compression.
	 * We may as well allow readers to keep reading the uncompressed data while
	 * we are compressing, so we only take an ExclusiveLock instead of AccessExclusive.
	 */</comment>
	<decl_stmt><decl><type><name>Relation</name></type> <name>in_rel</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>in_table</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="block">/* We are _just_ INSERTing into the out_table so in principle we could take
	 * a RowExclusive lock, and let other operations read and write this table
	 * as we work. However, we currently compress each table as a oneshot, so
	 * we're taking the stricter lock to prevent accidents.
	 */</comment>
	<decl_stmt><decl><type><name>Relation</name></type> <name>out_rel</name> <init>= <expr><call><name>relation_open</name><argument_list>(<argument><expr><name>out_table</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name> <modifier>*</modifier></type><name>in_column_offsets</name> <init>= <expr><call><name>compress_chunk_populate_keys</name><argument_list>(<argument><expr><name>in_table</name></expr></argument>,
															<argument><expr><name>column_compression_info</name></expr></argument>,
															<argument><expr><name>num_compression_infos</name></expr></argument>,
															<argument><expr><operator>&amp;</operator><name>n_keys</name></expr></argument>,
															<argument><expr><operator>&amp;</operator><name>keys</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>in_desc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>in_rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>out_desc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>out_rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>sorted_rel</name> <init>= <expr><call><name>compress_chunk_sort_relation</name><argument_list>(<argument><expr><name>in_rel</name></expr></argument>, <argument><expr><name>n_keys</name></expr></argument>, <argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>RowCompressor</name></type> <name>row_compressor</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>num_compression_infos</name> <operator>&lt;=</operator> <name><name>in_desc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>num_compression_infos</name> <operator>&lt;=</operator> <name><name>out_desc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>row_compressor_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>row_compressor</name></expr></argument>,
						<argument><expr><name>in_desc</name></expr></argument>,
						<argument><expr><name>out_rel</name></expr></argument>,
						<argument><expr><name>num_compression_infos</name></expr></argument>,
						<argument><expr><name>column_compression_info</name></expr></argument>,
						<argument><expr><name>in_column_offsets</name></expr></argument>,
						<argument><expr><name><name>out_desc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>,
						<argument><expr><name>true</name></expr></argument> <comment type="block">/*need_bistate*/</comment>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>row_compressor_append_sorted_rows</name><argument_list>(<argument><expr><operator>&amp;</operator><name>row_compressor</name></expr></argument>, <argument><expr><name>sorted_rel</name></expr></argument>, <argument><expr><name>in_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>row_compressor_finish</name><argument_list>(<argument><expr><operator>&amp;</operator><name>row_compressor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>tuplesort_end</name><argument_list>(<argument><expr><name>sorted_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>truncate_relation</name><argument_list>(<argument><expr><name>in_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Recreate all indexes on out rel, we already have an exclusive lock on it,
	 * so the strong locks taken by reindex_relation shouldn't matter. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_LT</name></expr></cpp:if>
	<decl_stmt><decl><type><name>int</name></type> <name>options</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<decl_stmt><decl><type><name>ReindexParams</name></type> <name>params</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ReindexParams</name> <modifier>*</modifier></type><name>options</name> <init>= <expr><operator>&amp;</operator><name>params</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>reindex_relation</name><argument_list>(<argument><expr><name>out_table</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>out_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>in_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cstat</name><operator>.</operator><name>rowcnt_pre_compression</name></name> <operator>=</operator> <name><name>row_compressor</name><operator>.</operator><name>rowcnt_pre_compression</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cstat</name><operator>.</operator><name>rowcnt_post_compression</name></name> <operator>=</operator> <name><name>row_compressor</name><operator>.</operator><name>num_compressed_rows</name></name></expr>;</expr_stmt>
	<return>return <expr><name>cstat</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int16</name> <modifier>*</modifier></type>
<name>compress_chunk_populate_keys</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>in_table</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ColumnCompressionInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>columns</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n_columns</name></decl></parameter>,
							 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>n_keys_out</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ColumnCompressionInfo</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>keys_out</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int16</name> <modifier>*</modifier></type><name>column_offsets</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>column_offsets</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>n_columns</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>n_segment_keys</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><operator>*</operator><name>n_keys_out</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n_columns</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>COMPRESSIONCOL_IS_SEGMENT_BY</name><argument_list>(<argument><expr><name><name>columns</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>n_segment_keys</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>COMPRESSIONCOL_IS_SEGMENT_BY</name><argument_list>(<argument><expr><name><name>columns</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>COMPRESSIONCOL_IS_ORDER_BY</name><argument_list>(<argument><expr><name><name>columns</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>n_keys_out</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>n_keys_out</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"compression should be configured with an orderby or segment by"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>keys_out</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><operator>*</operator><name>keys_out</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>*</operator><name>n_keys_out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n_columns</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>ColumnCompressionInfo</name> <modifier>*</modifier></type><name>column</name> <init>= <expr><name><name>columns</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<comment type="block">/* valid values for segmentby_columnn_index and orderby_column_index
		   are &gt; 0 */</comment>
		<decl_stmt><decl><type><name>int16</name></type> <name>segment_offset</name> <init>= <expr><name><name>column</name><operator>-&gt;</operator><name>segmentby_column_index</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int16</name></type> <name>orderby_offset</name> <init>= <expr><name><name>column</name><operator>-&gt;</operator><name>orderby_column_index</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type> <name>compressed_att</name></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>COMPRESSIONCOL_IS_SEGMENT_BY</name><argument_list>(<argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>(</operator><operator>*</operator><name>keys_out</name><operator>)</operator><index>[<expr><name>segment_offset</name></expr>]</index> <operator>=</operator> <name>column</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>COMPRESSIONCOL_IS_ORDER_BY</name><argument_list>(<argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>(</operator><operator>*</operator><name>keys_out</name><operator>)</operator><index>[<expr><name>n_segment_keys</name> <operator>+</operator> <name>orderby_offset</name></expr>]</index> <operator>=</operator> <name>column</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>compressed_att</name> <operator>=</operator> <call><name>get_attnum</name><argument_list>(<argument><expr><name>in_table</name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>column</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AttributeNumberIsValid</name><argument_list>(<argument><expr><name>compressed_att</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find compressed column for \"%s\""</literal></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>column</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>column_offsets</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>compressed_att</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>column_offsets</name></expr>;</return>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>compress_chunk_populate_sort_info_for_column</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>table</name></decl></parameter>,
														 <parameter><decl><type><specifier>const</specifier> <name>ColumnCompressionInfo</name> <modifier>*</modifier></type><name>column</name></decl></parameter>,
														 <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>att_nums</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>sort_operator</name></decl></parameter>,
														 <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>collation</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls_first</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>run_analyze_on_chunk</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>chunk_relid</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>Tuplesortstate</name> <modifier>*</modifier></type>
<name>compress_chunk_sort_relation</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>in_rel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n_keys</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ColumnCompressionInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>keys</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupDesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>in_rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>tuplesortstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TableScanDesc</name></type> <name>heapScan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>heap_tuple_slot</name> <init>= <expr><call><name>MakeTupleTableSlot</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>TTSOpsHeapTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>sort_keys</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>sort_keys</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>n_keys</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>sort_operators</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>sort_operators</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>n_keys</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>sort_collations</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>sort_collations</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>n_keys</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls_first</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>nulls_first</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>n_keys</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name>n_keys</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>compress_chunk_populate_sort_info_for_column</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>in_rel</name></expr></argument>)</argument_list></call></expr></argument>,
													 <argument><expr><name><name>keys</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>,
													 <argument><expr><operator>&amp;</operator><name><name>sort_keys</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>,
													 <argument><expr><operator>&amp;</operator><name><name>sort_operators</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>,
													 <argument><expr><operator>&amp;</operator><name><name>sort_collations</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>,
													 <argument><expr><operator>&amp;</operator><name><name>nulls_first</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><name>tuplesortstate</name> <operator>=</operator> <call><name>tuplesort_begin_heap</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>,
										  <argument><expr><name>n_keys</name></expr></argument>,
										  <argument><expr><name>sort_keys</name></expr></argument>,
										  <argument><expr><name>sort_operators</name></expr></argument>,
										  <argument><expr><name>sort_collations</name></expr></argument>,
										  <argument><expr><name>nulls_first</name></expr></argument>,
										  <argument><expr><name>maintenance_work_mem</name></expr></argument>,
										  <argument><expr><name>NULL</name></expr></argument>,
										  <argument><expr><name>false</name></expr></argument> <comment type="block">/*=randomAccess*/</comment>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>heapScan</name> <operator>=</operator> <call><name>table_beginscan</name><argument_list>(<argument><expr><name>in_rel</name></expr></argument>, <argument><expr><call><name>GetLatestSnapshot</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>ScanKey</name><operator>)</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>tuple</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>heapScan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>tuple</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
		 <incr><expr><name>tuple</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>heapScan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*    This may not be the most efficient way to do things.
			 *     Since we use begin_heap() the tuplestore expects tupleslots,
			 *      so ISTM that the options are this or maybe putdatum().
			 */</comment>
			<expr_stmt><expr><call><name>ExecStoreHeapTuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>heap_tuple_slot</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>tuplesort_puttupleslot</name><argument_list>(<argument><expr><name>tuplesortstate</name></expr></argument>, <argument><expr><name>heap_tuple_slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>heap_endscan</name><argument_list>(<argument><expr><name>heapScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Perform an analyze on the chunk to get up-to-date stats before compressing.
	 * We do it at this point because we've just read out the entire chunk into
	 * tuplesort, so its pages are likely to be cached and we can save on I/O.
	 */</comment>
	<expr_stmt><expr><call><name>run_analyze_on_chunk</name><argument_list>(<argument><expr><name><name>in_rel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name>heap_tuple_slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>tuplesort_performsort</name><argument_list>(<argument><expr><name>tuplesortstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>tuplesortstate</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>compress_chunk_populate_sort_info_for_column</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>table</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ColumnCompressionInfo</name> <modifier>*</modifier></type><name>column</name></decl></parameter>,
											 <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>att_nums</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>sort_operator</name></decl></parameter>,
											 <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>collation</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls_first</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att_tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>tentry</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCacheAttName</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>column</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			 <argument><expr><literal type="string">"table \"%s\" does not have column \"%s\""</literal></expr></argument>,
			 <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr></argument>,
			 <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>column</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>att_tup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Other valdation checks beyond just existence of a valid comparison operator could be useful
	 */</comment>

	<expr_stmt><expr><operator>*</operator><name>att_nums</name> <operator>=</operator> <name><name>att_tup</name><operator>-&gt;</operator><name>attnum</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>collation</name> <operator>=</operator> <name><name>att_tup</name><operator>-&gt;</operator><name>attcollation</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>nulls_first</name> <operator>=</operator> <operator>(</operator><operator>!</operator><operator>(</operator><call><name>COMPRESSIONCOL_IS_SEGMENT_BY</name><argument_list>(<argument><expr><name>column</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>column</name><operator>-&gt;</operator><name>orderby_nullsfirst</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>tentry</name> <operator>=</operator> <call><name>lookup_type_cache</name><argument_list>(<argument><expr><name><name>att_tup</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>, <argument><expr><name>TYPECACHE_LT_OPR</name> <operator>|</operator> <name>TYPECACHE_GT_OPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>COMPRESSIONCOL_IS_SEGMENT_BY</name><argument_list>(<argument><expr><name>column</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>column</name><operator>-&gt;</operator><name>orderby_asc</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>sort_operator</name> <operator>=</operator> <name><name>tentry</name><operator>-&gt;</operator><name>lt_opr</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>sort_operator</name> <operator>=</operator> <name><name>tentry</name><operator>-&gt;</operator><name>gt_opr</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><operator>*</operator><name>sort_operator</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			 <argument><expr><literal type="string">"no valid sort operator for column \"%s\" of type \"%s\""</literal></expr></argument>,
			 <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>column</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>,
			 <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>att_tup</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>run_analyze_on_chunk</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>chunk_relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>VacuumRelation</name></type> <name>vr</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>T_VacuumRelation</name></expr>,
		<expr><operator>.</operator><name>relation</name> <operator>=</operator> <name>NULL</name></expr>,
		<expr><operator>.</operator><name>oid</name> <operator>=</operator> <name>chunk_relid</name></expr>,
		<expr><operator>.</operator><name>va_cols</name> <operator>=</operator> <name>NIL</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VacuumStmt</name></type> <name>vs</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>T_VacuumStmt</name></expr>,
		<expr><operator>.</operator><name>rels</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vr</name></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>is_vacuumcmd</name> <operator>=</operator> <name>false</name></expr>,
		<expr><operator>.</operator><name>options</name> <operator>=</operator> <name>NIL</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ExecVacuum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vs</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/********************
 ** row_compressor **
 ********************/</comment>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>row_compressor_update_group</name><parameter_list>(<parameter><decl><type><name>RowCompressor</name> <modifier>*</modifier></type><name>row_compressor</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>row</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>row_compressor_new_row_is_in_new_group</name><parameter_list>(<parameter><decl><type><name>RowCompressor</name> <modifier>*</modifier></type><name>row_compressor</name></decl></parameter>,
												   <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>row</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>row_compressor_append_row</name><parameter_list>(<parameter><decl><type><name>RowCompressor</name> <modifier>*</modifier></type><name>row_compressor</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>row</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>row_compressor_flush</name><parameter_list>(<parameter><decl><type><name>RowCompressor</name> <modifier>*</modifier></type><name>row_compressor</name></decl></parameter>, <parameter><decl><type><name>CommandId</name></type> <name>mycid</name></decl></parameter>,
								 <parameter><decl><type><name>bool</name></type> <name>changed_groups</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>SegmentInfo</name> <modifier>*</modifier></type><name>segment_info_new</name><parameter_list>(<parameter><decl><type><name>Form_pg_attribute</name></type> <name>column_attr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>segment_info_update</name><parameter_list>(<parameter><decl><type><name>SegmentInfo</name> <modifier>*</modifier></type><name>segment_info</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_null</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>segment_info_datum_is_in_group</name><parameter_list>(<parameter><decl><type><name>SegmentInfo</name> <modifier>*</modifier></type><name>segment_info</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>datum</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_null</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Find segment by index for setting the correct sequence number if
 * we are trying to roll up chunks while compressing
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>get_compressed_chunk_index</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>compressed_chunk</name></decl></parameter>, <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>uncompressed_col_to_compressed_col</name></decl></parameter>,
						   <parameter><decl><type><name>PerColumn</name> <modifier>*</modifier></type><name>per_column</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n_input_columns</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>index_oids</name> <init>= <expr><call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>compressed_chunk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>index_oids</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>index_oid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>matches</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>num_segmentby_columns</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type> <name>index_rel</name> <init>= <expr><call><name>index_open</name><argument_list>(<argument><expr><name>index_oid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>index_info</name> <init>= <expr><call><name>BuildIndexInfo</name><argument_list>(<argument><expr><name>index_rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n_input_columns</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>per_column</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>segmentby_column_index</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/* Last member of the index must be the sequence number column. */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>per_column</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>segmentby_column_index</name> <operator>&gt;=</operator> <name><name>index_rel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>matches</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>

			<decl_stmt><decl><type><name>int</name></type> <name>index_att_offset</name> <init>= <expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name><name>per_column</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>segmentby_column_index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>index_info</name><operator>-&gt;</operator><name>ii_IndexAttrNumbers</name><index>[<expr><name>index_att_offset</name></expr>]</index></name> <operator>!=</operator>
				<call><name>AttrOffsetGetAttrNumber</name><argument_list>(<argument><expr><name><name>uncompressed_col_to_compressed_col</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>matches</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>num_segmentby_columns</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/* Check that we have the correct number of index attributes
		 * and that the last one is the sequence number
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>num_segmentby_columns</name> <operator>!=</operator> <name><name>index_rel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name> <operator>-</operator> <literal type="number">1</literal> <operator>||</operator>
			<call><name>namestrcmp</name><argument_list>(<argument><expr><operator>(</operator><name>Name</name><operator>)</operator> <operator>&amp;</operator><name><name>index_rel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>num_segmentby_columns</name></expr>]</index></name><operator>.</operator><name>attname</name></expr></argument>,
					   <argument><expr><name>COMPRESSION_COLUMN_METADATA_SEQUENCE_NUM_NAME</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>matches</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>index_rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>matches</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>index_oid</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>InvalidOid</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32</name></type>
<name>index_scan_sequence_number</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>table_rel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>index_oid</name></decl></parameter>, <parameter><decl><type><name>ScanKeyData</name> <modifier>*</modifier></type><name>scankey</name></decl></parameter>,
						   <parameter><decl><type><name>int</name></type> <name>num_scankeys</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type> <name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>is_null</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>index_rel</name> <init>= <expr><call><name>index_open</name><argument_list>(<argument><expr><name>index_oid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>RelationInitIndexAccessInfo</name><argument_list>(<argument><expr><name>index_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>IndexScanDesc</name></type> <name>index_scan</name> <init>=
		<expr><call><name>index_beginscan</name><argument_list>(<argument><expr><name>table_rel</name></expr></argument>, <argument><expr><name>index_rel</name></expr></argument>, <argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>num_scankeys</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>index_scan</name><operator>-&gt;</operator><name>xs_want_itup</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>index_rescan</name><argument_list>(<argument><expr><name>index_scan</name></expr></argument>, <argument><expr><name>scankey</name></expr></argument>, <argument><expr><name>num_scankeys</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>index_getnext_tid</name><argument_list>(<argument><expr><name>index_scan</name></expr></argument>, <argument><expr><name>BackwardScanDirection</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>index_getattr</name><argument_list>(<argument><expr><name><name>index_scan</name><operator>-&gt;</operator><name>xs_itup</name></name></expr></argument>,
							   <argument><expr><name><name>index_scan</name><operator>-&gt;</operator><name>xs_itupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>-</operator>
								   <literal type="number">1</literal></expr></argument>, <comment type="block">/* Last attribute of the index is sequence number. */</comment>
							   <argument><expr><name><name>index_scan</name><operator>-&gt;</operator><name>xs_itupdesc</name></name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>is_null</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>index_endscan</name><argument_list>(<argument><expr><name>index_scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>index_rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32</name></type>
<name>table_scan_sequence_number</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>table_rel</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>seq_num_column_num</name></decl></parameter>, <parameter><decl><type><name>ScanKeyData</name> <modifier>*</modifier></type><name>scankey</name></decl></parameter>,
						   <parameter><decl><type><name>int</name></type> <name>num_scankeys</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type> <name>curr_seq_num</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>max_seq_num</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>is_null</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>compressed_tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>seq_num</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>in_desc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>table_rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>TableScanDesc</name></type> <name>heap_scan</name> <init>=
		<expr><call><name>table_beginscan</name><argument_list>(<argument><expr><name>table_rel</name></expr></argument>, <argument><expr><call><name>GetLatestSnapshot</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>num_scankeys</name></expr></argument>, <argument><expr><name>scankey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>compressed_tuple</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>heap_scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>compressed_tuple</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
		 <incr><expr><name>compressed_tuple</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>heap_scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>compressed_tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>seq_num</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>compressed_tuple</name></expr></argument>, <argument><expr><name>seq_num_column_num</name></expr></argument>, <argument><expr><name>in_desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_null</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>curr_seq_num</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>seq_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>max_seq_num</name> <operator>&lt;</operator> <name>curr_seq_num</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>max_seq_num</name> <operator>=</operator> <name>curr_seq_num</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>heap_endscan</name><argument_list>(<argument><expr><name>heap_scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>max_seq_num</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Scan compressed chunk to get the sequence number for current group.
 * This is necessary to do when merging chunks. If the chunk is empty,
 * scan will always return 0 and the sequence number will start from
 * SEQUENCE_NUM_GAP.
 */</comment>
<function><type><specifier>static</specifier> <name>int32</name></type>
<name>get_sequence_number_for_current_group</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>table_rel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>index_oid</name></decl></parameter>,
									  <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>uncompressed_col_to_compressed_col</name></decl></parameter>,
									  <parameter><decl><type><name>PerColumn</name> <modifier>*</modifier></type><name>per_column</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n_input_columns</name></decl></parameter>,
									  <parameter><decl><type><name>int16</name></type> <name>seq_num_column_num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* No point scanning an empty relation. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>table_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpages</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>SEQUENCE_NUM_GAP</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* If there is a suitable index, use index scan otherwise fallback to heap scan. */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>is_index_scan</name> <init>= <expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>index_oid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>num_scankeys</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n_input_columns</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>per_column</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>segmentby_column_index</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>num_scankeys</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>scan_ctx</name> <init>= <expr><call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
												   <argument><expr><literal type="string">"get max sequence number scan"</literal></expr></argument>,
												   <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_ctx</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>old_ctx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>scan_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ScanKeyData</name> <modifier>*</modifier></type><name>scankey</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>num_scankeys</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>scankey</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ScanKeyData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>num_scankeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n_input_columns</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>per_column</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>segmentby_column_index</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<decl_stmt><decl><type><name>PerColumn</name></type> <name>col</name> <init>= <expr><name><name>per_column</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int16</name></type> <name>attno</name> <init>= <expr><ternary><condition><expr><name>is_index_scan</name></expr> ?</condition><then>
							  <expr><name><name>col</name><operator>.</operator><name>segmentby_column_index</name></name></expr> </then><else>:
							  <expr><call><name>AttrOffsetGetAttrNumber</name><argument_list>(<argument><expr><name><name>uncompressed_col_to_compressed_col</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>col</name><operator>.</operator><name>segment_info</name><operator>-&gt;</operator><name>is_null</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ScanKeyEntryInitialize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scankey</name><index>[<expr><name><name>col</name><operator>.</operator><name>segmentby_column_index</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
									   <argument><expr><name>SK_ISNULL</name> <operator>|</operator> <name>SK_SEARCHNULL</name></expr></argument>,
									   <argument><expr><name>attno</name></expr></argument>,
									   <argument><expr><name>InvalidStrategy</name></expr></argument>, <comment type="block">/* no strategy */</comment>
									   <argument><expr><name>InvalidOid</name></expr></argument>,		<comment type="block">/* no strategy subtype */</comment>
									   <argument><expr><name>InvalidOid</name></expr></argument>,		<comment type="block">/* no collation */</comment>
									   <argument><expr><name>InvalidOid</name></expr></argument>,		<comment type="block">/* no reg proc for this */</comment>
									   <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* constant */</comment>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>ScanKeyEntryInitializeWithInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scankey</name><index>[<expr><name><name>col</name><operator>.</operator><name>segmentby_column_index</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
											   <argument><expr><literal type="number">0</literal></expr></argument>, <comment type="block">/* flags */</comment>
											   <argument><expr><name>attno</name></expr></argument>,
											   <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
											   <argument><expr><name>InvalidOid</name></expr></argument>, <comment type="block">/* No strategy subtype. */</comment>
											   <argument><expr><name><name>col</name><operator>.</operator><name>segment_info</name><operator>-&gt;</operator><name>collation</name></name></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name><name>col</name><operator>.</operator><name>segment_info</name><operator>-&gt;</operator><name>eq_fn</name></name></expr></argument>,
											   <argument><expr><name><name>col</name><operator>.</operator><name>segment_info</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_index_scan</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Index scan should always use at least one scan key to get the sequence number. */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>num_scankeys</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>index_scan_sequence_number</name><argument_list>(<argument><expr><name>table_rel</name></expr></argument>, <argument><expr><name>index_oid</name></expr></argument>, <argument><expr><name>scankey</name></expr></argument>, <argument><expr><name>num_scankeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Table scan can work without scan keys. */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>table_scan_sequence_number</name><argument_list>(<argument><expr><name>table_rel</name></expr></argument>, <argument><expr><name>seq_num_column_num</name></expr></argument>, <argument><expr><name>scankey</name></expr></argument>, <argument><expr><name>num_scankeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>scan_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name> <operator>+</operator> <name>SEQUENCE_NUM_GAP</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* num_compression_infos is the number of columns we will write to in the compressed table */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>row_compressor_init</name><parameter_list>(<parameter><decl><type><name>RowCompressor</name> <modifier>*</modifier></type><name>row_compressor</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>uncompressed_tuple_desc</name></decl></parameter>,
					<parameter><decl><type><name>Relation</name></type> <name>compressed_table</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>num_compression_infos</name></decl></parameter>,
					<parameter><decl><type><specifier>const</specifier> <name>ColumnCompressionInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>column_compression_info</name></decl></parameter>, <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>in_column_offsets</name></decl></parameter>,
					<parameter><decl><type><name>int16</name></type> <name>num_columns_in_compressed_table</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>need_bistate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>out_desc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>compressed_table</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>col</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Name</name></type> <name>count_metadata_name</name> <init>= <expr><call><name>DatumGetName</name><argument_list>(
		<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>namein</name></expr></argument>, <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>COMPRESSION_COLUMN_METADATA_COUNT_NAME</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Name</name></type> <name>sequence_num_metadata_name</name> <init>= <expr><call><name>DatumGetName</name><argument_list>(
		<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>namein</name></expr></argument>,
							<argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>COMPRESSION_COLUMN_METADATA_SEQUENCE_NUM_NAME</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type> <name>count_metadata_column_num</name> <init>=
		<expr><call><name>get_attnum</name><argument_list>(<argument><expr><name><name>compressed_table</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>count_metadata_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type> <name>sequence_num_column_num</name> <init>=
		<expr><call><name>get_attnum</name><argument_list>(<argument><expr><name><name>compressed_table</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>sequence_num_metadata_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>compressed_data_type_oid</name> <init>= <expr><call><name>ts_custom_type_cache_get</name><argument_list>(<argument><expr><name>CUSTOM_TYPE_COMPRESSED_DATA</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>type_oid</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>count_metadata_column_num</name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			 <argument><expr><literal type="string">"missing metadata column '%s' in compressed table"</literal></expr></argument>,
			 <argument><expr><name>COMPRESSION_COLUMN_METADATA_COUNT_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>sequence_num_column_num</name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			 <argument><expr><literal type="string">"missing metadata column '%s' in compressed table"</literal></expr></argument>,
			 <argument><expr><name>COMPRESSION_COLUMN_METADATA_SEQUENCE_NUM_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>row_compressor</name> <operator>=</operator> <operator>(</operator><name>RowCompressor</name><operator>)</operator><block>{
		<expr><operator>.</operator><name>per_row_ctx</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
											 <argument><expr><literal type="string">"compress chunk per-row"</literal></expr></argument>,
											 <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>compressed_table</name> <operator>=</operator> <name>compressed_table</name></expr>,
		<expr><operator>.</operator><name>bistate</name> <operator>=</operator> <name>need_bistate</name> <operator>?</operator> <call><name>GetBulkInsertState</name><argument_list>()</argument_list></call> <operator>:</operator> <name>NULL</name></expr>,
		<expr><operator>.</operator><name>n_input_columns</name> <operator>=</operator> <name><name>uncompressed_tuple_desc</name><operator>-&gt;</operator><name>natts</name></name></expr>,
		<expr><operator>.</operator><name>per_column</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PerColumn</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>uncompressed_tuple_desc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>uncompressed_col_to_compressed_col</name> <operator>=</operator>
			<call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>row_compressor</name><operator>-&gt;</operator><name>uncompressed_col_to_compressed_col</name></name></expr></argument>)</argument_list></sizeof> <operator>*</operator>
					<name><name>uncompressed_tuple_desc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>count_metadata_column_offset</name> <operator>=</operator> <call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>count_metadata_column_num</name></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>sequence_num_metadata_column_offset</name> <operator>=</operator> <call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>sequence_num_column_num</name></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>compressed_values</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>num_columns_in_compressed_table</name></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>compressed_is_null</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>num_columns_in_compressed_table</name></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>rows_compressed_into_current_value</name> <operator>=</operator> <literal type="number">0</literal></expr>,
		<expr><operator>.</operator><name>rowcnt_pre_compression</name> <operator>=</operator> <literal type="number">0</literal></expr>,
		<expr><operator>.</operator><name>num_compressed_rows</name> <operator>=</operator> <literal type="number">0</literal></expr>,
		<expr><operator>.</operator><name>sequence_num</name> <operator>=</operator> <name>SEQUENCE_NUM_GAP</name></expr>,
	}</block></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>row_compressor</name><operator>-&gt;</operator><name>compressed_is_null</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>num_columns_in_compressed_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>col</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>col</name> <operator>&lt;</operator> <name>num_compression_infos</name></expr>;</condition> <incr><expr><name>col</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>ColumnCompressionInfo</name> <modifier>*</modifier></type><name>compression_info</name> <init>= <expr><name><name>column_compression_info</name><index>[<expr><name>col</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<comment type="block">/* we want row_compressor.per_column to be in the same order as the underlying table */</comment>
		<decl_stmt><decl><type><name>int16</name></type> <name>in_column_offset</name> <init>= <expr><name><name>in_column_offsets</name><index>[<expr><name>col</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PerColumn</name> <modifier>*</modifier></type><name>column</name> <init>= <expr><operator>&amp;</operator><name><name>row_compressor</name><operator>-&gt;</operator><name>per_column</name><index>[<expr><name>in_column_offset</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>column_attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>uncompressed_tuple_desc</name></expr></argument>, <argument><expr><name>in_column_offset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type> <name>compressed_colnum</name> <init>=
			<expr><call><name>get_attnum</name><argument_list>(<argument><expr><name><name>compressed_table</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>compression_info</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>compressed_column_attr</name> <init>=
			<expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>out_desc</name></expr></argument>, <argument><expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>compressed_colnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>row_compressor</name><operator>-&gt;</operator><name>uncompressed_col_to_compressed_col</name><index>[<expr><name>in_column_offset</name></expr>]</index></name> <operator>=</operator>
			<call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>compressed_colnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>compressed_colnum</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>num_columns_in_compressed_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>COMPRESSIONCOL_IS_SEGMENT_BY</name><argument_list>(<argument><expr><name>compression_info</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int16</name></type> <name>segment_min_attr_offset</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int16</name></type> <name>segment_max_attr_offset</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>SegmentMetaMinMaxBuilder</name> <modifier>*</modifier></type><name>segment_min_max_builder</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>compressed_column_attr</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>!=</operator> <name>compressed_data_type_oid</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					 <argument><expr><literal type="string">"expected column '%s' to be a compressed data type"</literal></expr></argument>,
					 <argument><expr><name><name>compression_info</name><operator>-&gt;</operator><name>attname</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>compression_info</name><operator>-&gt;</operator><name>orderby_column_index</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>segment_min_col_name</name> <init>= <expr><call><name>compression_column_segment_min_name</name><argument_list>(<argument><expr><name>compression_info</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>segment_max_col_name</name> <init>= <expr><call><name>compression_column_segment_max_name</name><argument_list>(<argument><expr><name>compression_info</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>AttrNumber</name></type> <name>segment_min_attr_number</name> <init>=
					<expr><call><name>get_attnum</name><argument_list>(<argument><expr><name><name>compressed_table</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>, <argument><expr><name>segment_min_col_name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>AttrNumber</name></type> <name>segment_max_attr_number</name> <init>=
					<expr><call><name>get_attnum</name><argument_list>(<argument><expr><name><name>compressed_table</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>, <argument><expr><name>segment_max_col_name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><name>segment_min_attr_number</name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"couldn't find metadata column \"%s\""</literal></expr></argument>, <argument><expr><name>segment_min_col_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>segment_max_attr_number</name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"couldn't find metadata column \"%s\""</literal></expr></argument>, <argument><expr><name>segment_max_col_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>segment_min_attr_offset</name> <operator>=</operator> <call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>segment_min_attr_number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>segment_max_attr_offset</name> <operator>=</operator> <call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>segment_max_attr_number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>segment_min_max_builder</name> <operator>=</operator>
					<call><name>segment_meta_min_max_builder_create</name><argument_list>(<argument><expr><name><name>column_attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
														<argument><expr><name><name>column_attr</name><operator>-&gt;</operator><name>attcollation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><operator>*</operator><name>column</name> <operator>=</operator> <operator>(</operator><name>PerColumn</name><operator>)</operator><block>{
				<expr><operator>.</operator><name>compressor</name> <operator>=</operator> <call><name>compressor_for_algorithm_and_type</name><argument_list>(<argument><expr><name><name>compression_info</name><operator>-&gt;</operator><name>algo_id</name></name></expr></argument>,
																<argument><expr><name><name>column_attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>)</argument_list></call></expr>,
				<expr><operator>.</operator><name>min_metadata_attr_offset</name> <operator>=</operator> <name>segment_min_attr_offset</name></expr>,
				<expr><operator>.</operator><name>max_metadata_attr_offset</name> <operator>=</operator> <name>segment_max_attr_offset</name></expr>,
				<expr><operator>.</operator><name>min_max_metadata_builder</name> <operator>=</operator> <name>segment_min_max_builder</name></expr>,
				<expr><operator>.</operator><name>segmentby_column_index</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>,
			}</block></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>column_attr</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>!=</operator> <name><name>compressed_column_attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					 <argument><expr><literal type="string">"expected segment by column \"%s\" to be same type as uncompressed column"</literal></expr></argument>,
					 <argument><expr><name><name>compression_info</name><operator>-&gt;</operator><name>attname</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><operator>*</operator><name>column</name> <operator>=</operator> <operator>(</operator><name>PerColumn</name><operator>)</operator><block>{
				<expr><operator>.</operator><name>segment_info</name> <operator>=</operator> <call><name>segment_info_new</name><argument_list>(<argument><expr><name>column_attr</name></expr></argument>)</argument_list></call></expr>,
				<expr><operator>.</operator><name>segmentby_column_index</name> <operator>=</operator> <name><name>compression_info</name><operator>-&gt;</operator><name>segmentby_column_index</name></name></expr>,
				<expr><operator>.</operator><name>min_metadata_attr_offset</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>,
				<expr><operator>.</operator><name>max_metadata_attr_offset</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>,
			}</block></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name><name>row_compressor</name><operator>-&gt;</operator><name>index_oid</name></name> <operator>=</operator>
		<call><name>get_compressed_chunk_index</name><argument_list>(<argument><expr><name>compressed_table</name></expr></argument>,
								   <argument><expr><name><name>row_compressor</name><operator>-&gt;</operator><name>uncompressed_col_to_compressed_col</name></name></expr></argument>,
								   <argument><expr><name><name>row_compressor</name><operator>-&gt;</operator><name>per_column</name></name></expr></argument>,
								   <argument><expr><name><name>row_compressor</name><operator>-&gt;</operator><name>n_input_columns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>row_compressor_append_sorted_rows</name><parameter_list>(<parameter><decl><type><name>RowCompressor</name> <modifier>*</modifier></type><name>row_compressor</name></decl></parameter>, <parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>sorted_rel</name></decl></parameter>,
								  <parameter><decl><type><name>TupleDesc</name></type> <name>sorted_desc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CommandId</name></type> <name>mycid</name> <init>= <expr><call><name>GetCurrentCommandId</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><call><name>MakeTupleTableSlot</name><argument_list>(<argument><expr><name>sorted_desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>TTSOpsMinimalTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>got_tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>first_iteration</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>got_tuple</name> <operator>=</operator> <call><name>tuplesort_gettupleslot</name><argument_list>(<argument><expr><name>sorted_rel</name></expr></argument>,
											<argument><expr><name>true</name></expr></argument> <comment type="block">/*=forward*/</comment>,
											<argument><expr><name>false</name></expr></argument> <comment type="block">/*=copy*/</comment>,
											<argument><expr><name>slot</name></expr></argument>,
											<argument><expr><name>NULL</name></expr></argument> <comment type="block">/*=abbrev*/</comment>)</argument_list></call></expr>;</init>
		 <condition><expr><name>got_tuple</name></expr>;</condition>
		 <incr><expr><name>got_tuple</name> <operator>=</operator> <call><name>tuplesort_gettupleslot</name><argument_list>(<argument><expr><name>sorted_rel</name></expr></argument>,
											<argument><expr><name>true</name></expr></argument> <comment type="block">/*=forward*/</comment>,
											<argument><expr><name>false</name></expr></argument> <comment type="block">/*=copy*/</comment>,
											<argument><expr><name>slot</name></expr></argument>,
											<argument><expr><name>NULL</name></expr></argument> <comment type="block">/*=abbrev*/</comment>)</argument_list></call></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>changed_groups</name></decl>, <decl><type ref="prev"/><name>compressed_row_is_full</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_ctx</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>slot_getallattrs</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>old_ctx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>row_compressor</name><operator>-&gt;</operator><name>per_row_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* first time through */</comment>
		<if_stmt><if>if <condition>(<expr><name>first_iteration</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>row_compressor_update_group</name><argument_list>(<argument><expr><name>row_compressor</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>first_iteration</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>changed_groups</name> <operator>=</operator> <call><name>row_compressor_new_row_is_in_new_group</name><argument_list>(<argument><expr><name>row_compressor</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>compressed_row_is_full</name> <operator>=</operator>
			<name><name>row_compressor</name><operator>-&gt;</operator><name>rows_compressed_into_current_value</name></name> <operator>&gt;=</operator> <name>MAX_ROWS_PER_COMPRESSION</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>compressed_row_is_full</name> <operator>||</operator> <name>changed_groups</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>row_compressor</name><operator>-&gt;</operator><name>rows_compressed_into_current_value</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>row_compressor_flush</name><argument_list>(<argument><expr><name>row_compressor</name></expr></argument>, <argument><expr><name>mycid</name></expr></argument>, <argument><expr><name>changed_groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>changed_groups</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>row_compressor_update_group</name><argument_list>(<argument><expr><name>row_compressor</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>row_compressor_append_row</name><argument_list>(<argument><expr><name>row_compressor</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name><name>row_compressor</name><operator>-&gt;</operator><name>rows_compressed_into_current_value</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>row_compressor_flush</name><argument_list>(<argument><expr><name>row_compressor</name></expr></argument>, <argument><expr><name>mycid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>row_compressor_update_group</name><parameter_list>(<parameter><decl><type><name>RowCompressor</name> <modifier>*</modifier></type><name>row_compressor</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>row</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>col</name></decl>;</decl_stmt>
	<comment type="block">/* save original memory context */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><name>CurrentMemoryContext</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>row_compressor</name><operator>-&gt;</operator><name>rows_compressed_into_current_value</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>row_compressor</name><operator>-&gt;</operator><name>n_input_columns</name></name> <operator>&lt;=</operator> <name><name>row</name><operator>-&gt;</operator><name>tts_nvalid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>row_compressor</name><operator>-&gt;</operator><name>per_row_ctx</name><operator>-&gt;</operator><name>parent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>col</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>col</name> <operator>&lt;</operator> <name><name>row_compressor</name><operator>-&gt;</operator><name>n_input_columns</name></name></expr>;</condition> <incr><expr><name>col</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PerColumn</name> <modifier>*</modifier></type><name>column</name> <init>= <expr><operator>&amp;</operator><name><name>row_compressor</name><operator>-&gt;</operator><name>per_column</name><index>[<expr><name>col</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type> <name>val</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>is_null</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>column</name><operator>-&gt;</operator><name>segment_info</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>column</name><operator>-&gt;</operator><name>compressor</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Performance Improvment: We should just use array access here; everything is guaranteed to
		   be fetched */</comment>
		<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>row</name></expr></argument>, <argument><expr><call><name>AttrOffsetGetAttrNumber</name><argument_list>(<argument><expr><name>col</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>segment_info_update</name><argument_list>(<argument><expr><name><name>column</name><operator>-&gt;</operator><name>segment_info</name></name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* switch to original memory context */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The sequence number of the compressed tuple is per segment by grouping
	 * and should be reset when the grouping changes to prevent overflows with
	 * many segmentby columns.
	 *
	 */</comment>
	<expr_stmt><expr><name><name>row_compressor</name><operator>-&gt;</operator><name>sequence_num</name></name> <operator>=</operator>
		<call><name>get_sequence_number_for_current_group</name><argument_list>(<argument><expr><name><name>row_compressor</name><operator>-&gt;</operator><name>compressed_table</name></name></expr></argument>,
											  <argument><expr><name><name>row_compressor</name><operator>-&gt;</operator><name>index_oid</name></name></expr></argument>,
											  <argument><expr><name><name>row_compressor</name><operator>-&gt;</operator><name>uncompressed_col_to_compressed_col</name></name></expr></argument>,
											  <argument><expr><name><name>row_compressor</name><operator>-&gt;</operator><name>per_column</name></name></expr></argument>,
											  <argument><expr><name><name>row_compressor</name><operator>-&gt;</operator><name>n_input_columns</name></name></expr></argument>,
											  <argument><expr><call><name>AttrOffsetGetAttrNumber</name><argument_list>(
												  <argument><expr><name><name>row_compressor</name>
													  <operator>-&gt;</operator><name>sequence_num_metadata_column_offset</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>row_compressor_new_row_is_in_new_group</name><parameter_list>(<parameter><decl><type><name>RowCompressor</name> <modifier>*</modifier></type><name>row_compressor</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>row</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>col</name></decl>;</decl_stmt>
	<for>for <control>(<init><expr><name>col</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>col</name> <operator>&lt;</operator> <name><name>row_compressor</name><operator>-&gt;</operator><name>n_input_columns</name></name></expr>;</condition> <incr><expr><name>col</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PerColumn</name> <modifier>*</modifier></type><name>column</name> <init>= <expr><operator>&amp;</operator><name><name>row_compressor</name><operator>-&gt;</operator><name>per_column</name><index>[<expr><name>col</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type> <name>datum</name> <init>= <expr><call><name>CharGetDatum</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>is_null</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>column</name><operator>-&gt;</operator><name>segment_info</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>column</name><operator>-&gt;</operator><name>compressor</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>row</name></expr></argument>, <argument><expr><call><name>AttrOffsetGetAttrNumber</name><argument_list>(<argument><expr><name>col</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>segment_info_datum_is_in_group</name><argument_list>(<argument><expr><name><name>column</name><operator>-&gt;</operator><name>segment_info</name></name></expr></argument>, <argument><expr><name>datum</name></expr></argument>, <argument><expr><name>is_null</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>row_compressor_append_row</name><parameter_list>(<parameter><decl><type><name>RowCompressor</name> <modifier>*</modifier></type><name>row_compressor</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>row</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>col</name></decl>;</decl_stmt>
	<for>for <control>(<init><expr><name>col</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>col</name> <operator>&lt;</operator> <name><name>row_compressor</name><operator>-&gt;</operator><name>n_input_columns</name></name></expr>;</condition> <incr><expr><name>col</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Compressor</name> <modifier>*</modifier></type><name>compressor</name> <init>= <expr><name><name>row_compressor</name><operator>-&gt;</operator><name>per_column</name><index>[<expr><name>col</name></expr>]</index></name><operator>.</operator><name>compressor</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>is_null</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type> <name>val</name></decl>;</decl_stmt>

		<comment type="block">/* if there is no compressor, this must be a segmenter, so just skip */</comment>
		<if_stmt><if>if <condition>(<expr><name>compressor</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Performance Improvement: Since we call getallatts at the beginning, slot_getattr is
		 * useless overhead here, and we should just access the array directly.
		 */</comment>
		<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>row</name></expr></argument>, <argument><expr><call><name>AttrOffsetGetAttrNumber</name><argument_list>(<argument><expr><name>col</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>is_null</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name><name>compressor</name><operator>-&gt;</operator><name>append_null</name></name><argument_list>(<argument><expr><name>compressor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>row_compressor</name><operator>-&gt;</operator><name>per_column</name><index>[<expr><name>col</name></expr>]</index></name><operator>.</operator><name>min_max_metadata_builder</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>segment_meta_min_max_builder_update_null</name><argument_list>(
					<argument><expr><name><name>row_compressor</name><operator>-&gt;</operator><name>per_column</name><index>[<expr><name>col</name></expr>]</index></name><operator>.</operator><name>min_max_metadata_builder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name><name>compressor</name><operator>-&gt;</operator><name>append_val</name></name><argument_list>(<argument><expr><name>compressor</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>row_compressor</name><operator>-&gt;</operator><name>per_column</name><index>[<expr><name>col</name></expr>]</index></name><operator>.</operator><name>min_max_metadata_builder</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>segment_meta_min_max_builder_update_val</name><argument_list>(<argument><expr><name><name>row_compressor</name><operator>-&gt;</operator><name>per_column</name><index>[<expr><name>col</name></expr>]</index></name>
															<operator>.</operator><name>min_max_metadata_builder</name></expr></argument>,
														<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name><name>row_compressor</name><operator>-&gt;</operator><name>rows_compressed_into_current_value</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>row_compressor_flush</name><parameter_list>(<parameter><decl><type><name>RowCompressor</name> <modifier>*</modifier></type><name>row_compressor</name></decl></parameter>, <parameter><decl><type><name>CommandId</name></type> <name>mycid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>changed_groups</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int16</name></type> <name>col</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>compressed_tuple</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>col</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>col</name> <operator>&lt;</operator> <name><name>row_compressor</name><operator>-&gt;</operator><name>n_input_columns</name></name></expr>;</condition> <incr><expr><name>col</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PerColumn</name> <modifier>*</modifier></type><name>column</name> <init>= <expr><operator>&amp;</operator><name><name>row_compressor</name><operator>-&gt;</operator><name>per_column</name><index>[<expr><name>col</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Compressor</name> <modifier>*</modifier></type><name>compressor</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int16</name></type> <name>compressed_col</name></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>column</name><operator>-&gt;</operator><name>compressor</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>column</name><operator>-&gt;</operator><name>segment_info</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>compressor</name> <operator>=</operator> <name><name>column</name><operator>-&gt;</operator><name>compressor</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>compressed_col</name> <operator>=</operator> <name><name>row_compressor</name><operator>-&gt;</operator><name>uncompressed_col_to_compressed_col</name><index>[<expr><name>col</name></expr>]</index></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>compressed_col</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>compressor</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>compressed_data</name></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>column</name><operator>-&gt;</operator><name>segment_info</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>compressed_data</name> <operator>=</operator> <call><name><name>compressor</name><operator>-&gt;</operator><name>finish</name></name><argument_list>(<argument><expr><name>compressor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* non-segment columns are NULL iff all the values are NULL */</comment>
			<expr_stmt><expr><name><name>row_compressor</name><operator>-&gt;</operator><name>compressed_is_null</name><index>[<expr><name>compressed_col</name></expr>]</index></name> <operator>=</operator> <name>compressed_data</name> <operator>==</operator> <name>NULL</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>compressed_data</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>row_compressor</name><operator>-&gt;</operator><name>compressed_values</name><index>[<expr><name>compressed_col</name></expr>]</index></name> <operator>=</operator>
					<call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>compressed_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>column</name><operator>-&gt;</operator><name>min_max_metadata_builder</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>column</name><operator>-&gt;</operator><name>min_metadata_attr_offset</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>column</name><operator>-&gt;</operator><name>max_metadata_attr_offset</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>segment_meta_min_max_builder_empty</name><argument_list>(<argument><expr><name><name>column</name><operator>-&gt;</operator><name>min_max_metadata_builder</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>compressed_data</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>row_compressor</name><operator>-&gt;</operator><name>compressed_is_null</name><index>[<expr><name><name>column</name><operator>-&gt;</operator><name>min_metadata_attr_offset</name></name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>row_compressor</name><operator>-&gt;</operator><name>compressed_is_null</name><index>[<expr><name><name>column</name><operator>-&gt;</operator><name>max_metadata_attr_offset</name></name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

					<expr_stmt><expr><name><name>row_compressor</name><operator>-&gt;</operator><name>compressed_values</name><index>[<expr><name><name>column</name><operator>-&gt;</operator><name>min_metadata_attr_offset</name></name></expr>]</index></name> <operator>=</operator>
						<call><name>segment_meta_min_max_builder_min</name><argument_list>(<argument><expr><name><name>column</name><operator>-&gt;</operator><name>min_max_metadata_builder</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>row_compressor</name><operator>-&gt;</operator><name>compressed_values</name><index>[<expr><name><name>column</name><operator>-&gt;</operator><name>max_metadata_attr_offset</name></name></expr>]</index></name> <operator>=</operator>
						<call><name>segment_meta_min_max_builder_max</name><argument_list>(<argument><expr><name><name>column</name><operator>-&gt;</operator><name>min_max_metadata_builder</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>compressed_data</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>row_compressor</name><operator>-&gt;</operator><name>compressed_is_null</name><index>[<expr><name><name>column</name><operator>-&gt;</operator><name>min_metadata_attr_offset</name></name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>row_compressor</name><operator>-&gt;</operator><name>compressed_is_null</name><index>[<expr><name><name>column</name><operator>-&gt;</operator><name>max_metadata_attr_offset</name></name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>column</name><operator>-&gt;</operator><name>segment_info</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>row_compressor</name><operator>-&gt;</operator><name>compressed_values</name><index>[<expr><name>compressed_col</name></expr>]</index></name> <operator>=</operator> <name><name>column</name><operator>-&gt;</operator><name>segment_info</name><operator>-&gt;</operator><name>val</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>row_compressor</name><operator>-&gt;</operator><name>compressed_is_null</name><index>[<expr><name>compressed_col</name></expr>]</index></name> <operator>=</operator> <name><name>column</name><operator>-&gt;</operator><name>segment_info</name><operator>-&gt;</operator><name>is_null</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name><name>row_compressor</name><operator>-&gt;</operator><name>compressed_values</name><index>[<expr><name><name>row_compressor</name><operator>-&gt;</operator><name>count_metadata_column_offset</name></name></expr>]</index></name> <operator>=</operator>
		<call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>row_compressor</name><operator>-&gt;</operator><name>rows_compressed_into_current_value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>row_compressor</name><operator>-&gt;</operator><name>compressed_is_null</name><index>[<expr><name><name>row_compressor</name><operator>-&gt;</operator><name>count_metadata_column_offset</name></name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>row_compressor</name><operator>-&gt;</operator><name>compressed_values</name><index>[<expr><name><name>row_compressor</name><operator>-&gt;</operator><name>sequence_num_metadata_column_offset</name></name></expr>]</index></name> <operator>=</operator>
		<call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>row_compressor</name><operator>-&gt;</operator><name>sequence_num</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>row_compressor</name><operator>-&gt;</operator><name>compressed_is_null</name><index>[<expr><name><name>row_compressor</name><operator>-&gt;</operator><name>sequence_num_metadata_column_offset</name></name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* overflow could happen only if chunk has more than 200B rows */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>row_compressor</name><operator>-&gt;</operator><name>sequence_num</name></name> <operator>&gt;</operator> <name>PG_INT32_MAX</name> <operator>-</operator> <name>SEQUENCE_NUM_GAP</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"sequence id overflow"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>row_compressor</name><operator>-&gt;</operator><name>sequence_num</name></name> <operator>+=</operator> <name>SEQUENCE_NUM_GAP</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>compressed_tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>row_compressor</name><operator>-&gt;</operator><name>compressed_table</name></name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><name><name>row_compressor</name><operator>-&gt;</operator><name>compressed_values</name></name></expr></argument>,
									   <argument><expr><name><name>row_compressor</name><operator>-&gt;</operator><name>compressed_is_null</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>row_compressor</name><operator>-&gt;</operator><name>bistate</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_insert</name><argument_list>(<argument><expr><name><name>row_compressor</name><operator>-&gt;</operator><name>compressed_table</name></name></expr></argument>,
				<argument><expr><name>compressed_tuple</name></expr></argument>,
				<argument><expr><name>mycid</name></expr></argument>,
				<argument><expr><literal type="number">0</literal></expr></argument> <comment type="block">/*=options*/</comment>,
				<argument><expr><name><name>row_compressor</name><operator>-&gt;</operator><name>bistate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>compressed_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* free the compressed values now that we're done with them (the old compressor is freed in
	 * finish()) */</comment>
	<for>for <control>(<init><expr><name>col</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>col</name> <operator>&lt;</operator> <name><name>row_compressor</name><operator>-&gt;</operator><name>n_input_columns</name></name></expr>;</condition> <incr><expr><name>col</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PerColumn</name> <modifier>*</modifier></type><name>column</name> <init>= <expr><operator>&amp;</operator><name><name>row_compressor</name><operator>-&gt;</operator><name>per_column</name><index>[<expr><name>col</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int16</name></type> <name>compressed_col</name></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>column</name><operator>-&gt;</operator><name>compressor</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>column</name><operator>-&gt;</operator><name>segment_info</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>compressed_col</name> <operator>=</operator> <name><name>row_compressor</name><operator>-&gt;</operator><name>uncompressed_col_to_compressed_col</name><index>[<expr><name>col</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>compressed_col</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>row_compressor</name><operator>-&gt;</operator><name>compressed_is_null</name><index>[<expr><name>compressed_col</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* don't free the segment-bys if we've overflowed the row, we still need them */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>column</name><operator>-&gt;</operator><name>segment_info</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>changed_groups</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>column</name><operator>-&gt;</operator><name>compressor</name></name> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><name><name>column</name><operator>-&gt;</operator><name>segment_info</name><operator>-&gt;</operator><name>typ_by_val</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>row_compressor</name><operator>-&gt;</operator><name>compressed_values</name><index>[<expr><name>compressed_col</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>column</name><operator>-&gt;</operator><name>min_max_metadata_builder</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* segment_meta_min_max_builder_reset will free the values, so  clear here */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>row_compressor</name><operator>-&gt;</operator><name>compressed_is_null</name><index>[<expr><name><name>column</name><operator>-&gt;</operator><name>min_metadata_attr_offset</name></name></expr>]</index></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>row_compressor</name><operator>-&gt;</operator><name>compressed_values</name><index>[<expr><name><name>column</name><operator>-&gt;</operator><name>min_metadata_attr_offset</name></name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>row_compressor</name><operator>-&gt;</operator><name>compressed_is_null</name><index>[<expr><name><name>column</name><operator>-&gt;</operator><name>min_metadata_attr_offset</name></name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>row_compressor</name><operator>-&gt;</operator><name>compressed_is_null</name><index>[<expr><name><name>column</name><operator>-&gt;</operator><name>max_metadata_attr_offset</name></name></expr>]</index></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>row_compressor</name><operator>-&gt;</operator><name>compressed_values</name><index>[<expr><name><name>column</name><operator>-&gt;</operator><name>max_metadata_attr_offset</name></name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>row_compressor</name><operator>-&gt;</operator><name>compressed_is_null</name><index>[<expr><name><name>column</name><operator>-&gt;</operator><name>max_metadata_attr_offset</name></name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>segment_meta_min_max_builder_reset</name><argument_list>(<argument><expr><name><name>column</name><operator>-&gt;</operator><name>min_max_metadata_builder</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>row_compressor</name><operator>-&gt;</operator><name>compressed_values</name><index>[<expr><name>compressed_col</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>row_compressor</name><operator>-&gt;</operator><name>compressed_is_null</name><index>[<expr><name>compressed_col</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>row_compressor</name><operator>-&gt;</operator><name>rowcnt_pre_compression</name></name> <operator>+=</operator> <name><name>row_compressor</name><operator>-&gt;</operator><name>rows_compressed_into_current_value</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>row_compressor</name><operator>-&gt;</operator><name>num_compressed_rows</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>row_compressor</name><operator>-&gt;</operator><name>rows_compressed_into_current_value</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>row_compressor</name><operator>-&gt;</operator><name>per_row_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>row_compressor_finish</name><parameter_list>(<parameter><decl><type><name>RowCompressor</name> <modifier>*</modifier></type><name>row_compressor</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>row_compressor</name><operator>-&gt;</operator><name>bistate</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>FreeBulkInsertState</name><argument_list>(<argument><expr><name><name>row_compressor</name><operator>-&gt;</operator><name>bistate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/******************
 ** segment_info **
 ******************/</comment>

<function><type><specifier>static</specifier> <name>SegmentInfo</name> <modifier>*</modifier></type>
<name>segment_info_new</name><parameter_list>(<parameter><decl><type><name>Form_pg_attribute</name></type> <name>column_attr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>eq_fn_oid</name> <init>=
		<expr><call><name>lookup_type_cache</name><argument_list>(<argument><expr><name><name>column_attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>, <argument><expr><name>TYPECACHE_EQ_OPR_FINFO</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>eq_opr_finfo</name><operator>.</operator><name>fn_oid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SegmentInfo</name> <modifier>*</modifier></type><name>segment_info</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>segment_info</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>segment_info</name> <operator>=</operator> <operator>(</operator><name>SegmentInfo</name><operator>)</operator><block>{
		<expr><operator>.</operator><name>typlen</name> <operator>=</operator> <name><name>column_attr</name><operator>-&gt;</operator><name>attlen</name></name></expr>,
		<expr><operator>.</operator><name>typ_by_val</name> <operator>=</operator> <name><name>column_attr</name><operator>-&gt;</operator><name>attbyval</name></name></expr>,
	}</block></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>eq_fn_oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"no equality function for column \"%s\""</literal></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>column_attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>fmgr_info_cxt</name><argument_list>(<argument><expr><name>eq_fn_oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>segment_info</name><operator>-&gt;</operator><name>eq_fn</name></name></expr></argument>, <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>segment_info</name><operator>-&gt;</operator><name>eq_fcinfo</name></name> <operator>=</operator> <call><name>HEAP_FCINFO</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>segment_info</name><operator>-&gt;</operator><name>collation</name></name> <operator>=</operator> <name><name>column_attr</name><operator>-&gt;</operator><name>attcollation</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><operator>*</operator><name><name>segment_info</name><operator>-&gt;</operator><name>eq_fcinfo</name></name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name><name>segment_info</name><operator>-&gt;</operator><name>eq_fn</name></name></expr></argument> <comment type="block">/*=Flinfo*/</comment>,
							 <argument><expr><literal type="number">2</literal></expr></argument> <comment type="block">/*=Nargs*/</comment>,
							 <argument><expr><name><name>column_attr</name><operator>-&gt;</operator><name>attcollation</name></name></expr></argument> <comment type="block">/*=Collation*/</comment>,
							 <argument><expr><name>NULL</name></expr></argument>, <comment type="block">/*=Context*/</comment>
							 <argument><expr><name>NULL</name></expr></argument>  <comment type="block">/*=ResultInfo*/</comment>
	)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>segment_info</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>segment_info_update</name><parameter_list>(<parameter><decl><type><name>SegmentInfo</name> <modifier>*</modifier></type><name>segment_info</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_null</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>segment_info</name><operator>-&gt;</operator><name>is_null</name></name> <operator>=</operator> <name>is_null</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>is_null</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>segment_info</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>segment_info</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name><name>segment_info</name><operator>-&gt;</operator><name>typ_by_val</name></name></expr></argument>, <argument><expr><name><name>segment_info</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>segment_info_datum_is_in_group</name><parameter_list>(<parameter><decl><type><name>SegmentInfo</name> <modifier>*</modifier></type><name>segment_info</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>datum</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_null</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type> <name>data_is_eq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FunctionCallInfo</name></type> <name>eq_fcinfo</name></decl>;</decl_stmt>
	<comment type="block">/* if one of the datums is null and the other isn't, we must be in a new group */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>segment_info</name><operator>-&gt;</operator><name>is_null</name></name> <operator>!=</operator> <name>is_null</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* they're both null */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>segment_info</name><operator>-&gt;</operator><name>is_null</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* neither is null, call the eq function */</comment>
	<expr_stmt><expr><name>eq_fcinfo</name> <operator>=</operator> <name><name>segment_info</name><operator>-&gt;</operator><name>eq_fcinfo</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FC_SET_ARG</name><argument_list>(<argument><expr><name>eq_fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>segment_info</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FC_SET_ARG</name><argument_list>(<argument><expr><name>eq_fcinfo</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>data_is_eq</name> <operator>=</operator> <call><name>FunctionCallInvoke</name><argument_list>(<argument><expr><name>eq_fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>eq_fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><name>data_is_eq</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************
 ** decompress_chunk **
 **********************/</comment>

<typedef>typedef <type><struct>struct <name>PerCompressedColumn</name>
<block>{
	<decl_stmt><decl><type><name>Oid</name></type> <name>decompressed_type</name></decl>;</decl_stmt>

	<comment type="block">/* the compressor to use for compressed columns, always NULL for segmenters
	 * only use if is_compressed
	 */</comment>
	<decl_stmt><decl><type><name>DecompressionIterator</name> <modifier>*</modifier></type><name>iterator</name></decl>;</decl_stmt>

	<comment type="block">/* segment info; only used if !is_compressed */</comment>
	<decl_stmt><decl><type><name>Datum</name></type> <name>val</name></decl>;</decl_stmt>

	<comment type="block">/* is this a compressed column or a segment-by column */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>is_compressed</name></decl>;</decl_stmt>

	<comment type="block">/* the value stored in the compressed table was NULL */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>is_null</name></decl>;</decl_stmt>

	<comment type="block">/* the index in the decompressed table of the data -1,
	 * if the data is metadata not found in the decompressed table
	 */</comment>
	<decl_stmt><decl><type><name>int16</name></type> <name>decompressed_column_offset</name></decl>;</decl_stmt>
}</block></struct></type> <name>PerCompressedColumn</name>;</typedef>

<typedef>typedef <type><struct>struct <name>RowDecompressor</name>
<block>{
	<decl_stmt><decl><type><name>PerCompressedColumn</name> <modifier>*</modifier></type><name>per_compressed_cols</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type> <name>num_compressed_columns</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>out_desc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>out_rel</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>CommandId</name></type> <name>mycid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BulkInsertState</name></type> <name>bistate</name></decl>;</decl_stmt>

	<comment type="block">/* cache memory used to store the decompressed datums/is_null for form_tuple */</comment>
	<decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>decompressed_datums</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>decompressed_is_nulls</name></decl>;</decl_stmt>
}</block></struct></type> <name>RowDecompressor</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>PerCompressedColumn</name> <modifier>*</modifier></type><name>create_per_compressed_column</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>in_desc</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>out_desc</name></decl></parameter>,
														 <parameter><decl><type><name>Oid</name></type> <name>out_relid</name></decl></parameter>,
														 <parameter><decl><type><name>Oid</name></type> <name>compressed_data_type_oid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>populate_per_compressed_columns_from_data</name><parameter_list>(<parameter><decl><type><name>PerCompressedColumn</name> <modifier>*</modifier></type><name>per_compressed_cols</name></decl></parameter>,
													  <parameter><decl><type><name>int16</name></type> <name>num_cols</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>compressed_datums</name></decl></parameter>,
													  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>compressed_is_nulls</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>row_decompressor_decompress_row</name><parameter_list>(<parameter><decl><type><name>RowDecompressor</name> <modifier>*</modifier></type><name>row_decompressor</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>per_compressed_col_get_data</name><parameter_list>(<parameter><decl><type><name>PerCompressedColumn</name> <modifier>*</modifier></type><name>per_compressed_col</name></decl></parameter>,
										<parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>decompressed_datums</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>decompressed_is_nulls</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>void</name></type>
<name>decompress_chunk</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>in_table</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>out_table</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* these locks are taken in the order uncompressed table then compressed table
	 * for consistency with compress_chunk
	 */</comment>
	<comment type="block">/* we are _just_ INSERTing into the out_table so in principle we could take
	 * a RowExclusive lock, and let other operations read and write this table
	 * as we work. However, we currently compress each table as a oneshot, so
	 * we're taking the stricter lock to prevent accidents.
	 */</comment>
	<decl_stmt><decl><type><name>Relation</name></type> <name>out_rel</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>out_table</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="block">/*We want to prevent other decompressors from decompressing this table,
	 * and we want to prevent INSERTs or UPDATEs which could mess up our decompression.
	 * We may as well allow readers to keep reading the compressed data while
	 * we are compressing, so we only take an ExclusiveLock instead of AccessExclusive.
	 */</comment>
	<decl_stmt><decl><type><name>Relation</name></type> <name>in_rel</name> <init>= <expr><call><name>relation_open</name><argument_list>(<argument><expr><name>in_table</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>in_desc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>in_rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>out_desc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>out_rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>compressed_data_type_oid</name> <init>= <expr><call><name>ts_custom_type_cache_get</name><argument_list>(<argument><expr><name>CUSTOM_TYPE_COMPRESSED_DATA</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>type_oid</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>compressed_data_type_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<block>{<block_content>
		<decl_stmt><decl><type><name>RowDecompressor</name></type> <name>decompressor</name> <init>= <expr><block>{
			<expr><operator>.</operator><name>per_compressed_cols</name> <operator>=</operator> <call><name>create_per_compressed_column</name><argument_list>(<argument><expr><name>in_desc</name></expr></argument>,
																<argument><expr><name>out_desc</name></expr></argument>,
																<argument><expr><name>out_table</name></expr></argument>,
																<argument><expr><name>compressed_data_type_oid</name></expr></argument>)</argument_list></call></expr>,
			<expr><operator>.</operator><name>num_compressed_columns</name> <operator>=</operator> <name><name>in_desc</name><operator>-&gt;</operator><name>natts</name></name></expr>,

			<expr><operator>.</operator><name>out_desc</name> <operator>=</operator> <name>out_desc</name></expr>,
			<expr><operator>.</operator><name>out_rel</name> <operator>=</operator> <name>out_rel</name></expr>,

			<expr><operator>.</operator><name>mycid</name> <operator>=</operator> <call><name>GetCurrentCommandId</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>,
			<expr><operator>.</operator><name>bistate</name> <operator>=</operator> <call><name>GetBulkInsertState</name><argument_list>()</argument_list></call></expr>,

			<comment type="block">/* cache memory used to store the decompressed datums/is_null for form_tuple */</comment>
			<expr><operator>.</operator><name>decompressed_datums</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>out_desc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>,
			<expr><operator>.</operator><name>decompressed_is_nulls</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>out_desc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>,
		}</block></expr></init></decl>;</decl_stmt>
		<comment type="block">/*
		 * We need to make sure decompressed_is_nulls is in a defined state. While this
		 * will get written for normal columns it will not get written for dropped columns
		 * since dropped columns don't exist in the compressed chunk so we initiallize
		 * with true here.
		 */</comment>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>decompressor</name><operator>.</operator><name>decompressed_is_nulls</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name><name>out_desc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>compressed_datums</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>compressed_datums</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>in_desc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>compressed_is_nulls</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>compressed_is_nulls</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>in_desc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>HeapTuple</name></type> <name>compressed_tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TableScanDesc</name></type> <name>heapScan</name> <init>= <expr><call><name>table_beginscan</name><argument_list>(<argument><expr><name>in_rel</name></expr></argument>, <argument><expr><call><name>GetLatestSnapshot</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>ScanKey</name><operator>)</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>per_compressed_row_ctx</name> <init>=
			<expr><call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
								  <argument><expr><literal type="string">"decompress chunk per-compressed row"</literal></expr></argument>,
								  <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>compressed_tuple</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>heapScan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call></expr>;</init>
			 <condition><expr><name>compressed_tuple</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
			 <incr><expr><name>compressed_tuple</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>heapScan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_ctx</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>compressed_tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>old_ctx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>per_compressed_row_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><name>compressed_tuple</name></expr></argument>, <argument><expr><name>in_desc</name></expr></argument>, <argument><expr><name>compressed_datums</name></expr></argument>, <argument><expr><name>compressed_is_nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>populate_per_compressed_columns_from_data</name><argument_list>(<argument><expr><name><name>decompressor</name><operator>.</operator><name>per_compressed_cols</name></name></expr></argument>,
													  <argument><expr><name><name>in_desc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>,
													  <argument><expr><name>compressed_datums</name></expr></argument>,
													  <argument><expr><name>compressed_is_nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>row_decompressor_decompress_row</name><argument_list>(<argument><expr><operator>&amp;</operator><name>decompressor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>per_compressed_row_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>heap_endscan</name><argument_list>(<argument><expr><name>heapScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FreeBulkInsertState</name><argument_list>(<argument><expr><name><name>decompressor</name><operator>.</operator><name>bistate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Recreate all indexes on out rel, we already have an exclusive lock on it,
	 * so the strong locks taken by reindex_relation shouldn't matter. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_LT</name></expr></cpp:if>
	<decl_stmt><decl><type><name>int</name></type> <name>options</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<decl_stmt><decl><type><name>ReindexParams</name></type> <name>params</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ReindexParams</name> <modifier>*</modifier></type><name>options</name> <init>= <expr><operator>&amp;</operator><name>params</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* The reindex_relation() function creates an AccessExclusiveLock on the
	 * chunk index (if present). After calling this function, concurrent
	 * SELECTs have to wait until the index lock is released. When no
	 * index is present concurrent SELECTs can be still performed in
	 * parallel. */</comment>
	<expr_stmt><expr><call><name>DEBUG_WAITPOINT</name><argument_list>(<argument><expr><literal type="string">"decompress_chunk_impl_before_reindex"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>reindex_relation</name><argument_list>(<argument><expr><name>out_table</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DEBUG_WAITPOINT</name><argument_list>(<argument><expr><literal type="string">"decompress_chunk_impl_after_reindex"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>out_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>in_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>PerCompressedColumn</name> <modifier>*</modifier></type>
<name>create_per_compressed_column</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>in_desc</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>out_desc</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>out_relid</name></decl></parameter>,
							 <parameter><decl><type><name>Oid</name></type> <name>compressed_data_type_oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PerCompressedColumn</name> <modifier>*</modifier></type><name>per_compressed_cols</name> <init>=
		<expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>per_compressed_cols</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>in_desc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>compressed_data_type_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><decl><type><name>int16</name></type> <name>col</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>col</name> <operator>&lt;</operator> <name><name>in_desc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>col</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>decompressed_type</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>is_compressed</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int16</name></type> <name>decompressed_column_offset</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PerCompressedColumn</name> <modifier>*</modifier></type><name>per_compressed_col</name> <init>= <expr><operator>&amp;</operator><name><name>per_compressed_cols</name><index>[<expr><name>col</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>compressed_attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>in_desc</name></expr></argument>, <argument><expr><name>col</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>col_name</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>compressed_attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* find the mapping from compressed column to uncompressed column, setting
		 * the index of columns that don't have an uncompressed version
		 * (such as metadata) to -1
		 * Assumption: column names are the same on compressed and
		 *       uncompressed chunk.
		 */</comment>
		<decl_stmt><decl><type><name>AttrNumber</name></type> <name>decompressed_colnum</name> <init>= <expr><call><name>get_attnum</name><argument_list>(<argument><expr><name>out_relid</name></expr></argument>, <argument><expr><name>col_name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AttributeNumberIsValid</name><argument_list>(<argument><expr><name>decompressed_colnum</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>per_compressed_col</name> <operator>=</operator> <operator>(</operator><name>PerCompressedColumn</name><operator>)</operator><block>{
				<expr><operator>.</operator><name>decompressed_column_offset</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>,
				<expr><operator>.</operator><name>is_null</name> <operator>=</operator> <name>true</name></expr>,
			}</block></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>decompressed_column_offset</name> <operator>=</operator> <call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>decompressed_colnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>decompressed_type</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>out_desc</name></expr></argument>, <argument><expr><name>decompressed_column_offset</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypid</name></expr>;</expr_stmt>

		<comment type="block">/* determine if the data is compressed or not */</comment>
		<expr_stmt><expr><name>is_compressed</name> <operator>=</operator> <name><name>compressed_attr</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>==</operator> <name>compressed_data_type_oid</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_compressed</name> <operator>&amp;&amp;</operator> <name><name>compressed_attr</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>!=</operator> <name>decompressed_type</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				 <argument><expr><literal type="string">"compressed table type '%s' does not match decompressed table type '%s' for "</literal>
				 <literal type="string">"segment-by column \"%s\""</literal></expr></argument>,
				 <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>compressed_attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>)</argument_list></call></expr></argument>,
				 <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>decompressed_type</name></expr></argument>)</argument_list></call></expr></argument>,
				 <argument><expr><name>col_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><operator>*</operator><name>per_compressed_col</name> <operator>=</operator> <operator>(</operator><name>PerCompressedColumn</name><operator>)</operator><block>{
			<expr><operator>.</operator><name>decompressed_column_offset</name> <operator>=</operator> <name>decompressed_column_offset</name></expr>,
			<expr><operator>.</operator><name>is_null</name> <operator>=</operator> <name>true</name></expr>,
			<expr><operator>.</operator><name>is_compressed</name> <operator>=</operator> <name>is_compressed</name></expr>,
			<expr><operator>.</operator><name>decompressed_type</name> <operator>=</operator> <name>decompressed_type</name></expr>,
		}</block></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>per_compressed_cols</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>populate_per_compressed_columns_from_data</name><parameter_list>(<parameter><decl><type><name>PerCompressedColumn</name> <modifier>*</modifier></type><name>per_compressed_cols</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>num_cols</name></decl></parameter>,
										  <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>compressed_datums</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>compressed_is_nulls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<for>for <control>(<init><decl><type><name>int16</name></type> <name>col</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>col</name> <operator>&lt;</operator> <name>num_cols</name></expr>;</condition> <incr><expr><name>col</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PerCompressedColumn</name> <modifier>*</modifier></type><name>per_col</name> <init>= <expr><operator>&amp;</operator><name><name>per_compressed_cols</name><index>[<expr><name>col</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>per_col</name><operator>-&gt;</operator><name>decompressed_column_offset</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>per_col</name><operator>-&gt;</operator><name>is_null</name></name> <operator>=</operator> <name><name>compressed_is_nulls</name><index>[<expr><name>col</name></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>per_col</name><operator>-&gt;</operator><name>is_null</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>per_col</name><operator>-&gt;</operator><name>is_null</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>per_col</name><operator>-&gt;</operator><name>iterator</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>per_col</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>per_col</name><operator>-&gt;</operator><name>is_compressed</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CompressedDataHeader</name> <modifier>*</modifier></type><name>header</name> <init>= <expr><call><name>get_compressed_data_header</name><argument_list>(<argument><expr><name><name>compressed_datums</name><index>[<expr><name>col</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>per_col</name><operator>-&gt;</operator><name>iterator</name></name> <operator>=</operator>
				<name><name>definitions</name><index>[<expr><name><name>header</name><operator>-&gt;</operator><name>compression_algorithm</name></name></expr>]</index></name>
					<operator>.</operator><call><name>iterator_init_forward</name><argument_list>(<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>per_col</name><operator>-&gt;</operator><name>decompressed_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>per_col</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <name><name>compressed_datums</name><index>[<expr><name>col</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>row_decompressor_decompress_row</name><parameter_list>(<parameter><decl><type><name>RowDecompressor</name> <modifier>*</modifier></type><name>row_decompressor</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* each compressed row decompresses to at least one row,
	 * even if all the data is NULL
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>wrote_data</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>is_done</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<do>do
	<block>{<block_content>
		<comment type="block">/* we're done if all the decompressors return NULL */</comment>
		<expr_stmt><expr><name>is_done</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<for>for <control>(<init><decl><type><name>int16</name></type> <name>col</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>col</name> <operator>&lt;</operator> <name><name>row_decompressor</name><operator>-&gt;</operator><name>num_compressed_columns</name></name></expr>;</condition> <incr><expr><name>col</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type> <name>col_is_done</name> <init>=
				<expr><call><name>per_compressed_col_get_data</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>row_decompressor</name><operator>-&gt;</operator><name>per_compressed_cols</name><index>[<expr><name>col</name></expr>]</index></name></expr></argument>,
											<argument><expr><name><name>row_decompressor</name><operator>-&gt;</operator><name>decompressed_datums</name></name></expr></argument>,
											<argument><expr><name><name>row_decompressor</name><operator>-&gt;</operator><name>decompressed_is_nulls</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>is_done</name> <operator>&amp;=</operator> <name>col_is_done</name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/* if we're not done we have data to write. even if we're done, each
		 * compressed should decompress to at least one row, so we should write that
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_done</name> <operator>||</operator> <operator>!</operator><name>wrote_data</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>HeapTuple</name></type> <name>decompressed_tuple</name> <init>= <expr><call><name>heap_form_tuple</name><argument_list>(<argument><expr><name><name>row_decompressor</name><operator>-&gt;</operator><name>out_desc</name></name></expr></argument>,
														   <argument><expr><name><name>row_decompressor</name><operator>-&gt;</operator><name>decompressed_datums</name></name></expr></argument>,
														   <argument><expr><name><name>row_decompressor</name><operator>-&gt;</operator><name>decompressed_is_nulls</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>heap_insert</name><argument_list>(<argument><expr><name><name>row_decompressor</name><operator>-&gt;</operator><name>out_rel</name></name></expr></argument>,
						<argument><expr><name>decompressed_tuple</name></expr></argument>,
						<argument><expr><name><name>row_decompressor</name><operator>-&gt;</operator><name>mycid</name></name></expr></argument>,
						<argument><expr><literal type="number">0</literal></expr></argument> <comment type="block">/*=options*/</comment>,
						<argument><expr><name><name>row_decompressor</name><operator>-&gt;</operator><name>bistate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>decompressed_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>wrote_data</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block> while <condition>(<expr><operator>!</operator><name>is_done</name></expr>)</condition>;</do>
</block_content>}</block></function>

<comment type="block">/* populate the relevent index in an array from a per_compressed_col.
 * returns if decompression is done for this column
 */</comment>
<function><type><name>bool</name></type>
<name>per_compressed_col_get_data</name><parameter_list>(<parameter><decl><type><name>PerCompressedColumn</name> <modifier>*</modifier></type><name>per_compressed_col</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>decompressed_datums</name></decl></parameter>,
							<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>decompressed_is_nulls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DecompressResult</name></type> <name>decompressed</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type> <name>decompressed_column_offset</name> <init>= <expr><name><name>per_compressed_col</name><operator>-&gt;</operator><name>decompressed_column_offset</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* skip metadata columns */</comment>
	<if_stmt><if>if <condition>(<expr><name>decompressed_column_offset</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* segment-bys */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>per_compressed_col</name><operator>-&gt;</operator><name>is_compressed</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>decompressed_datums</name><index>[<expr><name>decompressed_column_offset</name></expr>]</index></name> <operator>=</operator> <name><name>per_compressed_col</name><operator>-&gt;</operator><name>val</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>decompressed_is_nulls</name><index>[<expr><name>decompressed_column_offset</name></expr>]</index></name> <operator>=</operator> <name><name>per_compressed_col</name><operator>-&gt;</operator><name>is_null</name></name></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* compressed NULL */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>per_compressed_col</name><operator>-&gt;</operator><name>is_null</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>decompressed_is_nulls</name><index>[<expr><name>decompressed_column_offset</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* other compressed data */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>per_compressed_col</name><operator>-&gt;</operator><name>iterator</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"tried to decompress more data than was compressed in column"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>decompressed</name> <operator>=</operator> <call><name><name>per_compressed_col</name><operator>-&gt;</operator><name>iterator</name><operator>-&gt;</operator><name>try_next</name></name><argument_list>(<argument><expr><name><name>per_compressed_col</name><operator>-&gt;</operator><name>iterator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>decompressed</name><operator>.</operator><name>is_done</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We want a way to free the decompression iterator's data to avoid OOM issues */</comment>
		<expr_stmt><expr><name><name>per_compressed_col</name><operator>-&gt;</operator><name>iterator</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>decompressed_is_nulls</name><index>[<expr><name>decompressed_column_offset</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>decompressed_is_nulls</name><index>[<expr><name>decompressed_column_offset</name></expr>]</index></name> <operator>=</operator> <name><name>decompressed</name><operator>.</operator><name>is_null</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>decompressed</name><operator>.</operator><name>is_null</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>decompressed_datums</name><index>[<expr><name>decompressed_column_offset</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>decompressed_datums</name><index>[<expr><name>decompressed_column_offset</name></expr>]</index></name> <operator>=</operator> <name><name>decompressed</name><operator>.</operator><name>val</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/********************/</comment>
<comment type="block" format="doxygen">/*** SQL Bindings ***/</comment>
<comment type="block" format="doxygen">/********************/</comment>

<function><type><name>Datum</name></type>
<name>tsl_compressed_data_decompress_forward</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CompressedDataHeader</name> <modifier>*</modifier></type><name>header</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncCallContext</name> <modifier>*</modifier></type><name>funcctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DecompressionIterator</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DecompressResult</name></type> <name>res</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>SRF_IS_FIRSTCALL</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_FIRSTCALL_INIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>multi_call_memory_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>header</name> <operator>=</operator> <call><name>get_compressed_data_header</name><argument_list>(<argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>iter</name> <operator>=</operator> <name><name>definitions</name><index>[<expr><name><name>header</name><operator>-&gt;</operator><name>compression_algorithm</name></name></expr>]</index></name>
				   <operator>.</operator><call><name>iterator_init_forward</name><argument_list>(<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><call><name>get_fn_expr_argtype</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name> <operator>=</operator> <name>iter</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_PERCALL_SETUP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>iter</name> <operator>=</operator> <name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name><name>iter</name><operator>-&gt;</operator><name>try_next</name></name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>res</name><operator>.</operator><name>is_done</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>res</name><operator>.</operator><name>is_null</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SRF_RETURN_NEXT_NULL</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>SRF_RETURN_NEXT</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>, <argument><expr><name><name>res</name><operator>.</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>tsl_compressed_data_decompress_reverse</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CompressedDataHeader</name> <modifier>*</modifier></type><name>header</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncCallContext</name> <modifier>*</modifier></type><name>funcctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DecompressionIterator</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DecompressResult</name></type> <name>res</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>SRF_IS_FIRSTCALL</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_FIRSTCALL_INIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>multi_call_memory_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>header</name> <operator>=</operator> <call><name>get_compressed_data_header</name><argument_list>(<argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>iter</name> <operator>=</operator> <name><name>definitions</name><index>[<expr><name><name>header</name><operator>-&gt;</operator><name>compression_algorithm</name></name></expr>]</index></name>
				   <operator>.</operator><call><name>iterator_init_reverse</name><argument_list>(<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><call><name>get_fn_expr_argtype</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name> <operator>=</operator> <name>iter</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_PERCALL_SETUP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>iter</name> <operator>=</operator> <name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name><name>iter</name><operator>-&gt;</operator><name>try_next</name></name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>res</name><operator>.</operator><name>is_done</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>res</name><operator>.</operator><name>is_null</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SRF_RETURN_NEXT_NULL</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>SRF_RETURN_NEXT</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>, <argument><expr><name><name>res</name><operator>.</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<empty_stmt>;</empty_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>tsl_compressed_data_send</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CompressedDataHeader</name> <modifier>*</modifier></type><name>header</name> <init>= <expr><call><name>get_compressed_data_header</name><argument_list>(<argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pq_begintypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>header</name><operator>-&gt;</operator><name>compression_algorithm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>definitions</name><index>[<expr><name><name>header</name><operator>-&gt;</operator><name>compression_algorithm</name></name></expr>]</index></name><operator>.</operator><call><name>compressed_data_send</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><call><name>pq_endtypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>tsl_compressed_data_recv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>buf</name> <init>= <expr><operator>(</operator><name>StringInfo</name><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CompressedDataHeader</name></type> <name>header</name> <init>= <expr><block>{ <expr><operator>.</operator><name>vl_len_</name> <operator>=</operator> <block>{ <expr><literal type="number">0</literal></expr> }</block></expr> }</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>header</name><operator>.</operator><name>compression_algorithm</name></name> <operator>=</operator> <call><name>pq_getmsgbyte</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>header</name><operator>.</operator><name>compression_algorithm</name></name> <operator>&gt;=</operator> <name>_END_COMPRESSION_ALGORITHMS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid compression algorithm %d"</literal></expr></argument>, <argument><expr><name><name>header</name><operator>.</operator><name>compression_algorithm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name><name>definitions</name><index>[<expr><name><name>header</name><operator>.</operator><name>compression_algorithm</name></name></expr>]</index></name><operator>.</operator><call><name>compressed_data_recv</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>extern</specifier> <name>Datum</name></type>
<name>tsl_compressed_data_in</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name> <init>= <expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>input_len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>decoded_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>decoded</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>input_len</name> <operator>&gt;</operator> <name>PG_INT32_MAX</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"input too long"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>decoded_len</name> <operator>=</operator> <call><name>pg_b64_dec_len</name><argument_list>(<argument><expr><name>input_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>decoded</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>decoded_len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>decoded_len</name> <operator>=</operator> <call><name>pg_b64_decode_compat</name><argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><name>input_len</name></expr></argument>, <argument><expr><name>decoded</name></expr></argument>, <argument><expr><name>decoded_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>decoded_len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not decode base64-encoded compressed data"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>decoded</name><index>[<expr><name>decoded_len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>data</name> <operator>=</operator> <operator>(</operator><name>StringInfoData</name><operator>)</operator><block>{
		<expr><operator>.</operator><name>data</name> <operator>=</operator> <name>decoded</name></expr>,
		<expr><operator>.</operator><name>len</name> <operator>=</operator> <name>decoded_len</name></expr>,
		<expr><operator>.</operator><name>maxlen</name> <operator>=</operator> <name>decoded_len</name></expr>,
	}</block></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>tsl_compressed_data_recv</name></expr></argument>, <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>extern</specifier> <name>Datum</name></type>
<name>tsl_compressed_data_out</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type> <name>bytes_data</name> <init>= <expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>tsl_compressed_data_send</name></expr></argument>, <argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bytea</name> <modifier>*</modifier></type><name>bytes</name> <init>= <expr><call><name>DatumGetByteaP</name><argument_list>(<argument><expr><name>bytes_data</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>raw_len</name> <init>= <expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>raw_data</name> <init>= <expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>encoded_len</name> <init>= <expr><call><name>pg_b64_enc_len</name><argument_list>(<argument><expr><name>raw_len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>encoded</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><name>encoded_len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>encoded_len</name> <operator>=</operator> <call><name>pg_b64_encode_compat</name><argument_list>(<argument><expr><name>raw_data</name></expr></argument>, <argument><expr><name>raw_len</name></expr></argument>, <argument><expr><name>encoded</name></expr></argument>, <argument><expr><name>encoded_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>encoded_len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not base64-encode compressed data"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>encoded</name><index>[<expr><name>encoded_len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><name>encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>extern</specifier> <name>CompressionStorage</name></type>
<name>compression_get_toast_storage</name><parameter_list>(<parameter><decl><type><name>CompressionAlgorithms</name></type> <name>algorithm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>algorithm</name> <operator>==</operator> <name>_INVALID_COMPRESSION_ALGORITHM</name> <operator>||</operator> <name>algorithm</name> <operator>&gt;=</operator> <name>_END_COMPRESSION_ALGORITHMS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid compression algorithm %d"</literal></expr></argument>, <argument><expr><name>algorithm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name><name>definitions</name><index>[<expr><name>algorithm</name></expr>]</index></name><operator>.</operator><name>compressed_data_storage</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Get relstats from compressed chunk and insert into relstats for the
 * corresponding chunk (that held the uncompressed data) from raw hypertable
 */</comment>
<function><type><specifier>extern</specifier> <name>void</name></type>
<name>update_compressed_chunk_relstats</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>uncompressed_relid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>compressed_relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type> <name>rowcnt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>comp_pages</name></decl>, <decl><type ref="prev"/><name>uncomp_pages</name></decl>, <decl><type ref="prev"/><name>comp_visible</name></decl>, <decl><type ref="prev"/><name>uncomp_visible</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float</name></type> <name>comp_tuples</name></decl>, <decl><type ref="prev"/><name>uncomp_tuples</name></decl>, <decl><type ref="prev"/><name>out_tuples</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>uncompressed_chunk</name> <init>= <expr><call><name>ts_chunk_get_by_relid</name><argument_list>(<argument><expr><name>uncompressed_relid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>compressed_chunk</name> <init>= <expr><call><name>ts_chunk_get_by_relid</name><argument_list>(<argument><expr><name>compressed_relid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>uncompressed_chunk</name><operator>-&gt;</operator><name>table_id</name></name> <operator>!=</operator> <name>uncompressed_relid</name> <operator>||</operator>
		<name><name>uncompressed_chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>compressed_chunk_id</name></name> <operator>!=</operator> <name><name>compressed_chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name> <operator>||</operator>
		<name><name>compressed_chunk</name><operator>-&gt;</operator><name>table_id</name></name> <operator>!=</operator> <name>compressed_relid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"mismatched chunks for relstats update on compressed chunk \"%s\""</literal></expr></argument>,
						<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>uncompressed_relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>capture_pgclass_stats</name><argument_list>(<argument><expr><name>uncompressed_relid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>uncomp_pages</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>uncomp_visible</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>uncomp_tuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Before compressing a chunk in 2.0, we save its stats. Prior
	 * releases do not support this. So the stats on uncompressed relid
	 * could be invalid. In this case, do the best that we can.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>uncomp_tuples</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* we need page info from compressed relid */</comment>
		<expr_stmt><expr><call><name>capture_pgclass_stats</name><argument_list>(<argument><expr><name>compressed_relid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>comp_pages</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>comp_visible</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>comp_tuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rowcnt</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <call><name>ts_compression_chunk_size_row_count</name><argument_list>(<argument><expr><name><name>uncompressed_chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>rowcnt</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>out_tuples</name> <operator>=</operator> <operator>(</operator><name>float4</name><operator>)</operator> <name>rowcnt</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>out_tuples</name> <operator>=</operator> <operator>(</operator><name>float4</name><operator>)</operator> <name>comp_tuples</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><call><name>restore_pgclass_stats</name><argument_list>(<argument><expr><name>uncompressed_relid</name></expr></argument>, <argument><expr><name>comp_pages</name></expr></argument>, <argument><expr><name>comp_visible</name></expr></argument>, <argument><expr><name>out_tuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <name>CompressSingleRowState</name>
<block>{
	<decl_stmt><decl><type><name>Relation</name></type> <name>in_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>out_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RowCompressor</name></type> <name>row_compressor</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>out_slot</name></decl>;</decl_stmt>
}</block></struct></type> <name>CompressSingleRowState</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>compress_singlerow</name><parameter_list>(<parameter><decl><type><name>CompressSingleRowState</name> <modifier>*</modifier></type><name>cr</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>in_slot</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>CompressSingleRowState</name> <modifier>*</modifier></type>
<name>compress_row_init</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>srcht_id</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>in_rel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>out_rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>htcols_list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>cclen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ColumnCompressionInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>ccinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>in_desc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>in_rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>out_desc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>out_rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name> <modifier>*</modifier></type><name>in_column_offsets</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>n_keys</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ColumnCompressionInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>keys</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>CompressSingleRowState</name> <modifier>*</modifier></type><name>cr</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CompressSingleRowState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>cr</name><operator>-&gt;</operator><name>out_slot</name></name> <operator>=</operator>
		<call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>out_rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>table_slot_callbacks</name><argument_list>(<argument><expr><name>out_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cr</name><operator>-&gt;</operator><name>in_rel</name></name> <operator>=</operator> <name>in_rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cr</name><operator>-&gt;</operator><name>out_rel</name></name> <operator>=</operator> <name>out_rel</name></expr>;</expr_stmt>

	<comment type="block">/* get compression properties for hypertable */</comment>
	<expr_stmt><expr><name>htcols_list</name> <operator>=</operator> <call><name>ts_hypertable_compression_get</name><argument_list>(<argument><expr><name>srcht_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cclen</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>htcols_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ccinfo</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ColumnCompressionInfo</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>cclen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>htcols_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FormData_hypertable_compression</name> <modifier>*</modifier></type><name>fd</name> <init>= <expr><operator>(</operator><name>FormData_hypertable_compression</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>ccinfo</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>fd</name></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><name>in_column_offsets</name> <operator>=</operator>
		<call><name>compress_chunk_populate_keys</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>in_rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ccinfo</name></expr></argument>, <argument><expr><name>cclen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n_keys</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>row_compressor_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cr</name><operator>-&gt;</operator><name>row_compressor</name></name></expr></argument>,
						<argument><expr><name>in_desc</name></expr></argument>,
						<argument><expr><name>out_rel</name></expr></argument>,
						<argument><expr><name>cclen</name></expr></argument>,
						<argument><expr><name>ccinfo</name></expr></argument>,
						<argument><expr><name>in_column_offsets</name></expr></argument>,
						<argument><expr><name><name>out_desc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>,
						<argument><expr><name>false</name></expr></argument> <comment type="block">/*need_bistate*/</comment>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>cr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* create a single row compressed tuple from data in slot */</comment>
<function><type><name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>compress_row_exec</name><parameter_list>(<parameter><decl><type><name>CompressSingleRowState</name> <modifier>*</modifier></type><name>cr</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>compress_slot</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>slot_getallattrs</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>cr</name><operator>-&gt;</operator><name>row_compressor</name><operator>.</operator><name>rows_compressed_into_current_value</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>row_compressor_update_group</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cr</name><operator>-&gt;</operator><name>row_compressor</name></name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>row_compressor_append_row</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cr</name><operator>-&gt;</operator><name>row_compressor</name></name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>compress_slot</name> <operator>=</operator> <call><name>compress_singlerow</name><argument_list>(<argument><expr><name>cr</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>compress_slot</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>compress_singlerow</name><parameter_list>(<parameter><decl><type><name>CompressSingleRowState</name> <modifier>*</modifier></type><name>cr</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>in_slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>invalues</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>out_values</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>out_isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>out_slot</name> <init>= <expr><name><name>cr</name><operator>-&gt;</operator><name>out_slot</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RowCompressor</name> <modifier>*</modifier></type><name>row_compressor</name> <init>= <expr><operator>&amp;</operator><name><name>cr</name><operator>-&gt;</operator><name>row_compressor</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>out_slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* ExecClearTuple above will leave dropped columns as non-null, which will
	 * cause a segmentation fault in `heap_compute_data_size` since that
	 * function expects dropped columns to have the null bit set. Since the
	 * null bits are set below for all columns except */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>out_slot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></argument>,
		   <argument><expr><name>true</name></expr></argument>,
		   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>out_slot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>out_slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>invalues</name> <operator>=</operator> <name><name>in_slot</name><operator>-&gt;</operator><name>tts_values</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>out_values</name> <operator>=</operator> <name><name>out_slot</name><operator>-&gt;</operator><name>tts_values</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>out_isnull</name> <operator>=</operator> <name><name>out_slot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr>;</expr_stmt>

	<comment type="block">/* Possible optimization: Can we do a pass through compression without a
	 * full copy?  full copy needed for multiple values. But we are dealing
	 * only with a single value, so just need the result of transformation
	 * after passing it through the compressor function This probably needs a
	 * bit of rewrite of the compression algorithm code
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>row_compressor</name><operator>-&gt;</operator><name>n_input_columns</name></name> <operator>==</operator> <name><name>in_slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>col</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>col</name> <operator>&lt;</operator> <name><name>row_compressor</name><operator>-&gt;</operator><name>n_input_columns</name></name></expr>;</condition> <incr><expr><name>col</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PerColumn</name> <modifier>*</modifier></type><name>column</name> <init>= <expr><operator>&amp;</operator><name><name>row_compressor</name><operator>-&gt;</operator><name>per_column</name><index>[<expr><name>col</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Compressor</name> <modifier>*</modifier></type><name>compressor</name> <init>= <expr><name><name>row_compressor</name><operator>-&gt;</operator><name>per_column</name><index>[<expr><name>col</name></expr>]</index></name><operator>.</operator><name>compressor</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>in_colno</name> <init>= <expr><name>col</name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>int16</name></type> <name>out_colno</name> <init>= <expr><name><name>row_compressor</name><operator>-&gt;</operator><name>uncompressed_col_to_compressed_col</name><index>[<expr><name>col</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<comment type="block">/* if there is no compressor, this must be a segmenter */</comment>
		<if_stmt><if>if <condition>(<expr><name>compressor</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>compressed_data</name></decl>;</decl_stmt>
			<expr_stmt><expr><name>compressed_data</name> <operator>=</operator> <call><name><name>compressor</name><operator>-&gt;</operator><name>finish</name></name><argument_list>(<argument><expr><name>compressor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>out_isnull</name><index>[<expr><name>out_colno</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>compressed_data</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>compressed_data</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>out_values</name><index>[<expr><name>out_colno</name></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>compressed_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>column</name><operator>-&gt;</operator><name>min_max_metadata_builder</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>compressed_data</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* we can copy directly since we have only 1 row. */</comment>
					<expr_stmt><expr><name><name>out_isnull</name><index>[<expr><name><name>column</name><operator>-&gt;</operator><name>min_metadata_attr_offset</name></name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>out_isnull</name><index>[<expr><name><name>column</name><operator>-&gt;</operator><name>max_metadata_attr_offset</name></name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>out_values</name><index>[<expr><name><name>column</name><operator>-&gt;</operator><name>min_metadata_attr_offset</name></name></expr>]</index></name> <operator>=</operator> <name><name>invalues</name><index>[<expr><name>in_colno</name></expr>]</index></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>out_values</name><index>[<expr><name><name>column</name><operator>-&gt;</operator><name>max_metadata_attr_offset</name></name></expr>]</index></name> <operator>=</operator> <name><name>invalues</name><index>[<expr><name>in_colno</name></expr>]</index></name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name><name>out_isnull</name><index>[<expr><name><name>column</name><operator>-&gt;</operator><name>min_metadata_attr_offset</name></name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>out_isnull</name><index>[<expr><name><name>column</name><operator>-&gt;</operator><name>max_metadata_attr_offset</name></name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<expr_stmt><expr><call><name>segment_meta_min_max_builder_reset</name><argument_list>(<argument><expr><name><name>column</name><operator>-&gt;</operator><name>min_max_metadata_builder</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<comment type="block">/* if there is no compressor, this must be a segmenter */</comment>
		<if type="elseif">else if <condition>(<expr><name><name>column</name><operator>-&gt;</operator><name>segment_info</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>out_isnull</name><index>[<expr><name>out_colno</name></expr>]</index></name> <operator>=</operator> <name><name>column</name><operator>-&gt;</operator><name>segment_info</name><operator>-&gt;</operator><name>is_null</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>column</name><operator>-&gt;</operator><name>segment_info</name><operator>-&gt;</operator><name>is_null</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>out_values</name><index>[<expr><name>out_colno</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>out_values</name><index>[<expr><name>out_colno</name></expr>]</index></name> <operator>=</operator> <name><name>invalues</name><index>[<expr><name>in_colno</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* we have a 1-1 column mapping from uncompressed -&gt; compressed chunk.
			 * However, some columns could have been dropped from the uncompressed
			 *chunk before the compressed one is created.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>out_colno</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* fill in additional meta data info */</comment>
	<expr_stmt><expr><name><name>out_values</name><index>[<expr><name><name>row_compressor</name><operator>-&gt;</operator><name>count_metadata_column_offset</name></name></expr>]</index></name> <operator>=</operator>
		<call><name>Int32GetDatum</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/*we have only 1 row */</comment>
	<expr_stmt><expr><name><name>out_isnull</name><index>[<expr><name><name>row_compressor</name><operator>-&gt;</operator><name>count_metadata_column_offset</name></name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<comment type="block">/* Add an invalid sequence number */</comment>
	<expr_stmt><expr><name><name>out_values</name><index>[<expr><name><name>row_compressor</name><operator>-&gt;</operator><name>sequence_num_metadata_column_offset</name></name></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>out_isnull</name><index>[<expr><name><name>row_compressor</name><operator>-&gt;</operator><name>sequence_num_metadata_column_offset</name></name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>row_compressor</name><operator>-&gt;</operator><name>rows_compressed_into_current_value</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecStoreVirtualTuple</name><argument_list>(<argument><expr><name>out_slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>out_slot</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>compress_row_end</name><parameter_list>(<parameter><decl><type><name>CompressSingleRowState</name> <modifier>*</modifier></type><name>cr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>row_compressor_finish</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cr</name><operator>-&gt;</operator><name>row_compressor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>compress_row_destroy</name><parameter_list>(<parameter><decl><type><name>CompressSingleRowState</name> <modifier>*</modifier></type><name>cr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name><name>cr</name><operator>-&gt;</operator><name>out_slot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
