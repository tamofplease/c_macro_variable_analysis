<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/timescaledb/tsl/src/compression/gorilla.c"><comment type="block">/*
 * This file and its contents are licensed under the Timescale License.
 * Please see the included NOTICE for copyright information and
 * LICENSE-TIMESCALE for a copy of the license.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postgres.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/htup_details.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_type.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;common/base64.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;funcapi.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;libpq/pqformat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;lib/stringinfo.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;port/pg_bitutils.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/builtins.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/memutils.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compression/gorilla.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"float_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"adts/bit_array.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compression/compression.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compression/simple8b_rle.h"</cpp:file></cpp:include>

<comment type="block">/*
 * Gorilla compressed data is stored as
 *     uint16 compression_algorithm: id number for the compression scheme
 *     uint8 has_nulls: 1 if we store a NULLs bitmap after the data, otherwise 0
 *     uint8 bits_used_in_last_xor_bucket: number of bits used in the last bucket
 *     uint64 last_val: the last double stored, as bits
 *     simple8b_rle tag0: array of first tag bits (as in gorilla), also stores nelems
 *     simple8b_rle tag1: array of second tag bits (as in gorilla)
 *     BitArray leading_zeros: array of leading zeroes before the xor (as in gorilla)
 *     simple8b_rle num_bits_used: number of bits used for each xor (as in gorilla)
 *     BitArray xors: array xor values (as in gorilla)
 *     simple8b_rle nulls: 1 if the value is NULL, else 0
 */</comment>

<typedef>typedef <type><struct>struct <name>GorillaCompressed</name>
<block>{
	<expr_stmt><expr><name>CompressedDataHeaderFields</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>uint8</name></type> <name>has_nulls</name></decl>;</decl_stmt> <comment type="block">/* we only use one bit for has_nulls, the rest can be reused */</comment>
	<decl_stmt><decl><type><name>uint8</name></type> <name>bits_used_in_last_xor_bucket</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name></type> <name>bits_used_in_last_leading_zeros_bucket</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>num_leading_zeroes_buckets</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>num_xor_buckets</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>last_value</name></decl>;</decl_stmt>
}</block></struct></type> <name>GorillaCompressed</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BITS_PER_LEADING_ZEROS</name></cpp:macro> <cpp:value>6</cpp:value></cpp:define>

<comment type="block">/* expanded version of the compressed data */</comment>
<typedef>typedef <type><struct>struct <name>CompressedGorillaData</name>
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>GorillaCompressed</name> <modifier>*</modifier></type><name>header</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Simple8bRleSerialized</name> <modifier>*</modifier></type><name>tag0s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Simple8bRleSerialized</name> <modifier>*</modifier></type><name>tag1s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BitArray</name></type> <name>leading_zeros</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Simple8bRleSerialized</name> <modifier>*</modifier></type><name>num_bits_used_per_xor</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BitArray</name></type> <name>xors</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Simple8bRleSerialized</name> <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt> <comment type="block">/* NULL if no nulls */</comment>
}</block></struct></type> <name>CompressedGorillaData</name>;</typedef>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>pg_attribute_unused</name><parameter_list>()</parameter_list> assertions<parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GorillaCompressed</name></type> <name>test_val</name> <init>= <expr><block>{ <expr><operator>.</operator><name>vl_len_</name> <operator>=</operator> <block>{ <expr><literal type="number">0</literal></expr> }</block></expr> }</block></expr></init></decl>;</decl_stmt>
	<comment type="block">/* make sure no padding bytes make it to disk */</comment>
	<expr_stmt><expr><call><name>StaticAssertStmt</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GorillaCompressed</name></expr></argument>)</argument_list></sizeof> <operator>==</operator>
						 <sizeof>sizeof<argument_list>(<argument><expr><name><name>test_val</name><operator>.</operator><name>vl_len_</name></name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>test_val</name><operator>.</operator><name>compression_algorithm</name></name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
							 <sizeof>sizeof<argument_list>(<argument><expr><name><name>test_val</name><operator>.</operator><name>has_nulls</name></name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
							 <sizeof>sizeof<argument_list>(<argument><expr><name><name>test_val</name><operator>.</operator><name>bits_used_in_last_xor_bucket</name></name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
							 <sizeof>sizeof<argument_list>(<argument><expr><name><name>test_val</name><operator>.</operator><name>bits_used_in_last_leading_zeros_bucket</name></name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
							 <sizeof>sizeof<argument_list>(<argument><expr><name><name>test_val</name><operator>.</operator><name>num_leading_zeroes_buckets</name></name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
							 <sizeof>sizeof<argument_list>(<argument><expr><name><name>test_val</name><operator>.</operator><name>num_xor_buckets</name></name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>test_val</name><operator>.</operator><name>last_value</name></name></expr></argument>)</argument_list></sizeof></expr></argument>,
					 <argument><expr><literal type="string">"Gorilla wrong size"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>StaticAssertStmt</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GorillaCompressed</name></expr></argument>)</argument_list></sizeof> <operator>==</operator> <literal type="number">24</literal></expr></argument>, <argument><expr><literal type="string">"Gorilla wrong size"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <name>GorillaCompressor</name>
<block>{
	<comment type="line">// NOTE it is a small win to replace these next two with specialized RLE bitmaps</comment>
	<decl_stmt><decl><type><name>Simple8bRleCompressor</name></type> <name>tag0s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Simple8bRleCompressor</name></type> <name>tag1s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BitArray</name></type> <name>leading_zeros</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Simple8bRleCompressor</name></type> <name>bits_used_per_xor</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BitArray</name></type> <name>xors</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Simple8bRleCompressor</name></type> <name>nulls</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>uint64</name></type> <name>prev_val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name></type> <name>prev_leading_zeroes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name></type> <name>prev_trailing_zeros</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>has_nulls</name></decl>;</decl_stmt>
}</block></struct></type> <name>GorillaCompressor</name>;</typedef>

<typedef>typedef <type><struct>struct <name>ExtendedCompressor</name>
<block>{
	<decl_stmt><decl><type><name>Compressor</name></type> <name>base</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GorillaCompressor</name> <modifier>*</modifier></type><name>internal</name></decl>;</decl_stmt>
}</block></struct></type> <name>ExtendedCompressor</name>;</typedef>

<typedef>typedef <type><struct>struct <name>GorillaDecompressionIterator</name>
<block>{
	<decl_stmt><decl><type><name>DecompressionIterator</name></type> <name>base</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CompressedGorillaData</name></type> <name>gorilla_data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Simple8bRleDecompressionIterator</name></type> <name>tag0s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Simple8bRleDecompressionIterator</name></type> <name>tag1s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BitArrayIterator</name></type> <name>leading_zeros</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Simple8bRleDecompressionIterator</name></type> <name>num_bits_used</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BitArrayIterator</name></type> <name>xors</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Simple8bRleDecompressionIterator</name></type> <name>nulls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>prev_val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name></type> <name>prev_leading_zeroes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name></type> <name>prev_xor_bits_used</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>has_nulls</name></decl>;</decl_stmt>
}</block></struct></type> <name>GorillaDecompressionIterator</name>;</typedef>

<comment type="block" format="doxygen">/********************
 ***  Compressor  ***
 ********************/</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>gorilla_compressor_append_float</name><parameter_list>(<parameter><decl><type><name>Compressor</name> <modifier>*</modifier></type><name>compressor</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExtendedCompressor</name> <modifier>*</modifier></type><name>extended</name> <init>= <expr><operator>(</operator><name>ExtendedCompressor</name> <operator>*</operator><operator>)</operator> <name>compressor</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>value</name> <init>= <expr><call><name>float_get_bits</name><argument_list>(<argument><expr><call><name>DatumGetFloat4</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>extended</name><operator>-&gt;</operator><name>internal</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>extended</name><operator>-&gt;</operator><name>internal</name></name> <operator>=</operator> <call><name>gorilla_compressor_alloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>gorilla_compressor_append_value</name><argument_list>(<argument><expr><name><name>extended</name><operator>-&gt;</operator><name>internal</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>gorilla_compressor_append_double</name><parameter_list>(<parameter><decl><type><name>Compressor</name> <modifier>*</modifier></type><name>compressor</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExtendedCompressor</name> <modifier>*</modifier></type><name>extended</name> <init>= <expr><operator>(</operator><name>ExtendedCompressor</name> <operator>*</operator><operator>)</operator> <name>compressor</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>value</name> <init>= <expr><call><name>double_get_bits</name><argument_list>(<argument><expr><call><name>DatumGetFloat8</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>extended</name><operator>-&gt;</operator><name>internal</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>extended</name><operator>-&gt;</operator><name>internal</name></name> <operator>=</operator> <call><name>gorilla_compressor_alloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>gorilla_compressor_append_value</name><argument_list>(<argument><expr><name><name>extended</name><operator>-&gt;</operator><name>internal</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>gorilla_compressor_append_int16</name><parameter_list>(<parameter><decl><type><name>Compressor</name> <modifier>*</modifier></type><name>compressor</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExtendedCompressor</name> <modifier>*</modifier></type><name>extended</name> <init>= <expr><operator>(</operator><name>ExtendedCompressor</name> <operator>*</operator><operator>)</operator> <name>compressor</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>extended</name><operator>-&gt;</operator><name>internal</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>extended</name><operator>-&gt;</operator><name>internal</name></name> <operator>=</operator> <call><name>gorilla_compressor_alloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>gorilla_compressor_append_value</name><argument_list>(<argument><expr><name><name>extended</name><operator>-&gt;</operator><name>internal</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint16</name><operator>)</operator> <call><name>DatumGetInt16</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>gorilla_compressor_append_int32</name><parameter_list>(<parameter><decl><type><name>Compressor</name> <modifier>*</modifier></type><name>compressor</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExtendedCompressor</name> <modifier>*</modifier></type><name>extended</name> <init>= <expr><operator>(</operator><name>ExtendedCompressor</name> <operator>*</operator><operator>)</operator> <name>compressor</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>extended</name><operator>-&gt;</operator><name>internal</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>extended</name><operator>-&gt;</operator><name>internal</name></name> <operator>=</operator> <call><name>gorilla_compressor_alloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>gorilla_compressor_append_value</name><argument_list>(<argument><expr><name><name>extended</name><operator>-&gt;</operator><name>internal</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>gorilla_compressor_append_int64</name><parameter_list>(<parameter><decl><type><name>Compressor</name> <modifier>*</modifier></type><name>compressor</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExtendedCompressor</name> <modifier>*</modifier></type><name>extended</name> <init>= <expr><operator>(</operator><name>ExtendedCompressor</name> <operator>*</operator><operator>)</operator> <name>compressor</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>extended</name><operator>-&gt;</operator><name>internal</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>extended</name><operator>-&gt;</operator><name>internal</name></name> <operator>=</operator> <call><name>gorilla_compressor_alloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>gorilla_compressor_append_value</name><argument_list>(<argument><expr><name><name>extended</name><operator>-&gt;</operator><name>internal</name></name></expr></argument>, <argument><expr><call><name>DatumGetInt64</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>gorilla_compressor_append_null_value</name><parameter_list>(<parameter><decl><type><name>Compressor</name> <modifier>*</modifier></type><name>compressor</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExtendedCompressor</name> <modifier>*</modifier></type><name>extended</name> <init>= <expr><operator>(</operator><name>ExtendedCompressor</name> <operator>*</operator><operator>)</operator> <name>compressor</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>extended</name><operator>-&gt;</operator><name>internal</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>extended</name><operator>-&gt;</operator><name>internal</name></name> <operator>=</operator> <call><name>gorilla_compressor_alloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>gorilla_compressor_append_null</name><argument_list>(<argument><expr><name><name>extended</name><operator>-&gt;</operator><name>internal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>gorilla_compressor_finish_and_reset</name><parameter_list>(<parameter><decl><type><name>Compressor</name> <modifier>*</modifier></type><name>compressor</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExtendedCompressor</name> <modifier>*</modifier></type><name>extended</name> <init>= <expr><operator>(</operator><name>ExtendedCompressor</name> <operator>*</operator><operator>)</operator> <name>compressor</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>compressed</name> <init>= <expr><call><name>gorilla_compressor_finish</name><argument_list>(<argument><expr><name><name>extended</name><operator>-&gt;</operator><name>internal</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>extended</name><operator>-&gt;</operator><name>internal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>extended</name><operator>-&gt;</operator><name>internal</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<return>return <expr><name>compressed</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>const</specifier> <name>Compressor</name></type> <name>gorilla_float_compressor</name> <init>= <expr><block>{
	<expr><operator>.</operator><name>append_val</name> <operator>=</operator> <name>gorilla_compressor_append_float</name></expr>,
	<expr><operator>.</operator><name>append_null</name> <operator>=</operator> <name>gorilla_compressor_append_null_value</name></expr>,
	<expr><operator>.</operator><name>finish</name> <operator>=</operator> <name>gorilla_compressor_finish_and_reset</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>Compressor</name></type> <name>gorilla_double_compressor</name> <init>= <expr><block>{
	<expr><operator>.</operator><name>append_val</name> <operator>=</operator> <name>gorilla_compressor_append_double</name></expr>,
	<expr><operator>.</operator><name>append_null</name> <operator>=</operator> <name>gorilla_compressor_append_null_value</name></expr>,
	<expr><operator>.</operator><name>finish</name> <operator>=</operator> <name>gorilla_compressor_finish_and_reset</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Compressor</name></type> <name>gorilla_uint16_compressor</name> <init>= <expr><block>{
	<expr><operator>.</operator><name>append_val</name> <operator>=</operator> <name>gorilla_compressor_append_int16</name></expr>,
	<expr><operator>.</operator><name>append_null</name> <operator>=</operator> <name>gorilla_compressor_append_null_value</name></expr>,
	<expr><operator>.</operator><name>finish</name> <operator>=</operator> <name>gorilla_compressor_finish_and_reset</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Compressor</name></type> <name>gorilla_uint32_compressor</name> <init>= <expr><block>{
	<expr><operator>.</operator><name>append_val</name> <operator>=</operator> <name>gorilla_compressor_append_int32</name></expr>,
	<expr><operator>.</operator><name>append_null</name> <operator>=</operator> <name>gorilla_compressor_append_null_value</name></expr>,
	<expr><operator>.</operator><name>finish</name> <operator>=</operator> <name>gorilla_compressor_finish_and_reset</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Compressor</name></type> <name>gorilla_uint64_compressor</name> <init>= <expr><block>{
	<expr><operator>.</operator><name>append_val</name> <operator>=</operator> <name>gorilla_compressor_append_int64</name></expr>,
	<expr><operator>.</operator><name>append_null</name> <operator>=</operator> <name>gorilla_compressor_append_null_value</name></expr>,
	<expr><operator>.</operator><name>finish</name> <operator>=</operator> <name>gorilla_compressor_finish_and_reset</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<function><type><name>Compressor</name> <modifier>*</modifier></type>
<name>gorilla_compressor_for_type</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>element_type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExtendedCompressor</name> <modifier>*</modifier></type><name>compressor</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>compressor</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<switch>switch <condition>(<expr><name>element_type</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>FLOAT4OID</name></expr>:</case>
			<expr_stmt><expr><operator>*</operator><name>compressor</name> <operator>=</operator> <operator>(</operator><name>ExtendedCompressor</name><operator>)</operator><block>{ <expr><operator>.</operator><name>base</name> <operator>=</operator> <name>gorilla_float_compressor</name></expr> }</block></expr>;</expr_stmt>
			<return>return <expr><operator>&amp;</operator><name><name>compressor</name><operator>-&gt;</operator><name>base</name></name></expr>;</return>
		<case>case <expr><name>FLOAT8OID</name></expr>:</case>
			<expr_stmt><expr><operator>*</operator><name>compressor</name> <operator>=</operator> <operator>(</operator><name>ExtendedCompressor</name><operator>)</operator><block>{ <expr><operator>.</operator><name>base</name> <operator>=</operator> <name>gorilla_double_compressor</name></expr> }</block></expr>;</expr_stmt>
			<return>return <expr><operator>&amp;</operator><name><name>compressor</name><operator>-&gt;</operator><name>base</name></name></expr>;</return>
		<case>case <expr><name>INT2OID</name></expr>:</case>
			<expr_stmt><expr><operator>*</operator><name>compressor</name> <operator>=</operator> <operator>(</operator><name>ExtendedCompressor</name><operator>)</operator><block>{ <expr><operator>.</operator><name>base</name> <operator>=</operator> <name>gorilla_uint16_compressor</name></expr> }</block></expr>;</expr_stmt>
			<return>return <expr><operator>&amp;</operator><name><name>compressor</name><operator>-&gt;</operator><name>base</name></name></expr>;</return>
		<case>case <expr><name>INT4OID</name></expr>:</case>
			<expr_stmt><expr><operator>*</operator><name>compressor</name> <operator>=</operator> <operator>(</operator><name>ExtendedCompressor</name><operator>)</operator><block>{ <expr><operator>.</operator><name>base</name> <operator>=</operator> <name>gorilla_uint32_compressor</name></expr> }</block></expr>;</expr_stmt>
			<return>return <expr><operator>&amp;</operator><name><name>compressor</name><operator>-&gt;</operator><name>base</name></name></expr>;</return>
		<case>case <expr><name>INT8OID</name></expr>:</case>
			<expr_stmt><expr><operator>*</operator><name>compressor</name> <operator>=</operator> <operator>(</operator><name>ExtendedCompressor</name><operator>)</operator><block>{ <expr><operator>.</operator><name>base</name> <operator>=</operator> <name>gorilla_uint64_compressor</name></expr> }</block></expr>;</expr_stmt>
			<return>return <expr><operator>&amp;</operator><name><name>compressor</name><operator>-&gt;</operator><name>base</name></name></expr>;</return>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				 <argument><expr><literal type="string">"invalid type for Gorilla compression \"%s\""</literal></expr></argument>,
				 <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>element_type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
	<expr_stmt><expr><call><name>pg_unreachable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>GorillaCompressor</name> <modifier>*</modifier></type>
<name>gorilla_compressor_alloc</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GorillaCompressor</name> <modifier>*</modifier></type><name>compressor</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>compressor</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>simple8brle_compressor_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>compressor</name><operator>-&gt;</operator><name>tag0s</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>simple8brle_compressor_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>compressor</name><operator>-&gt;</operator><name>tag1s</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>bit_array_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>compressor</name><operator>-&gt;</operator><name>leading_zeros</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>simple8brle_compressor_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>compressor</name><operator>-&gt;</operator><name>bits_used_per_xor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>bit_array_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>compressor</name><operator>-&gt;</operator><name>xors</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>simple8brle_compressor_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>compressor</name><operator>-&gt;</operator><name>nulls</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>compressor</name><operator>-&gt;</operator><name>has_nulls</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>compressor</name><operator>-&gt;</operator><name>prev_leading_zeroes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>compressor</name><operator>-&gt;</operator><name>prev_trailing_zeros</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>compressor</name><operator>-&gt;</operator><name>prev_val</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<return>return <expr><name>compressor</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>tsl_gorilla_compressor_append</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>agg_context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GorillaCompressor</name> <modifier>*</modifier></type><name>compressor</name> <init>=
		<expr><operator>(</operator><name>GorillaCompressor</name> <operator>*</operator><operator>)</operator> <operator>(</operator><ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AggCheckCallContext</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>agg_context</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* cannot be called directly because of internal-type argument */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"tsl_gorilla_compressor_append called in non-aggregate context"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>old_context</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>agg_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>compressor</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>compressor</name> <operator>=</operator> <call><name>gorilla_compressor_alloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>gorilla_compressor_append_null</name><argument_list>(<argument><expr><name>compressor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>double</name></type> <name>next_val</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>gorilla_compressor_append_value</name><argument_list>(<argument><expr><name>compressor</name></expr></argument>, <argument><expr><call><name>double_get_bits</name><argument_list>(<argument><expr><name>next_val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>compressor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>gorilla_compressor_append_null</name><parameter_list>(<parameter><decl><type><name>GorillaCompressor</name> <modifier>*</modifier></type><name>compressor</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>simple8brle_compressor_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>compressor</name><operator>-&gt;</operator><name>nulls</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>compressor</name><operator>-&gt;</operator><name>has_nulls</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>gorilla_compressor_append_value</name><parameter_list>(<parameter><decl><type><name>GorillaCompressor</name> <modifier>*</modifier></type><name>compressor</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>has_values</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>xor</name> <init>= <expr><name><name>compressor</name><operator>-&gt;</operator><name>prev_val</name></name> <operator>^</operator> <name>val</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>simple8brle_compressor_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>compressor</name><operator>-&gt;</operator><name>nulls</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* for the first value we store the bitsize even if the xor is all zeroes,
	 * this ensures that the bits-per-xor isn't empty, and that we can calculate
	 * the remaining offsets correctly.
	 */</comment>
	<expr_stmt><expr><name>has_values</name> <operator>=</operator> <operator>!</operator><call><name>simple8brle_compressor_is_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>compressor</name><operator>-&gt;</operator><name>bits_used_per_xor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>has_values</name> <operator>&amp;&amp;</operator> <name>xor</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>simple8brle_compressor_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>compressor</name><operator>-&gt;</operator><name>tag0s</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* leftmost/rightmost 1 is not well-defined when all the bits in the number
		 * are 0; the C implementations of these functions will ERROR, while the
		 * assembly versions may return any value. We special-case 0 to to use
		 * values for leading and trailing-zeroes that we know will work.
		 */</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>leading_zeros</name> <init>= <expr><ternary><condition><expr><name>xor</name> <operator>!=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">63</literal> <operator>-</operator> <call><name>pg_leftmost_one_pos64</name><argument_list>(<argument><expr><name>xor</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">63</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>trailing_zeros</name> <init>= <expr><ternary><condition><expr><name>xor</name> <operator>!=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><call><name>pg_rightmost_one_pos64</name><argument_list>(<argument><expr><name>xor</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
		<comment type="block">/*   This can easily get stuck with a bad value for trailing_zeroes, leading to a bad
		 * compressed size. We use a new trailing_zeroes if the delta is too large, but the
		 *   threshold (12) was picked in a completely unprincipled manner.
		 *   Needs benchmarking to determine an ideal threshold.
		 */</comment>
		<decl_stmt><decl><type><name>bool</name></type> <name>reuse_bitsizes</name> <init>= <expr><name>has_values</name> <operator>&amp;&amp;</operator> <name>leading_zeros</name> <operator>&gt;=</operator> <name><name>compressor</name><operator>-&gt;</operator><name>prev_leading_zeroes</name></name> <operator>&amp;&amp;</operator>
							  <name>trailing_zeros</name> <operator>&gt;=</operator> <name><name>compressor</name><operator>-&gt;</operator><name>prev_trailing_zeros</name></name> <operator>&amp;&amp;</operator>
							  <operator>(</operator><operator>(</operator><name>leading_zeros</name> <operator>-</operator> <name><name>compressor</name><operator>-&gt;</operator><name>prev_leading_zeroes</name></name><operator>)</operator> <operator>+</operator>
								   <operator>(</operator><name>trailing_zeros</name> <operator>-</operator> <name><name>compressor</name><operator>-&gt;</operator><name>prev_trailing_zeros</name></name><operator>)</operator> <operator>&lt;=</operator>
							   <literal type="number">12</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint8</name></type> <name>num_bits_used</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>simple8brle_compressor_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>compressor</name><operator>-&gt;</operator><name>tag0s</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>simple8brle_compressor_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>compressor</name><operator>-&gt;</operator><name>tag1s</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name>reuse_bitsizes</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>reuse_bitsizes</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>compressor</name><operator>-&gt;</operator><name>prev_leading_zeroes</name></name> <operator>=</operator> <name>leading_zeros</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>compressor</name><operator>-&gt;</operator><name>prev_trailing_zeros</name></name> <operator>=</operator> <name>trailing_zeros</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>num_bits_used</name> <operator>=</operator> <literal type="number">64</literal> <operator>-</operator> <operator>(</operator><name>leading_zeros</name> <operator>+</operator> <name>trailing_zeros</name><operator>)</operator></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>bit_array_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>compressor</name><operator>-&gt;</operator><name>leading_zeros</name></name></expr></argument>, <argument><expr><name>BITS_PER_LEADING_ZEROS</name></expr></argument>, <argument><expr><name>leading_zeros</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>simple8brle_compressor_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>compressor</name><operator>-&gt;</operator><name>bits_used_per_xor</name></name></expr></argument>, <argument><expr><name>num_bits_used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>num_bits_used</name> <operator>=</operator> <literal type="number">64</literal> <operator>-</operator> <operator>(</operator><name><name>compressor</name><operator>-&gt;</operator><name>prev_leading_zeroes</name></name> <operator>+</operator> <name><name>compressor</name><operator>-&gt;</operator><name>prev_trailing_zeros</name></name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>bit_array_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>compressor</name><operator>-&gt;</operator><name>xors</name></name></expr></argument>, <argument><expr><name>num_bits_used</name></expr></argument>, <argument><expr><name>xor</name> <operator>&gt;&gt;</operator> <name><name>compressor</name><operator>-&gt;</operator><name>prev_trailing_zeros</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name><name>compressor</name><operator>-&gt;</operator><name>prev_val</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>GorillaCompressed</name> <modifier>*</modifier></type>
<name>compressed_gorilla_data_serialize</name><parameter_list>(<parameter><decl><type><name>CompressedGorillaData</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type> <name>tags0s_size</name> <init>= <expr><call><name>simple8brle_serialized_total_size</name><argument_list>(<argument><expr><name><name>input</name><operator>-&gt;</operator><name>tag0s</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type> <name>tags1s_size</name> <init>= <expr><call><name>simple8brle_serialized_total_size</name><argument_list>(<argument><expr><name><name>input</name><operator>-&gt;</operator><name>tag1s</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type> <name>leading_zeros_size</name> <init>= <expr><call><name>bit_array_data_bytes_used</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>input</name><operator>-&gt;</operator><name>leading_zeros</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type> <name>bits_used_per_xor_size</name> <init>= <expr><call><name>simple8brle_serialized_total_size</name><argument_list>(<argument><expr><name><name>input</name><operator>-&gt;</operator><name>num_bits_used_per_xor</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type> <name>xors_size</name> <init>= <expr><call><name>bit_array_data_bytes_used</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>input</name><operator>-&gt;</operator><name>xors</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type> <name>nulls_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Size</name></type> <name>compressed_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GorillaCompressed</name> <modifier>*</modifier></type><name>compressed</name></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>input</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>has_nulls</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>nulls_size</name> <operator>=</operator> <call><name>simple8brle_serialized_total_size</name><argument_list>(<argument><expr><name><name>input</name><operator>-&gt;</operator><name>nulls</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>compressed_size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GorillaCompressed</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>tags0s_size</name> <operator>+</operator> <name>tags1s_size</name> <operator>+</operator> <name>leading_zeros_size</name> <operator>+</operator>
					  <name>bits_used_per_xor_size</name> <operator>+</operator> <name>xors_size</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>input</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>has_nulls</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>compressed_size</name> <operator>+=</operator> <name>nulls_size</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AllocSizeIsValid</name><argument_list>(<argument><expr><name>compressed_size</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"compressed size exceeds the maximum allowed (%d)"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>MaxAllocSize</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>compressed_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>compressed</name> <operator>=</operator> <operator>(</operator><name>GorillaCompressed</name> <operator>*</operator><operator>)</operator> <name>data</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>compressed</name><operator>-&gt;</operator><name>vl_len_</name></name></expr></argument>, <argument><expr><name>compressed_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>compressed</name><operator>-&gt;</operator><name>last_value</name></name> <operator>=</operator> <name><name>input</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>last_value</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>compressed</name><operator>-&gt;</operator><name>compression_algorithm</name></name> <operator>=</operator> <name>COMPRESSION_ALGORITHM_GORILLA</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>compressed</name><operator>-&gt;</operator><name>has_nulls</name></name> <operator>=</operator> <name><name>input</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>has_nulls</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>data</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GorillaCompressed</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>bytes_serialize_simple8b_and_advance</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>tags0s_size</name></expr></argument>, <argument><expr><name><name>input</name><operator>-&gt;</operator><name>tag0s</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>bytes_serialize_simple8b_and_advance</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>tags1s_size</name></expr></argument>, <argument><expr><name><name>input</name><operator>-&gt;</operator><name>tag1s</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>bytes_store_bit_array_and_advance</name><argument_list>(<argument><expr><name>data</name></expr></argument>,
											 <argument><expr><name>leading_zeros_size</name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name><name>input</name><operator>-&gt;</operator><name>leading_zeros</name></name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name><name>compressed</name><operator>-&gt;</operator><name>num_leading_zeroes_buckets</name></name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name><name>compressed</name><operator>-&gt;</operator><name>bits_used_in_last_leading_zeros_bucket</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>bytes_serialize_simple8b_and_advance</name><argument_list>(<argument><expr><name>data</name></expr></argument>,
												<argument><expr><name>bits_used_per_xor_size</name></expr></argument>,
												<argument><expr><name><name>input</name><operator>-&gt;</operator><name>num_bits_used_per_xor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>bytes_store_bit_array_and_advance</name><argument_list>(<argument><expr><name>data</name></expr></argument>,
											 <argument><expr><name>xors_size</name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name><name>input</name><operator>-&gt;</operator><name>xors</name></name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name><name>compressed</name><operator>-&gt;</operator><name>num_xor_buckets</name></name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name><name>compressed</name><operator>-&gt;</operator><name>bits_used_in_last_xor_bucket</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>input</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>has_nulls</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>bytes_serialize_simple8b_and_advance</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>nulls_size</name></expr></argument>, <argument><expr><name><name>input</name><operator>-&gt;</operator><name>nulls</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>compressed</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type>
<name>gorilla_compressor_finish</name><parameter_list>(<parameter><decl><type><name>GorillaCompressor</name> <modifier>*</modifier></type><name>compressor</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GorillaCompressed</name></type> <name>header</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>compression_algorithm</name> <operator>=</operator> <name>COMPRESSION_ALGORITHM_GORILLA</name></expr>,
		<expr><operator>.</operator><name>has_nulls</name> <operator>=</operator> <name><name>compressor</name><operator>-&gt;</operator><name>has_nulls</name></name> <operator>?</operator> <literal type="number">1</literal> <operator>:</operator> <literal type="number">0</literal></expr>,
		<expr><operator>.</operator><name>last_value</name> <operator>=</operator> <name><name>compressor</name><operator>-&gt;</operator><name>prev_val</name></name></expr>,
	}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CompressedGorillaData</name></type> <name>data</name> <init>= <expr><block>{ <expr><operator>.</operator><name>header</name> <operator>=</operator> <operator>&amp;</operator><name>header</name></expr> }</block></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>data</name><operator>.</operator><name>tag0s</name></name> <operator>=</operator> <call><name>simple8brle_compressor_finish</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>compressor</name><operator>-&gt;</operator><name>tag0s</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>data</name><operator>.</operator><name>tag0s</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>data</name><operator>.</operator><name>tag1s</name></name> <operator>=</operator> <call><name>simple8brle_compressor_finish</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>compressor</name><operator>-&gt;</operator><name>tag1s</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>data</name><operator>.</operator><name>tag1s</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>data</name><operator>.</operator><name>leading_zeros</name></name> <operator>=</operator> <name><name>compressor</name><operator>-&gt;</operator><name>leading_zeros</name></name></expr>;</expr_stmt>
	<comment type="block">/* if all elements in the compressed are the same, there will be no xors,
	 * and thus bits_used_per_xor will be empty. Since we need to store the header
	 * to get the sizing right, we force at least one bits_used_per_xor to be created
	 * in append, above
	 */</comment>
	<expr_stmt><expr><name><name>data</name><operator>.</operator><name>num_bits_used_per_xor</name></name> <operator>=</operator> <call><name>simple8brle_compressor_finish</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>compressor</name><operator>-&gt;</operator><name>bits_used_per_xor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>data</name><operator>.</operator><name>num_bits_used_per_xor</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>data</name><operator>.</operator><name>xors</name></name> <operator>=</operator> <name><name>compressor</name><operator>-&gt;</operator><name>xors</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>data</name><operator>.</operator><name>nulls</name></name> <operator>=</operator> <call><name>simple8brle_compressor_finish</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>compressor</name><operator>-&gt;</operator><name>nulls</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>compressor</name><operator>-&gt;</operator><name>has_nulls</name></name> <operator>||</operator> <name><name>data</name><operator>.</operator><name>nulls</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>compressed_gorilla_data_serialize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>tsl_gorilla_compressor_finish</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GorillaCompressor</name> <modifier>*</modifier></type><name>compressor</name> <init>=
		<expr><operator>(</operator><name>GorillaCompressor</name> <operator>*</operator><operator>)</operator> <operator>(</operator><ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>compressed</name></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>compressor</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>compressed</name> <operator>=</operator> <call><name>gorilla_compressor_finish</name><argument_list>(<argument><expr><name>compressor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>compressed</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>compressed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*******************************
 ***  DecompressionIterator  ***
 *******************************/</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>compressed_gorilla_data_init_from_pointer</name><parameter_list>(<parameter><decl><type><name>CompressedGorillaData</name> <modifier>*</modifier></type><name>expanded</name></decl></parameter>,
										  <parameter><decl><type><specifier>const</specifier> <name>GorillaCompressed</name> <modifier>*</modifier></type><name>compressed</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>has_nulls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>compressed</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>expanded</name><operator>-&gt;</operator><name>header</name></name> <operator>=</operator> <name>compressed</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>expanded</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>compression_algorithm</name></name> <operator>!=</operator> <name>COMPRESSION_ALGORITHM_GORILLA</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unknown compression algorithm"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>has_nulls</name> <operator>=</operator> <name><name>expanded</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>has_nulls</name></name> <operator>==</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>data</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GorillaCompressed</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>expanded</name><operator>-&gt;</operator><name>tag0s</name></name> <operator>=</operator> <call><name>bytes_deserialize_simple8b_and_advance</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>expanded</name><operator>-&gt;</operator><name>tag1s</name></name> <operator>=</operator> <call><name>bytes_deserialize_simple8b_and_advance</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>bytes_attach_bit_array_and_advance</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>expanded</name><operator>-&gt;</operator><name>leading_zeros</name></name></expr></argument>,
											  <argument><expr><name>data</name></expr></argument>,
											  <argument><expr><name><name>expanded</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>num_leading_zeroes_buckets</name></name></expr></argument>,
											  <argument><expr><name><name>expanded</name><operator>-&gt;</operator><name>header</name>
												  <operator>-&gt;</operator><name>bits_used_in_last_leading_zeros_bucket</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>expanded</name><operator>-&gt;</operator><name>num_bits_used_per_xor</name></name> <operator>=</operator> <call><name>bytes_deserialize_simple8b_and_advance</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>bytes_attach_bit_array_and_advance</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>expanded</name><operator>-&gt;</operator><name>xors</name></name></expr></argument>,
											  <argument><expr><name>data</name></expr></argument>,
											  <argument><expr><name><name>expanded</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>num_xor_buckets</name></name></expr></argument>,
											  <argument><expr><name><name>expanded</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>bits_used_in_last_xor_bucket</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>has_nulls</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>expanded</name><operator>-&gt;</operator><name>nulls</name></name> <operator>=</operator> <call><name>bytes_deserialize_simple8b_and_advance</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>expanded</name><operator>-&gt;</operator><name>nulls</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>compressed_gorilla_data_init_from_datum</name><parameter_list>(<parameter><decl><type><name>CompressedGorillaData</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>gorilla_compressed</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>compressed_gorilla_data_init_from_pointer</name><argument_list>(<argument><expr><name>data</name></expr></argument>,
											  <argument><expr><operator>(</operator><name>GorillaCompressed</name> <operator>*</operator><operator>)</operator> <call><name>PG_DETOAST_DATUM</name><argument_list>(
												  <argument><expr><name>gorilla_compressed</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>DecompressionIterator</name> <modifier>*</modifier></type>
<name>gorilla_decompression_iterator_from_datum_forward</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>gorilla_compressed</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>element_type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GorillaDecompressionIterator</name> <modifier>*</modifier></type><name>iterator</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>iterator</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>compression_algorithm</name></name> <operator>=</operator> <name>COMPRESSION_ALGORITHM_GORILLA</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>forward</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>element_type</name></name> <operator>=</operator> <name>element_type</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>try_next</name></name> <operator>=</operator> <name>gorilla_decompression_iterator_try_next_forward</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>prev_val</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>prev_leading_zeroes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>prev_xor_bits_used</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>compressed_gorilla_data_init_from_datum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>iterator</name><operator>-&gt;</operator><name>gorilla_data</name></name></expr></argument>, <argument><expr><name>gorilla_compressed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>simple8brle_decompression_iterator_init_forward</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>iterator</name><operator>-&gt;</operator><name>tag0s</name></name></expr></argument>, <argument><expr><name><name>iterator</name><operator>-&gt;</operator><name>gorilla_data</name><operator>.</operator><name>tag0s</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>simple8brle_decompression_iterator_init_forward</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>iterator</name><operator>-&gt;</operator><name>tag1s</name></name></expr></argument>, <argument><expr><name><name>iterator</name><operator>-&gt;</operator><name>gorilla_data</name><operator>.</operator><name>tag1s</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>bit_array_iterator_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>iterator</name><operator>-&gt;</operator><name>leading_zeros</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>iterator</name><operator>-&gt;</operator><name>gorilla_data</name><operator>.</operator><name>leading_zeros</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>simple8brle_decompression_iterator_init_forward</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>iterator</name><operator>-&gt;</operator><name>num_bits_used</name></name></expr></argument>,
													<argument><expr><name><name>iterator</name><operator>-&gt;</operator><name>gorilla_data</name><operator>.</operator><name>num_bits_used_per_xor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>bit_array_iterator_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>iterator</name><operator>-&gt;</operator><name>xors</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>iterator</name><operator>-&gt;</operator><name>gorilla_data</name><operator>.</operator><name>xors</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>has_nulls</name></name> <operator>=</operator> <name><name>iterator</name><operator>-&gt;</operator><name>gorilla_data</name><operator>.</operator><name>nulls</name></name> <operator>!=</operator> <name>NULL</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>iterator</name><operator>-&gt;</operator><name>has_nulls</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>simple8brle_decompression_iterator_init_forward</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>iterator</name><operator>-&gt;</operator><name>nulls</name></name></expr></argument>,
														<argument><expr><name><name>iterator</name><operator>-&gt;</operator><name>gorilla_data</name><operator>.</operator><name>nulls</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><operator>&amp;</operator><name><name>iterator</name><operator>-&gt;</operator><name>base</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>DecompressResult</name></type>
<name>convert_from_internal</name><parameter_list>(<parameter><decl><type><name>DecompressResultInternal</name></type> <name>res_internal</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>element_type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>res_internal</name><operator>.</operator><name>is_done</name></name> <operator>||</operator> <name><name>res_internal</name><operator>.</operator><name>is_null</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><operator>(</operator><name>DecompressResult</name><operator>)</operator><block>{
			<expr><operator>.</operator><name>is_done</name> <operator>=</operator> <name><name>res_internal</name><operator>.</operator><name>is_done</name></name></expr>,
			<expr><operator>.</operator><name>is_null</name> <operator>=</operator> <name><name>res_internal</name><operator>.</operator><name>is_null</name></name></expr>,
		}</block></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<switch>switch <condition>(<expr><name>element_type</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>FLOAT8OID</name></expr>:</case>
			<return>return <expr><operator>(</operator><name>DecompressResult</name><operator>)</operator><block>{
				<expr><operator>.</operator><name>val</name> <operator>=</operator> <call><name>Float8GetDatum</name><argument_list>(<argument><expr><call><name>bits_get_double</name><argument_list>(<argument><expr><name><name>res_internal</name><operator>.</operator><name>val</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
			}</block></expr>;</return>
		<case>case <expr><name>FLOAT4OID</name></expr>:</case>
			<return>return <expr><operator>(</operator><name>DecompressResult</name><operator>)</operator><block>{
				<expr><operator>.</operator><name>val</name> <operator>=</operator> <call><name>Float4GetDatum</name><argument_list>(<argument><expr><call><name>bits_get_float</name><argument_list>(<argument><expr><name><name>res_internal</name><operator>.</operator><name>val</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
			}</block></expr>;</return>
		<case>case <expr><name>INT8OID</name></expr>:</case>
			<return>return <expr><operator>(</operator><name>DecompressResult</name><operator>)</operator><block>{
				<expr><operator>.</operator><name>val</name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><name><name>res_internal</name><operator>.</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>,
			}</block></expr>;</return>
		<case>case <expr><name>INT4OID</name></expr>:</case>
			<return>return <expr><operator>(</operator><name>DecompressResult</name><operator>)</operator><block>{
				<expr><operator>.</operator><name>val</name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>res_internal</name><operator>.</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>,
			}</block></expr>;</return>
		<case>case <expr><name>INT2OID</name></expr>:</case>
			<return>return <expr><operator>(</operator><name>DecompressResult</name><operator>)</operator><block>{
				<expr><operator>.</operator><name>val</name> <operator>=</operator> <call><name>Int16GetDatum</name><argument_list>(<argument><expr><name><name>res_internal</name><operator>.</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>,
			}</block></expr>;</return>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid type requested from gorilla decompression"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
	<expr_stmt><expr><call><name>pg_unreachable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DecompressResultInternal</name></type>
<name>gorilla_decompression_iterator_try_next_forward_internal</name><parameter_list>(<parameter><decl><type><name>GorillaDecompressionIterator</name> <modifier>*</modifier></type><name>iter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Simple8bRleDecompressResult</name></type> <name>tag0</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Simple8bRleDecompressResult</name></type> <name>tag1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>xor</name></decl> ;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>has_nulls</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Simple8bRleDecompressResult</name></type> <name>null</name> <init>=
			<expr><call><name>simple8brle_decompression_iterator_try_next_forward</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>iter</name><operator>-&gt;</operator><name>nulls</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="block">/* Could slightly improve performance here by not returning a tail of non-null bits */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>null</name><operator>.</operator><name>is_done</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>(</operator><name>DecompressResultInternal</name><operator>)</operator><block>{
				<expr><operator>.</operator><name>is_done</name> <operator>=</operator> <name>true</name></expr>,
			}</block></expr>;</return></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>null</name><operator>.</operator><name>val</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>null</name><operator>.</operator><name>val</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>(</operator><name>DecompressResultInternal</name><operator>)</operator><block>{
				<expr><operator>.</operator><name>is_null</name> <operator>=</operator> <name>true</name></expr>,
			}</block></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>tag0</name> <operator>=</operator> <call><name>simple8brle_decompression_iterator_try_next_forward</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>iter</name><operator>-&gt;</operator><name>tag0s</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* if we don't have a null bitset, this will determine when we're done */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tag0</name><operator>.</operator><name>is_done</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>DecompressResultInternal</name><operator>)</operator><block>{
			<expr><operator>.</operator><name>is_done</name> <operator>=</operator> <name>true</name></expr>,
		}</block></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tag0</name><operator>.</operator><name>val</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>DecompressResultInternal</name><operator>)</operator><block>{
			<expr><operator>.</operator><name>val</name> <operator>=</operator> <name><name>iter</name><operator>-&gt;</operator><name>prev_val</name></name></expr>,
		}</block></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tag1</name> <operator>=</operator> <call><name>simple8brle_decompression_iterator_try_next_forward</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>iter</name><operator>-&gt;</operator><name>tag1s</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>tag1</name><operator>.</operator><name>is_done</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tag1</name><operator>.</operator><name>val</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Simple8bRleDecompressResult</name></type> <name>num_xor_bits</name></decl>;</decl_stmt>
		<comment type="block">/* get new xor sizes */</comment>
		<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>prev_leading_zeroes</name></name> <operator>=</operator>
			<call><name>bit_array_iter_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>iter</name><operator>-&gt;</operator><name>leading_zeros</name></name></expr></argument>, <argument><expr><name>BITS_PER_LEADING_ZEROS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>num_xor_bits</name> <operator>=</operator> <call><name>simple8brle_decompression_iterator_try_next_forward</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>iter</name><operator>-&gt;</operator><name>num_bits_used</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>num_xor_bits</name><operator>.</operator><name>is_done</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>prev_xor_bits_used</name></name> <operator>=</operator> <name><name>num_xor_bits</name><operator>.</operator><name>val</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>xor</name> <operator>=</operator> <call><name>bit_array_iter_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>iter</name><operator>-&gt;</operator><name>xors</name></name></expr></argument>, <argument><expr><name><name>iter</name><operator>-&gt;</operator><name>prev_xor_bits_used</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>prev_leading_zeroes</name></name> <operator>+</operator> <name><name>iter</name><operator>-&gt;</operator><name>prev_xor_bits_used</name></name> <operator>&lt;</operator> <literal type="number">64</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>xor</name> <operator>&lt;&lt;=</operator> <literal type="number">64</literal> <operator>-</operator> <operator>(</operator><name><name>iter</name><operator>-&gt;</operator><name>prev_leading_zeroes</name></name> <operator>+</operator> <name><name>iter</name><operator>-&gt;</operator><name>prev_xor_bits_used</name></name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>prev_val</name></name> <operator>^=</operator> <name>xor</name></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>DecompressResultInternal</name><operator>)</operator><block>{
		<expr><operator>.</operator><name>val</name> <operator>=</operator> <name><name>iter</name><operator>-&gt;</operator><name>prev_val</name></name></expr>,
	}</block></expr>;</return>
</block_content>}</block></function>

<function><type><name>DecompressResult</name></type>
<name>gorilla_decompression_iterator_try_next_forward</name><parameter_list>(<parameter><decl><type><name>DecompressionIterator</name> <modifier>*</modifier></type><name>iter_base</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>iter_base</name><operator>-&gt;</operator><name>compression_algorithm</name></name> <operator>==</operator> <name>COMPRESSION_ALGORITHM_GORILLA</name> <operator>&amp;&amp;</operator> <name><name>iter_base</name><operator>-&gt;</operator><name>forward</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>convert_from_internal</name><argument_list>(<argument><expr><call><name>gorilla_decompression_iterator_try_next_forward_internal</name><argument_list>(
									 <argument><expr><operator>(</operator><name>GorillaDecompressionIterator</name> <operator>*</operator><operator>)</operator> <name>iter_base</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><name><name>iter_base</name><operator>-&gt;</operator><name>element_type</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/****************************************
 *** reversed  DecompressionIterator  ***
 ****************************************/</comment>

<comment type="block">/*
 * conceptually, the bits from the gorilla algorithm can be thought of like
 *      tag0:   1 1 1 1 1 1 1 1 1 1 1
 *      tag1:  1 0 0 0 0 1 0 0 0 0 1
 *     nbits: 0    4         5      3
 *       xor:   1 2 3 4 5 a b c d e Q
 * that is, tag1 represents the transition between one value in the number of
 * leading/used bits arrays, and thus can be transversed in any order, whenever
 * we see a `1`, we switch from using are current numbers to the "next" in
 * whichever iteration order we're following. When transversing in reverse order
 * there is a little subtlety in that we run out of lengths before we run out of
 * tag1 bits (there's an implicit leading `0`), but at that point we've run out
 * of values anyway, so it does not matter.
 */</comment>

<function><type><name>DecompressionIterator</name> <modifier>*</modifier></type>
<name>gorilla_decompression_iterator_from_datum_reverse</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>gorilla_compressed</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>element_type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GorillaDecompressionIterator</name> <modifier>*</modifier></type><name>iter</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>iter</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Simple8bRleDecompressResult</name></type> <name>num_xor_bits</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>compression_algorithm</name></name> <operator>=</operator> <name>COMPRESSION_ALGORITHM_GORILLA</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>forward</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>element_type</name></name> <operator>=</operator> <name>element_type</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>try_next</name></name> <operator>=</operator> <name>gorilla_decompression_iterator_try_next_reverse</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>compressed_gorilla_data_init_from_datum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>iter</name><operator>-&gt;</operator><name>gorilla_data</name></name></expr></argument>, <argument><expr><name>gorilla_compressed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>simple8brle_decompression_iterator_init_reverse</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>iter</name><operator>-&gt;</operator><name>tag0s</name></name></expr></argument>, <argument><expr><name><name>iter</name><operator>-&gt;</operator><name>gorilla_data</name><operator>.</operator><name>tag0s</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>simple8brle_decompression_iterator_init_reverse</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>iter</name><operator>-&gt;</operator><name>tag1s</name></name></expr></argument>, <argument><expr><name><name>iter</name><operator>-&gt;</operator><name>gorilla_data</name><operator>.</operator><name>tag1s</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>bit_array_iterator_init_rev</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>iter</name><operator>-&gt;</operator><name>leading_zeros</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>iter</name><operator>-&gt;</operator><name>gorilla_data</name><operator>.</operator><name>leading_zeros</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>simple8brle_decompression_iterator_init_reverse</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>iter</name><operator>-&gt;</operator><name>num_bits_used</name></name></expr></argument>,
													<argument><expr><name><name>iter</name><operator>-&gt;</operator><name>gorilla_data</name><operator>.</operator><name>num_bits_used_per_xor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>bit_array_iterator_init_rev</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>iter</name><operator>-&gt;</operator><name>xors</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>iter</name><operator>-&gt;</operator><name>gorilla_data</name><operator>.</operator><name>xors</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>has_nulls</name></name> <operator>=</operator> <name><name>iter</name><operator>-&gt;</operator><name>gorilla_data</name><operator>.</operator><name>nulls</name></name> <operator>!=</operator> <name>NULL</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>has_nulls</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>simple8brle_decompression_iterator_init_reverse</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>iter</name><operator>-&gt;</operator><name>nulls</name></name></expr></argument>, <argument><expr><name><name>iter</name><operator>-&gt;</operator><name>gorilla_data</name><operator>.</operator><name>nulls</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* we need to know how many bits are used, even if the last value didn't store them */</comment>
	<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>prev_leading_zeroes</name></name> <operator>=</operator>
		<call><name>bit_array_iter_next_rev</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>iter</name><operator>-&gt;</operator><name>leading_zeros</name></name></expr></argument>, <argument><expr><name>BITS_PER_LEADING_ZEROS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>num_xor_bits</name> <operator>=</operator> <call><name>simple8brle_decompression_iterator_try_next_reverse</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>iter</name><operator>-&gt;</operator><name>num_bits_used</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>num_xor_bits</name><operator>.</operator><name>is_done</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>prev_xor_bits_used</name></name> <operator>=</operator> <name><name>num_xor_bits</name><operator>.</operator><name>val</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>prev_val</name></name> <operator>=</operator> <name><name>iter</name><operator>-&gt;</operator><name>gorilla_data</name><operator>.</operator><name>header</name><operator>-&gt;</operator><name>last_value</name></name></expr>;</expr_stmt>
	<return>return <expr><operator>&amp;</operator><name><name>iter</name><operator>-&gt;</operator><name>base</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DecompressResultInternal</name></type>
<name>gorilla_decompression_iterator_try_next_reverse_internal</name><parameter_list>(<parameter><decl><type><name>GorillaDecompressionIterator</name> <modifier>*</modifier></type><name>iter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Simple8bRleDecompressResult</name></type> <name>tag0</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Simple8bRleDecompressResult</name></type> <name>tag1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>xor</name></decl> ;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>has_nulls</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Simple8bRleDecompressResult</name></type> <name>null</name> <init>=
			<expr><call><name>simple8brle_decompression_iterator_try_next_reverse</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>iter</name><operator>-&gt;</operator><name>nulls</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>null</name><operator>.</operator><name>is_done</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>(</operator><name>DecompressResultInternal</name><operator>)</operator><block>{
				<expr><operator>.</operator><name>is_done</name> <operator>=</operator> <name>true</name></expr>,
			}</block></expr>;</return></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>null</name><operator>.</operator><name>val</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>null</name><operator>.</operator><name>val</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>(</operator><name>DecompressResultInternal</name><operator>)</operator><block>{
				<expr><operator>.</operator><name>is_null</name> <operator>=</operator> <name>true</name></expr>,
			}</block></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>val</name> <operator>=</operator> <name><name>iter</name><operator>-&gt;</operator><name>prev_val</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>tag0</name> <operator>=</operator> <call><name>simple8brle_decompression_iterator_try_next_reverse</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>iter</name><operator>-&gt;</operator><name>tag0s</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* if we don't have a null bitset, this will determine when we're done */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tag0</name><operator>.</operator><name>is_done</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>DecompressResultInternal</name><operator>)</operator><block>{
			<expr><operator>.</operator><name>is_done</name> <operator>=</operator> <name>true</name></expr>,
		}</block></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tag0</name><operator>.</operator><name>val</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>DecompressResultInternal</name><operator>)</operator><block>{
			<expr><operator>.</operator><name>val</name> <operator>=</operator> <name>val</name></expr>,
		}</block></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>xor</name> <operator>=</operator> <call><name>bit_array_iter_next_rev</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>iter</name><operator>-&gt;</operator><name>xors</name></name></expr></argument>, <argument><expr><name><name>iter</name><operator>-&gt;</operator><name>prev_xor_bits_used</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>prev_leading_zeroes</name></name> <operator>+</operator> <name><name>iter</name><operator>-&gt;</operator><name>prev_xor_bits_used</name></name> <operator>&lt;</operator> <literal type="number">64</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>xor</name> <operator>&lt;&lt;=</operator> <literal type="number">64</literal> <operator>-</operator> <operator>(</operator><name><name>iter</name><operator>-&gt;</operator><name>prev_leading_zeroes</name></name> <operator>+</operator> <name><name>iter</name><operator>-&gt;</operator><name>prev_xor_bits_used</name></name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>prev_val</name></name> <operator>^=</operator> <name>xor</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>tag1</name> <operator>=</operator> <call><name>simple8brle_decompression_iterator_try_next_reverse</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>iter</name><operator>-&gt;</operator><name>tag1s</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tag1</name><operator>.</operator><name>val</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* get new xor sizes */</comment>
		<decl_stmt><decl><type><name>Simple8bRleDecompressResult</name></type> <name>num_xor_bits</name> <init>=
			<expr><call><name>simple8brle_decompression_iterator_try_next_reverse</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>iter</name><operator>-&gt;</operator><name>num_bits_used</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="block">/* there're an implicit leading 0 to num_xor_bits and prev_leading_zeroes,
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>num_xor_bits</name><operator>.</operator><name>is_done</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>prev_xor_bits_used</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>prev_leading_zeroes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>prev_xor_bits_used</name></name> <operator>=</operator> <name><name>num_xor_bits</name><operator>.</operator><name>val</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>prev_leading_zeroes</name></name> <operator>=</operator>
				<call><name>bit_array_iter_next_rev</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>iter</name><operator>-&gt;</operator><name>leading_zeros</name></name></expr></argument>, <argument><expr><name>BITS_PER_LEADING_ZEROS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><operator>(</operator><name>DecompressResultInternal</name><operator>)</operator><block>{
		<expr><operator>.</operator><name>val</name> <operator>=</operator> <name>val</name></expr>,
	}</block></expr>;</return>
</block_content>}</block></function>

<function><type><name>DecompressResult</name></type>
<name>gorilla_decompression_iterator_try_next_reverse</name><parameter_list>(<parameter><decl><type><name>DecompressionIterator</name> <modifier>*</modifier></type><name>iter_base</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>iter_base</name><operator>-&gt;</operator><name>compression_algorithm</name></name> <operator>==</operator> <name>COMPRESSION_ALGORITHM_GORILLA</name> <operator>&amp;&amp;</operator>
		   <operator>!</operator><name><name>iter_base</name><operator>-&gt;</operator><name>forward</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>convert_from_internal</name><argument_list>(<argument><expr><call><name>gorilla_decompression_iterator_try_next_reverse_internal</name><argument_list>(
									 <argument><expr><operator>(</operator><name>GorillaDecompressionIterator</name> <operator>*</operator><operator>)</operator> <name>iter_base</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><name><name>iter_base</name><operator>-&gt;</operator><name>element_type</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*************
 ***  I/O  ***
 **************/</comment>

<function><type><name>void</name></type>
<name>gorilla_compressed_send</name><parameter_list>(<parameter><decl><type><name>CompressedDataHeader</name> <modifier>*</modifier></type><name>header</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CompressedGorillaData</name></type> <name>data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>GorillaCompressed</name> <modifier>*</modifier></type><name>compressed</name> <init>= <expr><operator>(</operator><name>GorillaCompressed</name> <operator>*</operator><operator>)</operator> <name>header</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>compression_algorithm</name></name> <operator>==</operator> <name>COMPRESSION_ALGORITHM_GORILLA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>compressed_gorilla_data_init_from_pointer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><name>compressed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendbyte</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>data</name><operator>.</operator><name>header</name><operator>-&gt;</operator><name>has_nulls</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint64</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>data</name><operator>.</operator><name>header</name><operator>-&gt;</operator><name>last_value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>simple8brle_serialized_send</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>data</name><operator>.</operator><name>tag0s</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>simple8brle_serialized_send</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>data</name><operator>.</operator><name>tag1s</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>bit_array_send</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>data</name><operator>.</operator><name>leading_zeros</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>simple8brle_serialized_send</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>data</name><operator>.</operator><name>num_bits_used_per_xor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>bit_array_send</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>data</name><operator>.</operator><name>xors</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>data</name><operator>.</operator><name>header</name><operator>-&gt;</operator><name>has_nulls</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>simple8brle_serialized_send</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>data</name><operator>.</operator><name>nulls</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>gorilla_compressed_recv</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GorillaCompressed</name></type> <name>header</name> <init>= <expr><block>{ <expr><operator>.</operator><name>vl_len_</name> <operator>=</operator> <block>{ <expr><literal type="number">0</literal></expr> }</block></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CompressedGorillaData</name></type> <name>data</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>header</name> <operator>=</operator> <operator>&amp;</operator><name>header</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>header</name><operator>.</operator><name>has_nulls</name></name> <operator>=</operator> <call><name>pq_getmsgbyte</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>header</name><operator>.</operator><name>has_nulls</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>header</name><operator>.</operator><name>has_nulls</name></name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid recv in gorilla: bad bool"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>header</name><operator>.</operator><name>last_value</name></name> <operator>=</operator> <call><name>pq_getmsgint64</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>data</name><operator>.</operator><name>tag0s</name></name> <operator>=</operator> <call><name>simple8brle_serialized_recv</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>data</name><operator>.</operator><name>tag1s</name></name> <operator>=</operator> <call><name>simple8brle_serialized_recv</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>data</name><operator>.</operator><name>leading_zeros</name></name> <operator>=</operator> <call><name>bit_array_recv</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>data</name><operator>.</operator><name>num_bits_used_per_xor</name></name> <operator>=</operator> <call><name>simple8brle_serialized_recv</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>data</name><operator>.</operator><name>xors</name></name> <operator>=</operator> <call><name>bit_array_recv</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>header</name><operator>.</operator><name>has_nulls</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>data</name><operator>.</operator><name>nulls</name></name> <operator>=</operator> <call><name>simple8brle_serialized_recv</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>compressed_gorilla_data_serialize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
