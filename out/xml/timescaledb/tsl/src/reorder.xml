<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/timescaledb/tsl/src/reorder.c"><comment type="block">/*
 * This file and its contents are licensed under the Timescale License.
 * Please see the included NOTICE for copyright information and
 * LICENSE-TIMESCALE for a copy of the license.
 */</comment>

<comment type="block">/*
 * This file contains source code that was copied and/or modified from the
 * PostgreSQL database, which is licensed under the open-source PostgreSQL
 * License. Please see the NOTICE at the top level directory for a copy of
 * the PostgreSQL License.
 */</comment>

<comment type="block">/* see postgres commit ab5e9caa4a3ec4765348a0482e88edcf3f6aab4a */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postgres.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/amapi.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/multixact.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/relscan.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/rewriteheap.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/transam.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/xact.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/xlog.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_authid.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/catalog.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/dependency.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/heap.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/index.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/namespace.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/objectaccess.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_am.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/toasting.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;commands/cluster.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;commands/tablecmds.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;commands/tablespace.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;commands/vacuum.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;miscadmin.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/pg_list.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/planner.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;storage/bufmgr.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;storage/lmgr.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;storage/predicate.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;storage/smgr.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;tcop/tcopprot.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/acl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/builtins.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/fmgroids.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/guc.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/inval.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/lsyscache.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/memutils.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/pg_rusage.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/relmapper.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/snapmgr.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/syscache.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/tuplesort.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;executor/spi.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/snapmgr.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compat/compat.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG13_LT</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/tuptoaster.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/toast_internals.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"annotations.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"chunk.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"chunk_copy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"chunk_index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hypertable_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"reorder.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"debug_assert.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>reorder_rel</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>tableOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>indexOid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>wait_id</name></decl></parameter>,
						<parameter><decl><type><name>Oid</name></type> <name>destination_tablespace</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>index_tablespace</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REORDER_ACCESS_EXCLUSIVE_DEADLOCK_TIMEOUT</name></cpp:macro> <cpp:value>"101000"</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>rebuild_relation</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>OldHeap</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>indexOid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>wait_id</name></decl></parameter>,
							 <parameter><decl><type><name>Oid</name></type> <name>destination_tablespace</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>index_tablespace</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>copy_heap_data</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>OIDNewHeap</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>OIDOldHeap</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>OIDOldIndex</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>pSwapToastByContent</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>pFreezeXid</name></decl></parameter>,
						   <parameter><decl><type><name>MultiXactId</name> <modifier>*</modifier></type><name>pCutoffMulti</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>finish_heap_swaps</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>OIDOldHeap</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>OIDNewHeap</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>old_index_oids</name></decl></parameter>,
							  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>new_index_oids</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>swap_toast_by_content</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_internal</name></decl></parameter>,
							  <parameter><decl><type><name>TransactionId</name></type> <name>frozenXid</name></decl></parameter>, <parameter><decl><type><name>MultiXactId</name></type> <name>cutoffMulti</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>wait_id</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>swap_relation_files</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>r1</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>r2</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>swap_toast_by_content</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_internal</name></decl></parameter>,
								<parameter><decl><type><name>TransactionId</name></type> <name>frozenXid</name></decl></parameter>, <parameter><decl><type><name>MultiXactId</name></type> <name>cutoffMulti</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>chunk_get_reorder_index</name><parameter_list>(<parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>index_relid</name></decl></parameter>,
									<parameter><decl><type><name>ChunkIndexMapping</name> <modifier>*</modifier></type><name>cim_out</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>Datum</name></type>
<name>tsl_reorder_chunk</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>chunk_id</name> <init>= <expr><ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>InvalidOid</name></expr> </then><else>: <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>index_id</name> <init>= <expr><ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>InvalidOid</name></expr> </then><else>: <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>verbose</name> <init>= <expr><ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>false</name></expr> </then><else>: <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<comment type="block">/* used for debugging purposes only see finish_heap_swaps */</comment>
	<decl_stmt><decl><type><name>Oid</name></type> <name>wait_id</name> <init>= <expr><ternary><condition><expr><call><name>PG_NARGS</name><argument_list>()</argument_list></call> <operator>&lt;</operator> <literal type="number">4</literal> <operator>||</operator> <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>InvalidOid</name></expr> </then><else>: <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Allow reorder in transactions for testing purposes only
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>wait_id</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PreventInTransactionBlock</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="string">"reorder"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>reorder_chunk</name><argument_list>(<argument><expr><name>chunk_id</name></expr></argument>, <argument><expr><name>index_id</name></expr></argument>, <argument><expr><name>verbose</name></expr></argument>, <argument><expr><name>wait_id</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>tsl_move_chunk</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>chunk_id</name> <init>= <expr><ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>InvalidOid</name></expr> </then><else>: <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>destination_tablespace</name> <init>=
		<expr><ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>InvalidOid</name></expr> </then><else>: <expr><call><name>get_tablespace_oid</name><argument_list>(<argument><expr><call><name>PG_GETARG_NAME</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>data</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>index_destination_tablespace</name> <init>=
		<expr><ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>InvalidOid</name></expr> </then><else>: <expr><call><name>get_tablespace_oid</name><argument_list>(<argument><expr><call><name>PG_GETARG_NAME</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>data</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>index_id</name> <init>= <expr><ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>InvalidOid</name></expr> </then><else>: <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>verbose</name> <init>= <expr><ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>false</name></expr> </then><else>: <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl>;</decl_stmt>

	<comment type="block">/* used for debugging purposes only see finish_heap_swaps */</comment>
	<decl_stmt><decl><type><name>Oid</name></type> <name>wait_id</name> <init>= <expr><ternary><condition><expr><call><name>PG_NARGS</name><argument_list>()</argument_list></call> <operator>&lt;</operator> <literal type="number">6</literal> <operator>||</operator> <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>InvalidOid</name></expr> </then><else>: <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Allow move in transactions for testing purposes only
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>wait_id</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PreventInTransactionBlock</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="string">"move"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Index_destination_tablespace is currently a required parameter in order
	 * to avoid situations where there is ambiguity about where indexes should
	 * be placed based on where the index was created and the new tablespace
	 * (and avoid interactions with multi-tablespace hypertable functionality).
	 * Eventually we may want to offer an option to keep indexes in the
	 * tablespace of their parent if it is specified.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>chunk_id</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>destination_tablespace</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>index_destination_tablespace</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"valid chunk, destination_tablespace, and index_destination_tablespaces "</literal>
						<literal type="string">"are required"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>chunk</name> <operator>=</operator> <call><name>ts_chunk_get_by_relid</name><argument_list>(<argument><expr><name>chunk_id</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>chunk</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a chunk"</literal></expr></argument>, <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>chunk_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ts_chunk_contains_compressed_data</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk_parent</name> <init>= <expr><call><name>ts_chunk_get_compressed_chunk_parent</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot directly move internal compression data"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Chunk \"%s\" contains compressed data for chunk \"%s\" and cannot be "</literal>
						   <literal type="string">"moved directly."</literal></expr></argument>,
						   <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>chunk_id</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>chunk_parent</name><operator>-&gt;</operator><name>table_id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Moving chunk \"%s\" will also move the compressed data."</literal></expr></argument>,
						 <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>chunk_parent</name><operator>-&gt;</operator><name>table_id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* If chunk is compressed move it by altering tablespace on both chunks */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>compressed_chunk_id</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>compressed_chunk</name> <init>= <expr><call><name>ts_chunk_get_by_id</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>compressed_chunk_id</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AlterTableCmd</name></type> <name>cmd</name> <init>= <expr><block>{ <expr><operator>.</operator><name>type</name> <operator>=</operator> <name>T_AlterTableCmd</name></expr>,
							  <expr><operator>.</operator><name>subtype</name> <operator>=</operator> <name>AT_SetTableSpace</name></expr>,
							  <expr><operator>.</operator><name>name</name> <operator>=</operator> <macro><name>get_tablespace_name</name><argument_list>(<argument>destination_tablespace</argument>)</argument_list></macro></expr> }</block></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>index_id</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ignoring index parameter"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Chunk will not be reordered as it has compressed data."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>ts_alter_table_with_event_trigger</name><argument_list>(<argument><expr><name>chunk_id</name></expr></argument>, <argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ts_alter_table_with_event_trigger</name><argument_list>(<argument><expr><name><name>compressed_chunk</name><operator>-&gt;</operator><name>table_id</name></name></expr></argument>,
										  <argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr></argument>,
										  <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* move indexes on original and compressed chunk */</comment>
		<expr_stmt><expr><call><name>ts_chunk_index_move_all</name><argument_list>(<argument><expr><name>chunk_id</name></expr></argument>, <argument><expr><name>index_destination_tablespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ts_chunk_index_move_all</name><argument_list>(<argument><expr><name><name>compressed_chunk</name><operator>-&gt;</operator><name>table_id</name></name></expr></argument>, <argument><expr><name>index_destination_tablespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>reorder_chunk</name><argument_list>(<argument><expr><name>chunk_id</name></expr></argument>,
					  <argument><expr><name>index_id</name></expr></argument>,
					  <argument><expr><name>verbose</name></expr></argument>,
					  <argument><expr><name>wait_id</name></expr></argument>,
					  <argument><expr><name>destination_tablespace</name></expr></argument>,
					  <argument><expr><name>index_destination_tablespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Implement a distributed chunk copy/move operation.
 *
 * We use a procedure because multiple steps need to be performed via multiple
 * transactions across the access node and the two datanodes that are involved.
 * The progress of the various stages/steps are tracked in the
 * CHUNK_COPY_OPERATION catalog table
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>tsl_copy_or_move_chunk_proc</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>delete_on_src_node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>chunk_id</name> <init>= <expr><ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>InvalidOid</name></expr> </then><else>: <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>src_node_name</name> <init>= <expr><ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><call><name>PG_GETARG_NAME</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dst_node_name</name> <init>= <expr><ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><call><name>PG_GETARG_NAME</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>op_id</name> <init>= <expr><ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><call><name>PG_GETARG_NAME</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>nonatomic</name> <init>= <expr><name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr></argument>, <argument><expr><name>CallContext</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					 <operator>!</operator><call><name>castNode</name><argument_list>(<argument><expr><name>CallContext</name></expr></argument>, <argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atomic</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>TS_PREVENT_FUNC_IF_READ_ONLY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PreventInTransactionBlock</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><call><name>get_func_name</name><argument_list>(<argument><expr><call><name>FC_FN_OID</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* src_node and dst_node both have to be non-NULL */</comment>
	<if_stmt><if>if <condition>(<expr><name>src_node_name</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>dst_node_name</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid source or destination node"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>chunk_id</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid chunk"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>SPI_connect_ext</name><argument_list>(<argument><expr><ternary><condition><expr><name>nonatomic</name></expr> ?</condition><then> <expr><name>SPI_OPT_NONATOMIC</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>SPI_OK_CONNECT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_connect failed: %s"</literal></expr></argument>, <argument><expr><call><name>SPI_result_code_string</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* perform the actual distributed chunk move after a few sanity checks */</comment>
	<expr_stmt><expr><call><name>chunk_copy</name><argument_list>(<argument><expr><name>chunk_id</name></expr></argument>, <argument><expr><name>src_node_name</name></expr></argument>, <argument><expr><name>dst_node_name</name></expr></argument>, <argument><expr><name>op_id</name></expr></argument>, <argument><expr><name>delete_on_src_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>SPI_finish</name><argument_list>()</argument_list></call><operator>)</operator> <operator>!=</operator> <name>SPI_OK_FINISH</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_finish failed: %s"</literal></expr></argument>, <argument><expr><call><name>SPI_result_code_string</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>tsl_move_chunk_proc</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>tsl_copy_or_move_chunk_proc</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>tsl_copy_chunk_proc</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>tsl_copy_or_move_chunk_proc</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>tsl_subscription_exec</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>save_userid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>save_sec_context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>subscription_cmd</name> <init>= <expr><ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>parsetree_list</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>parsetree_item</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>subscription_cmd</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Subscription command needs a superuser
	 * so switch to that context. But first check that the passed in user has atleast
	 * REPLICATION privileges to justify the use of this function
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>superuser</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>has_rolreplication</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must be superuser or replication role to use this function"</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>GetUserIdAndSecContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>save_userid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>save_sec_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetUserIdAndSecContext</name><argument_list>(<argument><expr><name>BOOTSTRAP_SUPERUSERID</name></expr></argument>, <argument><expr><name>save_sec_context</name> <operator>|</operator> <name>SECURITY_LOCAL_USERID_CHANGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Parse the SQL string into a list of raw parse trees.
	 */</comment>
	<expr_stmt><expr><name>parsetree_list</name> <operator>=</operator> <call><name>pg_parse_query</name><argument_list>(<argument><expr><name>subscription_cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check that we have received a "SUBSCRIPTION" related command only. Anything else
	 * needs to error out
	 */</comment>
	<macro><name>foreach</name> <argument_list>(<argument>parsetree_item</argument>, <argument>parsetree_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RawStmt</name> <modifier>*</modifier></type><name>parsetree</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RawStmt</name></expr></argument>, <argument><expr><name>parsetree_item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* We are only interested in "CREATE/DROP SUBSCRIPTION" and "ALTER SUBSCRIPTION" stmts */</comment>
		<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>stmt</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>T_CreateSubscriptionStmt</name></expr>:</case>
				<break>break;</break>

			<case>case <expr><name>T_AlterSubscriptionStmt</name></expr>:</case>
				<break>break;</break>

			<case>case <expr><name>T_DropSubscriptionStmt</name></expr>:</case>
				<break>break;</break>

			<default>default:</default>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"this function only accepts SUBSCRIPTION commands"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><call><name>SPI_connect</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>SPI_OK_CONNECT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not connect to SPI"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>SPI_execute</name><argument_list>(<argument><expr><name>subscription_cmd</name></expr></argument>, <argument><expr><name>false</name></expr></argument> <comment type="block">/* read_only */</comment>, <argument><expr><literal type="number">0</literal></expr></argument> <comment type="block">/*count*/</comment>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"error in subscription cmd \"%s\""</literal></expr></argument>, <argument><expr><name>subscription_cmd</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>SPI_finish</name><argument_list>()</argument_list></call><operator>)</operator> <operator>!=</operator> <name>SPI_OK_FINISH</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_finish failed: %s"</literal></expr></argument>, <argument><expr><call><name>SPI_result_code_string</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Restore the earlier user */</comment>
	<expr_stmt><expr><call><name>SetUserIdAndSecContext</name><argument_list>(<argument><expr><name>save_userid</name></expr></argument>, <argument><expr><name>save_sec_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>tsl_copy_chunk_cleanup_proc</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>operation_id</name> <init>= <expr><ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><call><name>PG_GETARG_NAME</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>nonatomic</name> <init>= <expr><name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr></argument>, <argument><expr><name>CallContext</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					 <operator>!</operator><call><name>castNode</name><argument_list>(<argument><expr><name>CallContext</name></expr></argument>, <argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atomic</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>TS_PREVENT_FUNC_IF_READ_ONLY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PreventInTransactionBlock</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><call><name>get_func_name</name><argument_list>(<argument><expr><call><name>FC_FN_OID</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* valid input has to be provided */</comment>
	<if_stmt><if>if <condition>(<expr><name>operation_id</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid chunk copy operation id"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>SPI_connect_ext</name><argument_list>(<argument><expr><ternary><condition><expr><name>nonatomic</name></expr> ?</condition><then> <expr><name>SPI_OPT_NONATOMIC</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>SPI_OK_CONNECT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_connect failed: %s"</literal></expr></argument>, <argument><expr><call><name>SPI_result_code_string</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* perform the cleanup/repair depending on the stage */</comment>
	<expr_stmt><expr><call><name>chunk_copy_cleanup</name><argument_list>(<argument><expr><name>operation_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>SPI_finish</name><argument_list>()</argument_list></call><operator>)</operator> <operator>!=</operator> <name>SPI_OK_FINISH</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_finish failed: %s"</literal></expr></argument>, <argument><expr><call><name>SPI_result_code_string</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>reorder_chunk</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>chunk_id</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>index_id</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>wait_id</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>destination_tablespace</name></decl></parameter>,
			  <parameter><decl><type><name>Oid</name></type> <name>index_tablespace</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cache</name> <modifier>*</modifier></type><name>hcache</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ChunkIndexMapping</name></type> <name>cim</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>chunk_id</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must provide a valid chunk to cluster"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>chunk</name> <operator>=</operator> <call><name>ts_chunk_get_by_relid</name><argument_list>(<argument><expr><name>chunk_id</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>chunk</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a chunk"</literal></expr></argument>, <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>chunk_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>ht</name> <operator>=</operator> <call><name>ts_hypertable_cache_get_cache_and_entry</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>hypertable_relid</name></name></expr></argument>, <argument><expr><name>CACHE_FLAG_NONE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Our check gives better error messages, but keep the original one too. */</comment>
	<expr_stmt><expr><call><name>ts_hypertable_permissions_check</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_class_ownercheck</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>main_table_relid</name> <init>= <expr><name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><name>OBJECT_TABLE</name></expr></argument>, <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>main_table_relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>hypertable_is_distributed</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"move_chunk() and reorder_chunk() cannot be used "</literal>
						<literal type="string">"with distributed hypertables"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>chunk_get_reorder_index</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>index_id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cim</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>index_id</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a valid clustering index for table \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>index_id</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>chunk_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"there is no previously clustered index for table \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>chunk_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>destination_tablespace</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>destination_tablespace</name> <operator>!=</operator> <name>MyDatabaseTableSpace</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AclResult</name></type> <name>aclresult</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_tablespace_aclcheck</name><argument_list>(<argument><expr><name>destination_tablespace</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_CREATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied for tablespace \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>get_tablespace_name</name><argument_list>(<argument><expr><name>destination_tablespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<empty_stmt>;</empty_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>index_tablespace</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>index_tablespace</name> <operator>!=</operator> <name>MyDatabaseTableSpace</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AclResult</name></type> <name>aclresult</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_tablespace_aclcheck</name><argument_list>(<argument><expr><name>index_tablespace</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_CREATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied for tablespace \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>get_tablespace_name</name><argument_list>(<argument><expr><name>index_tablespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cim</name><operator>.</operator><name>chunkoid</name></name> <operator>==</operator> <name>chunk_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We must mark each chunk index as clustered before calling reorder_rel()
	 * because it expects indexes that need to be rechecked (due to new
	 * transaction) to already have that mark set
	 */</comment>
	<expr_stmt><expr><call><name>ts_chunk_index_mark_clustered</name><argument_list>(<argument><expr><name><name>cim</name><operator>.</operator><name>chunkoid</name></name></expr></argument>, <argument><expr><name><name>cim</name><operator>.</operator><name>indexoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>reorder_rel</name><argument_list>(<argument><expr><name><name>cim</name><operator>.</operator><name>chunkoid</name></name></expr></argument>,
				<argument><expr><name><name>cim</name><operator>.</operator><name>indexoid</name></name></expr></argument>,
				<argument><expr><name>verbose</name></expr></argument>,
				<argument><expr><name>wait_id</name></expr></argument>,
				<argument><expr><name>destination_tablespace</name></expr></argument>,
				<argument><expr><name>index_tablespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Find the index to reorder a chunk on based on a possibly NULL indexname
 * returns NULL if no such index is found
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>chunk_get_reorder_index</name><parameter_list>(<parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>index_relid</name></decl></parameter>, <parameter><decl><type><name>ChunkIndexMapping</name> <modifier>*</modifier></type><name>cim_out</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Index search order: 1. Explicitly named index 2. Chunk cluster index 3.
	 * Hypertable cluster index
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>index_relid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>ts_chunk_index_get_by_indexrelid</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>index_relid</name></expr></argument>, <argument><expr><name>cim_out</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

		<return>return <expr><call><name>ts_chunk_index_get_by_hypertable_indexrelid</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>index_relid</name></expr></argument>, <argument><expr><name>cim_out</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>index_relid</name> <operator>=</operator> <call><name>ts_indexing_find_clustered_index</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>table_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>index_relid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>ts_chunk_index_get_by_indexrelid</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>index_relid</name></expr></argument>, <argument><expr><name>cim_out</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>index_relid</name> <operator>=</operator> <call><name>ts_indexing_find_clustered_index</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>index_relid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>ts_chunk_index_get_by_hypertable_indexrelid</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>index_relid</name></expr></argument>, <argument><expr><name>cim_out</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* The following functions are based on their equivalents in postgres's cluster.c */</comment>

<comment type="block">/*
 * reorder_rel
 *
 * This clusters the table by creating a new, clustered table and
 * swapping the relfilenodes of the new table and the old table, so
 * the OID of the original table is preserved.
 *
 * Indexes are rebuilt in the same manner.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>reorder_rel</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>tableOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>indexOid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>wait_id</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>destination_tablespace</name></decl></parameter>,
			<parameter><decl><type><name>Oid</name></type> <name>index_tablespace</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type> <name>OldHeap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_index</name></type> <name>indexForm</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>indexOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Reorder must specify an index."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Check for user-requested abort. */</comment>
	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We grab exclusive access to the target rel and index for the duration
	 * of the transaction.  (This is redundant for the single-transaction
	 * case, since cluster() already did it.)  The index lock is taken inside
	 * check_index_is_clusterable.
	 */</comment>
	<expr_stmt><expr><name>OldHeap</name> <operator>=</operator> <call><name>try_relation_open</name><argument_list>(<argument><expr><name>tableOid</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If the table has gone away, we can skip processing it */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>OldHeap</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WARNING</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table disappeared during reorder"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Since we may open a new transaction for each relation, we have to check
	 * that the relation still is what we think it is.
	 */</comment>
	<comment type="block">/* Check that the user still owns the relation */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_class_ownercheck</name><argument_list>(<argument><expr><name>tableOid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WARNING</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ownership changed during reorder"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsSystemRelation</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot reorder a system relation"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>OldHeap</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>!=</operator> <name>RELPERSISTENCE_PERMANENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"can only reorder a permanent table"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* We do not allow reordering on shared catalogs. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>OldHeap</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relisshared</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot reorder a shared catalog"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>OldHeap</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"can only reorder a relation"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Check that the index still exists
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SearchSysCacheExists1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>indexOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WARNING</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index disappeared during reorder"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Check that the index is still the one with indisclustered set.
	 */</comment>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>indexOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition> <comment type="block">/* probably can't happen */</comment>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WARNING</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid index heap during reorder"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>indexForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_index</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We always mark indexes as clustered when we intercept a cluster
	 * command, if it's not marked as such here, something has gone wrong
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>indexForm</name><operator>-&gt;</operator><name>indisclustered</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ASSERT_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid index heap during reorder"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Also check for active uses of the relation in the current transaction,
	 * including open scans and pending AFTER trigger events.
	 */</comment>
	<expr_stmt><expr><call><name>CheckTableNotInUse</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>, <argument><expr><literal type="string">"CLUSTER"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check heap and index are valid to cluster on */</comment>
	<expr_stmt><expr><call><name>check_index_is_clusterable_compat</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>, <argument><expr><name>indexOid</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* rebuild_relation does all the dirty work */</comment>
	<expr_stmt><expr><call><name>rebuild_relation</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>, <argument><expr><name>indexOid</name></expr></argument>, <argument><expr><name>verbose</name></expr></argument>, <argument><expr><name>wait_id</name></expr></argument>, <argument><expr><name>destination_tablespace</name></expr></argument>, <argument><expr><name>index_tablespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* NB: rebuild_relation does table_close() on OldHeap */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * rebuild_relation: rebuild an existing relation in index or physical order
 *
 * OldHeap: table to rebuild --- must be opened and exclusive-locked!
 * indexOid: index to cluster by, or InvalidOid to rewrite in physical order.
 *
 * NB: this routine closes OldHeap at the right time; caller should not.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>rebuild_relation</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>OldHeap</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>indexOid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>wait_id</name></decl></parameter>,
				 <parameter><decl><type><name>Oid</name></type> <name>destination_tablespace</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>index_tablespace</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>tableOid</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>tableSpace</name> <init>= <expr><ternary><condition><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>destination_tablespace</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>destination_tablespace</name></expr> </then><else>:
														  <expr><name><name>OldHeap</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltablespace</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>OIDNewHeap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>old_index_oids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>new_index_oids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name>relpersistence</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>swap_toast_by_content</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>frozenXid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactId</name></type> <name>cutoffMulti</name></decl>;</decl_stmt>

	<comment type="block">/* Mark the correct index as clustered */</comment>
	<expr_stmt><expr><call><name>mark_index_clustered</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>, <argument><expr><name>indexOid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Remember info about rel before closing OldHeap */</comment>
	<expr_stmt><expr><name>relpersistence</name> <operator>=</operator> <name><name>OldHeap</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name></expr>;</expr_stmt>

	<comment type="block">/* Close relcache entry, but keep lock until transaction commit */</comment>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Create the transient table that will receive the re-ordered data */</comment>
	<expr_stmt><expr><name>OIDNewHeap</name> <operator>=</operator> <call><name>make_new_heap_compat</name><argument_list>(<argument><expr><name>tableOid</name></expr></argument>,
									  <argument><expr><name>tableSpace</name></expr></argument>,
									  <argument><expr><name><name>OldHeap</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relam</name></name></expr></argument>,
									  <argument><expr><name>relpersistence</name></expr></argument>,
									  <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Copy the heap data into the new table in the desired order */</comment>
	<expr_stmt><expr><call><name>copy_heap_data</name><argument_list>(<argument><expr><name>OIDNewHeap</name></expr></argument>,
				   <argument><expr><name>tableOid</name></expr></argument>,
				   <argument><expr><name>indexOid</name></expr></argument>,
				   <argument><expr><name>verbose</name></expr></argument>,
				   <argument><expr><operator>&amp;</operator><name>swap_toast_by_content</name></expr></argument>,
				   <argument><expr><operator>&amp;</operator><name>frozenXid</name></expr></argument>,
				   <argument><expr><operator>&amp;</operator><name>cutoffMulti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Create versions of the tables indexes for the new table */</comment>
	<expr_stmt><expr><name>new_index_oids</name> <operator>=</operator>
		<call><name>ts_chunk_index_duplicate</name><argument_list>(<argument><expr><name>tableOid</name></expr></argument>, <argument><expr><name>OIDNewHeap</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>old_index_oids</name></expr></argument>, <argument><expr><name>index_tablespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Swap the physical files of the target and transient tables, then
	 * rebuild the target's indexes and throw away the transient table.
	 */</comment>
	<expr_stmt><expr><call><name>finish_heap_swaps</name><argument_list>(<argument><expr><name>tableOid</name></expr></argument>,
					  <argument><expr><name>OIDNewHeap</name></expr></argument>,
					  <argument><expr><name>old_index_oids</name></expr></argument>,
					  <argument><expr><name>new_index_oids</name></expr></argument>,
					  <argument><expr><name>swap_toast_by_content</name></expr></argument>,
					  <argument><expr><name>true</name></expr></argument>,
					  <argument><expr><name>frozenXid</name></expr></argument>,
					  <argument><expr><name>cutoffMulti</name></expr></argument>,
					  <argument><expr><name>wait_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Do the physical copying of heap data.
 *
 * There are three output parameters:
 * *pSwapToastByContent is set true if toast tables must be swapped by content.
 * *pFreezeXid receives the TransactionId used as freeze cutoff point.
 * *pCutoffMulti receives the MultiXactId used as a cutoff point.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>copy_heap_data</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>OIDNewHeap</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>OIDOldHeap</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>OIDOldIndex</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>,
			   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>pSwapToastByContent</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>pFreezeXid</name></decl></parameter>, <parameter><decl><type><name>MultiXactId</name> <modifier>*</modifier></type><name>pCutoffMulti</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type> <name>NewHeap</name></decl>, <decl><type ref="prev"/><name>OldHeap</name></decl>, <decl><type ref="prev"/><name>OldIndex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>relRelation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>reltup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>relform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name> <name>PG_USED_FOR_ASSERTS_ONLY</name></type> <name>oldTupDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>newTupDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>natts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>OldestXmin</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>FreezeXid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactId</name></type> <name>MultiXactCutoff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>use_sort</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>num_tuples</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>tups_vacuumed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>tups_recently_dead</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>num_pages</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>elevel</name> <init>= <expr><ternary><condition><expr><name>verbose</name></expr> ?</condition><then> <expr><name>INFO</name></expr> </then><else>: <expr><name>DEBUG2</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGRUsage</name></type> <name>ru0</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>pg_rusage_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ru0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Open the relations we need.
	 */</comment>
	<expr_stmt><expr><name>NewHeap</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>OIDNewHeap</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>OldHeap</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>OIDOldHeap</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>OIDOldIndex</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>OldIndex</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name>OIDOldIndex</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>OldIndex</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Their tuple descriptors should be exactly alike, but here we only need
	 * assume that they have the same number of columns.
	 */</comment>
	<expr_stmt><expr><name>oldTupDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>newTupDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>NewHeap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>newTupDesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>==</operator> <name><name>oldTupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Preallocate values/isnull arrays */</comment>
	<expr_stmt><expr><name>natts</name> <operator>=</operator> <name><name>newTupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>values</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>natts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>isnull</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>natts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the OldHeap has a toast table, get lock on the toast table to keep
	 * it from being vacuumed.  This is needed because autovacuum processes
	 * toast tables independently of their main tables, with no lock on the
	 * latter.  If an autovacuum were to start on the toast table after we
	 * compute our OldestXmin below, it would use a later OldestXmin, and then
	 * possibly remove as DEAD toast tuples belonging to main tuples we think
	 * are only RECENTLY_DEAD.  Then we'd fail while trying to copy those
	 * tuples.
	 *
	 * We don't need to open the toast relation here, just lock it.  The lock
	 * will be held till end of transaction.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>OldHeap</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name><name>OldHeap</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* use_wal off requires smgr_targblock be initially invalid */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>RelationGetTargetBlock</name><argument_list>(<argument><expr><name>NewHeap</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>InvalidBlockNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If both tables have TOAST tables, perform toast swap by content.  It is
	 * possible that the old table has a toast table but the new one doesn't,
	 * if toastable columns have been dropped.  In that case we have to do
	 * swap by links.  This is okay because swap by content is only essential
	 * for system catalogs, and we don't support schema changes for them.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>OldHeap</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltoastrelid</name></name> <operator>&amp;&amp;</operator> <name><name>NewHeap</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>pSwapToastByContent</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * When doing swap by content, any toast pointers written into NewHeap
		 * must use the old toast table's OID, because that's where the toast
		 * data will eventually be found.  Set this up by setting rd_toastoid.
		 * This also tells toast_save_datum() to preserve the toast value
		 * OIDs, which we want so as not to invalidate toast pointers in
		 * system catalog caches, and to avoid making multiple copies of a
		 * single toast value.
		 *
		 * Note that we must hold NewHeap open until we are done writing data,
		 * since the relcache will not guarantee to remember this setting once
		 * the relation is closed.  Also, this technique depends on the fact
		 * that no one will try to read from the NewHeap until after we've
		 * finished writing it and swapping the rels --- otherwise they could
		 * follow the toast pointers to the wrong place.  (It would actually
		 * work for values copied over from the old toast table, but not for
		 * any values that we toast which were previously not toasted.)
		 */</comment>
		<expr_stmt><expr><name><name>NewHeap</name><operator>-&gt;</operator><name>rd_toastoid</name></name> <operator>=</operator> <name><name>OldHeap</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>pSwapToastByContent</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Compute xids used to freeze and weed out dead tuples and multixacts.
	 * Since we're going to rewrite the whole table anyway, there's no reason
	 * not to be aggressive about this.
	 */</comment>
	<expr_stmt><expr><call><name>vacuum_set_xid_limits_compat</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>OldestXmin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>FreezeXid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>MultiXactCutoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * FreezeXid will become the table's new relfrozenxid, and that mustn't go
	 * backwards, so take the max.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>FreezeXid</name></expr></argument>, <argument><expr><name><name>OldHeap</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relfrozenxid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>FreezeXid</name> <operator>=</operator> <name><name>OldHeap</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relfrozenxid</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * MultiXactCutoff, similarly, shouldn't go backwards either.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>MultiXactIdPrecedes</name><argument_list>(<argument><expr><name>MultiXactCutoff</name></expr></argument>, <argument><expr><name><name>OldHeap</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relminmxid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>MultiXactCutoff</name> <operator>=</operator> <name><name>OldHeap</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relminmxid</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* return selected values to caller */</comment>
	<expr_stmt><expr><operator>*</operator><name>pFreezeXid</name> <operator>=</operator> <name>FreezeXid</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>pCutoffMulti</name> <operator>=</operator> <name>MultiXactCutoff</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We know how to use a sort to duplicate the ordering of a btree index,
	 * and will use seqscan-and-sort for that.  Otherwise, always use an
	 * indexscan for other indexes or plain seqscan if no index is supplied.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>OldIndex</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>OldIndex</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relam</name></name> <operator>==</operator> <name>BTREE_AM_OID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>use_sort</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>use_sort</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Log what we're doing */</comment>
	<if_stmt><if>if <condition>(<expr><name>OldIndex</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>use_sort</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"reordering \"%s.%s\" using index scan on \"%s\""</literal></expr></argument>,
						<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>OldIndex</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>use_sort</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"reordering \"%s.%s\" using sequential scan and sort"</literal></expr></argument>,
						<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"tried to use a reorder without an index \"%s.%s\""</literal></expr></argument>,
						<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>table_relation_copy_for_cluster</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>,
									<argument><expr><name>NewHeap</name></expr></argument>,
									<argument><expr><name>OldIndex</name></expr></argument>,
									<argument><expr><name>use_sort</name></expr></argument>,
									<argument><expr><name>OldestXmin</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>FreezeXid</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>MultiXactCutoff</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>num_tuples</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>tups_vacuumed</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>tups_recently_dead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Reset rd_toastoid just to be tidy --- it shouldn't be looked at again */</comment>
	<expr_stmt><expr><name><name>NewHeap</name><operator>-&gt;</operator><name>rd_toastoid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>num_pages</name> <operator>=</operator> <call><name>RelationGetNumberOfBlocks</name><argument_list>(<argument><expr><name>NewHeap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Log what we did */</comment>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\": found %.0f removable, %.0f nonremovable row versions in %u pages"</literal></expr></argument>,
					<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>tups_vacuumed</name></expr></argument>,
					<argument><expr><name>num_tuples</name></expr></argument>,
					<argument><expr><call><name>RelationGetNumberOfBlocks</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%.0f dead row versions cannot be removed yet.\n"</literal>
					   <literal type="string">"%s."</literal></expr></argument>,
					   <argument><expr><name>tups_recently_dead</name></expr></argument>,
					   <argument><expr><call><name>pg_rusage_show</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ru0</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Clean up */</comment>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>OldIndex</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>OldIndex</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>NewHeap</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Update pg_class to reflect the correct values of pages and tuples. */</comment>
	<expr_stmt><expr><name>relRelation</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>reltup</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>OIDNewHeap</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>OIDNewHeap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>relform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>relform</name><operator>-&gt;</operator><name>relpages</name></name> <operator>=</operator> <name>num_pages</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relform</name><operator>-&gt;</operator><name>reltuples</name></name> <operator>=</operator> <name>num_tuples</name></expr>;</expr_stmt>

	<comment type="block">/* Don't update the stats for pg_class.  See swap_relation_files. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>OIDOldHeap</name> <operator>!=</operator> <name>RelationRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CacheInvalidateRelcacheByTuple</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Clean up. */</comment>
	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>relRelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make the update visible */</comment>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Remove the transient table that was built by make_new_heap, and finish
 * cleaning up (including rebuilding all indexes on the old heap).
 *
 * NB: new_index_oids must be in the same order as RelationGetIndexList
 *
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>finish_heap_swaps</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>OIDOldHeap</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>OIDNewHeap</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>old_index_oids</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>new_index_oids</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name></type> <name>swap_toast_by_content</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_internal</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>frozenXid</name></decl></parameter>,
				  <parameter><decl><type><name>MultiXactId</name></type> <name>cutoffMulti</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>wait_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>object</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>oldHeapRel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>old_index_cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>new_index_cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>config_change</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>

	<comment type="block">/*
	 * For debug purposes we serialize against wait_id if it exists, this
	 * allows us to "pause" reorder immediately before swapping in the new
	 * table
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>wait_id</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type> <name>waiter</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>wait_id</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>waiter</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * There's a risk of deadlock if some other process is also trying to
	 * upgrade their lock in the same manner as us, at this time. Since our
	 * transaction has performed a large amount of work, and only needs to be
	 * run once per chunk, we do not want to abort it due to this deadlock. To
	 * prevent abort we set our `deadlock_timeout` to a large value in the
	 * expectation that the other process will timeout and abort first.
	 * Currently we set `deadlock_timeout` to 1 hour, as this should be longer
	 * than any other normal process, while still allowing the system to make
	 * progress in the event of a real deadlock. As this is the last lock we
	 * grab, and the setting is local to our transaction we do not bother
	 * changing the guc back.
	 */</comment>
	<expr_stmt><expr><name>config_change</name> <operator>=</operator> <call><name>set_config_option</name><argument_list>(<argument><expr><literal type="string">"deadlock_timeout"</literal></expr></argument>,
									  <argument><expr><name>REORDER_ACCESS_EXCLUSIVE_DEADLOCK_TIMEOUT</name></expr></argument>,
									  <argument><expr><name>PGC_SUSET</name></expr></argument>,
									  <argument><expr><name>PGC_S_SESSION</name></expr></argument>,
									  <argument><expr><name>GUC_ACTION_LOCAL</name></expr></argument>,
									  <argument><expr><name>true</name></expr></argument>,
									  <argument><expr><literal type="number">0</literal></expr></argument>,
									  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>config_change</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"deadlock_timeout guc does not exist."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>config_change</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not set deadlock_timeout guc."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>oldHeapRel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>OIDOldHeap</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * All predicate locks on the tuples or pages are about to be made
	 * invalid, because we move tuples around.  Promote them to relation
	 * locks.  Predicate locks on indexes will be promoted when they are
	 * reindexed.
	 */</comment>
	<expr_stmt><expr><call><name>TransferPredicateLocksToHeapRelation</name><argument_list>(<argument><expr><name>oldHeapRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Swap the contents of the heap relations (including any toast tables).
	 * Also set old heap's relfrozenxid to frozenXid.
	 */</comment>
	<expr_stmt><expr><call><name>swap_relation_files</name><argument_list>(<argument><expr><name>OIDOldHeap</name></expr></argument>,
						<argument><expr><name>OIDNewHeap</name></expr></argument>,
						<argument><expr><name>swap_toast_by_content</name></expr></argument>,
						<argument><expr><name>is_internal</name></expr></argument>,
						<argument><expr><name>frozenXid</name></expr></argument>,
						<argument><expr><name>cutoffMulti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Swap the contents of the indexes */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>old_index_oids</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>new_index_oids</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>forboth</name> <argument_list>(<argument>old_index_cell</argument>, <argument>old_index_oids</argument>, <argument>new_index_cell</argument>, <argument>new_index_oids</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>old_index_oid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>old_index_cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>new_index_oid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>new_index_cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>swap_relation_files</name><argument_list>(<argument><expr><name>old_index_oid</name></expr></argument>,
							<argument><expr><name>new_index_oid</name></expr></argument>,
							<argument><expr><name>swap_toast_by_content</name></expr></argument>,
							<argument><expr><name>true</name></expr></argument>,
							<argument><expr><name>frozenXid</name></expr></argument>,
							<argument><expr><name>cutoffMulti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>oldHeapRel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Destroy new heap with old filenode */</comment>
	<expr_stmt><expr><name><name>object</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>object</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>OIDNewHeap</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>object</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * The new relation is local to our transaction and we know nothing
	 * depends on it, so DROP_RESTRICT should be OK.
	 */</comment>
	<expr_stmt><expr><call><name>performDeletion</name><argument_list>(<argument><expr><operator>&amp;</operator><name>object</name></expr></argument>, <argument><expr><name>DROP_RESTRICT</name></expr></argument>, <argument><expr><name>PERFORM_DELETION_INTERNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* performDeletion does CommandCounterIncrement at end */</comment>

	<comment type="block">/*
	 * At this point, everything is kosher except that, if we did toast swap
	 * by links, the toast table's name corresponds to the transient table.
	 * The name is irrelevant to the backend because it's referenced by OID,
	 * but users looking at the catalogs could be confused.  Rename it to
	 * prevent this problem.
	 *
	 * Note no lock required on the relation, because we already hold an
	 * exclusive lock on it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>swap_toast_by_content</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type> <name>newrel</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>newrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>OIDOldHeap</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>newrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type> <name>toastidx</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name></type> <name><name>NewToastName</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>

			<comment type="block">/* Get the associated valid index to be renamed */</comment>
			<expr_stmt><expr><name>toastidx</name> <operator>=</operator> <call><name>toast_get_valid_index</name><argument_list>(<argument><expr><name><name>newrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* rename the toast table ... */</comment>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>NewToastName</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>, <argument><expr><literal type="string">"pg_toast_%u"</literal></expr></argument>, <argument><expr><name>OIDOldHeap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>RenameRelationInternal</name><argument_list>(<argument><expr><name><name>newrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr></argument>, <argument><expr><name>NewToastName</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* ... and its valid index too. */</comment>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>NewToastName</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>, <argument><expr><literal type="string">"pg_toast_%u_index"</literal></expr></argument>, <argument><expr><name>OIDOldHeap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>RenameRelationInternal</name><argument_list>(<argument><expr><name>toastidx</name></expr></argument>, <argument><expr><name>NewToastName</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>newrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* it's not a catalog table, clear any missing attribute settings */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type> <name>newrel</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>newrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>OIDOldHeap</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>RelationClearMissing</name><argument_list>(<argument><expr><name>newrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>newrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Swap the physical files of two given relations.
 *
 * We swap the physical identity (reltablespace, relfilenode) while keeping the
 * same logical identities of the two relations.  relpersistence is also
 * swapped, which is critical since it determines where buffers live for each
 * relation.
 *
 * We can swap associated TOAST data in either of two ways: recursively swap
 * the physical content of the toast tables (and their indexes), or swap the
 * TOAST links in the given relations' pg_class entries. The latter is the only
 * way to handle cases in which a toast table is added or removed altogether.
 *
 * Additionally, the first relation is marked with relfrozenxid set to
 * frozenXid.  It seems a bit ugly to have this here, but the caller would
 * have to do it anyway, so having it here saves a heap_update.  Note: in
 * the swap-toast-links case, we assume we don't need to change the toast
 * table's relfrozenxid: the new version of the toast table should already
 * have relfrozenxid set to RecentXmin, which is good enough.
 *
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>swap_relation_files</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>r1</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>r2</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>swap_toast_by_content</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_internal</name></decl></parameter>,
					<parameter><decl><type><name>TransactionId</name></type> <name>frozenXid</name></decl></parameter>, <parameter><decl><type><name>MultiXactId</name></type> <name>cutoffMulti</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type> <name>relRelation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>reltup1</name></decl>, <decl><type ref="prev"/><name>reltup2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>relform1</name></decl>, <decl><type ref="prev"/><name>relform2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relfilenode1</name></decl>, <decl><type ref="prev"/><name>relfilenode2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>swaptemp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name>swptmpchr</name></decl>;</decl_stmt>

	<comment type="block">/* We need writable copies of both pg_class tuples. */</comment>
	<expr_stmt><expr><name>relRelation</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>reltup1</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>reltup1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>relform1</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>reltup1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>reltup2</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>reltup2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>relform2</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>reltup2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>relfilenode1</name> <operator>=</operator> <name><name>relform1</name><operator>-&gt;</operator><name>relfilenode</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>relfilenode2</name> <operator>=</operator> <name><name>relform2</name><operator>-&gt;</operator><name>relfilenode</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relfilenode1</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relfilenode2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot reorder mapped relation \"%s\"."</literal></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>relform1</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* swap relfilenodes, reltablespaces, relpersistence */</comment>

	<expr_stmt><expr><name>swaptemp</name> <operator>=</operator> <name><name>relform1</name><operator>-&gt;</operator><name>relfilenode</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relform1</name><operator>-&gt;</operator><name>relfilenode</name></name> <operator>=</operator> <name><name>relform2</name><operator>-&gt;</operator><name>relfilenode</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relform2</name><operator>-&gt;</operator><name>relfilenode</name></name> <operator>=</operator> <name>swaptemp</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>swaptemp</name> <operator>=</operator> <name><name>relform1</name><operator>-&gt;</operator><name>reltablespace</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relform1</name><operator>-&gt;</operator><name>reltablespace</name></name> <operator>=</operator> <name><name>relform2</name><operator>-&gt;</operator><name>reltablespace</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relform2</name><operator>-&gt;</operator><name>reltablespace</name></name> <operator>=</operator> <name>swaptemp</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>swptmpchr</name> <operator>=</operator> <name><name>relform1</name><operator>-&gt;</operator><name>relpersistence</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relform1</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>=</operator> <name><name>relform2</name><operator>-&gt;</operator><name>relpersistence</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relform2</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>=</operator> <name>swptmpchr</name></expr>;</expr_stmt>

	<comment type="block">/* Also swap toast links, if we're swapping by links */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>swap_toast_by_content</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>swaptemp</name> <operator>=</operator> <name><name>relform1</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relform1</name><operator>-&gt;</operator><name>reltoastrelid</name></name> <operator>=</operator> <name><name>relform2</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relform2</name><operator>-&gt;</operator><name>reltoastrelid</name></name> <operator>=</operator> <name>swaptemp</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* set rel1's frozen Xid and minimum MultiXid */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>relform1</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_INDEX</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>frozenXid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relform1</name><operator>-&gt;</operator><name>relfrozenxid</name></name> <operator>=</operator> <name>frozenXid</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>MultiXactIdIsValid</name><argument_list>(<argument><expr><name>cutoffMulti</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relform1</name><operator>-&gt;</operator><name>relminmxid</name></name> <operator>=</operator> <name>cutoffMulti</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* swap size statistics too, since new rel has freshly-updated stats */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int32</name></type> <name>swap_pages</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>float4</name></type> <name>swap_tuples</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type> <name>swap_allvisible</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>swap_pages</name> <operator>=</operator> <name><name>relform1</name><operator>-&gt;</operator><name>relpages</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relform1</name><operator>-&gt;</operator><name>relpages</name></name> <operator>=</operator> <name><name>relform2</name><operator>-&gt;</operator><name>relpages</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relform2</name><operator>-&gt;</operator><name>relpages</name></name> <operator>=</operator> <name>swap_pages</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>swap_tuples</name> <operator>=</operator> <name><name>relform1</name><operator>-&gt;</operator><name>reltuples</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relform1</name><operator>-&gt;</operator><name>reltuples</name></name> <operator>=</operator> <name><name>relform2</name><operator>-&gt;</operator><name>reltuples</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relform2</name><operator>-&gt;</operator><name>reltuples</name></name> <operator>=</operator> <name>swap_tuples</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>swap_allvisible</name> <operator>=</operator> <name><name>relform1</name><operator>-&gt;</operator><name>relallvisible</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relform1</name><operator>-&gt;</operator><name>relallvisible</name></name> <operator>=</operator> <name><name>relform2</name><operator>-&gt;</operator><name>relallvisible</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relform2</name><operator>-&gt;</operator><name>relallvisible</name></name> <operator>=</operator> <name>swap_allvisible</name></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Update the tuples in pg_class. */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CatalogIndexState</name></type> <name>indstate</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>indstate</name> <operator>=</operator> <call><name>CatalogOpenIndexes</name><argument_list>(<argument><expr><name>relRelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CatalogTupleUpdateWithInfo</name><argument_list>(<argument><expr><name>relRelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>reltup1</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>reltup1</name></expr></argument>, <argument><expr><name>indstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CatalogTupleUpdateWithInfo</name><argument_list>(<argument><expr><name>relRelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>reltup2</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>reltup2</name></expr></argument>, <argument><expr><name>indstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CatalogCloseIndexes</name><argument_list>(<argument><expr><name>indstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Post alter hook for modified relations. The change to r2 is always
	 * internal, but r1 depends on the invocation context.
	 */</comment>
	<expr_stmt><expr><call><name>InvokeObjectPostAlterHookArg</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>is_internal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>InvokeObjectPostAlterHookArg</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we have toast tables associated with the relations being swapped,
	 * deal with them too.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>relform1</name><operator>-&gt;</operator><name>reltoastrelid</name></name> <operator>||</operator> <name><name>relform2</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>swap_toast_by_content</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>relform1</name><operator>-&gt;</operator><name>reltoastrelid</name></name> <operator>&amp;&amp;</operator> <name><name>relform2</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Recursively swap the contents of the toast tables */</comment>
				<expr_stmt><expr><call><name>swap_relation_files</name><argument_list>(<argument><expr><name><name>relform1</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr></argument>,
									<argument><expr><name><name>relform2</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr></argument>,
									<argument><expr><name>swap_toast_by_content</name></expr></argument>,
									<argument><expr><name>is_internal</name></expr></argument>,
									<argument><expr><name>frozenXid</name></expr></argument>,
									<argument><expr><name>cutoffMulti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* caller messed up */</comment>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot swap toast files by content when there's only one"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * We swapped the ownership links, so we need to change dependency
			 * data to match.
			 *
			 * NOTE: it is possible that only one table has a toast table.
			 *
			 * NOTE: at present, a TOAST table's only dependency is the one on
			 * its owning table.  If more are ever created, we'd need to use
			 * something more selective than deleteDependencyRecordsFor() to
			 * get rid of just the link we want.
			 */</comment>
			<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>baseobject</name></decl>, <decl><type ref="prev"/><name>toastobject</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>long</name></type> <name>count</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * The original code disallowed this case for system catalogs. We
			 * don't allow reordering system catalogs, but Assert anyway
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsSystemClass</name><argument_list>(<argument><expr><name>r1</name></expr></argument>, <argument><expr><name>relform1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Delete old dependencies */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>relform1</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>count</name> <operator>=</operator>
					<call><name>deleteDependencyRecordsFor</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name><name>relform1</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>count</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"expected one dependency record for TOAST table, found %ld"</literal></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>relform2</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>count</name> <operator>=</operator>
					<call><name>deleteDependencyRecordsFor</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name><name>relform2</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>count</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"expected one dependency record for TOAST table, found %ld"</literal></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Register new dependencies */</comment>
			<expr_stmt><expr><name><name>baseobject</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>baseobject</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>toastobject</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>toastobject</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>relform1</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>baseobject</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>r1</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>toastobject</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name><name>relform1</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>toastobject</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>baseobject</name></expr></argument>, <argument><expr><name>DEPENDENCY_INTERNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>relform2</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>baseobject</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>r2</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>toastobject</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name><name>relform2</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>toastobject</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>baseobject</name></expr></argument>, <argument><expr><name>DEPENDENCY_INTERNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we're swapping two toast tables by content, do the same for their
	 * valid index. The swap can actually be safely done only if the relations
	 * have indexes.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>swap_toast_by_content</name> <operator>&amp;&amp;</operator> <name><name>relform1</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_TOASTVALUE</name> <operator>&amp;&amp;</operator>
		<name><name>relform2</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_TOASTVALUE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>toastIndex1</name></decl>, <decl><type ref="prev"/><name>toastIndex2</name></decl>;</decl_stmt>

		<comment type="block">/* Get valid index for each relation */</comment>
		<expr_stmt><expr><name>toastIndex1</name> <operator>=</operator> <call><name>toast_get_valid_index</name><argument_list>(<argument><expr><name>r1</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>toastIndex2</name> <operator>=</operator> <call><name>toast_get_valid_index</name><argument_list>(<argument><expr><name>r2</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>swap_relation_files</name><argument_list>(<argument><expr><name>toastIndex1</name></expr></argument>,
							<argument><expr><name>toastIndex2</name></expr></argument>,
							<argument><expr><name>swap_toast_by_content</name></expr></argument>,
							<argument><expr><name>is_internal</name></expr></argument>,
							<argument><expr><name>InvalidTransactionId</name></expr></argument>,
							<argument><expr><name>InvalidMultiXactId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Clean up. */</comment>
	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>reltup1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>reltup2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>relRelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Close both relcache entries' smgr links.  We need this kludge because
	 * both links will be invalidated during upcoming CommandCounterIncrement.
	 * Whichever of the rels is the second to be cleared will have a dangling
	 * reference to the other's smgr entry.  Rather than trying to avoid this
	 * by ordering operations just so, it's easiest to close the links first.
	 * (Fortunately, since one of the entries is local in our transaction,
	 * it's sufficient to clear out our own relcache this way; the problem
	 * cannot arise for other backends when they see our update on the
	 * non-transient relation.)
	 *
	 * Caution: the placement of this step interacts with the decision to
	 * handle toast rels by recursion.  When we are trying to rebuild pg_class
	 * itself, the smgr close on pg_class must happen after all accesses in
	 * this function.
	 */</comment>
	<expr_stmt><expr><call><name>RelationCloseSmgrByOid</name><argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RelationCloseSmgrByOid</name><argument_list>(<argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
