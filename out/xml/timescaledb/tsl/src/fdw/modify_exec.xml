<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/timescaledb/tsl/src/fdw/modify_exec.c"><comment type="block">/*
 * This file and its contents are licensed under the Timescale License.
 * Please see the included NOTICE for copyright information and
 * LICENSE-TIMESCALE for a copy of the license.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postgres.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;executor/executor.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;parser/parsetree.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/plannodes.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;commands/explain.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;foreign/fdwapi.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/rel.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fmgr.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;miscadmin.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;guc.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;remote/async.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;remote/stmt_params.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;remote/connection.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;remote/dist_txn.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;remote/utils.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;remote/tuplefactory.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ts_catalog/chunk_data_node.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/chunk_insert_state.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"scan_plan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"modify_exec.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"modify_plan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tsl/src/chunk.h"</cpp:file></cpp:include>

<comment type="block">/*
 * This enum describes what's kept in the fdw_private list for a ModifyTable
 * node referencing a timescaledb_fdw foreign table.  We store:
 *
 * 1) INSERT/UPDATE/DELETE statement text to be sent to the data node
 * 2) Integer list of target attribute numbers for INSERT/UPDATE
 *	  (NIL for a DELETE)
 * 3) Boolean flag showing if the remote query has a RETURNING clause
 * 4) Integer list of attribute numbers retrieved by RETURNING, if any
 */</comment>
<enum>enum <name>FdwModifyPrivateIndex</name>
<block>{
	<comment type="block">/* SQL statement to execute remotely (as a String node) */</comment>
	<decl><name>FdwModifyPrivateUpdateSql</name></decl>,
	<comment type="block">/* Integer list of target attribute numbers for INSERT/UPDATE */</comment>
	<decl><name>FdwModifyPrivateTargetAttnums</name></decl>,
	<comment type="block">/* has-returning flag (as an integer Value node) */</comment>
	<decl><name>FdwModifyPrivateHasReturning</name></decl>,
	<comment type="block">/* Integer list of attribute numbers retrieved by RETURNING */</comment>
	<decl><name>FdwModifyPrivateRetrievedAttrs</name></decl>,
	<comment type="block">/* The data nodes for the current chunk */</comment>
	<decl><name>FdwModifyPrivateDataNodes</name></decl>,
	<comment type="block">/* Insert state for the current chunk */</comment>
	<decl><name>FdwModifyPrivateChunkInsertState</name></decl>,
}</block>;</enum>

<typedef>typedef <type><struct>struct <name>TsFdwDataNodeState</name>
<block>{
	<decl_stmt><decl><type><name>TSConnectionId</name></type> <name>id</name></decl>;</decl_stmt>
	<comment type="block">/* for remote query execution */</comment>
	<decl_stmt><decl><type><name>TSConnection</name> <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>	  <comment type="block">/* connection for the scan */</comment>
	<decl_stmt><decl><type><name>PreparedStmt</name> <modifier>*</modifier></type><name>p_stmt</name></decl>;</decl_stmt> <comment type="block">/* prepared statement handle, if created */</comment>
}</block></struct></type> <name>TsFdwDataNodeState</name>;</typedef>

<comment type="block">/*
 * Execution state of a foreign insert/update/delete operation.
 */</comment>
<typedef>typedef <type><struct>struct <name>TsFdwModifyState</name>
<block>{
	<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name></decl>;</decl_stmt>						  <comment type="block">/* relcache entry for the foreign table */</comment>
	<decl_stmt><decl><type><name>AttConvInMetadata</name> <modifier>*</modifier></type><name>att_conv_metadata</name></decl>;</decl_stmt> <comment type="block">/* attribute datatype conversion metadata for converting
											 result to tuples */</comment>

	<comment type="block">/* extracted fdw_private data */</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>		<comment type="block">/* text of INSERT/UPDATE/DELETE command */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>target_attrs</name></decl>;</decl_stmt> <comment type="block">/* list of target attribute numbers */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>has_returning</name></decl>;</decl_stmt> <comment type="block">/* is there a RETURNING clause? */</comment>
	<decl_stmt><decl><type><name>TupleFactory</name> <modifier>*</modifier></type><name>tupfactory</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>AttrNumber</name></type> <name>ctid_attno</name></decl>;</decl_stmt> <comment type="block">/* attnum of input resjunk ctid column */</comment>

	<decl_stmt><decl><type><name>bool</name></type> <name>prepared</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>num_data_nodes</name></decl>;</decl_stmt>		 <comment type="block">/* number of "available" datanodes */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>num_all_data_nodes</name></decl>;</decl_stmt>	 <comment type="block">/* number of all datanodes assigned to this "rel" */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>stale_data_nodes</name></decl>;</decl_stmt>	 <comment type="block">/* DNs marked stale for this chunk */</comment>
	<decl_stmt><decl><type><name>StmtParams</name> <modifier>*</modifier></type><name>stmt_params</name></decl>;</decl_stmt> <comment type="block">/* prepared statement paremeters */</comment>
	<decl_stmt><decl><type><name>TsFdwDataNodeState</name></type> <name><name>data_nodes</name><index>[<expr><name>FLEXIBLE_ARRAY_MEMBER</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>TsFdwModifyState</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TS_FDW_MODIFY_STATE_SIZE</name><parameter_list>(<parameter><type><name>num_data_nodes</name></type></parameter>)</parameter_list></cpp:macro>                                                   \
	<cpp:value>(sizeof(TsFdwModifyState) + (sizeof(TsFdwDataNodeState) * (num_data_nodes)))</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>initialize_fdw_data_node_state</name><parameter_list>(<parameter><decl><type><name>TsFdwDataNodeState</name> <modifier>*</modifier></type><name>fdw_data_node</name></decl></parameter>, <parameter><decl><type><name>TSConnectionId</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>fdw_data_node</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <name>id</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fdw_data_node</name><operator>-&gt;</operator><name>conn</name></name> <operator>=</operator> <call><name>remote_dist_txn_get_connection</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>REMOTE_TXN_USE_PREP_STMT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fdw_data_node</name><operator>-&gt;</operator><name>p_stmt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * create_foreign_modify
 *		Construct an execution state of a foreign insert/update/delete
 *		operation
 */</comment>
<function><type><specifier>static</specifier> <name>TsFdwModifyState</name> <modifier>*</modifier></type>
<name>create_foreign_modify</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>CmdType</name></type> <name>operation</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>check_as_user</name></decl></parameter>,
					  <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>subplan</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>target_attrs</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>has_returning</name></decl></parameter>,
					  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>retrieved_attrs</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>server_id_list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TsFdwModifyState</name> <modifier>*</modifier></type><name>fmstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupdesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>user_id</name> <init>= <expr><ternary><condition><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>check_as_user</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>check_as_user</name></expr> </then><else>: <expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>num_data_nodes</name></decl>, <decl><type ref="prev"/><name>num_all_data_nodes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>hypertable_id</name> <init>= <expr><call><name>ts_chunk_get_hypertable_id_by_relid</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>all_replicas</name> <init>= <expr><name>NIL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>avail_replicas</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>hypertable_id</name> <operator>==</operator> <name>INVALID_HYPERTABLE_ID</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>num_data_nodes</name> <operator>=</operator> <name>num_all_data_nodes</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>int32</name></type> <name>chunk_id</name> <init>= <expr><call><name>ts_chunk_get_id_by_relid</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>all_replicas</name> <operator>=</operator> <call><name>ts_chunk_data_node_scan_by_chunk_id</name><argument_list>(<argument><expr><name>chunk_id</name></expr></argument>, <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>avail_replicas</name> <operator>=</operator> <call><name>ts_chunk_data_node_scan_by_chunk_id_filter</name><argument_list>(<argument><expr><name>chunk_id</name></expr></argument>, <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>num_all_data_nodes</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>all_replicas</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Identify which user to do the remote access as.  This should match what
	 * ExecCheckRTEPerms() does.
	 */</comment>

	<if_stmt><if>if <condition>(<expr><name>NIL</name> <operator>!=</operator> <name>server_id_list</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * This is either (1) an INSERT on a hypertable chunk, or (2) an
		 * UPDATE or DELETE on a chunk. In the former case (1), the data nodes
		 * were passed on from the INSERT path via the chunk insert state, and
		 * in the latter case (2), the data nodes were resolved at planning time
		 * in the FDW planning callback.
		 */</comment>

		<expr_stmt><expr><name>fmstate</name> <operator>=</operator>
			<operator>(</operator><name>TsFdwModifyState</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><call><name>TS_FDW_MODIFY_STATE_SIZE</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>server_id_list</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>server_id_list</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type> <name>server_id</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TSConnectionId</name></type> <name>id</name> <init>= <expr><call><name>remote_connection_id</name><argument_list>(<argument><expr><name>server_id</name></expr></argument>, <argument><expr><name>user_id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>initialize_fdw_data_node_state</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fmstate</name><operator>-&gt;</operator><name>data_nodes</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><name>num_data_nodes</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>server_id_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>num_data_nodes</name> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>avail_replicas</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * If there is no chunk insert state and no data nodes from planning,
		 * this is an INSERT, UPDATE, or DELETE on a standalone foreign table.
		 *
		 * If it's a regular foreign table then we must get the data node from
		 * the foreign table's metadata.
		 *
		 * Otherwise, we use the list of "available" DNs from earlier
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>hypertable_id</name> <operator>==</operator> <name>INVALID_HYPERTABLE_ID</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ForeignTable</name> <modifier>*</modifier></type><name>table</name> <init>= <expr><call><name>GetForeignTable</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TSConnectionId</name></type> <name>id</name> <init>= <expr><call><name>remote_connection_id</name><argument_list>(<argument><expr><name><name>table</name><operator>-&gt;</operator><name>serverid</name></name></expr></argument>, <argument><expr><name>user_id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>num_data_nodes</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>num_all_data_nodes</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>fmstate</name> <operator>=</operator> <operator>(</operator><name>TsFdwModifyState</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><call><name>TS_FDW_MODIFY_STATE_SIZE</name><argument_list>(<argument><expr><name>num_data_nodes</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>initialize_fdw_data_node_state</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fmstate</name><operator>-&gt;</operator><name>data_nodes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* we use only the available replicas */</comment>
			<expr_stmt><expr><name>fmstate</name> <operator>=</operator>
				<operator>(</operator><name>TsFdwModifyState</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><call><name>TS_FDW_MODIFY_STATE_SIZE</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>avail_replicas</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>avail_replicas</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ChunkDataNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>TSConnectionId</name></type> <name>id</name> <init>= <expr><call><name>remote_connection_id</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>foreign_server_oid</name></name></expr></argument>, <argument><expr><name>user_id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>initialize_fdw_data_node_state</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fmstate</name><operator>-&gt;</operator><name>data_nodes</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<expr_stmt><expr><name>num_data_nodes</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>avail_replicas</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Set up remote query information. */</comment>
	<expr_stmt><expr><name><name>fmstate</name><operator>-&gt;</operator><name>rel</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fmstate</name><operator>-&gt;</operator><name>query</name></name> <operator>=</operator> <name>query</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fmstate</name><operator>-&gt;</operator><name>target_attrs</name></name> <operator>=</operator> <name>target_attrs</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fmstate</name><operator>-&gt;</operator><name>has_returning</name></name> <operator>=</operator> <name>has_returning</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fmstate</name><operator>-&gt;</operator><name>prepared</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <comment type="block">/* PREPARE will happen later */</comment>
	<expr_stmt><expr><name><name>fmstate</name><operator>-&gt;</operator><name>num_data_nodes</name></name> <operator>=</operator> <name>num_data_nodes</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fmstate</name><operator>-&gt;</operator><name>num_all_data_nodes</name></name> <operator>=</operator> <name>num_all_data_nodes</name></expr>;</expr_stmt>

	<comment type="block">/* Prepare for input conversion of RETURNING results. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fmstate</name><operator>-&gt;</operator><name>has_returning</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>fmstate</name><operator>-&gt;</operator><name>att_conv_metadata</name></name> <operator>=</operator> <call><name>data_format_create_att_conv_in_metadata</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>operation</name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>||</operator> <name>operation</name> <operator>==</operator> <name>CMD_DELETE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>subplan</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Find the ctid resjunk column in the subplan's result */</comment>
		<expr_stmt><expr><name><name>fmstate</name><operator>-&gt;</operator><name>ctid_attno</name></name> <operator>=</operator> <call><name>ExecFindJunkAttributeInTlist</name><argument_list>(<argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>, <argument><expr><literal type="string">"ctid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AttributeNumberIsValid</name><argument_list>(<argument><expr><name><name>fmstate</name><operator>-&gt;</operator><name>ctid_attno</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find junk ctid column"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>fmstate</name><operator>-&gt;</operator><name>stmt_params</name></name> <operator>=</operator> <call><name>stmt_params_create</name><argument_list>(<argument><expr><name><name>fmstate</name><operator>-&gt;</operator><name>target_attrs</name></name></expr></argument>,
											  <argument><expr><name>operation</name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>||</operator> <name>operation</name> <operator>==</operator> <name>CMD_DELETE</name></expr></argument>,
											  <argument><expr><name>tupdesc</name></expr></argument>,
											  <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>fmstate</name><operator>-&gt;</operator><name>tupfactory</name></name> <operator>=</operator> <call><name>tuplefactory_create_for_rel</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>retrieved_attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>fmstate</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Convert a relation's attribute numbers to the corresponding numbers for
 * another relation.
 *
 * Conversions are necessary when, e.g., a (new) chunk's attribute numbers do
 * not match the root table's numbers after a column has been removed.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>convert_attrs</name><parameter_list>(<parameter><decl><type><name>TupleConversionMap</name> <modifier>*</modifier></type><name>map</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>attrs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>new_attrs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>attrs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AttrNumber</name></type> <name>attnum</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>map</name><operator>-&gt;</operator><name>outdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG13_GE</name></expr></cpp:if>
			<if_stmt><if>if <condition>(<expr><name><name>map</name><operator>-&gt;</operator><name>attrMap</name><operator>-&gt;</operator><name>attnums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>attnum</name></expr>)</condition><block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<if_stmt><if>if <condition>(<expr><name><name>map</name><operator>-&gt;</operator><name>attrMap</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>attnum</name></expr>)</condition>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<block>{<block_content>
				<expr_stmt><expr><name>new_attrs</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>new_attrs</name></expr></argument>, <argument><expr><call><name>AttrOffsetGetAttrNumber</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/* Assert that we found the attribute */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>i</name> <operator>!=</operator> <name><name>map</name><operator>-&gt;</operator><name>outdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>attrs</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>new_attrs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>new_attrs</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>get_chunk_server_id_list</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>chunk_data_nodes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>chunk_data_nodes</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ChunkDataNode</name> <modifier>*</modifier></type><name>cdn</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name><name>cdn</name><operator>-&gt;</operator><name>foreign_server_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>list</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>fdw_begin_foreign_modify</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>rri</name></decl></parameter>, <parameter><decl><type><name>CmdType</name></type> <name>operation</name></decl></parameter>,
						 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>fdw_private</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>subplan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TsFdwModifyState</name> <modifier>*</modifier></type><name>fmstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>pstate</name><operator>-&gt;</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>target_attrs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>has_returning</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>retrieved_attrs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>server_id_list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ChunkInsertState</name> <modifier>*</modifier></type><name>cis</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>

	<comment type="block">/* Deconstruct fdw_private data. */</comment>
	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name>fdw_private</name></expr></argument>, <argument><expr><name>FdwModifyPrivateUpdateSql</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>target_attrs</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name>fdw_private</name></expr></argument>, <argument><expr><name>FdwModifyPrivateTargetAttnums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>has_returning</name> <operator>=</operator> <call><name>intVal</name><argument_list>(<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name>fdw_private</name></expr></argument>, <argument><expr><name>FdwModifyPrivateHasReturning</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>retrieved_attrs</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name>fdw_private</name></expr></argument>, <argument><expr><name>FdwModifyPrivateRetrievedAttrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Find RTE. */</comment>
	<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>rri</name><operator>-&gt;</operator><name>ri_RangeTableIndex</name></name></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_range_table</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>fdw_private</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>FdwModifyPrivateDataNodes</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>data_nodes</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name>fdw_private</name></expr></argument>, <argument><expr><name>FdwModifyPrivateDataNodes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>data_nodes</argument>)</argument_list></macro>
			<expr_stmt><expr><name>server_id_list</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>server_id_list</name></expr></argument>, <argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>fdw_private</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>FdwModifyPrivateChunkInsertState</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>cis</name> <operator>=</operator> <operator>(</operator><name>ChunkInsertState</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name>fdw_private</name></expr></argument>, <argument><expr><name>FdwModifyPrivateChunkInsertState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * A chunk may have different attribute numbers than the root relation
		 * that we planned the attribute lists for
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>cis</name><operator>-&gt;</operator><name>hyper_to_chunk_map</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Convert the target attributes (the inserted or updated
			 * attributes)
			 */</comment>
			<expr_stmt><expr><name>target_attrs</name> <operator>=</operator> <call><name>convert_attrs</name><argument_list>(<argument><expr><name><name>cis</name><operator>-&gt;</operator><name>hyper_to_chunk_map</name></name></expr></argument>, <argument><expr><name>target_attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Convert the retrieved attributes, if there is a RETURNING
			 * statement
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>NIL</name> <operator>!=</operator> <name>retrieved_attrs</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>retrieved_attrs</name> <operator>=</operator> <call><name>convert_attrs</name><argument_list>(<argument><expr><name><name>cis</name><operator>-&gt;</operator><name>hyper_to_chunk_map</name></name></expr></argument>, <argument><expr><name>retrieved_attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If there's a chunk insert state, then it has the authoritative
		 * data node list.
		 */</comment>
		<expr_stmt><expr><name>server_id_list</name> <operator>=</operator> <call><name>get_chunk_server_id_list</name><argument_list>(<argument><expr><name><name>cis</name><operator>-&gt;</operator><name>chunk_data_nodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Construct an execution state. */</comment>
	<expr_stmt><expr><name>fmstate</name> <operator>=</operator> <call><name>create_foreign_modify</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
									<argument><expr><name><name>rri</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>,
									<argument><expr><name>operation</name></expr></argument>,
									<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>checkAsUser</name></name></expr></argument>,
									<argument><expr><name>subplan</name></expr></argument>,
									<argument><expr><name>query</name></expr></argument>,
									<argument><expr><name>target_attrs</name></expr></argument>,
									<argument><expr><name>has_returning</name></expr></argument>,
									<argument><expr><name>retrieved_attrs</name></expr></argument>,
									<argument><expr><name>server_id_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>rri</name><operator>-&gt;</operator><name>ri_FdwState</name></name> <operator>=</operator> <name>fmstate</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>PreparedStmt</name> <modifier>*</modifier></type>
<name>prepare_foreign_modify_data_node</name><parameter_list>(<parameter><decl><type><name>TsFdwModifyState</name> <modifier>*</modifier></type><name>fmstate</name></decl></parameter>, <parameter><decl><type><name>TsFdwDataNodeState</name> <modifier>*</modifier></type><name>fdw_data_node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AsyncRequest</name> <modifier>*</modifier></type><name>req</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>==</operator> <name><name>fdw_data_node</name><operator>-&gt;</operator><name>p_stmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>req</name> <operator>=</operator> <call><name>async_request_send_prepare</name><argument_list>(<argument><expr><name><name>fdw_data_node</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>,
									 <argument><expr><name><name>fmstate</name><operator>-&gt;</operator><name>query</name></name></expr></argument>,
									 <argument><expr><call><name>stmt_params_num_params</name><argument_list>(<argument><expr><name><name>fmstate</name><operator>-&gt;</operator><name>stmt_params</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>req</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Async request interface doesn't seem to allow waiting for multiple
	 * prepared statements in an AsyncRequestSet. Should fix async API
	 */</comment>
	<return>return <expr><call><name>async_request_wait_prepared_statement</name><argument_list>(<argument><expr><name>req</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * prepare_foreign_modify
 *		Establish a prepared statement for execution of INSERT/UPDATE/DELETE
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>prepare_foreign_modify</name><parameter_list>(<parameter><decl><type><name>TsFdwModifyState</name> <modifier>*</modifier></type><name>fmstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>fmstate</name><operator>-&gt;</operator><name>num_data_nodes</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TsFdwDataNodeState</name> <modifier>*</modifier></type><name>fdw_data_node</name> <init>= <expr><operator>&amp;</operator><name><name>fmstate</name><operator>-&gt;</operator><name>data_nodes</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>fdw_data_node</name><operator>-&gt;</operator><name>p_stmt</name></name> <operator>=</operator> <call><name>prepare_foreign_modify_data_node</name><argument_list>(<argument><expr><name>fmstate</name></expr></argument>, <argument><expr><name>fdw_data_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name><name>fmstate</name><operator>-&gt;</operator><name>prepared</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * store_returning_result
 *		Store the result of a RETURNING clause
 *
 * On error, be sure to release the PGresult on the way out.  Callers do not
 * have PG_TRY blocks to ensure this happens.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>store_returning_result</name><parameter_list>(<parameter><decl><type><name>TsFdwModifyState</name> <modifier>*</modifier></type><name>fmstate</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type> <name>newtup</name> <init>=
			<expr><call><name>tuplefactory_make_tuple</name><argument_list>(<argument><expr><name><name>fmstate</name><operator>-&gt;</operator><name>tupfactory</name></name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQbinaryTuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* tuple will be deleted when it is cleared from the slot */</comment>
		<expr_stmt><expr><call><name>ExecStoreHeapTuple</name><argument_list>(<argument><expr><name>newtup</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>response_type</name><parameter_list>(<parameter><decl><type><name>AttConvInMetadata</name> <modifier>*</modifier></type><name>att_conv_metadata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ts_guc_enable_connection_binary_data</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>FORMAT_TEXT</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><ternary><condition><expr><name>att_conv_metadata</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>att_conv_metadata</name><operator>-&gt;</operator><name>binary</name></name></expr> ?</condition><then> <expr><name>FORMAT_BINARY</name></expr> </then><else>: <expr><name>FORMAT_TEXT</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>fdw_chunk_update_stale_metadata</name><parameter_list>(<parameter><decl><type><name>TsFdwModifyState</name> <modifier>*</modifier></type><name>fmstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>all_data_nodes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name> <init>= <expr><name><name>fmstate</name><operator>-&gt;</operator><name>rel</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fmstate</name><operator>-&gt;</operator><name>num_all_data_nodes</name></name> <operator>==</operator> <name><name>fmstate</name><operator>-&gt;</operator><name>num_data_nodes</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fmstate</name><operator>-&gt;</operator><name>num_all_data_nodes</name></name> <operator>&gt;</operator> <name><name>fmstate</name><operator>-&gt;</operator><name>num_data_nodes</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name> <init>= <expr><call><name>ts_chunk_get_by_relid</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="block">/* get filtered list */</comment>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>serveroids</name> <init>= <expr><call><name>get_chunk_data_nodes</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>serveroids</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>fmstate</name><operator>-&gt;</operator><name>num_data_nodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>all_data_nodes</name> <operator>=</operator> <call><name>ts_chunk_data_node_scan_by_chunk_id</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>, <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>all_data_nodes</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>fmstate</name><operator>-&gt;</operator><name>num_all_data_nodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>all_data_nodes</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ChunkDataNode</name> <modifier>*</modifier></type><name>cdn</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<comment type="block">/*
			 * check if this DN is a part of serveroids. If not
			 * found in serveroids, then we need to remove this
			 * chunk id to node name mapping and also update the primary
			 * foreign server if necessary. It's possible that this metadata
			 * might have been already cleared earlier but we have no way of
			 * knowing that here.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_member_oid</name><argument_list>(<argument><expr><name>serveroids</name></expr></argument>, <argument><expr><name><name>cdn</name><operator>-&gt;</operator><name>foreign_server_oid</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<operator>!</operator><call><name>list_member_oid</name><argument_list>(<argument><expr><name><name>fmstate</name><operator>-&gt;</operator><name>stale_data_nodes</name></name></expr></argument>, <argument><expr><name><name>cdn</name><operator>-&gt;</operator><name>foreign_server_oid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>chunk_update_foreign_server_if_needed</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>, <argument><expr><name><name>cdn</name><operator>-&gt;</operator><name>foreign_server_oid</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ts_chunk_data_node_delete_by_chunk_id_and_node_name</name><argument_list>(<argument><expr><name><name>cdn</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>chunk_id</name></name></expr></argument>,
																	<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>cdn</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>node_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* append this DN serveroid to the list of DNs marked stale for this chunk */</comment>
				<expr_stmt><expr><name><name>fmstate</name><operator>-&gt;</operator><name>stale_data_nodes</name></name> <operator>=</operator>
					<call><name>lappend_oid</name><argument_list>(<argument><expr><name><name>fmstate</name><operator>-&gt;</operator><name>stale_data_nodes</name></name></expr></argument>, <argument><expr><name><name>cdn</name><operator>-&gt;</operator><name>foreign_server_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>fdw_exec_foreign_insert</name><parameter_list>(<parameter><decl><type><name>TsFdwModifyState</name> <modifier>*</modifier></type><name>fmstate</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
						<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>planslot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StmtParams</name> <modifier>*</modifier></type><name>params</name> <init>= <expr><name><name>fmstate</name><operator>-&gt;</operator><name>stmt_params</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AsyncRequestSet</name> <modifier>*</modifier></type><name>reqset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AsyncResponseResult</name> <modifier>*</modifier></type><name>rsp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>n_rows</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fmstate</name><operator>-&gt;</operator><name>prepared</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>prepare_foreign_modify</name><argument_list>(<argument><expr><name>fmstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>reqset</name> <operator>=</operator> <call><name>async_request_set_create</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>stmt_params_convert_values</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>fmstate</name><operator>-&gt;</operator><name>num_data_nodes</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TsFdwDataNodeState</name> <modifier>*</modifier></type><name>fdw_data_node</name> <init>= <expr><operator>&amp;</operator><name><name>fmstate</name><operator>-&gt;</operator><name>data_nodes</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AsyncRequest</name> <modifier>*</modifier></type><name>req</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>type</name> <init>= <expr><call><name>response_type</name><argument_list>(<argument><expr><name><name>fmstate</name><operator>-&gt;</operator><name>att_conv_metadata</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>req</name> <operator>=</operator> <call><name>async_request_send_prepared_stmt_with_params</name><argument_list>(<argument><expr><name><name>fdw_data_node</name><operator>-&gt;</operator><name>p_stmt</name></name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>req</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>async_request_set_add</name><argument_list>(<argument><expr><name>reqset</name></expr></argument>, <argument><expr><name>req</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<while>while <condition>(<expr><operator>(</operator><name>rsp</name> <operator>=</operator> <call><name>async_request_set_wait_any_result</name><argument_list>(<argument><expr><name>reqset</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><call><name>async_response_result_get_pg_result</name><argument_list>(<argument><expr><name>rsp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>(</operator><ternary><condition><expr><name><name>fmstate</name><operator>-&gt;</operator><name>has_returning</name></name></expr> ?</condition><then> <expr><name>PGRES_TUPLES_OK</name></expr> </then><else>: <expr><name>PGRES_COMMAND_OK</name></expr></else></ternary><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>async_response_report_error</name><argument_list>(<argument><expr><operator>(</operator><name>AsyncResponse</name> <operator>*</operator><operator>)</operator> <name>rsp</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If we insert into multiple replica chunks, we should only return
		 * the results from the first one
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>n_rows</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Check number of rows affected, and fetch RETURNING tuple if any */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>fmstate</name><operator>-&gt;</operator><name>has_returning</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>n_rows</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>n_rows</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>store_returning_result</name><argument_list>(<argument><expr><name>fmstate</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>n_rows</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><call><name>PQcmdTuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* And clean up */</comment>
		<expr_stmt><expr><call><name>async_response_result_close</name><argument_list>(<argument><expr><name>rsp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>stmt_params_reset</name><argument_list>(<argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Currently no way to do a deep cleanup of all request in the request
	 * set. The worry here is that since this runs in a per-chunk insert state
	 * memory context, the async API will accumulate a lot of cruft during
	 * inserts
	 */</comment>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>reqset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If rows are affected on DNs and a DN was excluded because of being
	 * "unavailable" then we need to update metadata on the AN to mark
	 * this chunk as "stale" for that "unavailable" DN
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>n_rows</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>fmstate</name><operator>-&gt;</operator><name>num_all_data_nodes</name></name> <operator>&gt;</operator> <name><name>fmstate</name><operator>-&gt;</operator><name>num_data_nodes</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fdw_chunk_update_stale_metadata</name><argument_list>(<argument><expr><name>fmstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Return NULL if nothing was inserted on the remote end */</comment>
	<return>return <expr><ternary><condition><expr><operator>(</operator><name>n_rows</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>slot</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Execute either an UPDATE or DELETE.
 */</comment>
<function><type><name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>fdw_exec_foreign_update_or_delete</name><parameter_list>(<parameter><decl><type><name>TsFdwModifyState</name> <modifier>*</modifier></type><name>fmstate</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
								  <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>planslot</name></decl></parameter>, <parameter><decl><type><name>ModifyCommand</name></type> <name>cmd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StmtParams</name> <modifier>*</modifier></type><name>params</name> <init>= <expr><name><name>fmstate</name><operator>-&gt;</operator><name>stmt_params</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AsyncRequestSet</name> <modifier>*</modifier></type><name>reqset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AsyncResponseResult</name> <modifier>*</modifier></type><name>rsp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>datum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>is_null</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>n_rows</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Set up the prepared statement on the data node, if we didn't yet */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fmstate</name><operator>-&gt;</operator><name>prepared</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>prepare_foreign_modify</name><argument_list>(<argument><expr><name>fmstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Get the ctid that was passed up as a resjunk column */</comment>
	<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>ExecGetJunkAttribute</name><argument_list>(<argument><expr><name>planslot</name></expr></argument>, <argument><expr><name><name>fmstate</name><operator>-&gt;</operator><name>ctid_attno</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* shouldn't ever get a null result... */</comment>
	<if_stmt><if>if <condition>(<expr><name>is_null</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"ctid is NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>stmt_params_convert_values</name><argument_list>(<argument><expr><name>params</name></expr></argument>,
							   <argument><expr><operator>(</operator><ternary><condition><expr><name>cmd</name> <operator>==</operator> <name>UPDATE_CMD</name></expr> ?</condition><then> <expr><name>slot</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary><operator>)</operator></expr></argument>,
							   <argument><expr><operator>(</operator><name>ItemPointer</name><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>reqset</name> <operator>=</operator> <call><name>async_request_set_create</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>fmstate</name><operator>-&gt;</operator><name>num_data_nodes</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AsyncRequest</name> <modifier>*</modifier></type><name>req</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TsFdwDataNodeState</name> <modifier>*</modifier></type><name>fdw_data_node</name> <init>= <expr><operator>&amp;</operator><name><name>fmstate</name><operator>-&gt;</operator><name>data_nodes</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>type</name> <init>= <expr><call><name>response_type</name><argument_list>(<argument><expr><name><name>fmstate</name><operator>-&gt;</operator><name>att_conv_metadata</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>req</name> <operator>=</operator> <call><name>async_request_send_prepared_stmt_with_params</name><argument_list>(<argument><expr><name><name>fdw_data_node</name><operator>-&gt;</operator><name>p_stmt</name></name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>req</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>async_request_attach_user_data</name><argument_list>(<argument><expr><name>req</name></expr></argument>, <argument><expr><name>fdw_data_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>async_request_set_add</name><argument_list>(<argument><expr><name>reqset</name></expr></argument>, <argument><expr><name>req</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<while>while <condition>(<expr><operator>(</operator><name>rsp</name> <operator>=</operator> <call><name>async_request_set_wait_any_result</name><argument_list>(<argument><expr><name>reqset</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><call><name>async_response_result_get_pg_result</name><argument_list>(<argument><expr><name>rsp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>(</operator><ternary><condition><expr><name><name>fmstate</name><operator>-&gt;</operator><name>has_returning</name></name></expr> ?</condition><then> <expr><name>PGRES_TUPLES_OK</name></expr> </then><else>: <expr><name>PGRES_COMMAND_OK</name></expr></else></ternary><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>remote_result_elog</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If we update multiple replica chunks, we should only return the
		 * results from the first one.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>n_rows</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Check number of rows affected, and fetch RETURNING tuple if any */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>fmstate</name><operator>-&gt;</operator><name>has_returning</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>n_rows</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>n_rows</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>store_returning_result</name><argument_list>(<argument><expr><name>fmstate</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>n_rows</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><call><name>PQcmdTuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* And clean up */</comment>
		<expr_stmt><expr><call><name>async_response_result_close</name><argument_list>(<argument><expr><name>rsp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Currently no way to do a deep cleanup of all request in the request
	 * set. The worry here is that since this runs in a per-chunk insert state
	 * memory context, the async API will accumulate a lot of cruft during
	 * inserts
	 */</comment>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>reqset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>stmt_params_reset</name><argument_list>(<argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If rows are affected on DNs and a DN was excluded because of being
	 * "unavailable" then we need to update metadata on the AN to mark
	 * this chunk as "stale" for that "unavailable" DN
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>n_rows</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>fmstate</name><operator>-&gt;</operator><name>num_all_data_nodes</name></name> <operator>&gt;</operator> <name><name>fmstate</name><operator>-&gt;</operator><name>num_data_nodes</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fdw_chunk_update_stale_metadata</name><argument_list>(<argument><expr><name>fmstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Return NULL if nothing was updated on the remote end */</comment>
	<return>return <expr><ternary><condition><expr><operator>(</operator><name>n_rows</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>slot</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * finish_foreign_modify
 *		Release resources for a foreign insert/update/delete operation
 */</comment>
<function><type><name>void</name></type>
<name>fdw_finish_foreign_modify</name><parameter_list>(<parameter><decl><type><name>TsFdwModifyState</name> <modifier>*</modifier></type><name>fmstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>fmstate</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>fmstate</name><operator>-&gt;</operator><name>num_data_nodes</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TsFdwDataNodeState</name> <modifier>*</modifier></type><name>fdw_data_node</name> <init>= <expr><operator>&amp;</operator><name><name>fmstate</name><operator>-&gt;</operator><name>data_nodes</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* If we created a prepared statement, destroy it */</comment>
		<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>fdw_data_node</name><operator>-&gt;</operator><name>p_stmt</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>prepared_stmt_close</name><argument_list>(<argument><expr><name><name>fdw_data_node</name><operator>-&gt;</operator><name>p_stmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fdw_data_node</name><operator>-&gt;</operator><name>p_stmt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>fdw_data_node</name><operator>-&gt;</operator><name>conn</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>stmt_params_free</name><argument_list>(<argument><expr><name><name>fmstate</name><operator>-&gt;</operator><name>stmt_params</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>fdw_explain_modify</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>ps</name></decl></parameter>, <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>rri</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>fdw_private</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>subplan_index</name></decl></parameter>,
				   <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>verbose</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sql</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name>fdw_private</name></expr></argument>, <argument><expr><name>FdwModifyPrivateUpdateSql</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ExplainPropertyText</name><argument_list>(<argument><expr><literal type="string">"Remote SQL"</literal></expr></argument>, <argument><expr><name>sql</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
</unit>
