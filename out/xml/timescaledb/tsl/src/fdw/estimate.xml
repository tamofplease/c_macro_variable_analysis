<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/timescaledb/tsl/src/fdw/estimate.c"><comment type="block">/*
 * This file and its contents are licensed under the Timescale License.
 * Please see the included NOTICE for copyright information and
 * LICENSE-TIMESCALE for a copy of the license.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postgres.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/nodes.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/nodeFuncs.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/cost.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/clauses.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/prep.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/tlist.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/paths.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/selfuncs.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/rel.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;lib/stringinfo.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;miscadmin.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;remote/connection.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;remote/async.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;remote/dist_txn.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;compat/compat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"relinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"estimate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"deparse.h"</cpp:file></cpp:include>

<comment type="block">/* If no remote estimates, assume a sort costs 5% extra.  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_FDW_SORT_MULTIPLIER</name></cpp:macro> <cpp:value>1.05</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>CostEstimate</name>
<block>{
	<decl_stmt><decl><type><name>double</name></type> <name>rows</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>retrieved_rows</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>width</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type> <name>startup_cost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type> <name>total_cost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type> <name>cpu_per_tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type> <name>run_cost</name></decl>;</decl_stmt>
}</block></struct></type> <name>CostEstimate</name>;</typedef>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>find_first_aggref_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>Aggref</name> <modifier>*</modifier><modifier>*</modifier></type><name>aggref</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>aggref</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>Aggref</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>find_first_aggref_walker</name></expr></argument>, <argument><expr><name>aggref</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get the AggsSplit mode of a relation.
 *
 * The AggSplit (partial or full aggregation) affects costing.
 * All aggregates to compute this relation must have the same
 * mode, so we only check mode on first match.
 */</comment>
<function><type><specifier>static</specifier> <name>AggSplit</name></type>
<name>get_aggsplit</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>agg</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>hasAggs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>find_first_aggref_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>agg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>agg</name><operator>-&gt;</operator><name>aggsplit</name></name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* If the aggregate is only referenced in the HAVING clause it will
	 * not be present in the targetlist so we have to check HAVING clause too. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>hasHavingQual</name></name> <operator>&amp;&amp;</operator> <call><name>find_first_aggref_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>agg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>agg</name><operator>-&gt;</operator><name>aggsplit</name></name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Since PlannerInfo has hasAggs true (checked in caller) we should
	 * never get here and always find an Aggref. */</comment>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"no aggref found in targetlist or HAVING clause"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_unreachable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_upper_rel_estimate</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>CostEstimate</name> <modifier>*</modifier></type><name>ce</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TsFdwRelInfo</name> <modifier>*</modifier></type><name>fpinfo</name> <init>= <expr><call><name>fdw_relinfo_get</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TsFdwRelInfo</name> <modifier>*</modifier></type><name>ofpinfo</name> <init>= <expr><call><name>fdw_relinfo_get</name><argument_list>(<argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>outerrel</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AggClauseCosts</name></type> <name>aggcosts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>input_rows</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>num_group_cols</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>num_groups</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Make sure the core code set the pathtarget. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>reltarget</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * This cost model is mixture of costing done for sorted and
	 * hashed aggregates in cost_agg().  We are not sure which
	 * strategy will be considered at remote side, thus for
	 * simplicity, we put all startup related costs in startup_cost
	 * and all finalization and run cost are added in total_cost.
	 *
	 * Also, core does not care about costing HAVING expressions and
	 * adding that to the costs.  So similarly, here too we are not
	 * considering remote and local conditions for costing.
	 */</comment>

	<comment type="block">/* Get rows from input rel */</comment>
	<expr_stmt><expr><name>input_rows</name> <operator>=</operator> <name><name>ofpinfo</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>

	<comment type="block">/* Collect statistics about aggregates for estimating costs. */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>aggcosts</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AggClauseCosts</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>hasAggs</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Get the aggsplit to use in order to support push-down of partial
		 * aggregation */</comment>
		<decl_stmt><decl><type><name>AggSplit</name></type> <name>aggsplit</name> <init>= <expr><call><name>get_aggsplit</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>get_agg_clause_costs_compat</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>fpinfo</name><operator>-&gt;</operator><name>grouped_tlist</name></name></expr></argument>, <argument><expr><name>aggsplit</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aggcosts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Get number of grouping columns and possible number of groups */</comment>
	<expr_stmt><expr><name>num_group_cols</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>num_groups</name> <operator>=</operator> <call><name>estimate_num_groups_compat</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											<argument><expr><call><name>get_sortgrouplist_exprs</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
																	<argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>grouped_tlist</name></name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><name>input_rows</name></expr></argument>,
											<argument><expr><name>NULL</name></expr></argument>,
											<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Get the retrieved_rows and rows estimates.  If there are HAVING
	 * quals, account for their selectivity.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>havingQual</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Factor in the selectivity of the remotely-checked quals */</comment>
		<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>retrieved_rows</name></name> <operator>=</operator> <call><name>clamp_row_est</name><argument_list>(
			<argument><expr><name>num_groups</name> <operator>*</operator> <call><name>clauselist_selectivity</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>remote_conds</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>JOIN_INNER</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Factor in the selectivity of the locally-checked quals */</comment>
		<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <call><name>clamp_row_est</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>retrieved_rows</name></name> <operator>*</operator> <name><name>fpinfo</name><operator>-&gt;</operator><name>local_conds_sel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Number of rows expected from data node will be same as
		 * that of number of groups.
		 */</comment>
		<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <name><name>ce</name><operator>-&gt;</operator><name>retrieved_rows</name></name> <operator>=</operator> <name>num_groups</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Use width estimate made by the core code. */</comment>
	<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>width</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>width</name></name></expr>;</expr_stmt>

	<comment type="block">/*-----
	 * Startup cost includes:
	 *	  1. Startup cost for underneath input * relation
	 *	  2. Cost of performing aggregation, per cost_agg()
	 *	  3. Startup cost for PathTarget eval
	 *-----
	 */</comment>
	<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>ofpinfo</name><operator>-&gt;</operator><name>rel_startup_cost</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>+=</operator> <name><name>rel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>+=</operator> <name><name>aggcosts</name><operator>.</operator><name>transCost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>+=</operator> <name><name>aggcosts</name><operator>.</operator><name>transCost</name><operator>.</operator><name>per_tuple</name></name> <operator>*</operator> <name>input_rows</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>+=</operator> <name><name>aggcosts</name><operator>.</operator><name>finalCost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>+=</operator> <operator>(</operator><name>cpu_operator_cost</name> <operator>*</operator> <name>num_group_cols</name><operator>)</operator> <operator>*</operator> <name>input_rows</name></expr>;</expr_stmt>

	<comment type="block">/*-----
	 * Run time cost includes:
	 *	  1. Run time cost of underneath input relation, adjusted for
	 *	     tlist replacement by apply_scanjoin_target_to_paths()
	 *	  2. Run time cost of performing aggregation, per cost_agg()
	 *-----
	 */</comment>
	<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>run_cost</name></name> <operator>=</operator> <name><name>ofpinfo</name><operator>-&gt;</operator><name>rel_total_cost</name></name> <operator>-</operator> <name><name>ofpinfo</name><operator>-&gt;</operator><name>rel_startup_cost</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>run_cost</name></name> <operator>+=</operator> <name><name>rel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>per_tuple</name></name> <operator>*</operator> <name>input_rows</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>run_cost</name></name> <operator>+=</operator> <name><name>aggcosts</name><operator>.</operator><name>finalCost</name><operator>.</operator><name>per_tuple</name></name> <operator>*</operator> <name>num_groups</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>run_cost</name></name> <operator>+=</operator> <name>cpu_tuple_cost</name> <operator>*</operator> <name>num_groups</name></expr>;</expr_stmt>

	<comment type="block">/* Account for the eval cost of HAVING quals, if any */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>havingQual</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>QualCost</name></type> <name>remote_cost</name></decl>;</decl_stmt>

		<comment type="block">/* Add in the eval cost of the remotely-checked quals */</comment>
		<expr_stmt><expr><call><name>cost_qual_eval</name><argument_list>(<argument><expr><operator>&amp;</operator><name>remote_cost</name></expr></argument>, <argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>remote_conds</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>+=</operator> <name><name>remote_cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>run_cost</name></name> <operator>+=</operator> <name><name>remote_cost</name><operator>.</operator><name>per_tuple</name></name> <operator>*</operator> <name>num_groups</name></expr>;</expr_stmt>
		<comment type="block">/* Add in the eval cost of the locally-checked quals */</comment>
		<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>+=</operator> <name><name>fpinfo</name><operator>-&gt;</operator><name>local_conds_cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>run_cost</name></name> <operator>+=</operator> <name><name>fpinfo</name><operator>-&gt;</operator><name>local_conds_cost</name><operator>.</operator><name>per_tuple</name></name> <operator>*</operator> <name><name>ce</name><operator>-&gt;</operator><name>retrieved_rows</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Add in tlist eval cost for each output row */</comment>
	<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>+=</operator> <name><name>rel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>run_cost</name></name> <operator>+=</operator> <name><name>rel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>per_tuple</name></name> <operator>*</operator> <name><name>ce</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_base_rel_estimate</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>CostEstimate</name> <modifier>*</modifier></type><name>ce</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TsFdwRelInfo</name> <modifier>*</modifier></type><name>fpinfo</name> <init>= <expr><call><name>fdw_relinfo_get</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>width</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>width</name></name></expr>;</expr_stmt>

	<comment type="block">/* Back into an estimate of the number of retrieved rows. */</comment>
	<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>retrieved_rows</name></name> <operator>=</operator> <call><name>clamp_row_est</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>rows</name></name> <operator>/</operator> <name><name>fpinfo</name><operator>-&gt;</operator><name>local_conds_sel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Clamp retrieved rows estimates to at most rel-&gt;tuples. */</comment>
	<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>retrieved_rows</name></name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>retrieved_rows</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>tuples</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Cost as though this were a seqscan, which is pessimistic.  We
	 * effectively imagine the local_conds are being evaluated
	 * remotely, too.
	 */</comment>
	<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>run_cost</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>run_cost</name></name> <operator>+=</operator> <name>seq_page_cost</name> <operator>*</operator> <name><name>rel</name><operator>-&gt;</operator><name>pages</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>+=</operator> <name><name>rel</name><operator>-&gt;</operator><name>baserestrictcost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>cpu_per_tuple</name></name> <operator>=</operator> <name>cpu_tuple_cost</name> <operator>+</operator> <name><name>rel</name><operator>-&gt;</operator><name>baserestrictcost</name><operator>.</operator><name>per_tuple</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>run_cost</name></name> <operator>+=</operator> <name><name>ce</name><operator>-&gt;</operator><name>cpu_per_tuple</name></name> <operator>*</operator> <name><name>rel</name><operator>-&gt;</operator><name>tuples</name></name></expr>;</expr_stmt>

	<comment type="block">/* Add in tlist eval cost for each output row */</comment>
	<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>+=</operator> <name><name>rel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>run_cost</name></name> <operator>+=</operator> <name><name>rel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>per_tuple</name></name> <operator>*</operator> <name><name>ce</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REL_HAS_CACHED_COSTS</name><parameter_list>(<parameter><type><name>fpinfo</name></type></parameter>)</parameter_list></cpp:macro>                                                               \
	<cpp:value>((fpinfo)-&gt;rel_startup_cost &gt;= 0 &amp;&amp; (fpinfo)-&gt;rel_total_cost &gt;= 0 &amp;&amp;                           \
	 (fpinfo)-&gt;rel_retrieved_rows &gt;= 0)</cpp:value></cpp:define>

<comment type="block">/*
 * Adjust the cost estimates of a foreign grouping path to include the cost of
 * generating properly-sorted output.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>adjust_foreign_grouping_path_cost</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>retrieved_rows</name></decl></parameter>,
								  <parameter><decl><type><name>double</name></type> <name>width</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>limit_tuples</name></decl></parameter>, <parameter><decl><type><name>Cost</name> <modifier>*</modifier></type><name>p_startup_cost</name></decl></parameter>,
								  <parameter><decl><type><name>Cost</name> <modifier>*</modifier></type><name>p_run_cost</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * If the GROUP BY clause isn't sort-able, the plan chosen by the remote
	 * side is unlikely to generate properly-sorted output, so it would need
	 * an explicit sort; adjust the given costs with cost_sort().  Likewise,
	 * if the GROUP BY clause is sort-able but isn't a superset of the given
	 * pathkeys, adjust the costs with that function.  Otherwise, adjust the
	 * costs by applying the same heuristic as for the scan or join case.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>grouping_is_sortable</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
		<operator>!</operator><call><name>pathkeys_contained_in</name><argument_list>(<argument><expr><name>pathkeys</name></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>group_pathkeys</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Path</name></type> <name>sort_path</name></decl>;</decl_stmt> <comment type="block">/* dummy for result of cost_sort */</comment>

		<expr_stmt><expr><call><name>cost_sort</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sort_path</name></expr></argument>,
				  <argument><expr><name>root</name></expr></argument>,
				  <argument><expr><name>pathkeys</name></expr></argument>,
				  <argument><expr><operator>*</operator><name>p_startup_cost</name> <operator>+</operator> <operator>*</operator><name>p_run_cost</name></expr></argument>,
				  <argument><expr><name>retrieved_rows</name></expr></argument>,
				  <argument><expr><name>width</name></expr></argument>,
				  <argument><expr><literal type="number">0.0</literal></expr></argument>,
				  <argument><expr><name>work_mem</name></expr></argument>,
				  <argument><expr><name>limit_tuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><operator>*</operator><name>p_startup_cost</name> <operator>=</operator> <name><name>sort_path</name><operator>.</operator><name>startup_cost</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>p_run_cost</name> <operator>=</operator> <name><name>sort_path</name><operator>.</operator><name>total_cost</name></name> <operator>-</operator> <name><name>sort_path</name><operator>.</operator><name>startup_cost</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * The default extra cost seems too large for foreign-grouping cases;
		 * add 1/4th of that default.
		 */</comment>
		<decl_stmt><decl><type><name>double</name></type> <name>sort_multiplier</name> <init>= <expr><literal type="number">1.0</literal> <operator>+</operator> <operator>(</operator><name>DEFAULT_FDW_SORT_MULTIPLIER</name> <operator>-</operator> <literal type="number">1.0</literal><operator>)</operator> <operator>*</operator> <literal type="number">0.25</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><operator>*</operator><name>p_startup_cost</name> <operator>*=</operator> <name>sort_multiplier</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>p_run_cost</name> <operator>*=</operator> <name>sort_multiplier</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * fdw_estimate_path_cost_size
 *		Get cost and size estimates for a foreign scan on given foreign
 *		relation either a base relation or an upper relation containing
 *		foreign relations. Estimate rows using whatever statistics we have
 *      locally, in a way similar to ordinary tables.
 *
 * pathkeys specify the expected sort order if any for given path being costed.
 *
 * The function returns the cost and size estimates in p_row, p_width,
 * p_startup_cost and p_total_cost variables.
 */</comment>
<function><type><name>void</name></type>
<name>fdw_estimate_path_cost_size</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>p_rows</name></decl></parameter>,
							<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>p_width</name></decl></parameter>, <parameter><decl><type><name>Cost</name> <modifier>*</modifier></type><name>p_startup_cost</name></decl></parameter>, <parameter><decl><type><name>Cost</name> <modifier>*</modifier></type><name>p_total_cost</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TsFdwRelInfo</name> <modifier>*</modifier></type><name>fpinfo</name> <init>= <expr><call><name>fdw_relinfo_get</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CostEstimate</name></type> <name>ce</name> <init>= <expr><block>{
		<comment type="block">/*
		 * Use rows/width estimates made by set_baserel_size_estimates() for
		 * base foreign relations.
		 */</comment>
		<expr><operator>.</operator><name>rows</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rows</name></name></expr>,
		<expr><operator>.</operator><name>width</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>width</name></name></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IS_JOIN_REL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"foreign joins are not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We will come here again and again with different set of pathkeys
	 * that caller wants to cost. We don't need to calculate the cost of
	 * bare scan each time. Instead, use the costs if we have cached them
	 * already.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>REL_HAS_CACHED_COSTS</name><argument_list>(<argument><expr><name>fpinfo</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>ce</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <name><name>fpinfo</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ce</name><operator>.</operator><name>width</name></name> <operator>=</operator> <name><name>fpinfo</name><operator>-&gt;</operator><name>width</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ce</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>fpinfo</name><operator>-&gt;</operator><name>rel_startup_cost</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ce</name><operator>.</operator><name>run_cost</name></name> <operator>=</operator> <name><name>fpinfo</name><operator>-&gt;</operator><name>rel_total_cost</name></name> <operator>-</operator> <name><name>fpinfo</name><operator>-&gt;</operator><name>rel_startup_cost</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ce</name><operator>.</operator><name>retrieved_rows</name></name> <operator>=</operator> <name><name>fpinfo</name><operator>-&gt;</operator><name>rel_retrieved_rows</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IS_UPPER_REL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>get_upper_rel_estimate</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>get_base_rel_estimate</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Without remote estimates, we have no real way to estimate the cost
	 * of generating sorted output.  It could be free if the query plan
	 * the remote side would have chosen generates properly-sorted output
	 * anyway, but in most cases it will cost something.  Estimate a value
	 * high enough that we won't pick the sorted path when the ordering
	 * isn't locally useful, but low enough that we'll err on the side of
	 * pushing down the ORDER BY clause when it's useful to do so.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>pathkeys</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IS_UPPER_REL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>==</operator> <name>RELOPT_UPPER_REL</name> <operator>||</operator>
				   <name><name>rel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>==</operator> <name>RELOPT_OTHER_UPPER_REL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* FIXME: Currently don't have a way to pass on limit here */</comment>
			<decl_stmt><decl><type><specifier>const</specifier> <name>double</name></type> <name>limit_tuples</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>adjust_foreign_grouping_path_cost</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											  <argument><expr><name>pathkeys</name></expr></argument>,
											  <argument><expr><name><name>ce</name><operator>.</operator><name>retrieved_rows</name></name></expr></argument>,
											  <argument><expr><name><name>ce</name><operator>.</operator><name>width</name></name></expr></argument>,
											  <argument><expr><name>limit_tuples</name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name><name>ce</name><operator>.</operator><name>startup_cost</name></name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name><name>ce</name><operator>.</operator><name>run_cost</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>ce</name><operator>.</operator><name>startup_cost</name></name> <operator>*=</operator> <name>DEFAULT_FDW_SORT_MULTIPLIER</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ce</name><operator>.</operator><name>run_cost</name></name> <operator>*=</operator> <name>DEFAULT_FDW_SORT_MULTIPLIER</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>ce</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <name><name>ce</name><operator>.</operator><name>startup_cost</name></name> <operator>+</operator> <name><name>ce</name><operator>.</operator><name>run_cost</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Cache the costs for scans without any pathkeys
	 * before adding the costs for transferring data from the data node.
	 * These costs are useful for costing the join between this relation and
	 * another foreign relation or to calculate the costs of paths with
	 * pathkeys for this relation, when the costs can not be obtained from the
	 * data node. This function will be called at least once for every
	 * foreign relation without pathkeys.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>REL_HAS_CACHED_COSTS</name><argument_list>(<argument><expr><name>fpinfo</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>pathkeys</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>rel_startup_cost</name></name> <operator>=</operator> <name><name>ce</name><operator>.</operator><name>startup_cost</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>rel_total_cost</name></name> <operator>=</operator> <name><name>ce</name><operator>.</operator><name>total_cost</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>rel_retrieved_rows</name></name> <operator>=</operator> <name><name>ce</name><operator>.</operator><name>retrieved_rows</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Add some additional cost factors to account for connection overhead
	 * (fdw_startup_cost), transferring data across the network
	 * (fdw_tuple_cost per retrieved row), and local manipulation of the data
	 * (cpu_tuple_cost per retrieved row).
	 */</comment>
	<expr_stmt><expr><name><name>ce</name><operator>.</operator><name>startup_cost</name></name> <operator>+=</operator> <name><name>fpinfo</name><operator>-&gt;</operator><name>fdw_startup_cost</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ce</name><operator>.</operator><name>total_cost</name></name> <operator>+=</operator> <name><name>fpinfo</name><operator>-&gt;</operator><name>fdw_startup_cost</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ce</name><operator>.</operator><name>total_cost</name></name> <operator>+=</operator> <name><name>fpinfo</name><operator>-&gt;</operator><name>fdw_tuple_cost</name></name> <operator>*</operator> <name><name>ce</name><operator>.</operator><name>retrieved_rows</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ce</name><operator>.</operator><name>total_cost</name></name> <operator>+=</operator> <name>cpu_tuple_cost</name> <operator>*</operator> <name><name>ce</name><operator>.</operator><name>retrieved_rows</name></name></expr>;</expr_stmt>

	<comment type="block">/* Return results. */</comment>
	<expr_stmt><expr><operator>*</operator><name>p_rows</name> <operator>=</operator> <name><name>ce</name><operator>.</operator><name>rows</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>p_width</name> <operator>=</operator> <name><name>ce</name><operator>.</operator><name>width</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>p_startup_cost</name> <operator>=</operator> <name><name>ce</name><operator>.</operator><name>startup_cost</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>p_total_cost</name> <operator>=</operator> <name><name>ce</name><operator>.</operator><name>total_cost</name></name></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
