<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/timescaledb/tsl/src/fdw/data_node_scan_plan.c"><comment type="block">/*
 * This file and its contents are licensed under the Timescale License.
 * Please see the included NOTICE for copyright information and
 * LICENSE-TIMESCALE for a copy of the license.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postgres.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/sysattr.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;foreign/fdwapi.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/extensible.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/makefuncs.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/nodeFuncs.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/pathnodes.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/plannodes.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/appendinfo.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/clauses.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/optimizer.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/pathnode.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/paths.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/prep.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/restrictinfo.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/tlist.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;parser/parsetree.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/memutils.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;compat/compat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;debug.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;debug_guc.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dimension.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;export.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;func_cache.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;hypertable_cache.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;import/allpaths.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;import/planner.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;planner.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"data_node_scan_plan.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"data_node_chunk_assignment.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"data_node_scan_exec.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"deparse.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fdw_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"relinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"scan_plan.h"</cpp:file></cpp:include>

<comment type="block">/*
 * DataNodeScan is a custom scan implementation for scanning hypertables on
 * remote data nodes instead of scanning individual remote chunks.
 *
 * A DataNodeScan plan is created by taking a regular per-chunk scan plan and
 * then assigning each chunk to a data node, and treating each data node as a
 * "partition" of the distributed hypertable. For each resulting data node, we
 * create a data node rel which is essentially a base rel representing a remote
 * hypertable partition. Since we treat a data node rel as a base rel, although
 * it has no corresponding data node table, we point each data node rel to the root
 * hypertable. This is conceptually the right thing to do, since each data node
 * rel is a partition of the same distributed hypertable.
 *
 * For each data node rel, we plan a DataNodeScan instead of a ForeignScan since a
 * data node rel does not correspond to a real foreign table. A ForeignScan of a
 * data node rel would fail when trying to lookup the ForeignServer via the
 * data node rel's RTE relid. The only other option to get around the
 * ForeignTable lookup is to make a data node rel an upper rel instead of a base
 * rel (see nodeForeignscan.c). However, that leads to other issues in
 * setrefs.c that messes up our target lists for some queries.
 */</comment>

<function_decl><type><specifier>static</specifier> <name>Path</name> <modifier>*</modifier></type><name>data_node_scan_path_create</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
										<parameter><decl><type><name>double</name></type> <name>rows</name></decl></parameter>, <parameter><decl><type><name>Cost</name></type> <name>startup_cost</name></decl></parameter>, <parameter><decl><type><name>Cost</name></type> <name>total_cost</name></decl></parameter>,
										<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>required_outer</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>fdw_outerpath</name></decl></parameter>,
										<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>private</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Path</name> <modifier>*</modifier></type><name>data_node_scan_upper_path_create</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
											  <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>rows</name></decl></parameter>, <parameter><decl><type><name>Cost</name></type> <name>startup_cost</name></decl></parameter>,
											  <parameter><decl><type><name>Cost</name></type> <name>total_cost</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>fdw_outerpath</name></decl></parameter>,
											  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>private</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>AppendRelInfo</name> <modifier>*</modifier></type>
<name>create_append_rel_info</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>childrelid</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>parentrelid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>parent_rte</name> <init>= <expr><call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name>parentrelid</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name><name>parent_rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appinfo</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>appinfo</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>AppendRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>appinfo</name><operator>-&gt;</operator><name>parent_relid</name></name> <operator>=</operator> <name>parentrelid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>appinfo</name><operator>-&gt;</operator><name>child_relid</name></name> <operator>=</operator> <name>childrelid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>appinfo</name><operator>-&gt;</operator><name>parent_reltype</name></name> <operator>=</operator> <name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltype</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>appinfo</name><operator>-&gt;</operator><name>child_reltype</name></name> <operator>=</operator> <name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltype</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_make_inh_translation_list</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>, <argument><expr><name>childrelid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>appinfo</name><operator>-&gt;</operator><name>translated_vars</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>appinfo</name><operator>-&gt;</operator><name>parent_reloid</name></name> <operator>=</operator> <name><name>parent_rte</name><operator>-&gt;</operator><name>relid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>appinfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Build a new RelOptInfo representing a data node.
 *
 * Note that the relid index should point to the corresponding range table
 * entry (RTE) we created for the data node rel when expanding the
 * hypertable. Each such RTE's relid (OID) refers to the hypertable's root
 * table. This has the upside that the planner can use the hypertable's
 * indexes to plan remote queries more efficiently. In contrast, chunks are
 * foreign tables and they cannot have indexes.
 */</comment>
<function><type><specifier>static</specifier> <name>RelOptInfo</name> <modifier>*</modifier></type>
<name>build_data_node_rel</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>serverid</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name> <init>= <expr><call><name>build_simple_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Use relevant exprs and restrictinfos from the parent rel. These will be
	 * adjusted to match the data node rel's relid later.
	 */</comment>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>exprs</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>baserestrictinfo</name></name> <operator>=</operator> <name><name>parent</name><operator>-&gt;</operator><name>baserestrictinfo</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>baserestrictcost</name></name> <operator>=</operator> <name><name>parent</name><operator>-&gt;</operator><name>baserestrictcost</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>baserestrict_min_security</name></name> <operator>=</operator> <name><name>parent</name><operator>-&gt;</operator><name>baserestrict_min_security</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>lateral_vars</name></name> <operator>=</operator> <name><name>parent</name><operator>-&gt;</operator><name>lateral_vars</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>lateral_referencers</name></name> <operator>=</operator> <name><name>parent</name><operator>-&gt;</operator><name>lateral_referencers</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>lateral_relids</name></name> <operator>=</operator> <name><name>parent</name><operator>-&gt;</operator><name>lateral_relids</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>serverid</name></name> <operator>=</operator> <name>serverid</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We need to use the FDW interface to get called by the planner for
	 * partial aggs. For some reason, the standard upper_paths_hook is never
	 * called for upper rels of type UPPERREL_PARTIAL_GROUP_AGG, which is odd
	 * (see end of PostgreSQL planner.c:create_partial_grouping_paths). Until
	 * this gets fixed in the PostgreSQL planner, we're forced to set
	 * fdwroutine here although we will scan this rel with a DataNodeScan and
	 * not a ForeignScan.
	 */</comment>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>fdwroutine</name></name> <operator>=</operator> <call><name>GetFdwRoutineByServerId</name><argument_list>(<argument><expr><name>serverid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>rel</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Adjust the attributes of data node rel quals.
 *
 * Code adapted from allpaths.c: set_append_rel_size.
 *
 * For each data node child rel, copy the quals/restrictions from the parent
 * (hypertable) rel and adjust the attributes (e.g., Vars) to point to the
 * child rel instead of the parent.
 *
 * Normally, this happens as part of estimating the rel size of an append
 * relation in standard planning, where constraint exclusion and partition
 * pruning also happens for each child. Here, however, we don't prune any
 * data node rels since they are created based on assignment of already pruned
 * chunk child rels at an earlier stage. Data node rels that aren't assigned any
 * chunks will never be created in the first place.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>adjust_data_node_rel_attrs</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>data_node_rel</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>hyper_rel</name></decl></parameter>,
						   <parameter><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>nodequals</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>hyper_rel-&gt;baserestrictinfo</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>nodequal</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>nodequal</name> <operator>=</operator> <call><name>adjust_appendrel_attrs</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>appinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>nodequal</name> <operator>=</operator> <call><name>eval_const_expressions</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>nodequal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* might have gotten an AND clause, if so flatten it */</comment>
		<macro><name>foreach</name> <argument_list>(<argument>lc2</argument>, <argument>make_ands_implicit((Expr *) nodequal)</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>onecq</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type> <name>pseudoconstant</name></decl>;</decl_stmt>

			<comment type="block">/* check for pseudoconstant (no Vars or volatile functions) */</comment>
			<expr_stmt><expr><name>pseudoconstant</name> <operator>=</operator> <operator>!</operator><call><name>contain_vars_of_level</name><argument_list>(<argument><expr><name>onecq</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>contain_volatile_functions</name><argument_list>(<argument><expr><name>onecq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>pseudoconstant</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* tell createplan.c to check for gating quals */</comment>
				<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>hasPseudoConstantQuals</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* reconstitute RestrictInfo with appropriate properties */</comment>
			<expr_stmt><expr><name>nodequals</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>nodequals</name></expr></argument>,
								<argument><expr><call><name>make_restrictinfo_compat</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
														 <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>onecq</name></expr></argument>,
														 <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>is_pushed_down</name></name></expr></argument>,
														 <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>outerjoin_delayed</name></name></expr></argument>,
														 <argument><expr><name>pseudoconstant</name></expr></argument>,
														 <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>security_level</name></name></expr></argument>,
														 <argument><expr><name>NULL</name></expr></argument>,
														 <argument><expr><name>NULL</name></expr></argument>,
														 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block>

	<expr_stmt><expr><name><name>data_node_rel</name><operator>-&gt;</operator><name>baserestrictinfo</name></name> <operator>=</operator> <name>nodequals</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>data_node_rel</name><operator>-&gt;</operator><name>joininfo</name></name> <operator>=</operator>
		<call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><call><name>adjust_appendrel_attrs</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>hyper_rel</name><operator>-&gt;</operator><name>joininfo</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>appinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>data_node_rel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>exprs</name></name> <operator>=</operator>
		<call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>,
				 <argument><expr><call><name>adjust_appendrel_attrs</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>hyper_rel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>appinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Add equivalence class for rel to push down joins and sorts */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>hyper_rel</name><operator>-&gt;</operator><name>has_eclass_joins</name></name> <operator>||</operator> <call><name>has_useful_pathkeys</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>hyper_rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>add_child_rel_equivalences</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>appinfo</name></expr></argument>, <argument><expr><name>hyper_rel</name></expr></argument>, <argument><expr><name>data_node_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>data_node_rel</name><operator>-&gt;</operator><name>has_eclass_joins</name></name> <operator>=</operator> <name><name>hyper_rel</name><operator>-&gt;</operator><name>has_eclass_joins</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Build RelOptInfos for each data node.
 *
 * Each data node rel will point to the root hypertable table, which is
 * conceptually correct since we query the identical (partial) hypertables on
 * the data nodes.
 */</comment>
<function><type><specifier>static</specifier> <name>RelOptInfo</name> <modifier>*</modifier><modifier>*</modifier></type>
<name>build_data_node_part_rels</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>hyper_rel</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nparts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimescaleDBPrivate</name> <modifier>*</modifier></type><name>priv</name> <init>= <expr><name><name>hyper_rel</name><operator>-&gt;</operator><name>fdw_private</name></name></expr></init></decl>;</decl_stmt>
	<comment type="block">/* Update the partitioning to reflect the new per-data node plan */</comment>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>part_rels</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RelOptInfo</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>priv</name><operator>-&gt;</operator><name>serverids</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>priv</name><operator>-&gt;</operator><name>serverids</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>bms_num_members</name><argument_list>(<argument><expr><name><name>priv</name><operator>-&gt;</operator><name>server_relids</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>priv-&gt;serverids</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>data_node_id</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>data_node_rel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appinfo</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name><name>priv</name><operator>-&gt;</operator><name>server_relids</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * The planner expects an AppendRelInfo for any part_rels. Needs to be
		 * added prior to creating the rel because build_simple_rel will
		 * invoke our planner hooks that classify relations using this
		 * information.
		 */</comment>
		<expr_stmt><expr><name>appinfo</name> <operator>=</operator> <call><name>create_append_rel_info</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>hyper_rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>append_rel_array</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>appinfo</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>data_node_rel</name> <operator>=</operator> <call><name>build_data_node_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>data_node_id</name></expr></argument>, <argument><expr><name>hyper_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>part_rels</name><index>[<expr><name>n</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>data_node_rel</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>adjust_data_node_rel_attrs</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>data_node_rel</name></expr></argument>, <argument><expr><name>hyper_rel</name></expr></argument>, <argument><expr><name>appinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>nparts</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>nparts</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>part_rels</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Callback argument for ts_ec_member_matches_foreign */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>current</name></decl>;</decl_stmt>		<comment type="block">/* current expr, or NULL if not yet found */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>already_used</name></decl>;</decl_stmt> <comment type="block">/* expressions already dealt with */</comment>
}</block></struct></type> <name>ts_ec_member_foreign_arg</name>;</typedef>

<comment type="block">/*
 * Detect whether we want to process an EquivalenceClass member.
 *
 * This is a callback for use by generate_implied_equalities_for_column.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ts_ec_member_matches_foreign</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>,
							 <parameter><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>em</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ts_ec_member_foreign_arg</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><operator>(</operator><name>ts_ec_member_foreign_arg</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><name><name>em</name><operator>-&gt;</operator><name>em_expr</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If we've identified what we're processing in the current scan, we only
	 * want to match that expression.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>current</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>equal</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>current</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Otherwise, ignore anything we've already processed.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_member</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>already_used</name></name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* This is the new target to process. */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>current</name></name> <operator>=</operator> <name>expr</name></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_data_node_scan_paths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>baserel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TsFdwRelInfo</name> <modifier>*</modifier></type><name>fpinfo</name> <init>= <expr><call><name>fdw_relinfo_get</name><argument_list>(<argument><expr><name>baserel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>baserel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>==</operator> <name>RELOPT_JOINREL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"foreign joins are not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>data_node_scan_path_create</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
									  <argument><expr><name>baserel</name></expr></argument>,
									  <argument><expr><name>NULL</name></expr></argument>, <comment type="block">/* default pathtarget */</comment>
									  <argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>,
									  <argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>startup_cost</name></name></expr></argument>,
									  <argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>total_cost</name></name></expr></argument>,
									  <argument><expr><name>NIL</name></expr></argument>, <comment type="block">/* no pathkeys */</comment>
									  <argument><expr><name>NULL</name></expr></argument>,
									  <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* no extra plan */</comment>,
									  <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>fdw_utils_add_path</name><argument_list>(<argument><expr><name>baserel</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Add paths with pathkeys */</comment>
	<expr_stmt><expr><call><name>fdw_add_paths_with_pathkeys_for_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>baserel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>data_node_scan_path_create</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Thumb through all join clauses for the rel to identify which outer
	 * relations could supply one or more safe-to-send-to-remote join clauses.
	 * We'll build a parameterized path for each such outer relation.
	 *
	 * Note that in case we have multiple local tables, this outer relation
	 * here may be the result of joining the local tables together. For an
	 * example, see the multiple join in the dist_param test.
	 *
	 * It's convenient to represent each candidate outer relation by the
	 * ParamPathInfo node for it.  We can then use the ppi_clauses list in the
	 * ParamPathInfo node directly as a list of the interesting join clauses for
	 * that rel.  This takes care of the possibility that there are multiple
	 * safe join clauses for such a rel, and also ensures that we account for
	 * unsafe join clauses that we'll still have to enforce locally (since the
	 * parameterized-path machinery insists that we handle all movable clauses).
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>ppi_list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>baserel-&gt;joininfo</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relids</name></type> <name>required_outer</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ParamPathInfo</name> <modifier>*</modifier></type><name>param_info</name></decl>;</decl_stmt>

		<comment type="block">/* Check if clause can be moved to this rel */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>join_clause_is_movable_to</name><argument_list>(<argument><expr><name>rinfo</name></expr></argument>, <argument><expr><name>baserel</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* See if it is safe to send to remote */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ts_is_foreign_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>baserel</name></expr></argument>, <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Calculate required outer rels for the resulting path */</comment>
		<expr_stmt><expr><name>required_outer</name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause_relids</name></name></expr></argument>, <argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>lateral_relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* We do not want the data node rel itself listed in required_outer */</comment>
		<expr_stmt><expr><name>required_outer</name> <operator>=</operator> <call><name>bms_del_member</name><argument_list>(<argument><expr><name>required_outer</name></expr></argument>, <argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * required_outer probably can't be empty here, but if it were, we
		 * couldn't make a parameterized path.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Get the ParamPathInfo */</comment>
		<expr_stmt><expr><name>param_info</name> <operator>=</operator> <call><name>get_baserel_parampathinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>baserel</name></expr></argument>, <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>param_info</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Add it to list unless we already have it.  Testing pointer equality
		 * is OK since get_baserel_parampathinfo won't make duplicates.
		 */</comment>
		<expr_stmt><expr><name>ppi_list</name> <operator>=</operator> <call><name>list_append_unique_ptr</name><argument_list>(<argument><expr><name>ppi_list</name></expr></argument>, <argument><expr><name>param_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * The above scan examined only "generic" join clauses, not those that
	 * were absorbed into EquivalenceClauses.  See if we can make anything out
	 * of EquivalenceClauses.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>baserel</name><operator>-&gt;</operator><name>has_eclass_joins</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We repeatedly scan the eclass list looking for column references
		 * (or expressions) belonging to the data node rel.  Each time we find
		 * one, we generate a list of equivalence joinclauses for it, and then
		 * see if any are safe to send to the remote.  Repeat till there are
		 * no more candidate EC members.
		 */</comment>
		<decl_stmt><decl><type><name>ts_ec_member_foreign_arg</name></type> <name>arg</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>arg</name><operator>.</operator><name>already_used</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>clauses</name></decl>;</decl_stmt>

			<comment type="block">/* Make clauses, skipping any that join to lateral_referencers */</comment>
			<expr_stmt><expr><name><name>arg</name><operator>.</operator><name>current</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>clauses</name> <operator>=</operator> <call><name>generate_implied_equalities_for_column</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
															 <argument><expr><name>baserel</name></expr></argument>,
															 <argument><expr><name>ts_ec_member_matches_foreign</name></expr></argument>,
															 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>arg</name></expr></argument>,
															 <argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>lateral_referencers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Done if there are no more expressions in the data node rel */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>arg</name><operator>.</operator><name>current</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>clauses</name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Scan the extracted join clauses */</comment>
			<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>clauses</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Relids</name></type> <name>required_outer</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ParamPathInfo</name> <modifier>*</modifier></type><name>param_info</name></decl>;</decl_stmt>

				<comment type="block">/* Check if clause can be moved to this rel */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>join_clause_is_movable_to</name><argument_list>(<argument><expr><name>rinfo</name></expr></argument>, <argument><expr><name>baserel</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* See if it is safe to send to remote */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ts_is_foreign_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>baserel</name></expr></argument>, <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* Calculate required outer rels for the resulting path */</comment>
				<expr_stmt><expr><name>required_outer</name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause_relids</name></name></expr></argument>, <argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>lateral_relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>required_outer</name> <operator>=</operator> <call><name>bms_del_member</name><argument_list>(<argument><expr><name>required_outer</name></expr></argument>, <argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* Get the ParamPathInfo */</comment>
				<expr_stmt><expr><name>param_info</name> <operator>=</operator> <call><name>get_baserel_parampathinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>baserel</name></expr></argument>, <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>param_info</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Add it to list unless we already have it */</comment>
				<expr_stmt><expr><name>ppi_list</name> <operator>=</operator> <call><name>list_append_unique_ptr</name><argument_list>(<argument><expr><name>ppi_list</name></expr></argument>, <argument><expr><name>param_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>

			<comment type="block">/* Try again, now ignoring the expression we found this time */</comment>
			<expr_stmt><expr><name><name>arg</name><operator>.</operator><name>already_used</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>arg</name><operator>.</operator><name>already_used</name></name></expr></argument>, <argument><expr><name><name>arg</name><operator>.</operator><name>current</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Now build a path for each useful outer relation.
	 */</comment>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>ppi_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ParamPathInfo</name> <modifier>*</modifier></type><name>param_info</name> <init>= <expr><operator>(</operator><name>ParamPathInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Cost</name></type> <name>startup_cost</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Cost</name></type> <name>run_cost</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type> <name>rows</name> <init>= <expr><ternary><condition><expr><name><name>baserel</name><operator>-&gt;</operator><name>tuples</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><name><name>baserel</name><operator>-&gt;</operator><name>tuples</name></name></expr> </then><else>: <expr><literal type="number">123456</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Run remote non-join clauses. */</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>double</name></type> <name>remote_sel_sane</name> <init>=
			<expr><ternary><condition><expr><operator>(</operator><name><name>fpinfo</name><operator>-&gt;</operator><name>remote_conds_sel</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>fpinfo</name><operator>-&gt;</operator><name>remote_conds_sel</name></name> <operator>&lt;=</operator> <literal type="number">1</literal><operator>)</operator></expr> ?</condition><then>
				<expr><name><name>fpinfo</name><operator>-&gt;</operator><name>remote_conds_sel</name></name></expr> </then><else>:
				<expr><literal type="number">0.1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name><name>baserel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name><name>fpinfo</name><operator>-&gt;</operator><name>remote_conds_cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name><name>fpinfo</name><operator>-&gt;</operator><name>remote_conds_cost</name><operator>.</operator><name>per_tuple</name></name> <operator>*</operator> <name>rows</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name>cpu_tuple_cost</name> <operator>*</operator> <name>rows</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name>seq_page_cost</name> <operator>*</operator> <name><name>baserel</name><operator>-&gt;</operator><name>pages</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>rows</name> <operator>*=</operator> <name>remote_sel_sane</name></expr>;</expr_stmt>

		<comment type="block">/* Run remote join clauses. */</comment>
		<decl_stmt><decl><type><name>QualCost</name></type> <name>remote_join_cost</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>cost_qual_eval</name><argument_list>(<argument><expr><operator>&amp;</operator><name>remote_join_cost</name></expr></argument>, <argument><expr><name><name>param_info</name><operator>-&gt;</operator><name>ppi_clauses</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/*
		 * We don't have up to date per-column statistics for distributed
		 * hypertables currently, so the join estimates are going to be way off.
		 * The worst is when they are too low and we end up transferring much
		 * more rows from the data node that we expected. Just hardcode it at
		 * 0.1 per clause for now.
		 */</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>double</name></type> <name>remote_join_sel</name> <init>= <expr><call><name>pow</name><argument_list>(<argument><expr><literal type="number">0.1</literal></expr></argument>, <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>param_info</name><operator>-&gt;</operator><name>ppi_clauses</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name><name>remote_join_cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name><name>remote_join_cost</name><operator>.</operator><name>per_tuple</name></name> <operator>*</operator> <name>rows</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>rows</name> <operator>*=</operator> <name>remote_join_sel</name></expr>;</expr_stmt>

		<comment type="block">/* Transfer the resulting tuples over the network. */</comment>
		<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name><name>fpinfo</name><operator>-&gt;</operator><name>fdw_startup_cost</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name><name>fpinfo</name><operator>-&gt;</operator><name>fdw_tuple_cost</name></name> <operator>*</operator> <name>rows</name></expr>;</expr_stmt>

		<comment type="block">/* Run local filters. */</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>double</name></type> <name>local_sel_sane</name> <init>=
			<expr><ternary><condition><expr><operator>(</operator><name><name>fpinfo</name><operator>-&gt;</operator><name>local_conds_sel</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>fpinfo</name><operator>-&gt;</operator><name>local_conds_sel</name></name> <operator>&lt;=</operator> <literal type="number">1</literal><operator>)</operator></expr> ?</condition><then>
				<expr><name><name>fpinfo</name><operator>-&gt;</operator><name>local_conds_sel</name></name></expr> </then><else>:
				<expr><literal type="number">0.5</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name><name>fpinfo</name><operator>-&gt;</operator><name>local_conds_cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name><name>fpinfo</name><operator>-&gt;</operator><name>local_conds_cost</name><operator>.</operator><name>per_tuple</name></name> <operator>*</operator> <name>rows</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name>cpu_tuple_cost</name> <operator>*</operator> <name>rows</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>rows</name> <operator>*=</operator> <name>local_sel_sane</name></expr>;</expr_stmt>

		<comment type="block">/* Compute the output targetlist. */</comment>
		<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name><name>baserel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>per_tuple</name></name> <operator>*</operator> <name>rows</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * ppi_rows currently won't get looked at by anything, but still we
		 * may as well ensure that it matches our idea of the rowcount.
		 */</comment>
		<expr_stmt><expr><name><name>param_info</name><operator>-&gt;</operator><name>ppi_rows</name></name> <operator>=</operator> <name>rows</name></expr>;</expr_stmt>

		<comment type="block">/* Make the path */</comment>
		<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>data_node_scan_path_create</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										  <argument><expr><name>baserel</name></expr></argument>,
										  <argument><expr><name>NULL</name></expr></argument>, <comment type="block">/* default pathtarget */</comment>
										  <argument><expr><name>rows</name></expr></argument>,
										  <argument><expr><name>startup_cost</name></expr></argument>,
										  <argument><expr><name>startup_cost</name> <operator>+</operator> <name>run_cost</name></expr></argument>,
										  <argument><expr><name>NIL</name></expr></argument>, <comment type="block">/* no pathkeys */</comment>
										  <argument><expr><name><name>param_info</name><operator>-&gt;</operator><name>ppi_req_outer</name></name></expr></argument>,
										  <argument><expr><name>NULL</name></expr></argument>,
										  <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* no fdw_private list */</comment>

		<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>baserel</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Force GROUP BY aggregates to be pushed down.
 *
 * Push downs are forced by making the GROUP BY expression in the query become
 * the partitioning keys, even if this is not compatible with
 * partitioning. This makes the planner believe partitioning and GROUP BYs
 * line up perfectly. Forcing a push down is useful because the PostgreSQL
 * planner is not smart enough to realize it can always push things down if
 * there's, e.g., only one partition (or data node) involved in the query.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>force_group_by_push_down</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>hyper_rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PartitionScheme</name></type> <name>partscheme</name> <init>= <expr><name><name>hyper_rel</name><operator>-&gt;</operator><name>part_scheme</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>groupexprs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>nullable_partexprs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type> <name>new_partnatts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>partopfamily</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>partopcintype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>partcollation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>partscheme</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>groupexprs</name> <operator>=</operator> <call><name>get_sortgrouplist_exprs</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>new_partnatts</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>groupexprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Only reallocate the partitioning attributes arrays if it is smaller than
	 * the new size. palloc0 is needed to zero out the extra space.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>partscheme</name><operator>-&gt;</operator><name>partnatts</name></name> <operator>&lt;</operator> <name>new_partnatts</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>partopfamily</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>new_partnatts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>partopcintype</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>new_partnatts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>partcollation</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>new_partnatts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nullable_partexprs</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>new_partnatts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>partopfamily</name></expr></argument>, <argument><expr><name><name>partscheme</name><operator>-&gt;</operator><name>partopfamily</name></name></expr></argument>, <argument><expr><name><name>partscheme</name><operator>-&gt;</operator><name>partnatts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>partopcintype</name></expr></argument>, <argument><expr><name><name>partscheme</name><operator>-&gt;</operator><name>partopcintype</name></name></expr></argument>, <argument><expr><name><name>partscheme</name><operator>-&gt;</operator><name>partnatts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>partcollation</name></expr></argument>, <argument><expr><name><name>partscheme</name><operator>-&gt;</operator><name>partcollation</name></name></expr></argument>, <argument><expr><name><name>partscheme</name><operator>-&gt;</operator><name>partnatts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>nullable_partexprs</name></expr></argument>,
			   <argument><expr><name><name>hyper_rel</name><operator>-&gt;</operator><name>nullable_partexprs</name></name></expr></argument>,
			   <argument><expr><name><name>partscheme</name><operator>-&gt;</operator><name>partnatts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>partscheme</name><operator>-&gt;</operator><name>partopfamily</name></name> <operator>=</operator> <name>partopfamily</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>partscheme</name><operator>-&gt;</operator><name>partopcintype</name></name> <operator>=</operator> <name>partopcintype</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>partscheme</name><operator>-&gt;</operator><name>partcollation</name></name> <operator>=</operator> <name>partcollation</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hyper_rel</name><operator>-&gt;</operator><name>nullable_partexprs</name></name> <operator>=</operator> <name>nullable_partexprs</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>hyper_rel</name><operator>-&gt;</operator><name>partexprs</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>new_partnatts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>partscheme</name><operator>-&gt;</operator><name>partnatts</name></name> <operator>=</operator> <name>new_partnatts</name></expr>;</expr_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>groupexprs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>hyper_rel</name><operator>-&gt;</operator><name>partexprs</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>i</name> <operator>==</operator> <name><name>partscheme</name><operator>-&gt;</operator><name>partnatts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Check if it is safe to push down GROUP BYs to remote nodes. A push down is
 * safe if the chunks that are part of the query are disjointedly partitioned
 * on data nodes along the first closed "space" dimension, or all dimensions are
 * covered in the GROUP BY expresssion.
 *
 * If we knew that the GROUP BY covers all partitioning keys, we would not
 * need to check overlaps. Such a check is done in
 * planner.c:group_by_has_partkey(), but this function is not public. We
 * could copy it here to avoid some unnecessary work.
 *
 * There are other "base" cases when we can always safely push down--even if
 * the GROUP BY does NOT cover the partitioning keys--for instance, when only
 * one data node is involved in the query. We try to account for such cases too
 * and "trick" the PG planner to do the "right" thing.
 *
 * We also want to add any bucketing expression (on, e.g., time) as a "meta"
 * partitioning key (in rel-&gt;partexprs). This will make the partitionwise
 * planner accept the GROUP BY clause for push down even though the expression
 * on time is a "derived" partitioning key.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>push_down_group_bys</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>hyper_rel</name></decl></parameter>, <parameter><decl><type><name>Hyperspace</name> <modifier>*</modifier></type><name>hs</name></decl></parameter>,
					<parameter><decl><type><name>DataNodeChunkAssignments</name> <modifier>*</modifier></type><name>scas</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type><name>dim</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>overlaps</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>hs</name><operator>-&gt;</operator><name>num_dimensions</name></name> <operator>&gt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>hyper_rel</name><operator>-&gt;</operator><name>part_scheme</name><operator>-&gt;</operator><name>partnatts</name></name> <operator>==</operator> <name><name>hs</name><operator>-&gt;</operator><name>num_dimensions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check for special case when there is only one data node with chunks. This
	 * can always be safely pushed down irrespective of partitioning
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>scas</name><operator>-&gt;</operator><name>num_nodes_with_chunks</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>force_group_by_push_down</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>hyper_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Get first closed dimension that we use for assigning chunks to
	 * data nodes. If there is no closed dimension, we are done.
	 */</comment>
	<expr_stmt><expr><name>dim</name> <operator>=</operator> <call><name>hyperspace_get_closed_dimension</name><argument_list>(<argument><expr><name>hs</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>dim</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>overlaps</name> <operator>=</operator> <call><name>data_node_chunk_assignments_are_overlapping</name><argument_list>(<argument><expr><name>scas</name></expr></argument>, <argument><expr><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>overlaps</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If data node chunk assignments are non-overlapping along the
		 * "space" dimension, we can treat this as a one-dimensional
		 * partitioned table since any aggregate GROUP BY that includes the
		 * data node assignment dimension is safe to execute independently on
		 * each data node.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>dim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hyper_rel</name><operator>-&gt;</operator><name>partexprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>ts_dimension_get_partexprs</name><argument_list>(<argument><expr><name>dim</name></expr></argument>, <argument><expr><name><name>hyper_rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hyper_rel</name><operator>-&gt;</operator><name>part_scheme</name><operator>-&gt;</operator><name>partnatts</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Turn chunk append paths into data node append paths.
 *
 * By default, a hypertable produces append plans where each child is a chunk
 * to be scanned. This function computes alternative append plans where each
 * child corresponds to a data node.
 *
 * In the future, additional assignment algorithms can create their own
 * append paths and have the cost optimizer pick the best one.
 */</comment>
<function><type><name>void</name></type>
<name>data_node_scan_add_node_paths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>hyper_rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>chunk_rels</name> <init>= <expr><name><name>hyper_rel</name><operator>-&gt;</operator><name>part_rels</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nchunk_rels</name> <init>= <expr><name><name>hyper_rel</name><operator>-&gt;</operator><name>nparts</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>hyper_rte</name> <init>= <expr><call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name><name>hyper_rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cache</name> <modifier>*</modifier></type><name>hcache</name> <init>= <expr><call><name>ts_hypertable_cache_pin</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name> <init>= <expr><call><name>ts_hypertable_cache_get_entry</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>, <argument><expr><name><name>hyper_rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>CACHE_FLAG_NONE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>data_node_rels_list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>data_node_rels</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG15_GE</name></expr></cpp:if>
	<decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>data_node_live_rels</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<decl_stmt><decl><type><name>int</name></type> <name>ndata_node_rels</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DataNodeChunkAssignments</name></type> <name>scas</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>nchunk_rels</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Create the RelOptInfo for each data node */</comment>
	<expr_stmt><expr><name>data_node_rels</name> <operator>=</operator> <call><name>build_data_node_part_rels</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>hyper_rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ndata_node_rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ndata_node_rels</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>data_node_chunk_assignments_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scas</name></expr></argument>, <argument><expr><name>SCA_STRATEGY_ATTACHED_DATA_NODE</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>ndata_node_rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Assign chunks to data nodes */</comment>
	<expr_stmt><expr><call><name>data_node_chunk_assignment_assign_chunks</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scas</name></expr></argument>, <argument><expr><name>chunk_rels</name></expr></argument>, <argument><expr><name>nchunk_rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Try to push down GROUP BY expressions and bucketing, if possible */</comment>
	<expr_stmt><expr><call><name>push_down_group_bys</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>hyper_rel</name></expr></argument>, <argument><expr><name><name>ht</name><operator>-&gt;</operator><name>space</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scas</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create estimates and paths for each data node rel based on data node chunk
	 * assignments.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndata_node_rels</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>data_node_rel</name> <init>= <expr><name><name>data_node_rels</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DataNodeChunkAssignment</name> <modifier>*</modifier></type><name>sca</name> <init>=
			<expr><call><name>data_node_chunk_assignment_get_or_create</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scas</name></expr></argument>, <argument><expr><name>data_node_rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TsFdwRelInfo</name> <modifier>*</modifier></type><name>fpinfo</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Basic stats for data node rels come from the assigned chunks since
		 * data node rels don't correspond to real tables in the system.
		 */</comment>
		<expr_stmt><expr><name><name>data_node_rel</name><operator>-&gt;</operator><name>pages</name></name> <operator>=</operator> <name><name>sca</name><operator>-&gt;</operator><name>pages</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>data_node_rel</name><operator>-&gt;</operator><name>tuples</name></name> <operator>=</operator> <name><name>sca</name><operator>-&gt;</operator><name>tuples</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>data_node_rel</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <name><name>sca</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>
		<comment type="block">/* The width should be the same as any chunk */</comment>
		<expr_stmt><expr><name><name>data_node_rel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>width</name></name> <operator>=</operator> <name><name>hyper_rel</name><operator>-&gt;</operator><name>part_rels</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>reltarget</name><operator>-&gt;</operator><name>width</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>fpinfo</name> <operator>=</operator> <call><name>fdw_relinfo_create</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
									<argument><expr><name>data_node_rel</name></expr></argument>,
									<argument><expr><name><name>data_node_rel</name><operator>-&gt;</operator><name>serverid</name></name></expr></argument>,
									<argument><expr><name><name>hyper_rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,
									<argument><expr><name>TS_FDW_RELINFO_HYPERTABLE_DATA_NODE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>sca</name></name> <operator>=</operator> <name>sca</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><name><name>sca</name><operator>-&gt;</operator><name>chunk_relids</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>add_data_node_scan_paths</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>data_node_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>data_node_rels_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>data_node_rels_list</name></expr></argument>, <argument><expr><name>data_node_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG15_GE</name></expr></cpp:if>
			<expr_stmt><expr><name>data_node_live_rels</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>data_node_live_rels</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ts_set_dummy_rel_pathlist</name><argument_list>(<argument><expr><name>data_node_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>set_cheapest</name><argument_list>(<argument><expr><name>data_node_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TS_DEBUG</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><name><name>ts_debug_optimizer_flags</name><operator>.</operator><name>show_rel</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>tsl_debug_log_rel_with_paths</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>data_node_rel</name></expr></argument>, <argument><expr><operator>(</operator><name>UpperRelationKind</name> <operator>*</operator><operator>)</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>data_node_rels_list</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Reset the pathlist since data node scans are preferred */</comment>
	<expr_stmt><expr><name><name>hyper_rel</name><operator>-&gt;</operator><name>pathlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<comment type="block">/* Must keep partitioning info consistent with the append paths we create */</comment>
	<expr_stmt><expr><name><name>hyper_rel</name><operator>-&gt;</operator><name>part_rels</name></name> <operator>=</operator> <name>data_node_rels</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hyper_rel</name><operator>-&gt;</operator><name>nparts</name></name> <operator>=</operator> <name>ndata_node_rels</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG15_GE</name></expr></cpp:if>
	<expr_stmt><expr><name><name>hyper_rel</name><operator>-&gt;</operator><name>live_parts</name></name> <operator>=</operator> <name>data_node_live_rels</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>add_paths_to_append_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>hyper_rel</name></expr></argument>, <argument><expr><name>data_node_rels_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Creates CustomScanPath for the data node and adds to output_rel. No custom_path is added,
 * i.e., it is encapsulated by the CustomScanPath, so it doesn't inflate continuation of the
 * planning and will be planned locally on the data node.
 */</comment>
<function><type><name>void</name></type>
<name>data_node_scan_create_upper_paths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>UpperRelationKind</name></type> <name>stage</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>input_rel</name></decl></parameter>,
								  <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>output_rel</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimescaleDBPrivate</name> <modifier>*</modifier></type><name>rel_private</name> <init>= <expr><name><name>input_rel</name><operator>-&gt;</operator><name>fdw_private</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TsFdwRelInfo</name> <modifier>*</modifier></type><name>fpinfo</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>rel_private</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>rel_private</name><operator>-&gt;</operator><name>fdw_relation_info</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/* Not a rel we're interested in */</comment>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>fpinfo</name> <operator>=</operator> <call><name>fdw_relinfo_get</name><argument_list>(<argument><expr><name>input_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Verify that this is a data node rel */</comment>
	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>fpinfo</name> <operator>||</operator> <name><name>fpinfo</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>TS_FDW_RELINFO_HYPERTABLE_DATA_NODE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>fdw_create_upper_paths</name><argument_list>(<argument><expr><name>fpinfo</name></expr></argument>,
						   <argument><expr><name>root</name></expr></argument>,
						   <argument><expr><name>stage</name></expr></argument>,
						   <argument><expr><name>input_rel</name></expr></argument>,
						   <argument><expr><name>output_rel</name></expr></argument>,
						   <argument><expr><name>extra</name></expr></argument>,
						   <argument><expr><name>data_node_scan_upper_path_create</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>CustomScanMethods</name></type> <name>data_node_scan_plan_methods</name> <init>= <expr><block>{
	<expr><operator>.</operator><name>CustomName</name> <operator>=</operator> <literal type="string">"DataNodeScan"</literal></expr>,
	<expr><operator>.</operator><name>CreateCustomScanState</name> <operator>=</operator> <name>data_node_scan_state_create</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<typedef>typedef <type><struct>struct <name>DataNodeScanPath</name>
<block>{
	<decl_stmt><decl><type><name>CustomPath</name></type> <name>cpath</name></decl>;</decl_stmt>
}</block></struct></type> <name>DataNodeScanPath</name>;</typedef>

<function><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type>
<name>data_node_scan_plan_create</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>CustomPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
						   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>clauses</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>custom_plans</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CustomScan</name> <modifier>*</modifier></type><name>cscan</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CustomScan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanInfo</name></type> <name>scaninfo</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scaninfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ScanInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>fdw_scan_info_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scaninfo</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name>clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>methods</name></name> <operator>=</operator> <operator>&amp;</operator><name>data_node_scan_plan_methods</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_plans</name></name> <operator>=</operator> <name>custom_plans</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>=</operator> <name><name>scaninfo</name><operator>.</operator><name>scan_relid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_scan_tlist</name></name> <operator>=</operator> <name><name>scaninfo</name><operator>.</operator><name>fdw_scan_tlist</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name> <operator>=</operator> <name><name>scaninfo</name><operator>.</operator><name>local_exprs</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_exprs</name></name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><name><name>scaninfo</name><operator>.</operator><name>params_list</name></name></expr></argument>, <argument><expr><name><name>scaninfo</name><operator>.</operator><name>fdw_recheck_quals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If this is a join, and to make it valid to push down we had to assume
	 * that the current user is the same as some user explicitly named in the
	 * query, mark the finished plan as depending on the current user.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>useridiscurrent</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>dependsOnRole</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If rel is a base relation, detect whether any system columns are
	 * requested from the rel.  (If rel is a join relation, rel-&gt;relid will be
	 * 0, but there can be no Var with relid 0 in the rel's targetlist or the
	 * restriction clauses, so we skip this in that case.  Note that any such
	 * columns in base relations that were joined are assumed to be contained
	 * in fdw_scan_tlist.)	This is a bit of a kluge and might go away
	 * someday, so we intentionally leave it out of the API presented to FDWs.
	 */</comment>

	<expr_stmt><expr><name><name>scaninfo</name><operator>.</operator><name>systemcol</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>scaninfo</name><operator>.</operator><name>scan_relid</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>attrs_used</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * First, examine all the attributes needed for joins or final output.
		 * Note: we must look at rel's targetlist, not the attr_needed data,
		 * because attr_needed isn't computed for inheritance child rels.
		 */</comment>
		<expr_stmt><expr><call><name>pull_varattnos</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>, <argument><expr><name><name>scaninfo</name><operator>.</operator><name>scan_relid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>attrs_used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Add all the attributes used by restriction clauses. */</comment>
		<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>rel-&gt;baserestrictinfo</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>pull_varattnos</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>, <argument><expr><name><name>scaninfo</name><operator>.</operator><name>scan_relid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>attrs_used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/* Now, are any system columns requested from rel? */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>FirstLowInvalidHeapAttributeNumber</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>i</name> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>, <argument><expr><name>attrs_used</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>scaninfo</name><operator>.</operator><name>systemcol</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>attrs_used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Raise an error when system column is requsted, eg. tableoid */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>scaninfo</name><operator>.</operator><name>systemcol</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"system columns are not accessible on distributed hypertables with current "</literal>
						<literal type="string">"settings"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Set timescaledb.enable_per_data_node_queries=false to query system "</literal>
						 <literal type="string">"columns."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Should have determined the fetcher type by now. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ts_data_node_fetcher_scan_type</name> <operator>!=</operator> <name>AutoFetcherType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_private</name></name> <operator>=</operator> <call><name>list_make3</name><argument_list>(<argument><expr><name><name>scaninfo</name><operator>.</operator><name>fdw_private</name></name></expr></argument>,
									   <argument><expr><call><name>list_make1_int</name><argument_list>(<argument><expr><name><name>scaninfo</name><operator>.</operator><name>systemcol</name></name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><call><name>makeInteger</name><argument_list>(<argument><expr><name>ts_data_node_fetcher_scan_type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>&amp;</operator><name><name>cscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name></name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>CustomPathMethods</name></type> <name>data_node_scan_path_methods</name> <init>= <expr><block>{
	<expr><operator>.</operator><name>CustomName</name> <operator>=</operator> <name>DATA_NODE_SCAN_PATH_NAME</name></expr>,
	<expr><operator>.</operator><name>PlanCustomPath</name> <operator>=</operator> <name>data_node_scan_plan_create</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>Path</name> <modifier>*</modifier></type>
<name>data_node_scan_path_create</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>rows</name></decl></parameter>,
						   <parameter><decl><type><name>Cost</name></type> <name>startup_cost</name></decl></parameter>, <parameter><decl><type><name>Cost</name></type> <name>total_cost</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>,
						   <parameter><decl><type><name>Relids</name></type> <name>required_outer</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>fdw_outerpath</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>private</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DataNodeScanPath</name> <modifier>*</modifier></type><name>scanpath</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DataNodeScanPath</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>lateral_relids</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>lateral_relids</name></name></expr></argument>, <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>required_outer</name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name>required_outer</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>lateral_relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>required_outer</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IS_SIMPLE_REL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"parameterized foreign joins are not supported yet"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>scanpath</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>T_CustomPath</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanpath</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_CustomScan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanpath</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>custom_paths</name></name> <operator>=</operator> <ternary><condition><expr><name>fdw_outerpath</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><name>NIL</name></expr> </then><else>: <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>fdw_outerpath</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanpath</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>methods</name></name> <operator>=</operator> <operator>&amp;</operator><name>data_node_scan_path_methods</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanpath</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanpath</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <ternary><condition><expr><name>target</name></expr> ?</condition><then> <expr><name>target</name></expr> </then><else>: <expr><name><name>rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanpath</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <call><name>get_baserel_parampathinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanpath</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanpath</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanpath</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanpath</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <name>rows</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanpath</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name>startup_cost</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanpath</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <name>total_cost</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanpath</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name>pathkeys</name></expr>;</expr_stmt>

	<return>return <expr><operator>&amp;</operator><name><name>scanpath</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Path</name> <modifier>*</modifier></type>
<name>data_node_scan_upper_path_create</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
								 <parameter><decl><type><name>double</name></type> <name>rows</name></decl></parameter>, <parameter><decl><type><name>Cost</name></type> <name>startup_cost</name></decl></parameter>, <parameter><decl><type><name>Cost</name></type> <name>total_cost</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>,
								 <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>fdw_outerpath</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>private</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DataNodeScanPath</name> <modifier>*</modifier></type><name>scanpath</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DataNodeScanPath</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Upper relations should never have any lateral references, since joining
	 * is complete.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>lateral_relids</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>scanpath</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>T_CustomPath</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanpath</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_CustomScan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanpath</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>custom_paths</name></name> <operator>=</operator> <ternary><condition><expr><name>fdw_outerpath</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><name>NIL</name></expr> </then><else>: <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>fdw_outerpath</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanpath</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>methods</name></name> <operator>=</operator> <operator>&amp;</operator><name>data_node_scan_path_methods</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanpath</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanpath</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <ternary><condition><expr><name>target</name></expr> ?</condition><then> <expr><name>target</name></expr> </then><else>: <expr><name><name>rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanpath</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanpath</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanpath</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanpath</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanpath</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <name>rows</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanpath</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name>startup_cost</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanpath</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <name>total_cost</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanpath</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name>pathkeys</name></expr>;</expr_stmt>

	<return>return <expr><operator>&amp;</operator><name><name>scanpath</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name></name></expr>;</return>
</block_content>}</block></function>
</unit>
