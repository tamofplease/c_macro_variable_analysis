<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/timescaledb/tsl/src/fdw/deparse.c"><comment type="block">/*
 * This file and its contents are licensed under the Timescale License.
 * Please see the included NOTICE for copyright information and
 * LICENSE-TIMESCALE for a copy of the license.
 */</comment>

<comment type="block">/*
 * This file contains source code that was copied and/or modified from
 * the PostgreSQL database, which is licensed under the open-source
 * PostgreSQL License. Please see the NOTICE at the top level
 * directory for a copy of the PostgreSQL License.
 */</comment>

<comment type="block">/*-------------------------------------------------------------------------
 *
 * deparse.c
 *		  Query deparser for postgres_fdw
 *
 * This file includes functions that examine query WHERE clauses to see
 * whether they're safe to send to the data node for execution, as
 * well as functions to construct the query text to be sent.  The latter
 * functionality is annoyingly duplicative of ruleutils.c, but there are
 * enough special considerations that it seems best to keep this separate.
 * One saving grace is that we only need deparse logic for node types that
 * we consider safe to send.
 *
 * We assume that the remote session's search_path is exactly "pg_catalog",
 * and thus we need schema-qualify all and only names outside pg_catalog.
 *
 * We consider collations and COLLATE expressions safe to send since we assume
 * that all nodes of a distributed hypertable has the same configuration
 * w.r.t. collations.
 *
 * Portions Copyright (c) 2012-2017, PostgreSQL Global Development Group
 *
 * IDENTIFICATION
 *		  contrib/postgres_fdw/deparse.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postgres.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/heapam.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/htup_details.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/sysattr.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_aggregate.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_collation.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_namespace.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_operator.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_proc.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_type.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;commands/defrem.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/makefuncs.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/nodeFuncs.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/pathnodes.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/plannodes.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/appendinfo.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/clauses.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/optimizer.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/paths.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/prep.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/tlist.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;parser/parsetree.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/builtins.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/lsyscache.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/rel.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/syscache.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/typcache.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;func_cache.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;remote/utils.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"relinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"deparse.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"shippable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"scan_plan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"extension_constants.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"partialize_finalize.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/gapfill/gapfill.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"planner/planner.h"</cpp:file></cpp:include>

<comment type="block">/*
 * Global context for foreign_expr_walker's search of an expression tree.
 */</comment>
<typedef>typedef <type><struct>struct <name>foreign_glob_cxt</name>
<block>{
	<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl>;</decl_stmt>		<comment type="block">/* global planner state */</comment>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>foreignrel</name></decl>;</decl_stmt> <comment type="block">/* the foreign relation we are planning for */</comment>
	<decl_stmt><decl><type><name>Relids</name></type> <name>relids</name></decl>;</decl_stmt>			<comment type="block">/* relids of base relations in the underlying
							 * scan */</comment>
}</block></struct></type> <name>foreign_glob_cxt</name>;</typedef>

<comment type="block">/*
 * Context for deparseExpr
 */</comment>
<typedef>typedef <type><struct>struct <name>deparse_expr_cxt</name>
<block>{
	<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl>;</decl_stmt>		<comment type="block">/* global planner state */</comment>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>foreignrel</name></decl>;</decl_stmt> <comment type="block">/* the foreign relation we are planning for */</comment>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>scanrel</name></decl>;</decl_stmt>	<comment type="block">/* the underlying scan relation. Same as
							 * foreignrel, when that represents a join or
							 * a base relation. */</comment>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>buf</name></decl>;</decl_stmt>			<comment type="block">/* output buffer to append to */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>params_list</name></decl>;</decl_stmt>		<comment type="block">/* exprs that will become remote Params */</comment>
	<decl_stmt><decl><type><name>DataNodeChunkAssignment</name> <modifier>*</modifier></type><name>sca</name></decl>;</decl_stmt>
}</block></struct></type> <name>deparse_expr_cxt</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REL_ALIAS_PREFIX</name></cpp:macro> <cpp:value>"r"</cpp:value></cpp:define>
<comment type="block">/* Handy macro to add relation name qualification */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADD_REL_QUALIFIER</name><parameter_list>(<parameter><type><name>buf</name></type></parameter>, <parameter><type><name>varno</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>appendStringInfo((buf), "%s%d.", REL_ALIAS_PREFIX, (varno))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SUBQUERY_REL_ALIAS_PREFIX</name></cpp:macro> <cpp:value>"s"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SUBQUERY_COL_ALIAS_PREFIX</name></cpp:macro> <cpp:value>"c"</cpp:value></cpp:define>

<comment type="block">/* Oids of mutable functions determined to safe to pushdown to data nodes */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>Oid</name></type> <name><name>PushdownSafeFunctionOIDs</name><index>[]</index></name> <init>= <expr><block>{
	<expr><name>F_DATE_CMP_TIMESTAMPTZ</name></expr>,
	<expr><name>F_DATE_IN</name></expr>,
	<expr><name>F_DATE_OUT</name></expr>,
	<expr><name>F_INTERVAL_IN</name></expr>,
	<expr><name>F_INTERVAL_PL</name></expr>,
	<expr><name>F_NOW</name></expr>, <comment type="block">/* Special case, this will be evaluated prior to pushdown */</comment>
	<expr><name>F_TIMESTAMPTZ_CMP_DATE</name></expr>,
	<expr><name>F_TIMESTAMPTZ_CMP_TIMESTAMP</name></expr>,
	<expr><name>F_TIMESTAMPTZ_DATE</name></expr>,
	<expr><name>F_TIMESTAMPTZ_EQ_DATE</name></expr>,
	<expr><name>F_TIMESTAMPTZ_EQ_TIMESTAMP</name></expr>,
	<expr><name>F_TIMESTAMPTZ_GE_DATE</name></expr>,
	<expr><name>F_TIMESTAMPTZ_GE_TIMESTAMP</name></expr>,
	<expr><name>F_TIMESTAMPTZ_GT_DATE</name></expr>,
	<expr><name>F_TIMESTAMPTZ_GT_TIMESTAMP</name></expr>,
	<expr><name>F_TIMESTAMPTZ_IN</name></expr>,
	<expr><name>F_TIMESTAMPTZ_LE_DATE</name></expr>,
	<expr><name>F_TIMESTAMPTZ_LE_TIMESTAMP</name></expr>,
	<expr><name>F_TIMESTAMPTZ_LT_DATE</name></expr>,
	<expr><name>F_TIMESTAMPTZ_LT_TIMESTAMP</name></expr>,
	<expr><name>F_TIMESTAMPTZ_MI_INTERVAL</name></expr>,
	<expr><name>F_TIMESTAMPTZ_NE_DATE</name></expr>,
	<expr><name>F_TIMESTAMPTZ_NE_TIMESTAMP</name></expr>,
	<expr><name>F_TIMESTAMPTZ_OUT</name></expr>,
	<expr><name>F_TIMESTAMPTZ_PL_INTERVAL</name></expr>,
	<expr><name>F_TIMESTAMPTZ_TIMESTAMP</name></expr>,
	<expr><name>F_TIMESTAMP_CMP_TIMESTAMPTZ</name></expr>,
	<expr><name>F_TIMESTAMP_EQ_TIMESTAMPTZ</name></expr>,
	<expr><name>F_TIMESTAMP_GE_TIMESTAMPTZ</name></expr>,
	<expr><name>F_TIMESTAMP_GT_TIMESTAMPTZ</name></expr>,
	<expr><name>F_TIMESTAMP_LE_TIMESTAMPTZ</name></expr>,
	<expr><name>F_TIMESTAMP_LT_TIMESTAMPTZ</name></expr>,
	<expr><name>F_TIMESTAMP_MI_INTERVAL</name></expr>,
	<expr><name>F_TIMESTAMP_NE_TIMESTAMPTZ</name></expr>,
	<expr><name>F_TIMESTAMP_PL_INTERVAL</name></expr>,
	<expr><name>F_TIMESTAMP_TIMESTAMPTZ</name></expr>,
	<expr><name>F_TIMETZ_IN</name></expr>,
	<expr><name>F_TIME_IN</name></expr>,
	<expr><name>F_TIME_TIMETZ</name></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_LT</name></expr></cpp:if>
	<expr><name>F_INTERVAL_PART</name></expr>,
	<expr><name>F_MAKE_TIMESTAMPTZ</name></expr>,
	<expr><name>F_MAKE_TIMESTAMPTZ_AT_TIMEZONE</name></expr>,
	<expr><name>F_TIMESTAMPTZ_PART</name></expr>,
	<expr><name>F_TIMESTAMPTZ_TIME</name></expr>,
	<expr><name>F_TIMESTAMPTZ_TIMETZ</name></expr>,
	<expr><name>F_TIMESTAMPTZ_TRUNC</name></expr>,
	<expr><name>F_TIMESTAMPTZ_TRUNC_ZONE</name></expr>,
	<expr><name>F_TO_TIMESTAMP</name></expr>,
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>PG14_GE</name></expr></cpp:elif>
	<expr><name>F_DATE_PART_TEXT_INTERVAL</name></expr>,
	<expr><name>F_MAKE_TIMESTAMPTZ_INT4_INT4_INT4_INT4_INT4_FLOAT8</name></expr>,
	<expr><name>F_MAKE_TIMESTAMPTZ_INT4_INT4_INT4_INT4_INT4_FLOAT8_TEXT</name></expr>,
	<expr><name>F_DATE_PART_TEXT_TIMESTAMPTZ</name></expr>,
	<expr><name>F_TIME_TIMESTAMPTZ</name></expr>,
	<expr><name>F_TIMETZ_TIMESTAMPTZ</name></expr>,
	<expr><name>F_DATE_TRUNC_TEXT_TIMESTAMPTZ</name></expr>,
	<expr><name>F_DATE_TRUNC_TEXT_TIMESTAMPTZ_TEXT</name></expr>,
	<expr><name>F_TO_TIMESTAMP_TEXT_TEXT</name></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>NumPushdownSafeOIDs</name> <init>=
	<expr><sizeof>sizeof<argument_list>(<argument><expr><name>PushdownSafeFunctionOIDs</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>PushdownSafeFunctionOIDs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Functions to determine whether an expression can be evaluated safely on
 * data node.
 */</comment>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>foreign_expr_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>foreign_glob_cxt</name> <modifier>*</modifier></type><name>glob_cxt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>deparse_type_name</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>type_oid</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>typemod</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Functions to construct string representation of a node tree.
 */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>deparseTargetList</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>rtindex</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
							  <parameter><decl><type><name>bool</name></type> <name>is_returning</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>attrs_used</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>qualify_col</name></decl></parameter>,
							  <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>retrieved_attrs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>deparseExplicitTargetList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_returning</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>retrieved_attrs</name></decl></parameter>,
									  <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>deparseSubqueryTargetList</name><parameter_list>(<parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>deparseReturningList</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>rtindex</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
								 <parameter><decl><type><name>bool</name></type> <name>trig_after_row</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>returningList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>retrieved_attrs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>deparseColumnRef</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>varno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>varattno</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>,
							 <parameter><decl><type><name>bool</name></type> <name>qualify_col</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>deparseRelation</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>deparseExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>deparseVar</name><parameter_list>(<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>deparseConst</name><parameter_list>(<parameter><decl><type><name>Const</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>showtype</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>deparseParam</name><parameter_list>(<parameter><decl><type><name>Param</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>deparseSubscriptingRef</name><parameter_list>(<parameter><decl><type><name>SubscriptingRef</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>deparseFuncExpr</name><parameter_list>(<parameter><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>deparseOpExpr</name><parameter_list>(<parameter><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>deparseOperatorName</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>Form_pg_operator</name></type> <name>opform</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>deparseDistinctExpr</name><parameter_list>(<parameter><decl><type><name>DistinctExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>deparseScalarArrayOpExpr</name><parameter_list>(<parameter><decl><type><name>ScalarArrayOpExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>deparseRelabelType</name><parameter_list>(<parameter><decl><type><name>RelabelType</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>deparseBoolExpr</name><parameter_list>(<parameter><decl><type><name>BoolExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>deparseNullTest</name><parameter_list>(<parameter><decl><type><name>NullTest</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>deparseArrayExpr</name><parameter_list>(<parameter><decl><type><name>ArrayExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>printRemoteParam</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>paramindex</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>paramtype</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>paramtypmod</name></decl></parameter>,
							 <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>printRemotePlaceholder</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>paramtype</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>paramtypmod</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>deparseSelectSql</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_subquery</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>retrieved_attrs</name></decl></parameter>,
							 <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>deparseLockingClause</name><parameter_list>(<parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>appendOrderByClause</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>appendLimit</name><parameter_list>(<parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>append_chunk_exclusion_condition</name><parameter_list>(<parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>use_alias</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>appendConditions</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>exprs</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_first</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>deparseFromExprForRel</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>foreignrel</name></decl></parameter>,
								  <parameter><decl><type><name>bool</name></type> <name>use_alias</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>ignore_rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>ignore_conds</name></decl></parameter>,
								  <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>params_list</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>deparseFromExpr</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>quals</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>deparseAggref</name><parameter_list>(<parameter><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>appendGroupByClause</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>appendAggOrderBy</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>orderList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>appendFunctionName</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>funcid</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>deparseSortGroupClause</name><parameter_list>(<parameter><decl><type><name>Index</name></type> <name>ref</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>force_colno</name></decl></parameter>,
									<parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Helper functions
 */</comment>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>is_subquery_var</name><parameter_list>(<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>foreignrel</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>relno</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>colno</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_relation_column_alias_ids</name><parameter_list>(<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>foreignrel</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>relno</name></decl></parameter>,
										  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>colno</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Examine each qual clause in input_conds, and classify them into two groups,
 * which are returned as two lists:
 *	- remote_conds contains expressions that can be evaluated remotely
 *	- local_conds contains expressions that can't be evaluated remotely
 */</comment>
<function><type><name>void</name></type>
<name>classify_conditions</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>baserel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>input_conds</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>remote_conds</name></decl></parameter>,
					<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>local_conds</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>remote_conds</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>local_conds</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>input_conds</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>ri</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RestrictInfo</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>ts_is_foreign_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>baserel</name></expr></argument>, <argument><expr><name><name>ri</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>remote_conds</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>remote_conds</name></expr></argument>, <argument><expr><name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>local_conds</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>local_conds</name></expr></argument>, <argument><expr><name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>oid_comparator</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <name>a</name> <operator>==</operator> <operator>*</operator><operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <name>b</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>*</operator><operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <name>a</name> <operator>&lt;</operator> <operator>*</operator><operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <name>b</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>function_is_whitelisted</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>func_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>PushdownOIDsSorted</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>PushdownOIDsSorted</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>PushdownSafeFunctionOIDs</name></expr></argument>, <argument><expr><name>NumPushdownSafeOIDs</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>oid_comparator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>PushdownOIDsSorted</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>bsearch</name><argument_list>(<argument><expr><operator>&amp;</operator><name>func_id</name></expr></argument>,
				   <argument><expr><name>PushdownSafeFunctionOIDs</name></expr></argument>,
				   <argument><expr><name>NumPushdownSafeOIDs</name></expr></argument>,
				   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>,
				   <argument><expr><name>oid_comparator</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check for mutable functions in an expression.
 *
 * This code is based on the corresponding PostgreSQL function, but with extra
 * handling to whitelist some bucketing functions that we know are safe to
 * push down despite mutability.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>contain_mutable_functions_checker</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>func_id</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FuncInfo</name> <modifier>*</modifier></type><name>finfo</name> <init>= <expr><call><name>ts_func_cache_get_bucketing_func</name><argument_list>(<argument><expr><name>func_id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* We treat all bucketing functions as shippable, even date_trunc(text,
	 * timestamptz). We do this special case for bucketing functions until we
	 * can figure out a more consistent way to deal with functions taking,
	 * e.g., timestamptz parameters since we ensure that all connections to
	 * other nodes have the access node's timezone setting. */</comment>
	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>finfo</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>func_volatile</name><argument_list>(<argument><expr><name>func_id</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PROVOLATILE_IMMUTABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Certain functions are mutable but are known to safe to push down to the data node. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>function_is_whitelisted</name><argument_list>(<argument><expr><name>func_id</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
	<comment type="block">/* Special debug functions that we want to ship to data nodes. */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>debug_func_prefix</name><index>[]</index></name> <init>= <expr><literal type="string">"ts_debug_shippable_"</literal></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><call><name>get_func_name</name><argument_list>(<argument><expr><name>func_id</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>debug_func_prefix</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>debug_func_prefix</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Expression walker based on the corresponding PostgreSQL function. We're
 * using a custom checker function, so need a modifed version of this walker.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>contain_mutable_functions_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<comment type="block">/* Check for mutable functions in node itself */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>check_functions_in_node</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>contain_mutable_functions_checker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SQLValueFunction</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* all variants of SQLValueFunction are stable */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NextValueExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* NextValueExpr is volatile */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * It should be safe to treat MinMaxExpr as immutable, because it will
	 * depend on a non-cross-type btree comparison function, and those should
	 * always be immutable.  Treating XmlExpr as immutable is more dubious,
	 * and treating CoerceToDomain as immutable is outright dangerous.  But we
	 * have done so historically, and changing this would probably cause more
	 * problems than it would fix.  In practice, if you have a non-immutable
	 * domain constraint you are in for pain anyhow.
	 */</comment>

	<comment type="block">/* Recurse to check arguments */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Recurse into subselects */</comment>
		<return>return <expr><call><name>query_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>contain_mutable_functions_walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>contain_mutable_functions_walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>foreign_expr_contains_mutable_functions</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>contain_mutable_functions_walker</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Returns true if given expr is safe to evaluate on the data node.
 */</comment>
<function><type><name>bool</name></type>
<name>ts_is_foreign_expr</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>baserel</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>foreign_glob_cxt</name></type> <name>glob_cxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TsFdwRelInfo</name> <modifier>*</modifier></type><name>fpinfo</name> <init>= <expr><call><name>fdw_relinfo_get</name><argument_list>(<argument><expr><name>baserel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Check that the expression consists of nodes that are safe to execute
	 * remotely.
	 */</comment>
	<expr_stmt><expr><name><name>glob_cxt</name><operator>.</operator><name>root</name></name> <operator>=</operator> <name>root</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>glob_cxt</name><operator>.</operator><name>foreignrel</name></name> <operator>=</operator> <name>baserel</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * For an upper relation, use relids from its underneath scan relation,
	 * because the upperrel's own relids currently aren't set to anything
	 * meaningful by the core code.  For other relation, use their own relids.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IS_UPPER_REL</name><argument_list>(<argument><expr><name>baserel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>glob_cxt</name><operator>.</operator><name>relids</name></name> <operator>=</operator> <name><name>fpinfo</name><operator>-&gt;</operator><name>outerrel</name><operator>-&gt;</operator><name>relids</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>glob_cxt</name><operator>.</operator><name>relids</name></name> <operator>=</operator> <name><name>baserel</name><operator>-&gt;</operator><name>relids</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>foreign_expr_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>glob_cxt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * It is not supported to execute time_bucket_gapfill on data node.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>gapfill_in_expression</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * An expression which includes any mutable functions can't be sent over
	 * because its result is not stable.  For example, sending now() remote
	 * side could cause confusion from clock offsets.  Future versions might
	 * be able to make this choice with more granularity.  (We check this last
	 * because it requires a lot of expensive catalog lookups.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>foreign_expr_contains_mutable_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* OK to evaluate on the data node */</comment>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check if expression is safe to execute remotely, and return true if so.
 *
 * We must check that the expression contains only node types we can deparse,
 * that all types/functions/operators are safe to send (they are "shippable"),
 * and that we aren't sending Var references to system columns.
 *
 * We do not care about collations because we assume that data nodes have
 * identical configuration as the access node.
 *
 * Note function mutability is not currently considered here.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>foreign_expr_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>foreign_glob_cxt</name> <modifier>*</modifier></type><name>glob_cxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>check_type</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TsFdwRelInfo</name> <modifier>*</modifier></type><name>fpinfo</name></decl>;</decl_stmt>

	<comment type="block">/* Need do nothing for empty subexpressions */</comment>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>fpinfo</name> <operator>=</operator> <call><name>fdw_relinfo_get</name><argument_list>(<argument><expr><name><name>glob_cxt</name><operator>-&gt;</operator><name>foreignrel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_Var</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>Var</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name><name>glob_cxt</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Var belongs to foreign table */</comment>

				<comment type="block">/*
				 * System columns other than ctid and oid should not be
				 * sent to the remote, since we don't make any effort to
				 * ensure that local and remote values match (tableoid, in
				 * particular, almost certainly doesn't match).
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>!=</operator> <name>SelfItemPointerAttributeNumber</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
		<break>break;</break>
		<case>case <expr><name>T_Const</name></expr>:</case>
			<comment type="block">/* Consts are OK to execute remotely */</comment>
			<break>break;</break>
		<case>case <expr><name>T_Param</name></expr>:</case>
			<comment type="block">/* Params are also OK to execute remotely */</comment>
			<break>break;</break>
		<case>case <expr><name>T_SubscriptingRef</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SubscriptingRef</name> <modifier>*</modifier></type><name>ar</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>SubscriptingRef</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* Assignment should not be in restrictions. */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>ar</name><operator>-&gt;</operator><name>refassgnexpr</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Recurse to remaining subexpressions.  Since the array
			 * subscripts must yield (noncollatable) integers, they won't
			 * affect the inner_cxt state.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>foreign_expr_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>ar</name><operator>-&gt;</operator><name>refupperindexpr</name></name></expr></argument>, <argument><expr><name>glob_cxt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>foreign_expr_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>ar</name><operator>-&gt;</operator><name>reflowerindexpr</name></name></expr></argument>, <argument><expr><name>glob_cxt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>foreign_expr_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>ar</name><operator>-&gt;</operator><name>refexpr</name></name></expr></argument>, <argument><expr><name>glob_cxt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block>
		<break>break;</break>
		<case>case <expr><name>T_FuncExpr</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>fe</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>FuncExpr</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * If function used by the expression is not shippable, it
			 * can't be sent to remote because it might have incompatible
			 * semantics on remote side.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_shippable</name><argument_list>(<argument><expr><name><name>fe</name><operator>-&gt;</operator><name>funcid</name></name></expr></argument>, <argument><expr><name>ProcedureRelationId</name></expr></argument>, <argument><expr><name>fpinfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Recurse to input subexpressions.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>foreign_expr_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>fe</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>glob_cxt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block>
		<break>break;</break>
		<case>case <expr><name>T_OpExpr</name></expr>:</case>
		<case>case <expr><name>T_DistinctExpr</name></expr>:</case> <comment type="block">/* struct-equivalent to OpExpr */</comment>
		<block>{<block_content>
			<decl_stmt><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>oe</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Similarly, only shippable operators can be sent to remote.
			 * (If the operator is shippable, we assume its underlying
			 * function is too.)
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_shippable</name><argument_list>(<argument><expr><name><name>oe</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>, <argument><expr><name>OperatorRelationId</name></expr></argument>, <argument><expr><name>fpinfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Recurse to input subexpressions.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>foreign_expr_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>oe</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>glob_cxt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block>
		<break>break;</break>
		<case>case <expr><name>T_ScalarArrayOpExpr</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ScalarArrayOpExpr</name> <modifier>*</modifier></type><name>oe</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>ScalarArrayOpExpr</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Again, only shippable operators can be sent to remote.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_shippable</name><argument_list>(<argument><expr><name><name>oe</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>, <argument><expr><name>OperatorRelationId</name></expr></argument>, <argument><expr><name>fpinfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Recurse to input subexpressions.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>foreign_expr_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>oe</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>glob_cxt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block>
		<break>break;</break>
		<case>case <expr><name>T_RelabelType</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RelabelType</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>RelabelType</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Recurse to input subexpression.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>foreign_expr_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>r</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>glob_cxt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block>
		<break>break;</break>
		<case>case <expr><name>T_BoolExpr</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>BoolExpr</name> <modifier>*</modifier></type><name>b</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>BoolExpr</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Recurse to input subexpressions.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>foreign_expr_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>b</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>glob_cxt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block>
		<break>break;</break>
		<case>case <expr><name>T_NullTest</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>NullTest</name> <modifier>*</modifier></type><name>nt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>NullTest</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Recurse to input subexpressions.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>foreign_expr_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>nt</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>glob_cxt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block>
		<break>break;</break>
		<case>case <expr><name>T_ArrayExpr</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ArrayExpr</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>ArrayExpr</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Recurse to input subexpressions.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>foreign_expr_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>a</name><operator>-&gt;</operator><name>elements</name></name></expr></argument>, <argument><expr><name>glob_cxt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block>
		<break>break;</break>
		<case>case <expr><name>T_List</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>l</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Recurse to component subexpressions.
			 */</comment>
			<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>l</argument>)</argument_list></macro>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>foreign_expr_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>glob_cxt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<comment type="block">/* Don't apply exprType() to the list. */</comment>
			<expr_stmt><expr><name>check_type</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block>
		<break>break;</break>
		<case>case <expr><name>T_Aggref</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>agg</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>Aggref</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

			<comment type="block">/* Not safe to pushdown when not in grouping context */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_UPPER_REL</name><argument_list>(<argument><expr><name><name>glob_cxt</name><operator>-&gt;</operator><name>foreignrel</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

			<comment type="block">/* As usual, it must be shippable. */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_shippable</name><argument_list>(<argument><expr><name><name>agg</name><operator>-&gt;</operator><name>aggfnoid</name></name></expr></argument>, <argument><expr><name>ProcedureRelationId</name></expr></argument>, <argument><expr><name>fpinfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Recurse to input args. aggdirectargs, aggorder and
			 * aggdistinct are all present in args, so no need to check
			 * their shippability explicitly.
			 */</comment>
			<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>agg-&gt;args</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<comment type="block">/* If TargetEntry, extract the expression from it */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>TargetEntry</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>TargetEntry</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>foreign_expr_walker</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>glob_cxt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>

			<comment type="block">/*
			 * For aggorder elements, check whether the sort operator, if
			 * specified, is shippable or not.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>agg</name><operator>-&gt;</operator><name>aggorder</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

				<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>agg-&gt;aggorder</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>srt</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>SortGroupClause</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Oid</name></type> <name>sortcoltype</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>get_sortgroupref_tle</name><argument_list>(<argument><expr><name><name>srt</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name></expr></argument>, <argument><expr><name><name>agg</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>sortcoltype</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>typentry</name> <operator>=</operator> <call><name>lookup_type_cache</name><argument_list>(<argument><expr><name>sortcoltype</name></expr></argument>, <argument><expr><name>TYPECACHE_LT_OPR</name> <operator>|</operator> <name>TYPECACHE_GT_OPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* Check shippability of non-default sort operator. */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>srt</name><operator>-&gt;</operator><name>sortop</name></name> <operator>!=</operator> <name><name>typentry</name><operator>-&gt;</operator><name>lt_opr</name></name> <operator>&amp;&amp;</operator> <name><name>srt</name><operator>-&gt;</operator><name>sortop</name></name> <operator>!=</operator> <name><name>typentry</name><operator>-&gt;</operator><name>gt_opr</name></name> <operator>&amp;&amp;</operator>
						<operator>!</operator><call><name>is_shippable</name><argument_list>(<argument><expr><name><name>srt</name><operator>-&gt;</operator><name>sortop</name></name></expr></argument>, <argument><expr><name>OperatorRelationId</name></expr></argument>, <argument><expr><name>fpinfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Check aggregate filter */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>foreign_expr_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>agg</name><operator>-&gt;</operator><name>aggfilter</name></name></expr></argument>, <argument><expr><name>glob_cxt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block>
		<break>break;</break>
		<default>default:</default>

			<comment type="block">/*
			 * If it's anything else, assume it's unsafe.  This list can be
			 * expanded later, but don't forget to add deparse support below.
			 */</comment>
			<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * If result type of given expression is not shippable, it can't be sent
	 * to remote because it might have incompatible semantics on remote side.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>check_type</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>is_shippable</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TypeRelationId</name></expr></argument>, <argument><expr><name>fpinfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* It looks OK */</comment>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Convert type OID + typmod info into a type name we can ship to the data
 * node.  Someplace else had better have verified that this type name is
 * expected to be known on the remote end.
 *
 * This is almost just format_type_with_typemod(), except that if left to its
 * own devices, that function will make schema-qualification decisions based
 * on the local search_path, which is wrong.  We must schema-qualify all
 * type names that are not in pg_catalog.  We assume here that built-in types
 * are all in pg_catalog and need not be qualified; otherwise, qualify.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>deparse_type_name</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>type_oid</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>typemod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bits16</name></type> <name>flags</name> <init>= <expr><name>FORMAT_TYPE_TYPEMOD_GIVEN</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_builtin</name><argument_list>(<argument><expr><name>type_oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>FORMAT_TYPE_FORCE_QUALIFY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><call><name>format_type_extended</name><argument_list>(<argument><expr><name>type_oid</name></expr></argument>, <argument><expr><name>typemod</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Build the targetlist for given relation to be deparsed as SELECT clause.
 *
 * The output targetlist contains the columns that need to be fetched from the
 * data node for the given relation.  If foreignrel is an upper relation,
 * then the output targetlist can also contain expressions to be evaluated on
 * data node.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>build_tlist_to_deparse</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>foreignrel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TsFdwRelInfo</name> <modifier>*</modifier></type><name>fpinfo</name> <init>= <expr><call><name>fdw_relinfo_get</name><argument_list>(<argument><expr><name>foreignrel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * For an upper relation, we have already built the target list while
	 * checking shippability, so just return that.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IS_UPPER_REL</name><argument_list>(<argument><expr><name>foreignrel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>fpinfo</name><operator>-&gt;</operator><name>grouped_tlist</name></name></expr>;</return></block_content></block></if></if_stmt>
	<comment type="block">/*
	 * We require columns specified in foreignrel-&gt;reltarget-&gt;exprs and those
	 * required for evaluating the local conditions.
	 */</comment>

	<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>add_to_flat_tlist</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>,
							  <argument><expr><call><name>pull_var_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>foreignrel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>,
											  <argument><expr><name>PVC_RECURSE_PLACEHOLDERS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>fpinfo-&gt;local_conds</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RestrictInfo</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>tlist</name> <operator>=</operator>
			<call><name>add_to_flat_tlist</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>,
							  <argument><expr><call><name>pull_var_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>, <argument><expr><name>PVC_RECURSE_PLACEHOLDERS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>tlist</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Deparse SELECT statement for given relation into buf.
 *
 * tlist contains the list of desired columns to be fetched from data node.
 * For a base relation fpinfo-&gt;attrs_used is used to construct SELECT clause,
 * hence the tlist is ignored for a base relation.
 *
 * remote_where is the list of conditions to be deparsed into the WHERE clause,
 * and remote_having into the HAVING clause (this is useful for upper relations).
 *
 * If params_list is not NULL, it receives a list of Params and other-relation
 * Vars used in the clauses; these values must be transmitted to the data
 * node as parameter values.
 *
 * If params_list is NULL, we're generating the query for EXPLAIN purposes,
 * so Params and other-relation Vars should be replaced by dummy values.
 *
 * pathkeys is the list of pathkeys to order the result by.
 *
 * is_subquery is the flag to indicate whether to deparse the specified
 * relation as a subquery.
 *
 * List of columns selected is returned in retrieved_attrs.
 */</comment>
<function><type><name>void</name></type>
<name>deparseSelectStmtForRel</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>remote_where</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>remote_having</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_subquery</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>retrieved_attrs</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>params_list</name></decl></parameter>, <parameter><decl><type><name>DataNodeChunkAssignment</name> <modifier>*</modifier></type><name>sca</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>deparse_expr_cxt</name></type> <name>context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TsFdwRelInfo</name> <modifier>*</modifier></type><name>fpinfo</name> <init>= <expr><call><name>fdw_relinfo_get</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We handle relations for foreign tables, joins between those and upper
	 * relations.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IS_JOIN_REL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IS_SIMPLE_REL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IS_UPPER_REL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Fill portions of context common to upper, join and base relation */</comment>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>buf</name></name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>root</name></name> <operator>=</operator> <name>root</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>foreignrel</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>scanrel</name></name> <operator>=</operator> <ternary><condition><expr><call><name>IS_UPPER_REL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name><name>fpinfo</name><operator>-&gt;</operator><name>outerrel</name></name></expr> </then><else>: <expr><name>rel</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>params_list</name></name> <operator>=</operator> <name>params_list</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>sca</name></name> <operator>=</operator> <name>sca</name></expr>;</expr_stmt>

	<comment type="block">/* Construct SELECT clause */</comment>
	<expr_stmt><expr><call><name>deparseSelectSql</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>is_subquery</name></expr></argument>, <argument><expr><name>retrieved_attrs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>, <argument><expr><name>pathkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Construct FROM and WHERE clauses */</comment>
	<expr_stmt><expr><call><name>deparseFromExpr</name><argument_list>(<argument><expr><name>remote_where</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IS_UPPER_REL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Append GROUP BY clause */</comment>
		<expr_stmt><expr><call><name>appendGroupByClause</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Append HAVING clause */</comment>
		<if_stmt><if>if <condition>(<expr><name>remote_having</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" HAVING "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendConditions</name><argument_list>(<argument><expr><name>remote_having</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Add ORDER BY clause if we found any useful pathkeys */</comment>
	<if_stmt><if>if <condition>(<expr><name>pathkeys</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendOrderByClause</name><argument_list>(<argument><expr><name>pathkeys</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Add LIMIT if it is set and can be pushed */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>.</operator><name>root</name><operator>-&gt;</operator><name>limit_tuples</name></name> <operator>&gt;</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendLimit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>context</name></expr></argument>, <argument><expr><name>pathkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Add any necessary FOR UPDATE/SHARE. */</comment>
	<expr_stmt><expr><call><name>deparseLockingClause</name><argument_list>(<argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Construct "SELECT DISTINCT target_list" or "SELECT DISTINCT ON (col1, col..)
 * target_list" statement to push down the DISTINCT clause to the remote side.
 *
 * We only allow references to basic "Vars" or constants in the DISTINCT exprs
 *
 * So, "SELECT DISTINCT col1" is fine but "SELECT DISTINCT 2*col1" is not.
 *
 * "SELECT DISTINCT col1, 'const1', NULL, col2" which is a mix of column
 * references and constants is also supported. Everything else is not supported.
 *
 * It should be noted that "SELECT DISTINCT col1, col2" will return the same
 * set of values as "SELECT DISTINCT col2, col1". So nothing additional needs
 * to be done here as the upper projection will take care of any ordering
 * between the attributes.
 *
 * We also explicitly deparse the distinctClause entries only for the
 * "DISTINCT ON (col..)" case. For regular DISTINCT the targetlist
 * deparsing which happens later is good enough
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>deparseDistinctClause</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>root</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>l</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>dc_l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>first</name> <init>= <expr><name>true</name></expr></init></decl>, <decl><type ref="prev"/><name>varno_assigned</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type> <name>varno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* mostly to quell compiler warning, handled via varno_assigned */</comment>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>dc_rte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>distinctClause</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>l</argument>, <argument>query-&gt;distinctClause</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sgc</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>SortGroupClause</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>get_sortgroupclause_tle</name><argument_list>(<argument><expr><name>sgc</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * We only send basic attributes to the remote side. So we can
		 * pushdown DISTINCT only if the tle is a simple one
		 * referring to the "Var" directly. Also all varno entries
		 * need to point to the same relid.
		 *
		 * Also handle "DISTINCT col1, CONST1, NULL" types cases
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>Var</name></expr></argument>, <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>first</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>varno</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>varno_assigned</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>varno</name> <operator>!=</operator> <operator>(</operator><name>Index</name><operator>)</operator> <name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<comment type="block">/* We only allow constants apart from vars, but we ignore them */</comment>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>hasDistinctOn</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Pushing down DISTINCT ON is more complex than plain DISTINCT.
		 * The DISTINCT ON columns must be a prefix of the ORDER BY columns.
		 * Without this, the DISTINCT ON would return an unpredictable row
		 * each time. There is a diagnostic for the case where the ORDER BY
		 * clause doesn't match the DISTINCT ON clause, so in this case we
		 * would get an error on the data node. There is no diagnostic for
		 * the case where the ORDER BY is absent, so in this case we would
		 * get a wrong result.
		 * The remote ORDER BY clause is created from the pathkeys of the
		 * corresponding relation. If the DISTINCT ON columns are not a prefix
		 * of these pathkeys, we cannot push it down.
		 */</comment>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>distinct_cell</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pathkey_cell</name></decl>;</decl_stmt>
		<macro><name>forboth</name> <argument_list>(<argument>distinct_cell</argument>, <argument>query-&gt;distinctClause</argument>, <argument>pathkey_cell</argument>, <argument>pathkeys</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sgc</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>SortGroupClause</name></expr></argument>, <argument><expr><name>distinct_cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>get_sortgroupclause_tle</name><argument_list>(<argument><expr><name>sgc</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>PathKey</name> <modifier>*</modifier></type><name>pk</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>PathKey</name></expr></argument>, <argument><expr><name>pathkey_cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><name><name>pk</name><operator>-&gt;</operator><name>pk_eclass</name></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * The find_ec_member_matching_expr() has many checks that don't seem
			 * to be relevant here. Enumerate the pathkey EquivalenceMembers by
			 * hand and find the one that matches the DISTINCT ON expression.
			 */</comment>
			<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>ec_member_cell</name></decl>;</decl_stmt>
			<macro><name>foreach</name> <argument_list>(<argument>ec_member_cell</argument>, <argument>ec-&gt;ec_members</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>ec_member</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>EquivalenceMember</name></expr></argument>, <argument><expr><name>ec_member_cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name><name>ec_member</name><operator>-&gt;</operator><name>em_expr</name></name></expr></argument>, <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
			</block_content>}</block>

			<if_stmt><if>if <condition>(<expr><name>ec_member_cell</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Went through all the equivalence class members and didn't
				 * find a match.
				 */</comment>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><name>pathkey_cell</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>distinct_cell</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Ran out of pathkeys before we matched all the DISTINCT ON columns. */</comment>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* If there are no varno entries in the distinctClause, we are done */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>varno_assigned</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If all distinctClause entries point to our rte-&gt;relid then it's
	 * safe to push down to the datanode
	 *
	 * The only other case we allow is if the dc_rte-&gt;relid has the
	 * rte-&gt;relid as a child
	 */</comment>
	<expr_stmt><expr><name>dc_rte</name> <operator>=</operator> <call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name>varno</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>foreignrel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dc_rte</name><operator>-&gt;</operator><name>relid</name></name> <operator>!=</operator> <name><name>rte</name><operator>-&gt;</operator><name>relid</name></name> <operator>&amp;&amp;</operator> <call><name>ts_inheritance_parent_relid</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>dc_rte</name><operator>-&gt;</operator><name>relid</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Ok to pushdown!
	 *
	 * The distinctClause entries will be referring to the
	 * varno pulled above, so adjust the scanrel temporarily
	 * for the deparsing of the distint clauses
	 *
	 * Note that we deparse the targetlist below only for the
	 * "DISTINCT ON" case. For DISTINCT, the regular targetlist
	 * deparsing later works
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>hasDistinctOn</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sep</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>scanrel</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>scanrel</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>varno</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>varno</name> <operator>&lt;</operator> <operator>(</operator><name>Index</name><operator>)</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rel_array_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>scanrel</name></name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rel_array</name><index>[<expr><name>varno</name></expr>]</index></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"DISTINCT ON ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<macro><name>foreach</name> <argument_list>(<argument>dc_l</argument>, <argument>query-&gt;distinctClause</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>srt</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>SortGroupClause</name></expr></argument>, <argument><expr><name>dc_l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>deparseSortGroupClause</name><argument_list>(<argument><expr><name><name>srt</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">", "</literal></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">") "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* reset scanrel to the earlier value now */</comment>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>scanrel</name></name> <operator>=</operator> <name>scanrel</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"DISTINCT "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Construct a simple SELECT statement that retrieves desired columns
 * of the specified foreign table, and append it to "buf".  The output
 * contains just "SELECT ... ".
 *
 * We also create an integer List of the columns being retrieved, which is
 * returned to *retrieved_attrs, unless we deparse the specified relation
 * as a subquery.
 *
 * tlist is the list of desired columns.  is_subquery is the flag to
 * indicate whether to deparse the specified relation as a subquery.
 * Read prologue of deparseSelectStmtForRel() for details.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>deparseSelectSql</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_subquery</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>retrieved_attrs</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
				 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>foreignrel</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>foreignrel</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>root</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TsFdwRelInfo</name> <modifier>*</modifier></type><name>fpinfo</name> <init>= <expr><call><name>fdw_relinfo_get</name><argument_list>(<argument><expr><name>foreignrel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Construct SELECT list
	 */</comment>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"SELECT "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_subquery</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * For a relation that is deparsed as a subquery, emit expressions
		 * specified in the relation's reltarget.  Note that since this is for
		 * the subquery, no need to care about *retrieved_attrs.
		 */</comment>
		<expr_stmt><expr><call><name>deparseSubqueryTargetList</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>tlist</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * For a join, hypertable-data node or upper relation the input tlist gives the list of
		 * columns required to be fetched from the data node.
		 */</comment>
		<expr_stmt><expr><call><name>deparseExplicitTargetList</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>retrieved_attrs</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * For a base relation fpinfo-&gt;attrs_used gives the list of columns
		 * required to be fetched from the data node.
		 */</comment>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name><name>foreignrel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Core code already has some lock on each rel being planned, so we
		 * can use NoLock here.
		 */</comment>
		<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>distinctClause</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>deparseDistinctClause</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>pathkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>deparseTargetList</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,
						  <argument><expr><name>rte</name></expr></argument>,
						  <argument><expr><name><name>foreignrel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,
						  <argument><expr><name>rel</name></expr></argument>,
						  <argument><expr><name>false</name></expr></argument>,
						  <argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>attrs_used</name></name></expr></argument>,
						  <argument><expr><name>false</name></expr></argument>,
						  <argument><expr><name>retrieved_attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Construct a FROM clause and, if needed, a WHERE clause, and append those to
 * "buf".
 *
 * quals is the list of clauses to be included in the WHERE clause.
 * (These may or may not include RestrictInfo decoration.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>deparseFromExpr</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>quals</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>scanrel</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>scanrel</name></name></expr></init></decl>;</decl_stmt>
	<comment type="block">/* Use alias if scan is on multiple rels, unless a per-data node scan */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>use_alias</name> <init>= <expr><call><name>bms_num_members</name><argument_list>(<argument><expr><name><name>scanrel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>context</name><operator>-&gt;</operator><name>sca</name></name> <operator>==</operator> <name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* For upper relations, scanrel must be either a joinrel or a baserel */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IS_UPPER_REL</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>foreignrel</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IS_JOIN_REL</name><argument_list>(<argument><expr><name>scanrel</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IS_SIMPLE_REL</name><argument_list>(<argument><expr><name>scanrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Construct FROM clause */</comment>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" FROM "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>deparseFromExprForRel</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,
						  <argument><expr><name><name>context</name><operator>-&gt;</operator><name>root</name></name></expr></argument>,
						  <argument><expr><name>scanrel</name></expr></argument>,
						  <argument><expr><name>use_alias</name></expr></argument>,
						  <argument><expr><operator>(</operator><name>Index</name><operator>)</operator> <literal type="number">0</literal></expr></argument>,
						  <argument><expr><name>NULL</name></expr></argument>,
						  <argument><expr><name><name>context</name><operator>-&gt;</operator><name>params_list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Construct WHERE clause */</comment>
	<if_stmt><if>if <condition>(<expr><name>quals</name> <operator>!=</operator> <name>NIL</name> <operator>||</operator> <name><name>context</name><operator>-&gt;</operator><name>sca</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" WHERE "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>sca</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>append_chunk_exclusion_condition</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>use_alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>quals</name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendConditions</name><argument_list>(<argument><expr><name>quals</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><operator>(</operator><name><name>context</name><operator>-&gt;</operator><name>sca</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Emit a target list that retrieves the columns specified in attrs_used.
 * This is used for both SELECT and RETURNING targetlists; the is_returning
 * parameter is true only for a RETURNING targetlist.
 *
 * The tlist text is appended to buf, and we also create an integer List
 * of the columns being retrieved, which is returned to *retrieved_attrs.
 *
 * If qualify_col is true, add relation alias before the column name.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>deparseTargetList</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>rtindex</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name></type> <name>is_returning</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>attrs_used</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>qualify_col</name></decl></parameter>,
				  <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>retrieved_attrs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupdesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>have_wholerow</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>first</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>retrieved_attrs</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<comment type="block">/* If there's a whole-row reference, we'll need all the columns. */</comment>
	<expr_stmt><expr><name>have_wholerow</name> <operator>=</operator> <call><name>bms_is_member</name><argument_list>(<argument><expr><literal type="number">0</literal> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>, <argument><expr><name>attrs_used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>first</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Ignore dropped attributes. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>have_wholerow</name> <operator>||</operator> <call><name>bms_is_member</name><argument_list>(<argument><expr><name>i</name> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>, <argument><expr><name>attrs_used</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name>is_returning</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" RETURNING "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>deparseColumnRef</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>rtindex</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>qualify_col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><operator>*</operator><name>retrieved_attrs</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><operator>*</operator><name>retrieved_attrs</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Add ctid and oid if needed.  We currently don't support retrieving any
	 * other system columns.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>SelfItemPointerAttributeNumber</name> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>,
					  <argument><expr><name>attrs_used</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>is_returning</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" RETURNING "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>qualify_col</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ADD_REL_QUALIFIER</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>rtindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ctid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><operator>*</operator><name>retrieved_attrs</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><operator>*</operator><name>retrieved_attrs</name></expr></argument>, <argument><expr><name>SelfItemPointerAttributeNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Don't generate bad syntax if no undropped columns */</comment>
	<if_stmt><if>if <condition>(<expr><name>first</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_returning</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Deparse the appropriate locking clause (FOR UPDATE or FOR SHARE) for a
 * given relation (context-&gt;scanrel).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>deparseLockingClause</name><parameter_list>(<parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>root</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>scanrel</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TsFdwRelInfo</name> <modifier>*</modifier></type><name>fpinfo</name> <init>= <expr><call><name>fdw_relinfo_get</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>relid</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>relid</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Ignore relation if it appears in a lower subquery.  Locking clause
		 * for such a relation is included in the subquery if necessary.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>lower_subquery_rels</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Add FOR UPDATE/SHARE if appropriate.  We apply locking during the
		 * initial row fetch, rather than later on as is done for local
		 * tables. The extra roundtrips involved in trying to duplicate the
		 * local semantics exactly don't seem worthwhile (see also comments
		 * for RowMarkType).
		 *
		 * Note: because we actually run the query as a cursor, this assumes
		 * that DECLARE CURSOR ... FOR UPDATE is supported, which it isn't
		 * before 8.3.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>relid</name> <operator>==</operator> <name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>resultRelation</name></name> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>||</operator> <name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_DELETE</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Relation is UPDATE/DELETE target, so use FOR UPDATE */</comment>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" FOR UPDATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Add the relation alias if we are here for a join relation */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>IS_JOIN_REL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" OF %s%d"</literal></expr></argument>, <argument><expr><name>REL_ALIAS_PREFIX</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>PlanRowMark</name> <modifier>*</modifier></type><name>rc</name> <init>= <expr><call><name>get_plan_rowmark</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>rowMarks</name></name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>rc</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Relation is specified as a FOR UPDATE/SHARE target, so
				 * handle that.  (But we could also see LCS_NONE, meaning this
				 * isn't a target relation after all.)
				 *
				 * For now, just ignore any [NO] KEY specification, since (a)
				 * it's not clear what that means for a remote table that we
				 * don't have complete information about, and (b) it wouldn't
				 * work anyway on older data nodes.  Likewise, we don't
				 * worry about NOWAIT.
				 */</comment>
				<switch>switch <condition>(<expr><name><name>rc</name><operator>-&gt;</operator><name>strength</name></name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>LCS_NONE</name></expr>:</case>
						<comment type="block">/* No locking needed */</comment>
						<break>break;</break>
					<case>case <expr><name>LCS_FORKEYSHARE</name></expr>:</case>
					<case>case <expr><name>LCS_FORSHARE</name></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" FOR SHARE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>LCS_FORNOKEYUPDATE</name></expr>:</case>
					<case>case <expr><name>LCS_FORUPDATE</name></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" FOR UPDATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
				</block_content>}</block></switch>

				<comment type="block">/* Add the relation alias if we are here for a join relation */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>bms_num_members</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>rc</name><operator>-&gt;</operator><name>strength</name></name> <operator>!=</operator> <name>LCS_NONE</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" OF %s%d"</literal></expr></argument>, <argument><expr><name>REL_ALIAS_PREFIX</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>append_chunk_exclusion_condition</name><parameter_list>(<parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>use_alias</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DataNodeChunkAssignment</name> <modifier>*</modifier></type><name>sca</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>sca</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>scanrel</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>scanrel</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>INTERNAL_SCHEMA_NAME</name> <literal type="string">"."</literal> <name>CHUNK_EXCL_FUNC_NAME</name> <literal type="string">"("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>use_alias</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s%d, "</literal></expr></argument>, <argument><expr><name>REL_ALIAS_PREFIX</name></expr></argument>, <argument><expr><name><name>scanrel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* use a qualfied relation name */</comment>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name><name>scanrel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>root</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>deparseRelation</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* We explicitly append expand operator `.*` to prevent
		 * confusing parser when using qualified name (otherwise parser believes that schema name is
		 * relation name) */</comment>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">".*, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ARRAY["</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>sca-&gt;remote_chunk_ids</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>remote_chunk_id</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>remote_chunk_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"])"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* end array and function call */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Deparse conditions from the provided list and append them to buf.
 *
 * The conditions in the list are assumed to be ANDed. This function is used to
 * deparse WHERE clauses, JOIN .. ON clauses and HAVING clauses.
 *
 * Depending on the caller, the list elements might be either RestrictInfos
 * or bare clauses.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>appendConditions</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>exprs</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_first</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>nestlevel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Make sure any constants in the exprs are printed portably */</comment>
	<expr_stmt><expr><name>nestlevel</name> <operator>=</operator> <call><name>set_transmission_modes</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>exprs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Extract clause from RestrictInfo, if required */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>RestrictInfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>clause</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Connect expressions with "AND" and parenthesize each condition. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_first</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" AND "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>deparseExpr</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>is_first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>reset_transmission_modes</name><argument_list>(<argument><expr><name>nestlevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Deparse given targetlist and append it to context-&gt;buf.
 *
 * tlist is list of TargetEntry's which in turn contain Var nodes.
 *
 * retrieved_attrs is the list of continuously increasing integers starting
 * from 1. It has same number of entries as tlist.
 *
 * This is used for both SELECT and RETURNING targetlists; the is_returning
 * parameter is true only for a RETURNING targetlist.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>deparseExplicitTargetList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_returning</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>retrieved_attrs</name></decl></parameter>,
						  <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>retrieved_attrs</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>tlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>TargetEntry</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>is_returning</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" RETURNING "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>deparseExpr</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><operator>*</operator><name>retrieved_attrs</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><operator>*</operator><name>retrieved_attrs</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_returning</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Emit expressions specified in the given relation's reltarget.
 *
 * This is used for deparsing the given relation as a subquery.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>deparseSubqueryTargetList</name><parameter_list>(<parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>foreignrel</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>foreignrel</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>first</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* Should only be called in these cases. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IS_SIMPLE_REL</name><argument_list>(<argument><expr><name>foreignrel</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IS_JOIN_REL</name><argument_list>(<argument><expr><name>foreignrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>first</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>foreignrel-&gt;reltarget-&gt;exprs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>deparseExpr</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Don't generate bad syntax if no expressions */</comment>
	<if_stmt><if>if <condition>(<expr><name>first</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Construct FROM clause for given relation
 *
 * The function constructs ... JOIN ... ON ... for join relation. For a base
 * relation it just returns schema-qualified tablename, with the appropriate
 * alias if so requested.
 *
 * 'ignore_rel' is either zero or the RT index of a target relation.  In the
 * latter case the function constructs FROM clause of UPDATE or USING clause
 * of DELETE; it deparses the join relation as if the relation never contained
 * the target relation, and creates a List of conditions to be deparsed into
 * the top-level WHERE clause, which is returned to *ignore_conds.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>deparseFromExprForRel</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>foreignrel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>use_alias</name></decl></parameter>,
					  <parameter><decl><type><name>Index</name></type> <name>ignore_rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>ignore_conds</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>params_list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IS_JOIN_REL</name><argument_list>(<argument><expr><name>foreignrel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"distributed JOINs are currently unsupported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name><name>foreignrel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Core code already has some lock on each rel being planned, so we
		 * can use NoLock here.
		 */</comment>
		<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>deparseRelation</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Add a unique alias to avoid any conflict in relation names due to
		 * pulled up subqueries in the query being built for a pushed down
		 * join.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>use_alias</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" %s%d"</literal></expr></argument>, <argument><expr><name>REL_ALIAS_PREFIX</name></expr></argument>, <argument><expr><name><name>foreignrel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * deparse remote INSERT statement
 *
 * The statement text is appended to buf, and we also create an integer List
 * of the columns being retrieved by RETURNING (if any), which is returned
 * to *retrieved_attrs.
 */</comment>
<function><type><name>void</name></type>
<name>deparse_insert_stmt</name><parameter_list>(<parameter><decl><type><name>DeparsedInsertStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>rtindex</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
					<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>target_attrs</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>do_nothing</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>returning_list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>first</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DeparsedInsertStmt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"INSERT INTO "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>deparseRelation</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>target</name></name> <operator>=</operator> <name><name>buf</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>num_target_attrs</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>target_attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>target_attrs</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>first</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>target_attrs</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>attnum</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>deparseColumnRef</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>rtindex</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">") VALUES "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>target_attrs</name></name> <operator>=</operator> <name><name>buf</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>do_nothing</name></name> <operator>=</operator> <name>do_nothing</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>deparseReturningList</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						 <argument><expr><name>rte</name></expr></argument>,
						 <argument><expr><name>rtindex</name></expr></argument>,
						 <argument><expr><name>rel</name></expr></argument>,
						 <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>trigdesc</name></name> <operator>&amp;&amp;</operator> <name><name>rel</name><operator>-&gt;</operator><name>trigdesc</name><operator>-&gt;</operator><name>trig_insert_after_row</name></name></expr></argument>,
						 <argument><expr><name>returning_list</name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>stmt</name><operator>-&gt;</operator><name>retrieved_attrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>retrieved_attrs</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>returning</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>returning</name></name> <operator>=</operator> <name><name>buf</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>append_values_params</name><parameter_list>(<parameter><decl><type><name>DeparsedInsertStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pindex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>stmt</name><operator>-&gt;</operator><name>num_target_attrs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"$%d"</literal></expr></argument>, <argument><expr><name>pindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pindex</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>pindex</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>deparsed_insert_stmt_get_sql_internal</name><parameter_list>(<parameter><decl><type><name>DeparsedInsertStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>num_rows</name></decl></parameter>,
									  <parameter><decl><type><name>bool</name></type> <name>abbrev</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>target</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>num_target_attrs</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>target_attrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>abbrev</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>append_values_params</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>num_rows</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", ..., "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>append_values_params</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>,
									 <argument><expr><name>buf</name></expr></argument>,
									 <argument><expr><operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>num_target_attrs</name></name> <operator>*</operator> <name>num_rows</name><operator>)</operator> <operator>-</operator> <name><name>stmt</name><operator>-&gt;</operator><name>num_target_attrs</name></name> <operator>+</operator>
										 <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>pindex</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int64</name></type> <name>i</name></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_rows</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name>pindex</name> <operator>=</operator> <call><name>append_values_params</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>pindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><name>num_rows</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" DEFAULT VALUES"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>do_nothing</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" ON CONFLICT DO NOTHING"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>returning</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>returning</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name><name>buf</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>deparsed_insert_stmt_get_sql</name><parameter_list>(<parameter><decl><type><name>DeparsedInsertStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>num_rows</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>deparsed_insert_stmt_get_sql_internal</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>num_rows</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>deparsed_insert_stmt_get_sql_explain</name><parameter_list>(<parameter><decl><type><name>DeparsedInsertStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>num_rows</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>deparsed_insert_stmt_get_sql_internal</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>num_rows</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<enum>enum <name>DeparsedInsertStmtIndex</name>
<block>{
	<decl><name>DeparsedInsertStmtTarget</name></decl>,
	<decl><name>DeparsedInsertStmtNumTargetAttrs</name></decl>,
	<decl><name>DeparsedInsertStmtTargetAttrs</name></decl>,
	<decl><name>DeparsedInsertStmtDoNothing</name></decl>,
	<decl><name>DeparsedInsertStmtRetrievedAttrs</name></decl>,
	<decl><name>DeparsedInsertStmtReturning</name></decl>,
}</block>;</enum>

<function><type><name>List</name> <modifier>*</modifier></type>
<name>deparsed_insert_stmt_to_list</name><parameter_list>(<parameter><decl><type><name>DeparsedInsertStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>stmt_list</name> <init>=
		<expr><call><name>list_make5</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>target</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
				   <argument><expr><call><name>makeInteger</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>num_target_attrs</name></name></expr></argument>)</argument_list></call></expr></argument>,
				   <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><ternary><condition><expr><name><name>stmt</name><operator>-&gt;</operator><name>target_attrs</name></name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>target_attrs</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>,
				   <argument><expr><call><name>makeInteger</name><argument_list>(<argument><expr><ternary><condition><expr><name><name>stmt</name><operator>-&gt;</operator><name>do_nothing</name></name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>,
				   <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>retrieved_attrs</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>returning</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>stmt_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>stmt_list</name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>returning</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>stmt_list</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>deparsed_insert_stmt_from_list</name><parameter_list>(<parameter><decl><type><name>DeparsedInsertStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>list_stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>target</name></name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name>list_stmt</name></expr></argument>, <argument><expr><name>DeparsedInsertStmtTarget</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>num_target_attrs</name></name> <operator>=</operator> <call><name>intVal</name><argument_list>(<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name>list_stmt</name></expr></argument>, <argument><expr><name>DeparsedInsertStmtNumTargetAttrs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>target_attrs</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>num_target_attrs</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then>
							 <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name>list_stmt</name></expr></argument>, <argument><expr><name>DeparsedInsertStmtTargetAttrs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>:
							 <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>do_nothing</name></name> <operator>=</operator> <call><name>intVal</name><argument_list>(<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name>list_stmt</name></expr></argument>, <argument><expr><name>DeparsedInsertStmtDoNothing</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>retrieved_attrs</name></name> <operator>=</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name>list_stmt</name></expr></argument>, <argument><expr><name>DeparsedInsertStmtRetrievedAttrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>list_stmt</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>DeparsedInsertStmtReturning</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>retrieved_attrs</name></name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>returning</name></name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name>list_stmt</name></expr></argument>, <argument><expr><name>DeparsedInsertStmtReturning</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>returning</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>deparseInsertSql</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>rtindex</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetAttrs</name></decl></parameter>,
				 <parameter><decl><type><name>int64</name></type> <name>num_rows</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>doNothing</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>returningList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>retrieved_attrs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DeparsedInsertStmt</name></type> <name>stmt</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>deparse_insert_stmt</name><argument_list>(<argument><expr><operator>&amp;</operator><name>stmt</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>rtindex</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>targetAttrs</name></expr></argument>, <argument><expr><name>doNothing</name></expr></argument>, <argument><expr><name>returningList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>deparsed_insert_stmt_get_sql_internal</name><argument_list>(<argument><expr><operator>&amp;</operator><name>stmt</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>num_rows</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>retrieved_attrs</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>retrieved_attrs</name> <operator>=</operator> <name><name>stmt</name><operator>.</operator><name>retrieved_attrs</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * deparse remote UPDATE statement
 *
 * The statement text is appended to buf, and we also create an integer List
 * of the columns being retrieved by RETURNING (if any), which is returned
 * to *retrieved_attrs.
 */</comment>
<function><type><name>void</name></type>
<name>deparseUpdateSql</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>rtindex</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetAttrs</name></decl></parameter>,
				 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>returningList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>retrieved_attrs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AttrNumber</name></type> <name>pindex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>first</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"UPDATE "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>deparseRelation</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" SET "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>pindex</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt> <comment type="block">/* ctid is always the first param */</comment>
	<expr_stmt><expr><name>first</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>targetAttrs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>attnum</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>deparseColumnRef</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>rtindex</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" = $%d"</literal></expr></argument>, <argument><expr><name>pindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pindex</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" WHERE ctid = $1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>deparseReturningList</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,
						 <argument><expr><name>rte</name></expr></argument>,
						 <argument><expr><name>rtindex</name></expr></argument>,
						 <argument><expr><name>rel</name></expr></argument>,
						 <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>trigdesc</name></name> <operator>&amp;&amp;</operator> <name><name>rel</name><operator>-&gt;</operator><name>trigdesc</name><operator>-&gt;</operator><name>trig_update_after_row</name></name></expr></argument>,
						 <argument><expr><name>returningList</name></expr></argument>,
						 <argument><expr><name>retrieved_attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * deparse remote DELETE statement
 *
 * The statement text is appended to buf, and we also create an integer List
 * of the columns being retrieved by RETURNING (if any), which is returned
 * to *retrieved_attrs.
 */</comment>
<function><type><name>void</name></type>
<name>deparseDeleteSql</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>rtindex</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
				 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>returningList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>retrieved_attrs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"DELETE FROM "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>deparseRelation</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" WHERE ctid = $1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>deparseReturningList</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,
						 <argument><expr><name>rte</name></expr></argument>,
						 <argument><expr><name>rtindex</name></expr></argument>,
						 <argument><expr><name>rel</name></expr></argument>,
						 <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>trigdesc</name></name> <operator>&amp;&amp;</operator> <name><name>rel</name><operator>-&gt;</operator><name>trigdesc</name><operator>-&gt;</operator><name>trig_delete_after_row</name></name></expr></argument>,
						 <argument><expr><name>returningList</name></expr></argument>,
						 <argument><expr><name>retrieved_attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Add a RETURNING clause, if needed, to an INSERT/UPDATE/DELETE.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>deparseReturningList</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>rtindex</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
					 <parameter><decl><type><name>bool</name></type> <name>trig_after_row</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>returningList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>retrieved_attrs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>attrs_used</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* We currently do not handle triggers (trig_after_row == TRUE) given that
	 * we know these triggers should exist also on data nodes and
	 * can/should be executed there. The only reason to handle triggers on the
	 * frontend is to (1) more efficiently handle BEFORE triggers (executing
	 * them on the frontend before sending tuples), or (2) have triggers that
	 * do not exist on data nodes.
	 *
	 * Note that, for a hypertable, trig_after_row is always true because of
	 * the insert blocker trigger.
	 */</comment>

	<if_stmt><if>if <condition>(<expr><name>returningList</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We need the attrs, non-system and system, mentioned in the local
		 * query's RETURNING list.
		 */</comment>
		<expr_stmt><expr><call><name>pull_varattnos</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>returningList</name></expr></argument>, <argument><expr><name>rtindex</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>attrs_used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>attrs_used</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>deparseTargetList</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>rtindex</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>attrs_used</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>retrieved_attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>retrieved_attrs</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Construct SELECT statement to acquire size in blocks of given relation.
 *
 * Note: we use local definition of block size, not remote definition.
 * This is perhaps debatable.
 *
 * Note: pg_relation_size() exists in 8.1 and later.
 */</comment>
<function><type><name>void</name></type>
<name>deparseAnalyzeSizeSql</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>relname</name></decl>;</decl_stmt>

	<comment type="block">/* We'll need the remote relation name as a literal. */</comment>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>relname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>deparseRelation</name><argument_list>(<argument><expr><operator>&amp;</operator><name>relname</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"SELECT pg_catalog.pg_relation_size("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>deparseStringLiteral</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>relname</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"::pg_catalog.regclass) / %d"</literal></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Construct SELECT statement to acquire sample rows of given relation.
 *
 * SELECT command is appended to buf, and list of columns retrieved
 * is returned to *retrieved_attrs.
 */</comment>
<function><type><name>void</name></type>
<name>deparseAnalyzeSql</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>retrieved_attrs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relid</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupdesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>colname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>options</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>retrieved_attrs</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"SELECT "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* Ignore dropped columns. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attisdropped</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/* Use attribute name or column_name option. */</comment>
		<expr_stmt><expr><name>colname</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>GetForeignColumnOptions</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>options</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>def</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"column_name"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>colname</name> <operator>=</operator> <call><name>defGetString</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><operator>*</operator><name>retrieved_attrs</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><operator>*</operator><name>retrieved_attrs</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Don't generate bad syntax for zero-column relation. */</comment>
	<if_stmt><if>if <condition>(<expr><name>first</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Construct FROM clause
	 */</comment>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" FROM "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>deparseRelation</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Construct name to use for given column, and emit it into buf.
 * If it has a column_name FDW option, use that instead of attribute name.
 *
 * If qualify_col is true, qualify column name with the alias of relation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>deparseColumnRef</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>varno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>varattno</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>qualify_col</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* We support fetching the remote side's CTID and OID. */</comment>
	<if_stmt><if>if <condition>(<expr><name>varattno</name> <operator>==</operator> <name>SelfItemPointerAttributeNumber</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>qualify_col</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ADD_REL_QUALIFIER</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>varno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ctid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>varattno</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * All other system attributes are fetched as 0, except for table OID,
		 * which is fetched as the local table OID.  However, we must be
		 * careful; the table could be beneath an outer join, in which case it
		 * must go to NULL whenever the rest of the row does.
		 */</comment>
		<decl_stmt><decl><type><name>Oid</name></type> <name>fetchval</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>varattno</name> <operator>==</operator> <name>TableOidAttributeNumber</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>fetchval</name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>qualify_col</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"CASE WHEN ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ADD_REL_QUALIFIER</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>varno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"*)::text IS NOT NULL THEN %u END"</literal></expr></argument>, <argument><expr><name>fetchval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><name>fetchval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>varattno</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Whole row reference */</comment>
		<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>attrs_used</name></decl>;</decl_stmt>

		<comment type="block">/* Required only to be passed down to deparseTargetList(). */</comment>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>retrieved_attrs</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * The lock on the relation will be held by upper callers, so it's
		 * fine to open it with no lock here.
		 */</comment>
		<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * The local name of the foreign table can not be recognized by the
		 * data node and the table it references on data node might
		 * have different column ordering or different columns than those
		 * declared locally. Hence we have to deparse whole-row reference as
		 * ROW(columns referenced locally). Construct this by deparsing a
		 * "whole row" attribute.
		 */</comment>
		<expr_stmt><expr><name>attrs_used</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * In case the whole-row reference is under an outer join then it has
		 * to go NULL whenever the rest of the row goes NULL. Deparsing a join
		 * query would always involve multiple relations, thus qualify_col
		 * would be true.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>qualify_col</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"CASE WHEN ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ADD_REL_QUALIFIER</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>varno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"*)::text IS NOT NULL THEN "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ROW("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>deparseTargetList</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>varno</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>attrs_used</name></expr></argument>, <argument><expr><name>qualify_col</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>retrieved_attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Complete the CASE WHEN statement started above. */</comment>
		<if_stmt><if>if <condition>(<expr><name>qualify_col</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" END"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>attrs_used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>colname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>options</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<comment type="block">/* varno must not be any of OUTER_VAR, INNER_VAR and INDEX_VAR. */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IS_SPECIAL_VARNO</name><argument_list>(<argument><expr><name>varno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If it's a column of a foreign table, and it has the column_name FDW
		 * option, use that value.
		 */</comment>
		<expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>GetForeignColumnOptions</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>varattno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>options</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>def</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"column_name"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>colname</name> <operator>=</operator> <call><name>defGetString</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * If it's a column of a regular table or it doesn't have column_name
		 * FDW option, use attribute name.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>colname</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>colname</name> <operator>=</operator> <call><name>get_attname</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>varattno</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>qualify_col</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ADD_REL_QUALIFIER</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>varno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Append name of table being queried.
 *
 * Note, we enforce that table names are the same across nodes.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>deparseRelation</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nspname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relname</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>||</operator>
		   <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>relname</name> <operator>=</operator> <call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s.%s"</literal></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Append a SQL string literal representing "val" to buf.
 */</comment>
<function><type><name>void</name></type>
<name>deparseStringLiteral</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>valptr</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Rather than making assumptions about the data node's value of
	 * standard_conforming_strings, always use E'foo' syntax if there are any
	 * backslashes.  This will fail on data nodes before 8.1, but those
	 * are long out of support.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="char">'\\'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>ESCAPE_STRING_SYNTAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\''</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>valptr</name> <operator>=</operator> <name>val</name></expr>;</init> <condition><expr><operator>*</operator><name>valptr</name></expr>;</condition> <incr><expr><name>valptr</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type> <name>ch</name> <init>= <expr><operator>*</operator><name>valptr</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>SQL_STR_DOUBLE</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\''</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Deparse given expression into context-&gt;buf.
 *
 * This function must support all the same node types that foreign_expr_walker
 * accepts.
 *
 * Note: unlike ruleutils.c, we just use a simple hard-wired parenthesization
 * scheme: anything more complex than a Var, Const, function call or cast
 * should be self-parenthesized.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>deparseExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_Var</name></expr>:</case>
			<expr_stmt><expr><call><name>deparseVar</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>Var</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Const</name></expr>:</case>
			<expr_stmt><expr><call><name>deparseConst</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Param</name></expr>:</case>
			<expr_stmt><expr><call><name>deparseParam</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>Param</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_SubscriptingRef</name></expr>:</case>
			<expr_stmt><expr><call><name>deparseSubscriptingRef</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>SubscriptingRef</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_FuncExpr</name></expr>:</case>
			<expr_stmt><expr><call><name>deparseFuncExpr</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>FuncExpr</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_OpExpr</name></expr>:</case>
			<expr_stmt><expr><call><name>deparseOpExpr</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>OpExpr</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_DistinctExpr</name></expr>:</case>
			<expr_stmt><expr><call><name>deparseDistinctExpr</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>DistinctExpr</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ScalarArrayOpExpr</name></expr>:</case>
			<expr_stmt><expr><call><name>deparseScalarArrayOpExpr</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>ScalarArrayOpExpr</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_RelabelType</name></expr>:</case>
			<expr_stmt><expr><call><name>deparseRelabelType</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>RelabelType</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_BoolExpr</name></expr>:</case>
			<expr_stmt><expr><call><name>deparseBoolExpr</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>BoolExpr</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_NullTest</name></expr>:</case>
			<expr_stmt><expr><call><name>deparseNullTest</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>NullTest</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ArrayExpr</name></expr>:</case>
			<expr_stmt><expr><call><name>deparseArrayExpr</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>ArrayExpr</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Aggref</name></expr>:</case>
			<expr_stmt><expr><call><name>deparseAggref</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>Aggref</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unsupported expression type for deparse: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Deparse given Var node into context-&gt;buf.
 *
 * If the Var belongs to the foreign relation, just print its remote name.
 * Otherwise, it's effectively a Param (and will in fact be a Param at
 * run time).  Handle it the same way we handle plain Params --- see
 * deparseParam for comments.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>deparseVar</name><parameter_list>(<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relids</name></type> <name>relids</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>scanrel</name><operator>-&gt;</operator><name>relids</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>relno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>colno</name></decl>;</decl_stmt>

	<comment type="block">/* Qualify columns when multiple relations are involved, unless it is a
	 * per-data node scan. */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>qualify_col</name> <init>= <expr><operator>(</operator><call><name>bms_num_members</name><argument_list>(<argument><expr><name>relids</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>context</name><operator>-&gt;</operator><name>sca</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the Var belongs to the foreign relation that is deparsed as a
	 * subquery, use the relation and column alias to the Var provided by the
	 * subquery, instead of the remote name.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>is_subquery_var</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>scanrel</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>relno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>colno</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>,
						 <argument><expr><literal type="string">"%s%d.%s%d"</literal></expr></argument>,
						 <argument><expr><name>SUBQUERY_REL_ALIAS_PREFIX</name></expr></argument>,
						 <argument><expr><name>relno</name></expr></argument>,
						 <argument><expr><name>SUBQUERY_COL_ALIAS_PREFIX</name></expr></argument>,
						 <argument><expr><name>colno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name>relids</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>node</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>deparseColumnRef</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>,
						 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>,
						 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>,
						 <argument><expr><call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>root</name></name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name>qualify_col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Treat like a Param */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>params_list</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>pindex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

			<comment type="block">/* find its index in params_list */</comment>
			<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>*context-&gt;params_list</argument>)</argument_list></macro>
			<block>{<block_content>
				<expr_stmt><expr><name>pindex</name><operator>++</operator></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
			</block_content>}</block>
			<if_stmt><if>if <condition>(<expr><name>lc</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* not in list, so add it */</comment>
				<expr_stmt><expr><name>pindex</name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name><name>context</name><operator>-&gt;</operator><name>params_list</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name><name>context</name><operator>-&gt;</operator><name>params_list</name></name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>printRemoteParam</name><argument_list>(<argument><expr><name>pindex</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>vartype</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>vartypmod</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>printRemotePlaceholder</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>vartype</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>vartypmod</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Deparse given constant value into context-&gt;buf.
 *
 * This function has to be kept in sync with ruleutils.c's get_const_expr.
 * As for that function, showtype can be -1 to never show "::typename" decoration,
 * or +1 to always show it, or 0 to show it only if the constant wouldn't be assumed
 * to be the right type by default.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>deparseConst</name><parameter_list>(<parameter><decl><type><name>Const</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>showtype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>typoutput</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>typIsVarlena</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>extval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>isfloat</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>needlabel</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>constisnull</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>showtype</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"::%s"</literal></expr></argument>, <argument><expr><call><name>deparse_type_name</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>consttype</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>consttypmod</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>consttype</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typoutput</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typIsVarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>extval</name> <operator>=</operator> <call><name>OidOutputFunctionCall</name><argument_list>(<argument><expr><name>typoutput</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>consttype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>INT2OID</name></expr>:</case>
		<case>case <expr><name>INT4OID</name></expr>:</case>
		<case>case <expr><name>INT8OID</name></expr>:</case>
		<case>case <expr><name>OIDOID</name></expr>:</case>
		<case>case <expr><name>FLOAT4OID</name></expr>:</case>
		<case>case <expr><name>FLOAT8OID</name></expr>:</case>
		<case>case <expr><name>NUMERICOID</name></expr>:</case>
		<block>{<block_content>
			<comment type="block">/*
			 * No need to quote unless it's a special value such as 'NaN'.
			 * See comments in get_const_expr().
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>strspn</name><argument_list>(<argument><expr><name>extval</name></expr></argument>, <argument><expr><literal type="string">"0123456789+-eE."</literal></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>extval</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>extval</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'+'</literal> <operator>||</operator> <name><name>extval</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"(%s)"</literal></expr></argument>, <argument><expr><name>extval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>extval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>strcspn</name><argument_list>(<argument><expr><name>extval</name></expr></argument>, <argument><expr><literal type="string">"eE."</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>extval</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>isfloat</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* it looks like a float */</comment>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"'%s'"</literal></expr></argument>, <argument><expr><name>extval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block>
		<break>break;</break>
		<case>case <expr><name>BITOID</name></expr>:</case>
		<case>case <expr><name>VARBITOID</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"B'%s'"</literal></expr></argument>, <argument><expr><name>extval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>BOOLOID</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>extval</name></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"false"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>deparseStringLiteral</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>extval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>extval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>showtype</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * For showtype == 0, append ::typename unless the constant will be
	 * implicitly typed as the right type when it is read in.
	 *
	 * XXX this code has to be kept in sync with the behavior of the parser,
	 * especially make_const.
	 */</comment>
	<switch>switch <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>consttype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>BOOLOID</name></expr>:</case>
		<case>case <expr><name>INT4OID</name></expr>:</case>
		<case>case <expr><name>UNKNOWNOID</name></expr>:</case>
			<expr_stmt><expr><name>needlabel</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>NUMERICOID</name></expr>:</case>
			<expr_stmt><expr><name>needlabel</name> <operator>=</operator> <operator>!</operator><name>isfloat</name> <operator>||</operator> <operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>consttypmod</name></name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><name>needlabel</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
	<if_stmt><if>if <condition>(<expr><name>needlabel</name> <operator>||</operator> <name>showtype</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"::%s"</literal></expr></argument>, <argument><expr><call><name>deparse_type_name</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>consttype</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>consttypmod</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Deparse given Param node.
 *
 * If we're generating the query "for real", add the Param to
 * context-&gt;params_list if it's not already present, and then use its index
 * in that list as the remote parameter number.  During EXPLAIN, there's
 * no need to identify a parameter number.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>deparseParam</name><parameter_list>(<parameter><decl><type><name>Param</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>params_list</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>pindex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<comment type="block">/* find its index in params_list */</comment>
		<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>*context-&gt;params_list</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>pindex</name><operator>++</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block>
		<if_stmt><if>if <condition>(<expr><name>lc</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* not in list, so add it */</comment>
			<expr_stmt><expr><name>pindex</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name><name>context</name><operator>-&gt;</operator><name>params_list</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name><name>context</name><operator>-&gt;</operator><name>params_list</name></name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>printRemoteParam</name><argument_list>(<argument><expr><name>pindex</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>paramtype</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>paramtypmod</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>printRemotePlaceholder</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>paramtype</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>paramtypmod</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Deparse a subscripting expression.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>deparseSubscriptingRef</name><parameter_list>(<parameter><decl><type><name>SubscriptingRef</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lowlist_item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>uplist_item</name></decl>;</decl_stmt>

	<comment type="block">/* Always parenthesize the expression. */</comment>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Deparse referenced container expression first.  If that expression includes
	 * a cast, we have to parenthesize to prevent the array subscript from
	 * being taken as typename decoration.  We can avoid that in the typical
	 * case of subscripting a Var, but otherwise do it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>refexpr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>deparseExpr</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>refexpr</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>deparseExpr</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>refexpr</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Deparse subscript expressions. */</comment>
	<expr_stmt><expr><name>lowlist_item</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>reflowerindexpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* could be NULL */</comment>
	<macro><name>foreach</name> <argument_list>(<argument>uplist_item</argument>, <argument>node-&gt;refupperindexpr</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'['</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>lowlist_item</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>deparseExpr</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lowlist_item</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>lowlist_item</name> <operator>=</operator> <call><name>lnext_compat</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>reflowerindexpr</name></name></expr></argument>, <argument><expr><name>lowlist_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>deparseExpr</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>uplist_item</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">']'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Deparse a function call.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>deparseFuncExpr</name><parameter_list>(<parameter><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>use_variadic</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>first</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the function call came from an implicit coercion, then just show the
	 * first argument.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>funcformat</name></name> <operator>==</operator> <name>COERCE_IMPLICIT_CAST</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>deparseExpr</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If the function call came from a cast, then show the first argument
	 * plus an explicit cast operation.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>funcformat</name></name> <operator>==</operator> <name>COERCE_EXPLICIT_CAST</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>rettype</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>funcresulttype</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type> <name>coercedTypmod</name></decl>;</decl_stmt>

		<comment type="block">/* Get the typmod if this is a length-coercion function */</comment>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>exprIsLengthCoercion</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>coercedTypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>deparseExpr</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"::%s"</literal></expr></argument>, <argument><expr><call><name>deparse_type_name</name><argument_list>(<argument><expr><name>rettype</name></expr></argument>, <argument><expr><name>coercedTypmod</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Check if need to print VARIADIC (cf. ruleutils.c) */</comment>
	<expr_stmt><expr><name>use_variadic</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>funcvariadic</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Normal function: display as proname(args).
	 */</comment>
	<expr_stmt><expr><call><name>appendFunctionName</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>funcid</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* ... and all the arguments */</comment>
	<expr_stmt><expr><name>first</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>arg</argument>, <argument>node-&gt;args</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>use_variadic</name> <operator>&amp;&amp;</operator> <call><name>lnext_compat</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"VARIADIC "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>deparseExpr</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Deparse given operator expression.   To avoid problems around
 * priority of operations, we always parenthesize the arguments.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>deparseOpExpr</name><parameter_list>(<parameter><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_operator</name></type> <name>form</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name>oprkind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>

	<comment type="block">/* Retrieve information about the operator from system catalog. */</comment>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>OPEROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for operator %u"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>form</name> <operator>=</operator> <operator>(</operator><name>Form_pg_operator</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oprkind</name> <operator>=</operator> <name><name>form</name><operator>-&gt;</operator><name>oprkind</name></name></expr>;</expr_stmt>

	<comment type="block">/* Sanity check. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>oprkind</name> <operator>==</operator> <literal type="char">'r'</literal> <operator>&amp;&amp;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal><operator>)</operator> <operator>||</operator>
		   <operator>(</operator><name>oprkind</name> <operator>==</operator> <literal type="char">'l'</literal> <operator>&amp;&amp;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal><operator>)</operator> <operator>||</operator>
		   <operator>(</operator><name>oprkind</name> <operator>==</operator> <literal type="char">'b'</literal> <operator>&amp;&amp;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Always parenthesize the expression. */</comment>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Deparse left operand. */</comment>
	<if_stmt><if>if <condition>(<expr><name>oprkind</name> <operator>==</operator> <literal type="char">'r'</literal> <operator>||</operator> <name>oprkind</name> <operator>==</operator> <literal type="char">'b'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>deparseExpr</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Deparse operator name. */</comment>
	<expr_stmt><expr><call><name>deparseOperatorName</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>form</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Deparse right operand. */</comment>
	<if_stmt><if>if <condition>(<expr><name>oprkind</name> <operator>==</operator> <literal type="char">'l'</literal> <operator>||</operator> <name>oprkind</name> <operator>==</operator> <literal type="char">'b'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>list_tail</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>deparseExpr</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Print the name of an operator.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>deparseOperatorName</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>Form_pg_operator</name></type> <name>opform</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>opname</name></decl>;</decl_stmt>

	<comment type="block">/* opname is not a SQL identifier, so we should not quote it. */</comment>
	<expr_stmt><expr><name>opname</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>opform</name><operator>-&gt;</operator><name>oprname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Print schema name only if it's not pg_catalog */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>opform</name><operator>-&gt;</operator><name>oprnamespace</name></name> <operator>!=</operator> <name>PG_CATALOG_NAMESPACE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>opnspname</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>opnspname</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>opform</name><operator>-&gt;</operator><name>oprnamespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Print fully qualified operator name. */</comment>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"OPERATOR(%s.%s)"</literal></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>opnspname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>opname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Just print operator name. */</comment>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>opname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Deparse IS DISTINCT FROM.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>deparseDistinctExpr</name><parameter_list>(<parameter><decl><type><name>DistinctExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>deparseExpr</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" IS DISTINCT FROM "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>deparseExpr</name><argument_list>(<argument><expr><call><name>lsecond</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Deparse given ScalarArrayOpExpr expression.  To avoid problems
 * around priority of operations, we always parenthesize the arguments.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>deparseScalarArrayOpExpr</name><parameter_list>(<parameter><decl><type><name>ScalarArrayOpExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_operator</name></type> <name>form</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>arg1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>arg2</name></decl>;</decl_stmt>

	<comment type="block">/* Retrieve information about the operator from system catalog. */</comment>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>OPEROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for operator %u"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>form</name> <operator>=</operator> <operator>(</operator><name>Form_pg_operator</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Sanity check. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Always parenthesize the expression. */</comment>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Deparse left operand. */</comment>
	<expr_stmt><expr><name>arg1</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>deparseExpr</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Deparse operator name plus decoration. */</comment>
	<expr_stmt><expr><call><name>deparseOperatorName</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>form</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" %s ("</literal></expr></argument>, <argument><expr><ternary><condition><expr><name><name>node</name><operator>-&gt;</operator><name>useOr</name></name></expr> ?</condition><then> <expr><literal type="string">"ANY"</literal></expr> </then><else>: <expr><literal type="string">"ALL"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Deparse right operand. */</comment>
	<expr_stmt><expr><name>arg2</name> <operator>=</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>deparseExpr</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Always parenthesize the expression. */</comment>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Deparse a RelabelType (binary-compatible cast) node.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>deparseRelabelType</name><parameter_list>(<parameter><decl><type><name>RelabelType</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>deparseExpr</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>relabelformat</name></name> <operator>!=</operator> <name>COERCE_IMPLICIT_CAST</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>,
						 <argument><expr><literal type="string">"::%s"</literal></expr></argument>,
						 <argument><expr><call><name>deparse_type_name</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>resulttype</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>resulttypmod</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Deparse a BoolExpr node.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>deparseBoolExpr</name><parameter_list>(<parameter><decl><type><name>BoolExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> <comment type="block">/* keep compiler quiet */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>first</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>boolop</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>AND_EXPR</name></expr>:</case>
			<expr_stmt><expr><name>op</name> <operator>=</operator> <literal type="string">"AND"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OR_EXPR</name></expr>:</case>
			<expr_stmt><expr><name>op</name> <operator>=</operator> <literal type="string">"OR"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>NOT_EXPR</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"(NOT "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>deparseExpr</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>first</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>node-&gt;args</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" %s "</literal></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>deparseExpr</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Deparse IS [NOT] NULL expression.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>deparseNullTest</name><parameter_list>(<parameter><decl><type><name>NullTest</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>deparseExpr</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * For scalar inputs, we prefer to print as IS [NOT] NULL, which is
	 * shorter and traditional.  If it's a rowtype input but we're applying a
	 * scalar test, must print IS [NOT] DISTINCT FROM NULL to be semantically
	 * correct.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>argisrow</name></name> <operator>||</operator> <operator>!</operator><call><name>type_is_rowtype</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>nulltesttype</name></name> <operator>==</operator> <name>IS_NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" IS NULL)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" IS NOT NULL)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>nulltesttype</name></name> <operator>==</operator> <name>IS_NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" IS NOT DISTINCT FROM NULL)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" IS DISTINCT FROM NULL)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Deparse ARRAY[...] construct.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>deparseArrayExpr</name><parameter_list>(<parameter><decl><type><name>ArrayExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ARRAY["</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>node-&gt;elements</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>deparseExpr</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">']'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If the array is empty, we need an explicit cast to the array type. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>elements</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"::%s"</literal></expr></argument>, <argument><expr><call><name>deparse_type_name</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>array_typeid</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Deparse an Aggref node.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>deparseAggref</name><parameter_list>(<parameter><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>use_variadic</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>partial_agg</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>aggsplit</name></name> <operator>!=</operator> <name>AGGSPLIT_SIMPLE</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>aggsplit</name></name> <operator>==</operator> <name>AGGSPLIT_SIMPLE</name> <operator>||</operator> <name><name>node</name><operator>-&gt;</operator><name>aggsplit</name></name> <operator>==</operator> <name>AGGSPLIT_INITIAL_SERIAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check if need to print VARIADIC (cf. ruleutils.c) */</comment>
	<expr_stmt><expr><name>use_variadic</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>aggvariadic</name></name></expr>;</expr_stmt>

	<comment type="block">/* Find aggregate name from aggfnoid which is a pg_proc entry */</comment>
	<if_stmt><if>if <condition>(<expr><name>partial_agg</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>INTERNAL_SCHEMA_NAME</name> <literal type="string">"."</literal> <name>PARTIALIZE_FUNC_NAME</name> <literal type="string">"("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendFunctionName</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>aggfnoid</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Add DISTINCT */</comment>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>aggdistinct</name></name> <operator>!=</operator> <name>NIL</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"DISTINCT "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>AGGKIND_IS_ORDERED_SET</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>aggkind</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Add WITHIN GROUP (ORDER BY ..) */</comment>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>aggvariadic</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>aggorder</name></name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<macro><name>foreach</name> <argument_list>(<argument>arg</argument>, <argument>node-&gt;aggdirectargs</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>deparseExpr</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">") WITHIN GROUP (ORDER BY "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendAggOrderBy</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>aggorder</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* aggstar can be set only in zero-argument aggregates */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>aggstar</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'*'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type> <name>first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* Add all the arguments */</comment>
			<macro><name>foreach</name> <argument_list>(<argument>arg</argument>, <argument>node-&gt;args</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

				<comment type="block">/* Add VARIADIC */</comment>
				<if_stmt><if>if <condition>(<expr><name>use_variadic</name> <operator>&amp;&amp;</operator> <call><name>lnext_compat</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"VARIADIC "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>deparseExpr</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>n</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Add ORDER BY */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>aggorder</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" ORDER BY "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendAggOrderBy</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>aggorder</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Add FILTER (WHERE ..) */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>aggfilter</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">") FILTER (WHERE "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>deparseExpr</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>aggfilter</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><ternary><condition><expr><name>partial_agg</name></expr> ?</condition><then> <expr><literal type="string">"))"</literal></expr> </then><else>: <expr><literal type="string">")"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Append ORDER BY within aggregate function.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>appendAggOrderBy</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>orderList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>orderList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>srt</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>sortexpr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>sortcoltype</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>sortexpr</name> <operator>=</operator> <call><name>deparseSortGroupClause</name><argument_list>(<argument><expr><name><name>srt</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name></expr></argument>, <argument><expr><name>targetList</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sortcoltype</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><name>sortexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* See whether operator is default &lt; or &gt; for datatype */</comment>
		<expr_stmt><expr><name>typentry</name> <operator>=</operator> <call><name>lookup_type_cache</name><argument_list>(<argument><expr><name>sortcoltype</name></expr></argument>, <argument><expr><name>TYPECACHE_LT_OPR</name> <operator>|</operator> <name>TYPECACHE_GT_OPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>srt</name><operator>-&gt;</operator><name>sortop</name></name> <operator>==</operator> <name><name>typentry</name><operator>-&gt;</operator><name>lt_opr</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" ASC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>srt</name><operator>-&gt;</operator><name>sortop</name></name> <operator>==</operator> <name><name>typentry</name><operator>-&gt;</operator><name>gt_opr</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" DESC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>HeapTuple</name></type> <name>opertup</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Form_pg_operator</name></type> <name>operform</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" USING "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Append operator name. */</comment>
			<expr_stmt><expr><name>opertup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>OPEROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>srt</name><operator>-&gt;</operator><name>sortop</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>opertup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for operator %u"</literal></expr></argument>, <argument><expr><name><name>srt</name><operator>-&gt;</operator><name>sortop</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>operform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_operator</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>opertup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>deparseOperatorName</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>operform</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>opertup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>srt</name><operator>-&gt;</operator><name>nulls_first</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" NULLS FIRST"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" NULLS LAST"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Print the representation of a parameter to be sent to the remote side.
 *
 * Note: we always label the Param's type explicitly rather than relying on
 * transmitting a numeric type OID in PQexecParams().  This allows us to
 * avoid assuming that types have the same OIDs on the remote side as they
 * do locally --- they need only have the same names.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>printRemoteParam</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>paramindex</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>paramtype</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>paramtypmod</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptypename</name> <init>= <expr><call><name>deparse_type_name</name><argument_list>(<argument><expr><name>paramtype</name></expr></argument>, <argument><expr><name>paramtypmod</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"$%d::%s"</literal></expr></argument>, <argument><expr><name>paramindex</name></expr></argument>, <argument><expr><name>ptypename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Print the representation of a placeholder for a parameter that will be
 * sent to the remote side at execution time.
 *
 * This is used when we're just trying to EXPLAIN the remote query.
 * We don't have the actual value of the runtime parameter yet, and we don't
 * want the remote planner to generate a plan that depends on such a value
 * anyway.  Thus, we can't do something simple like "$1::paramtype".
 * Instead, we emit "((SELECT null::paramtype)::paramtype)".
 * In all extant versions of Postgres, the planner will see that as an unknown
 * constant value, which is what we want.  This might need adjustment if we
 * ever make the planner flatten scalar subqueries.  Note: the reason for the
 * apparently useless outer cast is to ensure that the representation as a
 * whole will be parsed as an a_expr and not a select_with_parens; the latter
 * would do the wrong thing in the context "x = ANY(...)".
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>printRemotePlaceholder</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>paramtype</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>paramtypmod</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptypename</name> <init>= <expr><call><name>deparse_type_name</name><argument_list>(<argument><expr><name>paramtype</name></expr></argument>, <argument><expr><name>paramtypmod</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"((SELECT null::%s)::%s)"</literal></expr></argument>, <argument><expr><name>ptypename</name></expr></argument>, <argument><expr><name>ptypename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Deparse GROUP BY clause.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>appendGroupByClause</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Nothing to be done, if there's no GROUP BY clause in the query. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>query</name><operator>-&gt;</operator><name>groupClause</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" GROUP BY "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Queries with grouping sets are not pushed down, so we don't expect
	 * grouping sets here.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>query</name><operator>-&gt;</operator><name>groupingSets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>query-&gt;groupClause</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>grp</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>deparseSortGroupClause</name><argument_list>(<argument><expr><name><name>grp</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Deparse ORDER BY clause according to the given pathkeys for given base
 * relation. From given pathkeys expressions belonging entirely to the given
 * base relation are obtained and deparsed.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>appendOrderByClause</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lcell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nestlevel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>delim</name> <init>= <expr><literal type="string">" "</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>baserel</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>scanrel</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Make sure any constants in the exprs are printed portably */</comment>
	<expr_stmt><expr><name>nestlevel</name> <operator>=</operator> <call><name>set_transmission_modes</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" ORDER BY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>lcell</argument>, <argument>pathkeys</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PathKey</name> <modifier>*</modifier></type><name>pathkey</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lcell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>em_expr</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>em_expr</name> <operator>=</operator> <call><name>find_em_expr_for_rel</name><argument_list>(<argument><expr><name><name>pathkey</name><operator>-&gt;</operator><name>pk_eclass</name></name></expr></argument>, <argument><expr><name>baserel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>em_expr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>delim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>deparseExpr</name><argument_list>(<argument><expr><name>em_expr</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>pathkey</name><operator>-&gt;</operator><name>pk_strategy</name></name> <operator>==</operator> <name>BTLessStrategyNumber</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" ASC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" DESC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>pathkey</name><operator>-&gt;</operator><name>pk_nulls_first</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" NULLS FIRST"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" NULLS LAST"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>delim</name> <operator>=</operator> <literal type="string">", "</literal></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>reset_transmission_modes</name><argument_list>(<argument><expr><name>nestlevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>appendLimit</name><parameter_list>(<parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Limit is always set to value greater than zero, even for
	 * the LIMIT 0 case.
	 *
	 * We do not explicitly push OFFSET clause, since PostgreSQL
	 * treats limit_tuples as a sum of original
	 * LIMIT + OFFSET.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>root</name><operator>-&gt;</operator><name>limit_tuples</name></name> <operator>&gt;=</operator> <literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Do LIMIT deparsing only for supported clauses.
	 *
	 * Current implementation does not handle aggregates with LIMIT
	 * pushdown. It should have different deparsing logic because
	 * at this point PostgreSQL already excluded LIMIT for the most of
	 * the incompatible features during group planning:
	 * distinct, aggs, window functions, group by and having.
	 *
	 * See: grouping_planner() backend/optimizer/plan/planner.c
	 *
	 * Just make sure this is true.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name><name>query</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>||</operator> <name><name>query</name><operator>-&gt;</operator><name>groupingSets</name></name> <operator>||</operator> <name><name>query</name><operator>-&gt;</operator><name>distinctClause</name></name> <operator>||</operator> <name><name>query</name><operator>-&gt;</operator><name>hasAggs</name></name> <operator>||</operator>
			 <name><name>query</name><operator>-&gt;</operator><name>hasWindowFuncs</name></name> <operator>||</operator> <name><name>query</name><operator>-&gt;</operator><name>hasTargetSRFs</name></name> <operator>||</operator> <name><name>context</name><operator>-&gt;</operator><name>root</name><operator>-&gt;</operator><name>hasHavingQual</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* JOIN restrict to only one table */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>list_length</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>fromlist</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
		  <call><name>IsA</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>fromlist</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* ORDER BY is used but not pushed down */</comment>
	<if_stmt><if>if <condition>(<expr><name>pathkeys</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>context</name><operator>-&gt;</operator><name>root</name><operator>-&gt;</operator><name>query_pathkeys</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Use format to round float value */</comment>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="string">" LIMIT %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>ceil</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>root</name><operator>-&gt;</operator><name>limit_tuples</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * appendFunctionName
 *		Deparses function name from given function oid.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>appendFunctionName</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>funcid</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>proctup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>procform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>proname</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>proctup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>procform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Print schema name only if it's not pg_catalog */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>procform</name><operator>-&gt;</operator><name>pronamespace</name></name> <operator>!=</operator> <name>PG_CATALOG_NAMESPACE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>schemaname</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>schemaname</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>procform</name><operator>-&gt;</operator><name>pronamespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s."</literal></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>schemaname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>proname</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>procform</name><operator>-&gt;</operator><name>proname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Always print the function name */</comment>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>proname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Appends a sort or group clause.
 *
 * Like get_rule_sortgroupclause(), returns the expression tree, so caller
 * need not find it again.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>deparseSortGroupClause</name><parameter_list>(<parameter><decl><type><name>Index</name></type> <name>ref</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>force_colno</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>get_sortgroupref_tle</name><argument_list>(<argument><expr><name>ref</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>expr</name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>force_colno</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Use column-number form when requested by caller. */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>expr</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Force a typecast here so that we don't emit something like "GROUP
		 * BY 2", which will be misconstrued as a column position rather than
		 * a constant.
		 */</comment>
		<expr_stmt><expr><call><name>deparseConst</name><argument_list>(<argument><expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><name>expr</name> <operator>||</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>deparseExpr</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Always parenthesize the expression. */</comment>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>deparseExpr</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Returns true if given Var is deparsed as a subquery output column, in
 * which case, *relno and *colno are set to the IDs for the relation and
 * column alias to the Var provided by the subquery.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_subquery_var</name><parameter_list>(<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>foreignrel</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>relno</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>colno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TsFdwRelInfo</name> <modifier>*</modifier></type><name>fpinfo</name> <init>= <expr><call><name>fdw_relinfo_get</name><argument_list>(<argument><expr><name>foreignrel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>outerrel</name> <init>= <expr><name><name>fpinfo</name><operator>-&gt;</operator><name>outerrel</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>innerrel</name> <init>= <expr><name><name>fpinfo</name><operator>-&gt;</operator><name>innerrel</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Should only be called in these cases. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IS_SIMPLE_REL</name><argument_list>(<argument><expr><name>foreignrel</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IS_JOIN_REL</name><argument_list>(<argument><expr><name>foreignrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the given relation isn't a join relation, it doesn't have any lower
	 * subqueries, so the Var isn't a subquery output column.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_JOIN_REL</name><argument_list>(<argument><expr><name>foreignrel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If the Var doesn't belong to any lower subqueries, it isn't a subquery
	 * output column.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>lower_subquery_rels</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name><name>outerrel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If outer relation is deparsed as a subquery, the Var is an output
		 * column of the subquery; get the IDs for the relation/column alias.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>fpinfo</name><operator>-&gt;</operator><name>make_outerrel_subquery</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>get_relation_column_alias_ids</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>outerrel</name></expr></argument>, <argument><expr><name>relno</name></expr></argument>, <argument><expr><name>colno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Otherwise, recurse into the outer relation. */</comment>
		<return>return <expr><call><name>is_subquery_var</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>outerrel</name></expr></argument>, <argument><expr><name>relno</name></expr></argument>, <argument><expr><name>colno</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name><name>innerrel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If inner relation is deparsed as a subquery, the Var is an output
		 * column of the subquery; get the IDs for the relation/column alias.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>fpinfo</name><operator>-&gt;</operator><name>make_innerrel_subquery</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>get_relation_column_alias_ids</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>innerrel</name></expr></argument>, <argument><expr><name>relno</name></expr></argument>, <argument><expr><name>colno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Otherwise, recurse into the inner relation. */</comment>
		<return>return <expr><call><name>is_subquery_var</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>innerrel</name></expr></argument>, <argument><expr><name>relno</name></expr></argument>, <argument><expr><name>colno</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get the IDs for the relation and column alias to given Var belonging to
 * given relation, which are returned into *relno and *colno.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_relation_column_alias_ids</name><parameter_list>(<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>foreignrel</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>relno</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>colno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TsFdwRelInfo</name> <modifier>*</modifier></type><name>fpinfo</name> <init>= <expr><call><name>fdw_relinfo_get</name><argument_list>(<argument><expr><name>foreignrel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* Get the relation alias ID */</comment>
	<expr_stmt><expr><operator>*</operator><name>relno</name> <operator>=</operator> <name><name>fpinfo</name><operator>-&gt;</operator><name>relation_index</name></name></expr>;</expr_stmt>

	<comment type="block">/* Get the column alias ID */</comment>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>foreignrel-&gt;reltarget-&gt;exprs</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>colno</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Shouldn't get here */</comment>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected expression in subquery output"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
