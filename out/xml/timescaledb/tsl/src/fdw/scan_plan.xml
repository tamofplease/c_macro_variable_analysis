<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/timescaledb/tsl/src/fdw/scan_plan.c"><comment type="block">/*
 * This file and its contents are licensed under the Timescale License.
 * Please see the included NOTICE for copyright information and
 * LICENSE-TIMESCALE for a copy of the license.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postgres.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/makefuncs.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/nodeFuncs.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;parser/parsetree.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/pathnode.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/restrictinfo.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/planmain.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/cost.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/clauses.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/tlist.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/paths.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/builtins.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/fmgroids.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/syscache.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/lsyscache.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/selfuncs.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;miscadmin.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fmgr.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;export.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;planner.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"estimate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"relinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"deparse.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"scan_plan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"debug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fdw_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"scan_exec.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"chunk.h"</cpp:file></cpp:include>

<comment type="block">/*
 * get_useful_pathkeys_for_relation
 *		Determine which orderings of a relation might be useful.
 *
 * Getting data in sorted order can be useful either because the requested
 * order matches the final output ordering for the overall query we're
 * planning, or because it enables an efficient merge join.  Here, we try
 * to figure out which pathkeys to consider.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>get_useful_pathkeys_for_relation</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>useful_pathkeys_list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Pushing the query_pathkeys to the data node is always worth
	 * considering, because it might let us avoid a local sort.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>query_pathkeys</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>query_pathkeys_ok</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>root-&gt;query_pathkeys</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PathKey</name> <modifier>*</modifier></type><name>pathkey</name> <init>= <expr><operator>(</operator><name>PathKey</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>pathkey_ec</name> <init>= <expr><name><name>pathkey</name><operator>-&gt;</operator><name>pk_eclass</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>em_expr</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * The planner and executor don't have any clever strategy for
			 * taking data sorted by a prefix of the query's pathkeys and
			 * getting it to be sorted by all of those pathkeys. We'll just
			 * end up resorting the entire data set.  So, unless we can push
			 * down all of the query pathkeys, forget it.
			 *
			 * is_foreign_expr would detect volatile expressions as well, but
			 * checking ec_has_volatile here saves some cycles.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>pathkey_ec</name><operator>-&gt;</operator><name>ec_has_volatile</name></name> <operator>||</operator> <operator>!</operator><operator>(</operator><name>em_expr</name> <operator>=</operator> <call><name>find_em_expr_for_rel</name><argument_list>(<argument><expr><name>pathkey_ec</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
				<operator>!</operator><call><name>ts_is_foreign_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>em_expr</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>query_pathkeys_ok</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><name>query_pathkeys_ok</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>useful_pathkeys_list</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>list_copy</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>query_pathkeys</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>useful_pathkeys_list</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_paths_with_pathkeys_for_rel</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>epq_path</name></decl></parameter>,
								<parameter><decl><type><name>CreatePathFunc</name></type> <name>create_scan_path</name></decl></parameter>,
								<parameter><decl><type><name>CreateUpperPathFunc</name></type> <name>create_upper_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>useful_pathkeys_list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt> <comment type="block">/* List of all pathkeys */</comment>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>create_scan_path</name> <operator>||</operator> <name>create_upper_path</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>create_scan_path</name> <operator>&amp;&amp;</operator> <name>create_upper_path</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>useful_pathkeys_list</name> <operator>=</operator> <call><name>get_useful_pathkeys_for_relation</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Create one path for each set of pathkeys we found above. */</comment>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>useful_pathkeys_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>double</name></type> <name>rows</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>width</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Cost</name></type> <name>startup_cost</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Cost</name></type> <name>total_cost</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>useful_pathkeys</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Path</name> <modifier>*</modifier></type><name>sorted_epq_path</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Path</name> <modifier>*</modifier></type><name>scan_path</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>fdw_estimate_path_cost_size</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
									<argument><expr><name>rel</name></expr></argument>,
									<argument><expr><name>useful_pathkeys</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>rows</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>width</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>startup_cost</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>total_cost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * The EPQ path must be at least as well sorted as the path itself, in
		 * case it gets used as input to a mergejoin.
		 */</comment>
		<expr_stmt><expr><name>sorted_epq_path</name> <operator>=</operator> <name>epq_path</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>sorted_epq_path</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>pathkeys_contained_in</name><argument_list>(<argument><expr><name>useful_pathkeys</name></expr></argument>, <argument><expr><name><name>sorted_epq_path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>sorted_epq_path</name> <operator>=</operator>
				<operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_sort_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>sorted_epq_path</name></expr></argument>, <argument><expr><name>useful_pathkeys</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>create_scan_path</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IS_SIMPLE_REL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>scan_path</name> <operator>=</operator> <call><name>create_scan_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										 <argument><expr><name>rel</name></expr></argument>,
										 <argument><expr><name>NULL</name></expr></argument>,
										 <argument><expr><name>rows</name></expr></argument>,
										 <argument><expr><name>startup_cost</name></expr></argument>,
										 <argument><expr><name>total_cost</name></expr></argument>,
										 <argument><expr><name>useful_pathkeys</name></expr></argument>,
										 <argument><expr><name>NULL</name></expr></argument>,
										 <argument><expr><name>sorted_epq_path</name></expr></argument>,
										 <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IS_UPPER_REL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>scan_path</name> <operator>=</operator> <call><name>create_upper_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										  <argument><expr><name>rel</name></expr></argument>,
										  <argument><expr><name>NULL</name></expr></argument>,
										  <argument><expr><name>rows</name></expr></argument>,
										  <argument><expr><name>startup_cost</name></expr></argument>,
										  <argument><expr><name>total_cost</name></expr></argument>,
										  <argument><expr><name>useful_pathkeys</name></expr></argument>,
										  <argument><expr><name>sorted_epq_path</name></expr></argument>,
										  <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>fdw_utils_add_path</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>scan_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>fdw_add_paths_with_pathkeys_for_rel</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>epq_path</name></decl></parameter>,
									<parameter><decl><type><name>CreatePathFunc</name></type> <name>create_scan_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>add_paths_with_pathkeys_for_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>epq_path</name></expr></argument>, <argument><expr><name>create_scan_path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>fdw_add_upper_paths_with_pathkeys_for_rel</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>epq_path</name></decl></parameter>,
										  <parameter><decl><type><name>CreateUpperPathFunc</name></type> <name>create_upper_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>add_paths_with_pathkeys_for_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>epq_path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>create_upper_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>ParamListInfo</name></type> <name>boundParams</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>active_fns</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>case_val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>estimate</name></decl>;</decl_stmt>
}</block></struct></type> <name>eval_stable_functions_context</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>eval_stable_functions_mutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type>
<name>evaluate_stable_function</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>funcid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>result_type</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>result_typmod</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>result_collid</name></decl></parameter>,
						 <parameter><decl><type><name>Oid</name></type> <name>input_collid</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>funcvariadic</name></decl></parameter>, <parameter><decl><type><name>Form_pg_proc</name></type> <name>funcform</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>has_nonconst_input</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PG_USED_FOR_ASSERTS_ONLY</name> <name>bool</name></type> <name>has_null_input</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>newexpr</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TS_DEBUG</name></cpp:ifdef>
	<comment type="block">/* Allow tests to specify the time to push down in place of now() */</comment>
	<if_stmt><if>if <condition>(<expr><name>funcid</name> <operator>==</operator> <name>F_NOW</name> <operator>&amp;&amp;</operator> <name>ts_current_timestamp_override_value</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name>TIMESTAMPTZOID</name></expr></argument>,
								  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
								  <argument><expr><name>InvalidOid</name></expr></argument>,
								  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TimestampTz</name></expr></argument>)</argument_list></sizeof></expr></argument>,
								  <argument><expr><call><name>TimestampTzGetDatum</name><argument_list>(<argument><expr><name>ts_current_timestamp_override_value</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>false</name></expr></argument>,
								  <argument><expr><name>FLOAT8PASSBYVAL</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Can't simplify if it returns a set or a RECORD. See the comments for
	 * eval_const_expressions(). We should only see the whitelisted functions
	 * here, no sets or RECORDS among them.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>funcform</name><operator>-&gt;</operator><name>proretset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>funcform</name><operator>-&gt;</operator><name>prorettype</name></name> <operator>!=</operator> <name>RECORDOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check for constant inputs and especially constant-NULL inputs.
	 */</comment>
	<macro><name>foreach</name> <argument_list>(<argument>arg</argument>, <argument>args</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>has_null_input</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>constisnull</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>has_nonconst_input</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * The simplification of strict functions with constant NULL inputs must
	 * have been already performed by eval_const_expressions().
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name><name>funcform</name><operator>-&gt;</operator><name>proisstrict</name></name> <operator>&amp;&amp;</operator> <name>has_null_input</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Otherwise, can simplify only if all inputs are constants. (For a
	 * non-strict function, constant NULL inputs are treated the same as
	 * constant non-NULL inputs.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>has_nonconst_input</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * This is called on the access node for the expressions that will be pushed
	 * down to data nodes. These expressions can contain only whitelisted stable
	 * functions, so we shouldn't see volatile functions here. Immutable
	 * functions can also occur here for expressions like
	 * `immutable(stable(....))`, after we evaluate the stable function.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>funcform</name><operator>-&gt;</operator><name>provolatile</name></name> <operator>!=</operator> <name>PROVOLATILE_VOLATILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * OK, looks like we can simplify this operator/function.
	 *
	 * Build a new FuncExpr node containing the already-simplified arguments.
	 */</comment>
	<expr_stmt><expr><name>newexpr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>funcid</name></name> <operator>=</operator> <name>funcid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>funcresulttype</name></name> <operator>=</operator> <name>result_type</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>funcretset</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>funcvariadic</name></name> <operator>=</operator> <name>funcvariadic</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>funcformat</name></name> <operator>=</operator> <name>COERCE_EXPLICIT_CALL</name></expr>;</expr_stmt> <comment type="block">/* doesn't matter */</comment>
	<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>funccollid</name></name> <operator>=</operator> <name>result_collid</name></expr>;</expr_stmt>		<comment type="block">/* doesn't matter */</comment>
	<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>inputcollid</name></name> <operator>=</operator> <name>input_collid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>args</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<return>return <expr><call><name>evaluate_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>newexpr</name></expr></argument>, <argument><expr><name>result_type</name></expr></argument>, <argument><expr><name>result_typmod</name></expr></argument>, <argument><expr><name>result_collid</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Execute the function to deliver a constant result.
 */</comment>
<function><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type>
<name>simplify_stable_function</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>funcid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>result_type</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>result_typmod</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>result_collid</name></decl></parameter>,
						 <parameter><decl><type><name>Oid</name></type> <name>input_collid</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>args_p</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>funcvariadic</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name> <init>= <expr><operator>*</operator><name>args_p</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>func_tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>funcform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>newexpr</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>func_tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>func_tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>funcform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>func_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Process the function arguments. Here we must deal with named or defaulted
	 * arguments, and then recursively apply eval_stable_functions to the whole
	 * argument list.
	 */</comment>
	<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>expand_function_arguments_compat</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>result_type</name></expr></argument>, <argument><expr><name>func_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>args</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>expression_tree_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>args</name></expr></argument>, <argument><expr><name>eval_stable_functions_mutator</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Argument processing done, give it back to the caller */</comment>
	<expr_stmt><expr><operator>*</operator><name>args_p</name> <operator>=</operator> <name>args</name></expr>;</expr_stmt>

	<comment type="block">/* Now attempt simplification of the function call proper. */</comment>
	<expr_stmt><expr><name>newexpr</name> <operator>=</operator> <call><name>evaluate_stable_function</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>,
									   <argument><expr><name>result_type</name></expr></argument>,
									   <argument><expr><name>result_typmod</name></expr></argument>,
									   <argument><expr><name>result_collid</name></expr></argument>,
									   <argument><expr><name>input_collid</name></expr></argument>,
									   <argument><expr><name>args</name></expr></argument>,
									   <argument><expr><name>funcvariadic</name></expr></argument>,
									   <argument><expr><name>funcform</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>func_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>newexpr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Recursive guts of eval_stable_functions.
 * We don't use 'context' here but it is required by the signature of
 * expression_tree_mutator.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>eval_stable_functions_mutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_FuncExpr</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name> <init>= <expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>simple</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>newexpr</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Code for op/func reduction is pretty bulky, so split it out
			 * as a separate function.  Note: exprTypmod normally returns
			 * -1 for a FuncExpr, but not when the node is recognizably a
			 * length coercion; we want to preserve the typmod in the
			 * eventual Const if so.
			 */</comment>
			<expr_stmt><expr><name>simple</name> <operator>=</operator> <call><name>simplify_stable_function</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>funcid</name></name></expr></argument>,
											  <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>funcresulttype</name></name></expr></argument>,
											  <argument><expr><call><name>exprTypmod</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>,
											  <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>funccollid</name></name></expr></argument>,
											  <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>inputcollid</name></name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>,
											  <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>funcvariadic</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>simple</name></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* successfully simplified it */</comment>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>simple</name></expr>;</return></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * The expression cannot be simplified any further, so build
			 * and return a replacement FuncExpr node using the
			 * possibly-simplified arguments.  Note that we have also
			 * converted the argument list to positional notation.
			 */</comment>
			<expr_stmt><expr><name>newexpr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>funcid</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>funcid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>funcresulttype</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>funcresulttype</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>funcretset</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>funcretset</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>funcvariadic</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>funcvariadic</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>funcformat</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>funcformat</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>funccollid</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>funccollid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>inputcollid</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>inputcollid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>args</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newexpr</name></expr>;</return>
		</block_content>}</block>
		<case>case <expr><name>T_OpExpr</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name> <init>= <expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>simple</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>newexpr</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Need to get OID of underlying function.  Okay to scribble
			 * on input to this extent.
			 */</comment>
			<expr_stmt><expr><call><name>set_opfuncid</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Code for op/func reduction is pretty bulky, so split it out
			 * as a separate function.
			 */</comment>
			<expr_stmt><expr><name>simple</name> <operator>=</operator> <call><name>simplify_stable_function</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>opfuncid</name></name></expr></argument>,
											  <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>opresulttype</name></name></expr></argument>,
											  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
											  <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>opcollid</name></name></expr></argument>,
											  <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>inputcollid</name></name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>,
											  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>simple</name></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* successfully simplified it */</comment>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>simple</name></expr>;</return></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * The expression cannot be simplified any further, so build
			 * and return a replacement OpExpr node using the
			 * possibly-simplified arguments.
			 */</comment>
			<expr_stmt><expr><name>newexpr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>opno</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>opno</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>opfuncid</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>opfuncid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>opresulttype</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>opresulttype</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>opretset</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>opretset</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>opcollid</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>opcollid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>inputcollid</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>inputcollid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>args</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newexpr</name></expr>;</return>
		</block_content>}</block>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>
	<comment type="block">/*
	 * For any node type not handled above, copy the node unchanged but
	 * const-simplify its subexpressions.  This is the correct thing for node
	 * types whose behavior might change between planning and execution, such
	 * as CurrentOfExpr.  It's also a safe default for new node types not
	 * known to this routine.
	 */</comment>
	<return>return <expr><call><name>expression_tree_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>eval_stable_functions_mutator</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Try to evaluate stable functions and operators on the access node. This
 * function is similar to eval_const_expressions, but much simpler, because it
 * only evaluates the functions and doesn't have to perform any additional
 * canonicalizations.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>eval_stable_functions</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>eval_stable_functions_mutator</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>fdw_scan_info_init</name><parameter_list>(<parameter><decl><type><name>ScanInfo</name> <modifier>*</modifier></type><name>scaninfo</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
				   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_clauses</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TsFdwRelInfo</name> <modifier>*</modifier></type><name>fpinfo</name> <init>= <expr><call><name>fdw_relinfo_get</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>remote_where</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>remote_having</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>local_exprs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>params_list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>fdw_scan_tlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>fdw_recheck_quals</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>retrieved_attrs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>fdw_private</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type> <name>scan_relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>sql</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IS_SIMPLE_REL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * For base relations, set scan_relid as the relid of the relation.
		 */</comment>
		<expr_stmt><expr><name>scan_relid</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * In a base-relation scan, we must apply the given scan_clauses.
		 *
		 * Separate the scan_clauses into those that can be executed remotely
		 * and those that can't.  baserestrictinfo clauses that were
		 * previously determined to be safe or unsafe by classifyConditions
		 * are found in fpinfo-&gt;remote_conds and fpinfo-&gt;local_conds. Anything
		 * else in the scan_clauses list will be a join clause, which we have
		 * to check for remote-safety.
		 *
		 * Note: the join clauses we see here should be the exact same ones
		 * previously examined by GetForeignPaths.  Possibly it'd be worth
		 * passing forward the classification work done then, rather than
		 * repeating it here.
		 *
		 * This code must match "extract_actual_clauses(scan_clauses, false)"
		 * except for the additional decision about remote versus local
		 * execution.
		 */</comment>
		<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>scan_clauses</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RestrictInfo</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* Ignore any pseudoconstants, they're dealt with elsewhere */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>rinfo</name><operator>-&gt;</operator><name>pseudoconstant</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>list_member_ptr</name><argument_list>(<argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>remote_conds</name></name></expr></argument>, <argument><expr><name>rinfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>remote_where</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>remote_where</name></expr></argument>, <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>list_member_ptr</name><argument_list>(<argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>local_conds</name></name></expr></argument>, <argument><expr><name>rinfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>local_exprs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>local_exprs</name></expr></argument>, <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>ts_is_foreign_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>remote_where</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>remote_where</name></expr></argument>, <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>local_exprs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>local_exprs</name></expr></argument>, <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * For a base-relation scan, we have to support EPQ recheck, which
		 * should recheck all the remote quals.
		 */</comment>
		<expr_stmt><expr><name>fdw_recheck_quals</name> <operator>=</operator> <name>remote_where</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IS_JOIN_REL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"foreign joins are not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Upper relation - set scan_relid to 0.
		 */</comment>
		<expr_stmt><expr><name>scan_relid</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<comment type="block">/*
		 * For a join rel, baserestrictinfo is NIL and we are not considering
		 * parameterization right now, so there should be no scan_clauses for
		 * a joinrel or an upper rel either.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Instead we get the conditions to apply from the fdw_private
		 * structure.
		 * For upper relations, the WHERE clause is built from the remote
		 * conditions of the underlying scan relation.
		 */</comment>
		<decl_stmt><decl><type><name>TsFdwRelInfo</name> <modifier>*</modifier></type><name>ofpinfo</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>ofpinfo</name> <operator>=</operator> <call><name>fdw_relinfo_get</name><argument_list>(<argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>outerrel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>remote_where</name> <operator>=</operator> <call><name>extract_actual_clauses</name><argument_list>(<argument><expr><name><name>ofpinfo</name><operator>-&gt;</operator><name>remote_conds</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>remote_having</name> <operator>=</operator> <call><name>extract_actual_clauses</name><argument_list>(<argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>remote_conds</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>local_exprs</name> <operator>=</operator> <call><name>extract_actual_clauses</name><argument_list>(<argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>local_conds</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We leave fdw_recheck_quals empty in this case, since we never need
		 * to apply EPQ recheck clauses.  In the case of a joinrel, EPQ
		 * recheck is handled elsewhere --- see GetForeignJoinPaths().  If
		 * we're planning an upperrel (ie, remote grouping or aggregation)
		 * then there's no EPQ to do because SELECT FOR UPDATE wouldn't be
		 * allowed, and indeed we *can't* put the remote clauses into
		 * fdw_recheck_quals because the unaggregated Vars won't be available
		 * locally.
		 */</comment>

		<comment type="block">/* Build the list of columns to be fetched from the data node. */</comment>
		<expr_stmt><expr><name>fdw_scan_tlist</name> <operator>=</operator> <call><name>build_tlist_to_deparse</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Try to locally evaluate the stable functions such as now() before pushing
	 * them to the remote node.
	 * We have to do this at the execution stage as oppossed to the planning stage, because stable
	 * functions must be recalculated with each execution of a prepared
	 * statement.
	 * Note that the query planner currently only pushes down to remote side
	 * the whitelisted stable functions, see `function_is_whitelisted()`. So
	 * this code only has to deal with such functions.
	 */</comment>
	<expr_stmt><expr><name>remote_where</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>eval_stable_functions</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>remote_where</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>remote_having</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>eval_stable_functions</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>remote_having</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Build the query string to be sent for execution, and identify
	 * expressions to be sent as parameters.
	 */</comment>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>deparseSelectStmtForRel</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>,
							<argument><expr><name>root</name></expr></argument>,
							<argument><expr><name>rel</name></expr></argument>,
							<argument><expr><name>fdw_scan_tlist</name></expr></argument>,
							<argument><expr><name>remote_where</name></expr></argument>,
							<argument><expr><name>remote_having</name></expr></argument>,
							<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>,
							<argument><expr><name>false</name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>retrieved_attrs</name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>params_list</name></expr></argument>,
							<argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>sca</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Remember remote_exprs for possible use by PlanDirectModify */</comment>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>final_remote_exprs</name></name> <operator>=</operator> <name>remote_where</name></expr>;</expr_stmt>

	<comment type="block">/* Build the chunk oid list for use by EXPLAIN. */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>chunk_oids</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>fpinfo</name><operator>-&gt;</operator><name>sca</name></name></expr>)</condition>
	<block>{<block_content>
		<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>fpinfo-&gt;sca-&gt;chunks</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name> <init>= <expr><operator>(</operator><name>Chunk</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>chunk_oids</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>chunk_oids</name></expr></argument>, <argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>table_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Build the fdw_private list that will be available to the executor.
	 * Items in the list must match order in enum FdwScanPrivateIndex.
	 */</comment>
	<expr_stmt><expr><name>fdw_private</name> <operator>=</operator> <call><name>list_make5</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name><name>sql</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name>retrieved_attrs</name></expr></argument>,
							 <argument><expr><call><name>makeInteger</name><argument_list>(<argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>fetch_size</name></name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><call><name>makeInteger</name><argument_list>(<argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>server</name><operator>-&gt;</operator><name>serverid</name></name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name>chunk_oids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IS_JOIN_REL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IS_UPPER_REL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>fdw_private</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>fdw_private</name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>relation_name</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>scaninfo</name><operator>-&gt;</operator><name>fdw_private</name></name> <operator>=</operator> <name>fdw_private</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scaninfo</name><operator>-&gt;</operator><name>fdw_scan_tlist</name></name> <operator>=</operator> <name>fdw_scan_tlist</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scaninfo</name><operator>-&gt;</operator><name>fdw_recheck_quals</name></name> <operator>=</operator> <name>fdw_recheck_quals</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scaninfo</name><operator>-&gt;</operator><name>local_exprs</name></name> <operator>=</operator> <name>local_exprs</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scaninfo</name><operator>-&gt;</operator><name>params_list</name></name> <operator>=</operator> <name>params_list</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scaninfo</name><operator>-&gt;</operator><name>scan_relid</name></name> <operator>=</operator> <name>scan_relid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scaninfo</name><operator>-&gt;</operator><name>data_node_serverid</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>serverid</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Merge FDW options from input relations into a new set of options for a join
 * or an upper rel.
 *
 * For a join relation, FDW-specific information about the inner and outer
 * relations is provided using fpinfo_i and fpinfo_o.  For an upper relation,
 * fpinfo_o provides the information for the input relation; fpinfo_i is
 * expected to be NULL.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>merge_fdw_options</name><parameter_list>(<parameter><decl><type><name>TsFdwRelInfo</name> <modifier>*</modifier></type><name>fpinfo</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TsFdwRelInfo</name> <modifier>*</modifier></type><name>fpinfo_o</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TsFdwRelInfo</name> <modifier>*</modifier></type><name>fpinfo_i</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* We must always have fpinfo_o. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>fpinfo_o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* fpinfo_i may be NULL, but if present the servers must both match. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>fpinfo_i</name> <operator>||</operator> <name><name>fpinfo_i</name><operator>-&gt;</operator><name>server</name><operator>-&gt;</operator><name>serverid</name></name> <operator>==</operator> <name><name>fpinfo_o</name><operator>-&gt;</operator><name>server</name><operator>-&gt;</operator><name>serverid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Currently, we don't support JOINs, so Asserting fpinfo_i is NULL here
	 * in the meantime. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>fpinfo_i</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Copy the server specific FDW options. (For a join, both relations come
	 * from the same server, so the server options should have the same value
	 * for both relations.)
	 */</comment>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>fdw_startup_cost</name></name> <operator>=</operator> <name><name>fpinfo_o</name><operator>-&gt;</operator><name>fdw_startup_cost</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>fdw_tuple_cost</name></name> <operator>=</operator> <name><name>fpinfo_o</name><operator>-&gt;</operator><name>fdw_tuple_cost</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>shippable_extensions</name></name> <operator>=</operator> <name><name>fpinfo_o</name><operator>-&gt;</operator><name>shippable_extensions</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>fetch_size</name></name> <operator>=</operator> <name><name>fpinfo_o</name><operator>-&gt;</operator><name>fetch_size</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Assess whether the aggregation, grouping and having operations can be pushed
 * down to the data node.  As a side effect, save information we obtain in
 * this function to TsFdwRelInfo of the input relation.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>foreign_grouping_ok</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>grouped_rel</name></decl></parameter>, <parameter><decl><type><name>GroupPathExtraData</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>having_qual</name> <init>= <expr><name><name>extra</name><operator>-&gt;</operator><name>havingQual</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TsFdwRelInfo</name> <modifier>*</modifier></type><name>fpinfo</name> <init>= <expr><call><name>fdw_relinfo_get</name><argument_list>(<argument><expr><name>grouped_rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>grouping_target</name> <init>= <expr><name><name>grouped_rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>ispartial</name> <init>= <expr><name><name>extra</name><operator>-&gt;</operator><name>patype</name></name> <operator>==</operator> <name>PARTITIONWISE_AGGREGATE_PARTIAL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TsFdwRelInfo</name> <modifier>*</modifier></type><name>ofpinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>aggvars</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Cannot have grouping sets since that wouldn't be a distinct coverage of
	 * all partition keys */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>groupingSets</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get the fpinfo of the underlying scan relation. */</comment>
	<expr_stmt><expr><name>ofpinfo</name> <operator>=</operator> <operator>(</operator><name>TsFdwRelInfo</name> <operator>*</operator><operator>)</operator> <call><name>fdw_relinfo_get</name><argument_list>(<argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>outerrel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If underlying scan relation has any local conditions, those conditions
	 * are required to be applied before performing aggregation.  Hence the
	 * aggregate cannot be pushed down.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ofpinfo</name><operator>-&gt;</operator><name>local_conds</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Examine grouping expressions, as well as other expressions we'd need to
	 * compute, and check whether they are safe to push down to the data
	 * node.  All GROUP BY expressions will be part of the grouping target
	 * and thus there is no need to search for them separately.  Add grouping
	 * expressions into target list which will be passed to data node.
	 */</comment>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>grouping_target-&gt;exprs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Index</name></type> <name>sgref</name> <init>= <expr><call><name>get_pathtarget_sortgroupref</name><argument_list>(<argument><expr><name>grouping_target</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

		<comment type="block">/* Check whether this expression is part of GROUP BY clause */</comment>
		<if_stmt><if>if <condition>(<expr><name>sgref</name> <operator>&amp;&amp;</operator> <call><name>get_sortgroupref_clause_noerr</name><argument_list>(<argument><expr><name>sgref</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * If any GROUP BY expression is not shippable, then we cannot
			 * push down aggregation to the data node.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ts_is_foreign_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>grouped_rel</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Pushable, so add to tlist.  We need to create a TLE for this
			 * expression and apply the sortgroupref to it.  We cannot use
			 * add_to_flat_tlist() here because that avoids making duplicate
			 * entries in the tlist.  If there are duplicate entries with
			 * distinct sortgrouprefs, we have to duplicate that situation in
			 * the output tlist.
			 */</comment>
			<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name> <operator>=</operator> <name>sgref</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Non-grouping expression we need to compute.  Is it shippable?
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>ts_is_foreign_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>grouped_rel</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Yes, so add to tlist as-is; OK to suppress duplicates */</comment>
				<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>add_to_flat_tlist</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* Not pushable as a whole; extract its Vars and aggregates */</comment>
				<expr_stmt><expr><name>aggvars</name> <operator>=</operator> <call><name>pull_var_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>, <argument><expr><name>PVC_INCLUDE_AGGREGATES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * If any aggregate expression is not shippable, then we
				 * cannot push down aggregation to the data node.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ts_is_foreign_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>grouped_rel</name></expr></argument>, <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>aggvars</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * Add aggregates, if any, into the targetlist.  Plain Vars
				 * outside an aggregate can be ignored, because they should be
				 * either same as some GROUP BY column or part of some GROUP
				 * BY expression.  In either case, they are already part of
				 * the targetlist and thus no need to add them again.  In fact
				 * including plain Vars in the tlist when they do not match a
				 * GROUP BY column would cause the data node to complain
				 * that the shipped query is invalid.
				 */</comment>
				<macro><name>foreach</name> <argument_list>(<argument>l</argument>, <argument>aggvars</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>add_to_flat_tlist</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * For non-partial aggregations, classify the pushable and non-pushable
	 * HAVING clauses and save them in remote_conds and local_conds of the
	 * grouped rel's fpinfo.
	 *
	 * For partial agggregations, we never push-down the HAVING clause since
	 * it either has (1) been reduced by the planner to a simple filter on the
	 * base rel, or, in case of aggregates, the aggregates must be partials
	 * and have therefore been pulled up into the target list (unless they're
	 * already there). Any partial aggregates in the HAVING clause must be
	 * finalized on the access node and applied there.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>having_qual</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>ispartial</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>(List *) having_qual</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Currently, the core code doesn't wrap havingQuals in
			 * RestrictInfos, so we must make our own.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>RestrictInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>rinfo</name> <operator>=</operator> <call><name>make_restrictinfo_compat</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											 <argument><expr><name>expr</name></expr></argument>,
											 <argument><expr><name>true</name></expr></argument>,
											 <argument><expr><name>false</name></expr></argument>,
											 <argument><expr><name>false</name></expr></argument>,
											 <argument><expr><name><name>root</name><operator>-&gt;</operator><name>qual_security_level</name></name></expr></argument>,
											 <argument><expr><name><name>grouped_rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
											 <argument><expr><name>NULL</name></expr></argument>,
											 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>ts_is_foreign_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>grouped_rel</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>remote_conds</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>remote_conds</name></name></expr></argument>, <argument><expr><name>rinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>local_conds</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>local_conds</name></name></expr></argument>, <argument><expr><name>rinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If there are any local conditions, pull Vars and aggregates from it and
	 * check whether they are safe to pushdown or not.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fpinfo</name><operator>-&gt;</operator><name>local_conds</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>aggvars</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>fpinfo-&gt;local_conds</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RestrictInfo</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>aggvars</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>aggvars</name></expr></argument>,
								  <argument><expr><call><name>pull_var_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>, <argument><expr><name>PVC_INCLUDE_AGGREGATES</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>aggvars</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * If aggregates within local conditions are not safe to push
			 * down, then we cannot push down the query.  Vars are already
			 * part of GROUP BY clause which are checked above, so no need to
			 * access them again here.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ts_is_foreign_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>grouped_rel</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>add_to_flat_tlist</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Store generated targetlist */</comment>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>grouped_tlist</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>

	<comment type="block">/* Safe to pushdown */</comment>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>pushdown_safe</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set cached relation costs to some negative value, so that we can detect
	 * when they are set to some sensible costs, during one (usually the
	 * first) of the calls to fdw_estimate_path_cost_size().
	 */</comment>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>rel_startup_cost</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>rel_total_cost</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set the string describing this grouped relation to be used in EXPLAIN
	 * output of corresponding ForeignScan.
	 */</comment>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>relation_name</name></name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>relation_name</name></name></expr></argument>, <argument><expr><literal type="string">"Aggregate on (%s)"</literal></expr></argument>, <argument><expr><name><name>ofpinfo</name><operator>-&gt;</operator><name>relation_name</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * add_foreign_grouping_paths
 *		Add foreign path for grouping and/or aggregation.
 *
 * Given input_rel represents the underlying scan.  The paths are added to the
 * given grouped_rel.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_foreign_grouping_paths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>input_rel</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>grouped_rel</name></decl></parameter>,
						   <parameter><decl><type><name>GroupPathExtraData</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>CreateUpperPathFunc</name></type> <name>create_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TsFdwRelInfo</name> <modifier>*</modifier></type><name>ifpinfo</name> <init>= <expr><call><name>fdw_relinfo_get</name><argument_list>(<argument><expr><name>input_rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TsFdwRelInfo</name> <modifier>*</modifier></type><name>fpinfo</name> <init>= <expr><call><name>fdw_relinfo_get</name><argument_list>(<argument><expr><name>grouped_rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name> <modifier>*</modifier></type><name>grouppath</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>rows</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>width</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type> <name>startup_cost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type> <name>total_cost</name></decl>;</decl_stmt>

	<comment type="block">/* Nothing to be done, if there is no grouping or aggregation required. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>parse</name><operator>-&gt;</operator><name>groupingSets</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>parse</name><operator>-&gt;</operator><name>hasAggs</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>root</name><operator>-&gt;</operator><name>hasHavingQual</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* save the input_rel as outerrel in fpinfo */</comment>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>outerrel</name></name> <operator>=</operator> <name>input_rel</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Copy foreign table, data node, user mapping, FDW options etc.
	 * details from the input relation's fpinfo.
	 */</comment>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>table</name></name> <operator>=</operator> <name><name>ifpinfo</name><operator>-&gt;</operator><name>table</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>server</name></name> <operator>=</operator> <name><name>ifpinfo</name><operator>-&gt;</operator><name>server</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>sca</name></name> <operator>=</operator> <name><name>ifpinfo</name><operator>-&gt;</operator><name>sca</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>merge_fdw_options</name><argument_list>(<argument><expr><name>fpinfo</name></expr></argument>, <argument><expr><name>ifpinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Assess if it is safe to push down aggregation and grouping.
	 *
	 * Use HAVING qual from extra. In case of child partition, it will have
	 * translated Vars.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>foreign_grouping_ok</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>grouped_rel</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Estimate the cost of push down */</comment>
	<expr_stmt><expr><call><name>fdw_estimate_path_cost_size</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>grouped_rel</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rows</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>width</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>startup_cost</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>total_cost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now update this information in the fpinfo */</comment>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <name>rows</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>width</name></name> <operator>=</operator> <name>width</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>=</operator> <name>startup_cost</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>=</operator> <name>total_cost</name></expr>;</expr_stmt>

	<comment type="block">/* Create and add path to the grouping relation. */</comment>
	<expr_stmt><expr><name>grouppath</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
									 <argument><expr><name>grouped_rel</name></expr></argument>,
									 <argument><expr><name><name>grouped_rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr></argument>,
									 <argument><expr><name>rows</name></expr></argument>,
									 <argument><expr><name>startup_cost</name></expr></argument>,
									 <argument><expr><name>total_cost</name></expr></argument>,
									 <argument><expr><name>NIL</name></expr></argument>, <comment type="block">/* no pathkeys */</comment>
									 <argument><expr><name>NULL</name></expr></argument>,
									 <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* no fdw_private */</comment>

	<comment type="block">/* Add generated path into grouped_rel by add_path(). */</comment>
	<expr_stmt><expr><call><name>fdw_utils_add_path</name><argument_list>(<argument><expr><name>grouped_rel</name></expr></argument>, <argument><expr><name>grouppath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Add paths with pathkeys if there's an order by clause */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>sort_pathkeys</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fdw_add_upper_paths_with_pathkeys_for_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>grouped_rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>create_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>fdw_create_upper_paths</name><parameter_list>(<parameter><decl><type><name>TsFdwRelInfo</name> <modifier>*</modifier></type><name>input_fpinfo</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>UpperRelationKind</name></type> <name>stage</name></decl></parameter>,
					   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>input_rel</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>output_rel</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>,
					   <parameter><decl><type><name>CreateUpperPathFunc</name></type> <name>create_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>input_fpinfo</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>TsFdwRelInfo</name> <modifier>*</modifier></type><name>output_fpinfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If input rel is not safe to pushdown, then simply return as we cannot
	 * perform any post-join operations on the data node.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>input_fpinfo</name><operator>-&gt;</operator><name>pushdown_safe</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Skip any duplicate calls (i.e., output_rel-&gt;fdw_private has already
	 * been set by a previous call to this function). */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>output_rel</name><operator>-&gt;</operator><name>fdw_private</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><name>stage</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>UPPERREL_GROUP_AGG</name></expr>:</case>
		<case>case <expr><name>UPPERREL_PARTIAL_GROUP_AGG</name></expr>:</case>
			<expr_stmt><expr><name>output_fpinfo</name> <operator>=</operator> <call><name>fdw_relinfo_alloc_or_get</name><argument_list>(<argument><expr><name>output_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>output_fpinfo</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name><name>input_fpinfo</name><operator>-&gt;</operator><name>type</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>output_fpinfo</name><operator>-&gt;</operator><name>pushdown_safe</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>add_foreign_grouping_paths</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
									   <argument><expr><name>input_rel</name></expr></argument>,
									   <argument><expr><name>output_rel</name></expr></argument>,
									   <argument><expr><operator>(</operator><name>GroupPathExtraData</name> <operator>*</operator><operator>)</operator> <name>extra</name></expr></argument>,
									   <argument><expr><name>create_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
			<comment type="block">/* Currently not handled (or received) */</comment>
		<case>case <expr><name>UPPERREL_DISTINCT</name></expr>:</case>
		<case>case <expr><name>UPPERREL_ORDERED</name></expr>:</case>
		<case>case <expr><name>UPPERREL_SETOP</name></expr>:</case>
		<case>case <expr><name>UPPERREL_WINDOW</name></expr>:</case>
		<case>case <expr><name>UPPERREL_FINAL</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG15_GE</name></expr></cpp:if>
		<case>case <expr><name>UPPERREL_PARTIAL_DISTINCT</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>
</unit>
