<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/timescaledb/tsl/src/fdw/relinfo.c"><comment type="block">/*
 * This file and its contents are licensed under the Timescale License.
 * Please see the included NOTICE for copyright information and
 * LICENSE-TIMESCALE for a copy of the license.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postgres.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/htup_details.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;parser/parsetree.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;commands/extension.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;commands/defrem.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/hsearch.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/builtins.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/lsyscache.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/syscache.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;miscadmin.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;extension_constants.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;planner.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"chunk.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"chunk_adaptive.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"deparse.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dimension.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"errors.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"estimate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"extension.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hypercube.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hypertable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hypertable_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"option.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"relinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"remote/connection.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"scan_exec.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"planner.h"</cpp:file></cpp:include>

<comment type="block">/* Default CPU cost to start up a foreign query. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_FDW_STARTUP_COST</name></cpp:macro> <cpp:value>100.0</cpp:value></cpp:define>

<comment type="block">/* Default CPU cost to process 1 row (above and beyond cpu_tuple_cost). */</comment>
<comment type="block">/* Note that postgres_fdw sets this to 0.01, but we want to penalize
 * transferring many tuples in order to make it more attractive to push down
 * aggregates and thus transfer/process less tuples. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_FDW_TUPLE_COST</name></cpp:macro> <cpp:value>0.08</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_FDW_FETCH_SIZE</name></cpp:macro> <cpp:value>10000</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_CHUNK_LOOKBACK_WINDOW</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>

<comment type="block">/*
 * Parse options from the foreign data wrapper and foreign server and apply
 * them to fpinfo. The server options take precedence over the data wrapper
 * ones.
 *
 * New options might also require tweaking merge_fdw_options().
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>apply_fdw_and_server_options</name><parameter_list>(<parameter><decl><type><name>TsFdwRelInfo</name> <modifier>*</modifier></type><name>fpinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ForeignDataWrapper</name> <modifier>*</modifier></type><name>fdw</name> <init>= <expr><call><name>GetForeignDataWrapper</name><argument_list>(<argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>server</name><operator>-&gt;</operator><name>fdwid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name><name>options</name><index>[]</index></name> <init>= <expr><block>{ <expr><name><name>fdw</name><operator>-&gt;</operator><name>options</name></name></expr>, <expr><name><name>fpinfo</name><operator>-&gt;</operator><name>server</name><operator>-&gt;</operator><name>options</name></name></expr> }</block></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>options[i]</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>def</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"fdw_startup_cost"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>fdw_startup_cost</name></name> <operator>=</operator> <call><name>strtod</name><argument_list>(<argument><expr><call><name>defGetString</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"fdw_tuple_cost"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>fdw_tuple_cost</name></name> <operator>=</operator> <call><name>strtod</name><argument_list>(<argument><expr><call><name>defGetString</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"extensions"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>shippable_extensions</name></name> <operator>=</operator>
					<call><name>list_concat</name><argument_list>(<argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>shippable_extensions</name></name></expr></argument>,
								<argument><expr><call><name>option_extract_extension_list</name><argument_list>(<argument><expr><call><name>defGetString</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"fetch_size"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>fetch_size</name></name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><call><name>defGetString</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>TsFdwRelInfo</name> <modifier>*</modifier></type>
<name>fdw_relinfo_get</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimescaleDBPrivate</name> <modifier>*</modifier></type><name>rel_private</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>fdw_private</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TsFdwRelInfo</name> <modifier>*</modifier></type><name>fdw_relation_info</name> <init>= <expr><name><name>rel_private</name><operator>-&gt;</operator><name>fdw_relation_info</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * This function is expected to return either null or a fully initialized
	 * fdw_relation_info struct.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>fdw_relation_info</name> <operator>||</operator> <name><name>fdw_relation_info</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>TS_FDW_RELINFO_UNINITIALIZED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>fdw_relation_info</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>TsFdwRelInfo</name> <modifier>*</modifier></type>
<name>fdw_relinfo_alloc_or_get</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimescaleDBPrivate</name> <modifier>*</modifier></type><name>rel_private</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>fdw_private</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>rel_private</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>rel_private</name> <operator>=</operator> <call><name>ts_create_private_reloptinfo</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>rel_private</name><operator>-&gt;</operator><name>fdw_relation_info</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>rel_private</name><operator>-&gt;</operator><name>fdw_relation_info</name></name> <operator>=</operator> <operator>(</operator><name>TsFdwRelInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TsFdwRelInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>rel_private</name><operator>-&gt;</operator><name>fdw_relation_info</name></name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>double</name></type> <name>FILL_FACTOR_CURRENT_CHUNK</name> <init>= <expr><literal type="number">0.5</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>double</name></type> <name>FILL_FACTOR_HISTORICAL_CHUNK</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>DimensionSlice</name> <modifier>*</modifier></type>
<name>get_chunk_time_slice</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Hyperspace</name> <modifier>*</modifier></type><name>space</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type> <name>time_dim_id</name> <init>= <expr><call><name>hyperspace_get_open_dimension</name><argument_list>(<argument><expr><name>space</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>fd</name><operator>.</operator><name>id</name></name></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>ts_hypercube_get_slice_by_dimension_id</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>cube</name></name></expr></argument>, <argument><expr><name>time_dim_id</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Sums of slices belonging to closed dimensions
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>get_total_number_of_slices</name><parameter_list>(<parameter><decl><type><name>Hyperspace</name> <modifier>*</modifier></type><name>space</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>dim_idx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>total_slices</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>dim_idx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>dim_idx</name> <operator>&lt;</operator> <name><name>space</name><operator>-&gt;</operator><name>num_dimensions</name></name></expr>;</condition> <incr><expr><name>dim_idx</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Dimension</name> <modifier>*</modifier></type><name>dim</name> <init>= <expr><operator>&amp;</operator><name><name>space</name><operator>-&gt;</operator><name>dimensions</name><index>[<expr><name>dim_idx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>IS_CLOSED_DIMENSION</name><argument_list>(<argument><expr><name>dim</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>total_slices</name> <operator>+=</operator> <name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>num_slices</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>total_slices</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Estimate fill factor for the chunks that don't have ANALYZE statistics.
 * Fill factor values are between 0 and 1. It's an indication of how much data is
 * in the chunk, expressed as a fraction of its estimated final size.
 *
 * Fill factor estimation assumes that data written is 'recent' in regards to
 * time dimension (eg. almost real-time). For the case when writing historical
 * data, given estimates might be more off as we assume that historical chunks
 * have fill factor 1. Even for writing historical data we might not be totally
 * wrong since most probably data has monotonically increasing time.
 *
 * Estimation handles two possible hypertable configurations:
 * 1. time dimension is of timestamp type
 * 2. time dimension is of integer type.
 *
 * If hypertable uses timestamp type to partition data then there are three
 * possible scenarios here: we are beyond chunk end time (historical chunk), we
 * are somewhere in between chunk time boundaries (current chunk) or chunk start
 * time is in the future (highly unlikely, also treated as current chunk).
 *
 * For integer type we assume that all chunks w/o ANALYZE stats are current.
 * We could use the user-specified integer time function here
 * (set_integer_now_func()), but this logic is a fallback so we're keeping it
 * simple for now.
 *
 * Earlier, this function used chunk ids to guess which chunks are created later,
 * and treated such chunks as current. Unfortunately, the chunk ids are global
 * for all hypertables, so this approach didn't really work if there was more
 * than one hypertable.
 */</comment>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>estimate_chunk_fillfactor</name><parameter_list>(<parameter><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>, <parameter><decl><type><name>Hyperspace</name> <modifier>*</modifier></type><name>space</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type><name>time_dim</name> <init>= <expr><call><name>hyperspace_get_open_dimension</name><argument_list>(<argument><expr><name>space</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>DimensionSlice</name> <modifier>*</modifier></type><name>time_slice</name> <init>= <expr><call><name>get_chunk_time_slice</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>space</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>time_dim_type</name> <init>= <expr><call><name>ts_dimension_get_partition_type</name><argument_list>(<argument><expr><name>time_dim</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IS_TIMESTAMP_TYPE</name><argument_list>(<argument><expr><name>time_dim_type</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TimestampTz</name></type> <name>now</name> <init>= <expr><call><name>GetSQLCurrentTimestamp</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TS_DEBUG</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><name>ts_current_timestamp_override_value</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>now</name> <operator>=</operator> <name>ts_current_timestamp_override_value</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<decl_stmt><decl><type><name>int64</name></type> <name>now_internal_time</name> <init>=
			<expr><call><name>ts_time_value_to_internal</name><argument_list>(<argument><expr><call><name>TimestampTzGetDatum</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TIMESTAMPTZOID</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* if we are beyond end range then chunk can possibly be totally filled */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>time_slice</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>range_end</name></name> <operator>&lt;=</operator> <name>now_internal_time</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Current time is later than the end of the chunk time range, which
			 * means it is a historical chunk.
			 */</comment>
			<return>return <expr><name>FILL_FACTOR_HISTORICAL_CHUNK</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * The chunk time range starts later than current time, so we treat it
		 * as a current chunk.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>time_slice</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>range_start</name></name> <operator>&gt;=</operator> <name>now_internal_time</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>FILL_FACTOR_CURRENT_CHUNK</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Current time falls within chunk time constraints. The fill factor is
		 * interpolated linearly based on where the current time is inside the
		 * range, from 'current chunk fill factor' at the start of the range, to
		 * 'historical chunk fill factor' at the end of the range.
		 */</comment>
		<decl_stmt><decl><type><name>double</name></type> <name>elapsed</name> <init>= <expr><operator>(</operator><name>now_internal_time</name> <operator>-</operator> <name><name>time_slice</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>range_start</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type> <name>interval</name> <init>= <expr><operator>(</operator><name><name>time_slice</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>range_end</name></name> <operator>-</operator> <name><name>time_slice</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>range_start</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>interval</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>elapsed</name> <operator>&lt;=</operator> <name>interval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>FILL_FACTOR_HISTORICAL_CHUNK</name> <operator>&gt;=</operator> <name>FILL_FACTOR_CURRENT_CHUNK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>double</name></type> <name>fill_factor</name> <init>=
			<expr><name>FILL_FACTOR_CURRENT_CHUNK</name> <operator>+</operator>
			<operator>(</operator><name>FILL_FACTOR_HISTORICAL_CHUNK</name> <operator>-</operator> <name>FILL_FACTOR_CURRENT_CHUNK</name><operator>)</operator> <operator>*</operator> <operator>(</operator><name>elapsed</name> <operator>/</operator> <name>interval</name><operator>)</operator></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>fill_factor</name> <operator>&gt;=</operator> <literal type="number">0.</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>fill_factor</name> <operator>&lt;=</operator> <literal type="number">1.</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>fill_factor</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * This chunk doesn't have the ANALYZE data, so it's more likely to be a
	 * recently created, current chunk, not an old historical chunk.
	 */</comment>
	<return>return <expr><name>FILL_FACTOR_CURRENT_CHUNK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>estimate_tuples_and_pages_using_shared_buffers</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int64</name></type> <name>chunk_size_estimate</name> <init>= <expr><call><name>ts_chunk_calculate_initial_chunk_target_size</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>result_width</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>width</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>ht</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>total_slices</name> <init>= <expr><call><name>get_total_number_of_slices</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>space</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>total_slices</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>chunk_size_estimate</name> <operator>/=</operator> <name>total_slices</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<comment type="block">/* half-size seems to be the safest bet */</comment>
		<expr_stmt><expr><name>chunk_size_estimate</name> <operator>/=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>tuples</name></name> <operator>=</operator> <name>chunk_size_estimate</name> <operator>/</operator> <operator>(</operator><name>result_width</name> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>SizeofHeapTupleHeader</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>pages</name></name> <operator>=</operator> <name>chunk_size_estimate</name> <operator>/</operator> <name>BLCKSZ</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Estimate the chunk size if we don't have ANALYZE statistics, and update the
 * moving average of chunk sizes used for estimation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>estimate_chunk_size</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>chunk_rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>parent_relid</name> <init>= <expr><call><name>bms_next_member</name><argument_list>(<argument><expr><name><name>chunk_rel</name><operator>-&gt;</operator><name>top_parent_relids</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>parent_relid</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * In some cases (e.g., UPDATE stmt) top_parent_relids is not set so the
		 * best we can do is using shared buffers size without partitioning
		 * information. Since updates are not something we generaly optimize
		 * for, this should be fine.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>chunk_rel</name><operator>-&gt;</operator><name>pages</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Can't have nonzero tuples in zero pages */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>chunk_rel</name><operator>-&gt;</operator><name>tuples</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>estimate_tuples_and_pages_using_shared_buffers</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>chunk_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Check if we have the chunk info cached for this chunk relation. For
	 * SELECTs, we should have cached it when we performed chunk exclusion.
	 * The UPDATEs use a completely different code path that doesn't do chunk
	 * exclusion, so we'll have to look up this info now.
	 */</comment>
	<decl_stmt><decl><type><name>TimescaleDBPrivate</name> <modifier>*</modifier></type><name>chunk_private</name> <init>= <expr><call><name>ts_get_private_reloptinfo</name><argument_list>(<argument><expr><name>chunk_rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>chunk_private</name><operator>-&gt;</operator><name>chunk</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>chunk_rte</name> <init>= <expr><call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name><name>chunk_rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>chunk_private</name><operator>-&gt;</operator><name>chunk</name></name> <operator>=</operator>
			<call><name>ts_chunk_get_by_relid</name><argument_list>(<argument><expr><name><name>chunk_rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument> <comment type="block">/* fail_if_not_found */</comment>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>parent_info</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>simple_rel_array</name><index>[<expr><name>parent_relid</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<comment type="block">/*
	 * The parent FdwRelInfo might not be allocated and initialized here, because
	 * it happens later in tsl_set_pathlist callback. We don't care about this
	 * because we only need it for chunk size estimates, so allocate it ourselves.
	 */</comment>
	<decl_stmt><decl><type><name>TsFdwRelInfo</name> <modifier>*</modifier></type><name>parent_private</name> <init>= <expr><call><name>fdw_relinfo_alloc_or_get</name><argument_list>(<argument><expr><name>parent_info</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>parent_rte</name> <init>= <expr><call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name>parent_relid</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cache</name> <modifier>*</modifier></type><name>hcache</name> <init>= <expr><call><name>ts_hypertable_cache_pin</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name> <init>= <expr><call><name>ts_hypertable_cache_get_entry</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>, <argument><expr><name><name>parent_rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>CACHE_FLAG_NONE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Hyperspace</name> <modifier>*</modifier></type><name>hyperspace</name> <init>= <expr><name><name>ht</name><operator>-&gt;</operator><name>space</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>double</name></type> <name>fillfactor</name> <init>= <expr><call><name>estimate_chunk_fillfactor</name><argument_list>(<argument><expr><name><name>chunk_private</name><operator>-&gt;</operator><name>chunk</name></name></expr></argument>, <argument><expr><name>hyperspace</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Can't have nonzero tuples in zero pages */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>parent_private</name><operator>-&gt;</operator><name>average_chunk_pages</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>parent_private</name><operator>-&gt;</operator><name>average_chunk_tuples</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>chunk_rel</name><operator>-&gt;</operator><name>pages</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>chunk_rel</name><operator>-&gt;</operator><name>tuples</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>have_chunk_statistics</name> <init>= <expr><name><name>chunk_rel</name><operator>-&gt;</operator><name>pages</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>have_moving_average</name> <init>=
		<expr><name><name>parent_private</name><operator>-&gt;</operator><name>average_chunk_pages</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>parent_private</name><operator>-&gt;</operator><name>average_chunk_tuples</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>have_chunk_statistics</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If we don't have the statistics from ANALYZE for this chunk,
		 * use the moving average of chunk sizes. If we don't have even
		 * that, use an estimate based on the default shared buffers
		 * size for a chunk.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>have_moving_average</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>chunk_rel</name><operator>-&gt;</operator><name>pages</name></name> <operator>=</operator> <name><name>parent_private</name><operator>-&gt;</operator><name>average_chunk_pages</name></name> <operator>*</operator> <name>fillfactor</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>chunk_rel</name><operator>-&gt;</operator><name>tuples</name></name> <operator>=</operator> <name><name>parent_private</name><operator>-&gt;</operator><name>average_chunk_tuples</name></name> <operator>*</operator> <name>fillfactor</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>estimate_tuples_and_pages_using_shared_buffers</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>ht</name></expr></argument>, <argument><expr><name>chunk_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>chunk_rel</name><operator>-&gt;</operator><name>pages</name></name> <operator>*=</operator> <name>fillfactor</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>chunk_rel</name><operator>-&gt;</operator><name>tuples</name></name> <operator>*=</operator> <name>fillfactor</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>have_moving_average</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Initialize the moving average data if we don't have any yet.
		 * Use even a bad estimate from shared buffers, to save on
		 * recalculating the same bad estimate for the subsequent chunks
		 * that are likely to not have the statistics as well.
		 */</comment>
		<expr_stmt><expr><name><name>parent_private</name><operator>-&gt;</operator><name>average_chunk_pages</name></name> <operator>=</operator> <name><name>chunk_rel</name><operator>-&gt;</operator><name>pages</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>parent_private</name><operator>-&gt;</operator><name>average_chunk_tuples</name></name> <operator>=</operator> <name><name>chunk_rel</name><operator>-&gt;</operator><name>tuples</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>have_chunk_statistics</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We have the moving average of chunk sizes and a good estimate
		 * of this chunk size from ANALYZE. Update the moving average.
		 */</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>double</name></type> <name>f</name> <init>= <expr><literal type="number">0.1</literal></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>parent_private</name><operator>-&gt;</operator><name>average_chunk_pages</name></name> <operator>=</operator>
			<operator>(</operator><literal type="number">1</literal> <operator>-</operator> <name>f</name><operator>)</operator> <operator>*</operator> <name><name>parent_private</name><operator>-&gt;</operator><name>average_chunk_pages</name></name> <operator>+</operator> <name>f</name> <operator>*</operator> <name><name>chunk_rel</name><operator>-&gt;</operator><name>pages</name></name> <operator>/</operator> <name>fillfactor</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>parent_private</name><operator>-&gt;</operator><name>average_chunk_tuples</name></name> <operator>=</operator>
			<operator>(</operator><literal type="number">1</literal> <operator>-</operator> <name>f</name><operator>)</operator> <operator>*</operator> <name><name>parent_private</name><operator>-&gt;</operator><name>average_chunk_tuples</name></name> <operator>+</operator> <name>f</name> <operator>*</operator> <name><name>chunk_rel</name><operator>-&gt;</operator><name>tuples</name></name> <operator>/</operator> <name>fillfactor</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Already have some moving average data, but don't have good
		 * statistics for this chunk. Do nothing.
		 */</comment>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>TsFdwRelInfo</name> <modifier>*</modifier></type>
<name>fdw_relinfo_create</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>server_oid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>local_table_id</name></decl></parameter>,
				   <parameter><decl><type><name>TsFdwRelInfoType</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TsFdwRelInfo</name> <modifier>*</modifier></type><name>fpinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>refname</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We use TsFdwRelInfo to pass various information to subsequent
	 * functions. It might be already partially initialized for a data node
	 * hypertable, because we use it to maintain the chunk size estimates when
	 * planning.
	 */</comment>
	<expr_stmt><expr><name>fpinfo</name> <operator>=</operator> <call><name>fdw_relinfo_alloc_or_get</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>TS_FDW_RELINFO_UNINITIALIZED</name> <operator>||</operator> <name><name>fpinfo</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set the name of relation in fpinfo, while we are constructing it here.
	 * It will be used to build the string describing the join relation in
	 * EXPLAIN output. We can't know whether VERBOSE option is specified or
	 * not, so always schema-qualify the foreign table name.
	 */</comment>

	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>relation_name</name></name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>refname</name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>relation_name</name></name></expr></argument>,
					 <argument><expr><literal type="string">"%s.%s"</literal></expr></argument>,
					 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>refname</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>refname</name></expr></argument>, <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>relation_name</name></name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>TS_FDW_RELINFO_HYPERTABLE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* nothing more to do for hypertables */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>server_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>fpinfo</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Base foreign tables need to be pushed down always. */</comment>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>pushdown_safe</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/* Look up foreign-table catalog info. */</comment>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>server</name></name> <operator>=</operator> <call><name>GetForeignServer</name><argument_list>(<argument><expr><name>server_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Extract user-settable option values.  Note that per-table setting
	 * overrides per-server setting.
	 */</comment>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>fdw_startup_cost</name></name> <operator>=</operator> <name>DEFAULT_FDW_STARTUP_COST</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>fdw_tuple_cost</name></name> <operator>=</operator> <name>DEFAULT_FDW_TUPLE_COST</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>shippable_extensions</name></name> <operator>=</operator> <call><name>list_make1_oid</name><argument_list>(<argument><expr><call><name>ts_extension_get_oid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>fetch_size</name></name> <operator>=</operator> <name>DEFAULT_FDW_FETCH_SIZE</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>apply_fdw_and_server_options</name><argument_list>(<argument><expr><name>fpinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Identify which baserestrictinfo clauses can be sent to the data
	 * node and which can't.
	 */</comment>
	<expr_stmt><expr><call><name>classify_conditions</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
						<argument><expr><name>rel</name></expr></argument>,
						<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>baserestrictinfo</name></name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name><name>fpinfo</name><operator>-&gt;</operator><name>remote_conds</name></name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name><name>fpinfo</name><operator>-&gt;</operator><name>local_conds</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Identify which attributes will need to be retrieved from the data
	 * node.  These include all attrs needed for joins or final output, plus
	 * all attrs used in the local_conds.  (Note: if we end up using a
	 * parameterized scan, it's possible that some of the join clauses will be
	 * sent to the remote and thus we wouldn't really need to retrieve the
	 * columns used in them.  Doesn't seem worth detecting that case though.)
	 */</comment>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>attrs_used</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pull_varattnos</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>fpinfo</name><operator>-&gt;</operator><name>attrs_used</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>fpinfo-&gt;local_conds</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RestrictInfo</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pull_varattnos</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>fpinfo</name><operator>-&gt;</operator><name>attrs_used</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Compute the selectivity and cost of the local and remote conditions, so
	 * that we don't have to do it over again for each path. The best we can do
	 * for these conditions is to estimate selectivity on the basis of local
	 * statistics.
	 */</comment>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>local_conds_sel</name></name> <operator>=</operator>
		<call><name>clauselist_selectivity</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>local_conds</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>JOIN_INNER</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>cost_qual_eval</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fpinfo</name><operator>-&gt;</operator><name>local_conds_cost</name></name></expr></argument>, <argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>local_conds</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>remote_conds_sel</name></name> <operator>=</operator>
		<call><name>clauselist_selectivity</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>remote_conds</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>JOIN_INNER</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>cost_qual_eval</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fpinfo</name><operator>-&gt;</operator><name>remote_conds_cost</name></name></expr></argument>, <argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>remote_conds</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set cached relation costs to some negative value, so that we can detect
	 * when they are set to some sensible costs during one (usually the first)
	 * of the calls to fdw_estimate_path_cost_size().
	 */</comment>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>rel_startup_cost</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>rel_total_cost</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>rel_retrieved_rows</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>TS_FDW_RELINFO_FOREIGN_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * For a chunk, estimate its size if we don't know it, and update the
		 * moving average of chunk sizes used for this estimation.
		 */</comment>
		<expr_stmt><expr><call><name>estimate_chunk_size</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Estimate rel size as best we can with local statistics. There are
	 * no local statistics for data node rels since they aren't real base
	 * rels (there's no corresponding table in the system to associate
	 * stats with). Instead, data node rels already have basic stats set
	 * at creation time based on data-node-chunk assignment. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fpinfo</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>TS_FDW_RELINFO_HYPERTABLE_DATA_NODE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>set_baserel_size_estimates</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Fill in basically-bogus cost estimates for use later. */</comment>
	<expr_stmt><expr><call><name>fdw_estimate_path_cost_size</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
								<argument><expr><name>rel</name></expr></argument>,
								<argument><expr><name>NIL</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name><name>fpinfo</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name><name>fpinfo</name><operator>-&gt;</operator><name>width</name></name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name><name>fpinfo</name><operator>-&gt;</operator><name>startup_cost</name></name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name><name>fpinfo</name><operator>-&gt;</operator><name>total_cost</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* No outer and inner relations. */</comment>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>make_outerrel_subquery</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>make_innerrel_subquery</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>lower_subquery_rels</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<comment type="block">/* Set the relation index. */</comment>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>relation_index</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr>;</expr_stmt>

	<return>return <expr><name>fpinfo</name></expr>;</return>
</block_content>}</block></function>
</unit>
