<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/timescaledb/tsl/src/nodes/async_append.c"><comment type="block">/*
 * This file and its contents are licensed under the Timescale License.
 * Please see the included NOTICE for copyright information and
 * LICENSE-TIMESCALE for a copy of the license.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postgres.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;parser/parsetree.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/plannodes.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/extensible.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/nodeFuncs.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/paths.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/pathnode.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/prep.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;foreign/fdwapi.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/sysattr.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;miscadmin.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"async_append.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fdw/scan_plan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fdw/scan_exec.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fdw/data_node_scan_plan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hypertable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hypertable_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils.h"</cpp:file></cpp:include>

<comment type="block">/*
 * AsyncAppend provides an asynchronous API during query execution that
 * decouples the sending of query requests from the reading of the result.
 *
 * Normally, an Append executes serially, i.e., it first executes the first
 * child node, then the second, and so forth. In the case of a distributed
 * query, that means the query on the second data node will not start
 * executing until the first node has finished. Thus, if there are three data
 * nodes, the remote communication will proceed as follows:
 *
 * 1. Send query to data node 1.
 * 2. Get data from data node 1.
 * 3. Send query to data node 2.
 * 4. Get data from data node 2.
 * 5. Send query to data node 3.
 * 6. Get data from data node 4.
 *
 * Since a data node will always need some time to process a query before it
 * is ready to send back results, this won't be very efficient.

 * In contrast, AsyncAppend makes sure that all data node requests are sent
 * before any data is read:
 *
 * 1. Send query to data node 1.
 * 2. Send query to data node 2.
 * 3. Send query to data node 3.
 * 4. Get data from data node 1.
 * 5. Get data from data node 2.
 * 6. Get data from data node 4.
 *
 * With asynchronous approach, data node 2 and 3 will start processing their
 * queries while the data from data node 1 is still being read.
 *
 * There's a caveat with this asynchronous approach, however. Since there's
 * only one connection to each data node (to make sure that each data node is
 * tied to a single transaction and snapshot), it is not possible to start
 * executing a new query on the same data node until the first query is
 * complete (to ensure the connection in idle state). This is important if a
 * query consists of several sub-queries that are sent as separate queries to
 * the same node. In that case, the entire result of the first sub-query must
 * be fetched before proceeding with the next sub-query, which may cause
 * memory blow up.
 *
 * The sub-query issue can be solved by using a CURSOR to break up a query in
 * batches (multiple FETCH statements that fetch a fixed amount of rows each
 * time). FETCH statements for multiple CURSORs (for different sub-queries)
 * can be interleaved as long as they always read the full batch before
 * returning. The downside of a CURSOR, however, is that it doesn't support
 * parallel execution of the query on the data nodes.
 *
 * AsyncAppend is only used for plans that involve distributed hypertables (a
 * plan that involves scanning of data nodes). The node is injected as a
 * parent of Append or MergeAppend nodes.  Here is how the modified plan looks
 * like.
 *
 *       .......
 *          |
 *    -------------
 *   | AsyncAppend |
 *    -------------
 *          |           -----------------------
 *          -----------| Append or MergeAppend |
 *                      -----------------------
 *                                |               --------------
 *                                ---------------| DataNodeScan |
 *                                |               --------------
 *                                |               --------------
 *                                ---------------| DataNodeScan |
 *                                |                --------------
 *
 *                              .....
 *
 *
 * Since the PostgreSQL planner treats partitioned relations in a special way
 * (throwing away existing and generating new paths), we needed to adjust plan
 * paths at a later stage, thus using upper path hooks to do that.
 *
 * There are ways asynchronous appends can be further improved. For instance,
 * after sending the initial queries to all nodes, the append node should pick
 * the child to read based on which data node returns data first instead of
 * just picking the first child.
 *
 */</comment>

<comment type="block">/* Plan state node for AsyncAppend plan */</comment>
<typedef>typedef <type><struct>struct <name>AsyncAppendState</name>
<block>{
	<decl_stmt><decl><type><name>CustomScanState</name></type> <name>css</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>subplan_state</name></decl>;</decl_stmt> <comment type="block">/* AppendState or MergeAppendState */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>data_node_scans</name></decl>;</decl_stmt>	  <comment type="block">/* DataNodeScan states */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>first_run</name></decl>;</decl_stmt>
}</block></struct></type> <name>AsyncAppendState</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>async_append_exec</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>async_append_begin</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>async_append_end</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>async_append_rescan</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <name>CustomExecMethods</name></type> <name>async_append_state_methods</name> <init>= <expr><block>{
	<expr><operator>.</operator><name>CustomName</name> <operator>=</operator> <literal type="string">"AsyncAppendState"</literal></expr>,
	<expr><operator>.</operator><name>BeginCustomScan</name> <operator>=</operator> <name>async_append_begin</name></expr>,
	<expr><operator>.</operator><name>EndCustomScan</name> <operator>=</operator> <name>async_append_end</name></expr>,
	<expr><operator>.</operator><name>ExecCustomScan</name> <operator>=</operator> <name>async_append_exec</name></expr>,
	<expr><operator>.</operator><name>ReScanCustomScan</name> <operator>=</operator> <name>async_append_rescan</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>async_append_state_create</name><parameter_list>(<parameter><decl><type><name>CustomScan</name> <modifier>*</modifier></type><name>cscan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AsyncAppendState</name> <modifier>*</modifier></type><name>state</name> <init>=
		<expr><operator>(</operator><name>AsyncAppendState</name> <operator>*</operator><operator>)</operator> <call><name>newNode</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AsyncAppendState</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>T_CustomScanState</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>subplan_state</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>css</name><operator>.</operator><name>methods</name></name> <operator>=</operator> <operator>&amp;</operator><name>async_append_state_methods</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>first_run</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>state</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>CustomScanMethods</name></type> <name>async_append_plan_methods</name> <init>= <expr><block>{
	<expr><operator>.</operator><name>CustomName</name> <operator>=</operator> <literal type="string">"AsyncAppend"</literal></expr>,
	<expr><operator>.</operator><name>CreateCustomScanState</name> <operator>=</operator> <name>async_append_state_create</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>PlanState</name> <modifier>*</modifier></type>
<name>find_data_node_scan_state_child</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>state</name></expr>)</condition>
	<block>{<block_content>
		<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>T_CustomScanState</name></expr>:</case>
				<return>return <expr><name>state</name></expr>;</return>
			<case>case <expr><name>T_AggState</name></expr>:</case>
			<case>case <expr><name>T_ResultState</name></expr>:</case>
			<case>case <expr><name>T_SortState</name></expr>:</case>
				<comment type="block">/* Data scan state can be buried under AggState or SortState  */</comment>
				<return>return <expr><call><name>find_data_node_scan_state_child</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>lefttree</name></name></expr></argument>)</argument_list></call></expr>;</return>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					 <argument><expr><literal type="string">"unexpected child node of Append or MergeAppend: %s"</literal></expr></argument>,
					 <argument><expr><call><name>ts_get_node_name</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find a DataNodeScan in plan state for AsyncAppend"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_unreachable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>get_data_node_async_scan_states</name><parameter_list>(<parameter><decl><type><name>AsyncAppendState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlanState</name> <modifier>*</modifier><modifier>*</modifier></type><name>child_plans</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>num_child_plans</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>dn_plans</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>subplan_state</name></name></expr></argument>, <argument><expr><name>AppendState</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AppendState</name> <modifier>*</modifier></type><name>astate</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>AppendState</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>subplan_state</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>child_plans</name> <operator>=</operator> <name><name>astate</name><operator>-&gt;</operator><name>appendplans</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>num_child_plans</name> <operator>=</operator> <name><name>astate</name><operator>-&gt;</operator><name>as_nplans</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>subplan_state</name></name></expr></argument>, <argument><expr><name>MergeAppendState</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MergeAppendState</name> <modifier>*</modifier></type><name>mstate</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>MergeAppendState</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>subplan_state</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>child_plans</name> <operator>=</operator> <name><name>mstate</name><operator>-&gt;</operator><name>mergeplans</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>num_child_plans</name> <operator>=</operator> <name><name>mstate</name><operator>-&gt;</operator><name>ms_nplans</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			 <argument><expr><literal type="string">"unexpected child node of AsyncAppend: %s"</literal></expr></argument>,
			 <argument><expr><call><name>ts_get_node_name</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>subplan_state</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_child_plans</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name>dn_plans</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>dn_plans</name></expr></argument>, <argument><expr><call><name>find_data_node_scan_state_child</name><argument_list>(<argument><expr><name><name>child_plans</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<return>return <expr><name>dn_plans</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>async_append_begin</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AsyncAppendState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><operator>(</operator><name>AsyncAppendState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CustomScan</name> <modifier>*</modifier></type><name>cscan</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>CustomScan</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>subplan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>subplan_state</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_plans</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_plans</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_plans</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>subplan_state</name> <operator>=</operator> <call><name>ExecInitNode</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>subplan_state</name></name> <operator>=</operator> <name>subplan_state</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>css</name><operator>.</operator><name>custom_ps</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>subplan_state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>data_node_scans</name></name> <operator>=</operator> <call><name>get_data_node_async_scan_states</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>iterate_data_nodes_and_exec</name><parameter_list>(<parameter><decl><type><name>AsyncAppendState</name> <modifier>*</modifier></type><name>aas</name></decl></parameter>, <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>dn_exec</name>)<parameter_list>(<parameter><decl><type><name>AsyncScanState</name> <modifier>*</modifier></type><name>ass</name></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>aas-&gt;data_node_scans</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AsyncScanState</name> <modifier>*</modifier></type><name>dnss</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>dn_exec</name><argument_list>(<argument><expr><name>dnss</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>init</name><parameter_list>(<parameter><decl><type><name>AsyncScanState</name> <modifier>*</modifier></type><name>ass</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name><name>ass</name><operator>-&gt;</operator><name>init</name></name><argument_list>(<argument><expr><name>ass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>send_fetch_request</name><parameter_list>(<parameter><decl><type><name>AsyncScanState</name> <modifier>*</modifier></type><name>ass</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name><name>ass</name><operator>-&gt;</operator><name>send_fetch_request</name></name><argument_list>(<argument><expr><name>ass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>fetch_data</name><parameter_list>(<parameter><decl><type><name>AsyncScanState</name> <modifier>*</modifier></type><name>ass</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name><name>ass</name><operator>-&gt;</operator><name>fetch_data</name></name><argument_list>(<argument><expr><name>ass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>async_append_exec</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AsyncAppendState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><operator>(</operator><name>AsyncAppendState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>subplan_state</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>data_node_scans</name></name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>first_run</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>first_run</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>iterate_data_nodes_and_exec</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>init</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>iterate_data_nodes_and_exec</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>send_fetch_request</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Fetch a new data batch into all sub-nodes. This will clear the
		 * connection for new requests (important when there are, e.g.,
		 * subqueries that share the connection). */</comment>
		<expr_stmt><expr><call><name>iterate_data_nodes_and_exec</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>fetch_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecProcNode</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>subplan_state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ProjInfo</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>slot</name></expr>;</return></block_content></block></if></if_stmt>
		<return>return <expr><call><name>ExecProject</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ProjInfo</name></name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>async_append_end</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AsyncAppendState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><operator>(</operator><name>AsyncAppendState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ExecEndNode</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>subplan_state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>async_append_rescan</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AsyncAppendState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><operator>(</operator><name>AsyncAppendState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>chgParam</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>UpdateChangedParamSet</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>subplan_state</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>chgParam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ExecReScan</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>subplan_state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type>
<name>async_append_plan_create</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>CustomPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
						 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>clauses</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>custom_plans</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CustomScan</name> <modifier>*</modifier></type><name>cscan</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CustomScan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>subplan</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>methods</name></name> <operator>=</operator> <operator>&amp;</operator><name>async_append_plan_methods</name></expr>;</expr_stmt>
	<comment type="block">/* output target list */</comment>
	<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>
	<comment type="block">/* we don't scan a real relation here */</comment>
	<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name><name>best_path</name><operator>-&gt;</operator><name>flags</name></name></expr>;</expr_stmt>

	<comment type="block">/* remove Result node since AsyncAppend node will project */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>custom_plans</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Result</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>castNode</name><argument_list>(<argument><expr><name>Result</name></expr></argument>, <argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>custom_plans</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>resconstantqual</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Result</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>Result</name></expr></argument>, <argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>custom_plans</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>righttree</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected right tree below result node in async append"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>custom_plans</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>lefttree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_plans</name></name> <operator>=</operator> <name>custom_plans</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>custom_plans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>IsA</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>, <argument><expr><name>MergeAppend</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>, <argument><expr><name>Append</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected child node of AsyncAppend: %s"</literal></expr></argument>, <argument><expr><call><name>ts_get_node_name</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>subplan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* input target list */</comment>
	<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_scan_tlist</name></name> <operator>=</operator> <name><name>subplan</name><operator>-&gt;</operator><name>targetlist</name></name></expr>;</expr_stmt>
	<return>return <expr><operator>&amp;</operator><name><name>cscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name></name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>CustomPathMethods</name></type> <name>async_append_path_methods</name> <init>= <expr><block>{
	<expr><operator>.</operator><name>CustomName</name> <operator>=</operator> <literal type="string">"AsyncAppendPath"</literal></expr>,
	<expr><operator>.</operator><name>PlanCustomPath</name> <operator>=</operator> <name>async_append_plan_create</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_data_node_scan_path</name><parameter_list>(<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CustomPath</name> <modifier>*</modifier></type><name>cpath</name></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>CustomPath</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>cpath</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>CustomPath</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>cpath</name><operator>-&gt;</operator><name>methods</name><operator>-&gt;</operator><name>CustomName</name></name></expr></argument>, <argument><expr><name>DATA_NODE_SCAN_PATH_NAME</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>path_process</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier><modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Path</name> <modifier>*</modifier><modifier>*</modifier></type><name>subpath</name> <init>= <expr><name>path</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name> <modifier>*</modifier></type><name>subp</name> <init>= <expr><operator>*</operator><name>subpath</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>children</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name> <modifier>*</modifier></type><name>child</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AsyncAppendPath</name> <modifier>*</modifier></type><name>aa_path</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><operator>*</operator><name>subpath</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_AppendPath</name></expr>:</case>
			<expr_stmt><expr><name>children</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>AppendPath</name></expr></argument>, <argument><expr><name>subp</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>subpaths</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_MergeAppendPath</name></expr>:</case>
			<expr_stmt><expr><name>children</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>MergeAppendPath</name></expr></argument>, <argument><expr><name>subp</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>subpaths</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_AggPath</name></expr>:</case>
			<expr_stmt><expr><call><name>path_process</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><call><name>castNode</name><argument_list>(<argument><expr><name>AggPath</name></expr></argument>, <argument><expr><name>subp</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>subpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><name>T_GroupPath</name></expr>:</case>
			<expr_stmt><expr><call><name>path_process</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><call><name>castNode</name><argument_list>(<argument><expr><name>GroupPath</name></expr></argument>, <argument><expr><name>subp</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>subpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><name>T_SortPath</name></expr>:</case>
			<expr_stmt><expr><call><name>path_process</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><call><name>castNode</name><argument_list>(<argument><expr><name>SortPath</name></expr></argument>, <argument><expr><name>subp</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>subpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><name>T_UpperUniquePath</name></expr>:</case>
			<expr_stmt><expr><call><name>path_process</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><call><name>castNode</name><argument_list>(<argument><expr><name>UpperUniquePath</name></expr></argument>, <argument><expr><name>subp</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>subpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><name>T_ProjectionPath</name></expr>:</case>
			<expr_stmt><expr><call><name>path_process</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><call><name>castNode</name><argument_list>(<argument><expr><name>ProjectionPath</name></expr></argument>, <argument><expr><name>subp</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>subpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><name>T_ProjectSetPath</name></expr>:</case>
			<expr_stmt><expr><call><name>path_process</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><call><name>castNode</name><argument_list>(<argument><expr><name>ProjectSetPath</name></expr></argument>, <argument><expr><name>subp</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>subpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><name>T_LimitPath</name></expr>:</case>
			<expr_stmt><expr><call><name>path_process</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><call><name>castNode</name><argument_list>(<argument><expr><name>LimitPath</name></expr></argument>, <argument><expr><name>subp</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>subpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><name>T_UniquePath</name></expr>:</case>
			<expr_stmt><expr><call><name>path_process</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><call><name>castNode</name><argument_list>(<argument><expr><name>UniquePath</name></expr></argument>, <argument><expr><name>subp</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>subpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><name>T_GatherPath</name></expr>:</case>
			<expr_stmt><expr><call><name>path_process</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><call><name>castNode</name><argument_list>(<argument><expr><name>GatherPath</name></expr></argument>, <argument><expr><name>subp</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>subpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><name>T_GatherMergePath</name></expr>:</case>
			<expr_stmt><expr><call><name>path_process</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><call><name>castNode</name><argument_list>(<argument><expr><name>GatherMergePath</name></expr></argument>, <argument><expr><name>subp</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>subpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><name>T_MaterialPath</name></expr>:</case>
			<expr_stmt><expr><call><name>path_process</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><call><name>castNode</name><argument_list>(<argument><expr><name>MaterialPath</name></expr></argument>, <argument><expr><name>subp</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>subpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><name>T_NestPath</name></expr>:</case>
		<case>case <expr><name>T_MergePath</name></expr>:</case>
		<case>case <expr><name>T_HashPath</name></expr>:</case>
			<expr_stmt><expr><call><name>path_process</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><name>JoinPath</name> <operator>*</operator><operator>)</operator> <name>subp</name><operator>)</operator><operator>-&gt;</operator><name>outerjoinpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>path_process</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><name>JoinPath</name> <operator>*</operator><operator>)</operator> <name>subp</name><operator>)</operator><operator>-&gt;</operator><name>innerjoinpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><name>T_MinMaxAggPath</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>MinMaxAggPath</name> <modifier>*</modifier></type><name>mm_path</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>MinMaxAggPath</name></expr></argument>, <argument><expr><name>subp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>mm_lc</name></decl>;</decl_stmt>
			<macro><name>foreach</name> <argument_list>(<argument>mm_lc</argument>, <argument>mm_path-&gt;mmaggregates</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>MinMaxAggInfo</name> <modifier>*</modifier></type><name>mm_info</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>MinMaxAggInfo</name></expr></argument>, <argument><expr><name>mm_lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>path_process</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>mm_info</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<return>return;</return>
		</block_content>}</block>
		<case>case <expr><name>T_WindowAggPath</name></expr>:</case>
			<expr_stmt><expr><call><name>path_process</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><call><name>castNode</name><argument_list>(<argument><expr><name>WindowAggPath</name></expr></argument>, <argument><expr><name>subp</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>subpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<default>default:</default>
			<return>return;</return>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><name>children</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* AsyncAppend only makes sense when there are multiple children that we'd
	 * like to asynchronously scan. Also note that PG12 will remove append
	 * nodes when there's a single child and this will confuse AsyncAppend. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>children</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>child</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>children</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* sometimes data node scan is buried under ProjectionPath or AggPath */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr><name>ProjectionPath</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>child</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>ProjectionPath</name></expr></argument>, <argument><expr><name>child</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>subpath</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr><name>AggPath</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>child</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>AggPath</name></expr></argument>, <argument><expr><name>child</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>subpath</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_data_node_scan_path</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>aa_path</name> <operator>=</operator> <operator>(</operator><name>AsyncAppendPath</name> <operator>*</operator><operator>)</operator> <call><name>newNode</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AsyncAppendPath</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>T_CustomPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>aa_path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_CustomScan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aa_path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name><name>subp</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aa_path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>subp</name><operator>-&gt;</operator><name>pathtarget</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aa_path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aa_path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>methods</name></name> <operator>=</operator> <operator>&amp;</operator><name>async_append_path_methods</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aa_path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aa_path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <name><name>subp</name><operator>-&gt;</operator><name>param_info</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aa_path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aa_path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <name><name>subp</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aa_path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name><name>subp</name><operator>-&gt;</operator><name>pathkeys</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aa_path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>custom_paths</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>subp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* reuse subpath estimated rows and costs */</comment>
	<expr_stmt><expr><name><name>aa_path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <name><name>subp</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aa_path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>subp</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aa_path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <name><name>subp</name><operator>-&gt;</operator><name>total_cost</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>subpath</name> <operator>=</operator> <operator>&amp;</operator><name><name>aa_path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>async_append_add_paths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>final_rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>final_rel-&gt;pathlist</argument>)</argument_list></macro>
		<expr_stmt><expr><call><name>path_process</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>*</operator><operator>)</operator> <operator>&amp;</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
