<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/timescaledb/tsl/src/nodes/decompress_chunk/planner.c"><comment type="block">/*
 * This file and its contents are licensed under the Timescale License.
 * Please see the included NOTICE for copyright information and
 * LICENSE-TIMESCALE for a copy of the license.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postgres.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/sysattr.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_namespace.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_operator.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/bitmapset.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/extensible.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/makefuncs.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/nodeFuncs.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/optimizer.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/paths.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/plancat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/restrictinfo.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/tlist.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;parser/parsetree.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/builtins.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/typcache.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compression/compression.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compression/create.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/decompress_chunk/decompress_chunk.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/decompress_chunk/planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/decompress_chunk/exec.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"import/planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"custom_type_cache.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>static</specifier> <name>CustomScanMethods</name></type> <name>decompress_chunk_plan_methods</name> <init>= <expr><block>{
	<expr><operator>.</operator><name>CustomName</name> <operator>=</operator> <literal type="string">"DecompressChunk"</literal></expr>,
	<expr><operator>.</operator><name>CreateCustomScanState</name> <operator>=</operator> <name>decompress_chunk_state_create</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<function><type><name>void</name></type>
<name>_decompress_chunk_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>TryRegisterCustomScanMethods</name><argument_list>(<argument><expr><operator>&amp;</operator><name>decompress_chunk_plan_methods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_for_system_columns</name><parameter_list>(<parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>attrs_used</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>bit</name> <init>= <expr><call><name>bms_next_member</name><argument_list>(<argument><expr><name>attrs_used</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>bit</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>bit</name> <operator>+</operator> <name>FirstLowInvalidHeapAttributeNumber</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* we support tableoid so skip that */</comment>
		<if_stmt><if>if <condition>(<expr><name>bit</name> <operator>==</operator> <name>TableOidAttributeNumber</name> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>bit</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name>attrs_used</name></expr></argument>, <argument><expr><name>bit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>bit</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>bit</name> <operator>+</operator> <name>FirstLowInvalidHeapAttributeNumber</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"transparent decompression only supports tableoid system column"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Given the scan targetlist and the bitmapset of the needed columns, determine
 * which scan columns become which decompressed columns (fill decompression_map).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>build_decompression_map</name><parameter_list>(<parameter><decl><type><name>DecompressChunkPath</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_tlist</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>chunk_attrs_needed</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Track which normal and metadata columns we were able to find in the
	 * targetlist.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>missing_count</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>missing_sequence</name> <init>= <expr><name><name>path</name><operator>-&gt;</operator><name>needs_sequence_num</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>chunk_attrs_found</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * FIXME this way to determine which columns are used is actually wrong, see
	 * https://github.com/timescale/timescaledb/issues/4195#issuecomment-1104238863
	 * Left as is for now, because changing it uncovers a whole new story with
	 * ctid.
	 */</comment>
	<expr_stmt><expr><call><name>check_for_system_columns</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>info</name><operator>-&gt;</operator><name>ht_rte</name><operator>-&gt;</operator><name>selectedCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We allow tableoid system column, it won't be in the targetlist but will
	 * be added at decompression time. Always mark it as found.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>TableOidAttributeNumber</name> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>,
					  <argument><expr><name>chunk_attrs_needed</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>chunk_attrs_found</name> <operator>=</operator>
			<call><name>bms_add_member</name><argument_list>(<argument><expr><name>chunk_attrs_found</name></expr></argument>,
						   <argument><expr><name>TableOidAttributeNumber</name> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Fill the helper array of compressed attno -&gt; compression info.
	 */</comment>
	<decl_stmt><decl><type><name>FormData_hypertable_compression</name> <modifier>*</modifier><modifier>*</modifier></type><name>compressed_attno_to_compression_info</name> <init>=
		<expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name><name>path</name><operator>-&gt;</operator><name>info</name><operator>-&gt;</operator><name>compressed_rel</name><operator>-&gt;</operator><name>max_attr</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>path-&gt;info-&gt;hypertable_compression_info</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FormData_hypertable_compression</name> <modifier>*</modifier></type><name>fd</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type> <name>compressed_attno</name> <init>=
			<expr><call><name>get_attnum</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>info</name><operator>-&gt;</operator><name>compressed_rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>fd</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>compressed_attno</name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				 <argument><expr><literal type="string">"column '%s' not found in the compressed chunk '%s'"</literal></expr></argument>,
				 <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>fd</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>,
				 <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>info</name><operator>-&gt;</operator><name>compressed_rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>compressed_attno_to_compression_info</name><index>[<expr><name>compressed_attno</name></expr>]</index></name> <operator>=</operator> <name>fd</name></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Go over the scan targetlist and determine to which output column each
	 * scan column goes.
	 */</comment>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>decompression_map</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>scan_tlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>target</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"compressed scan targetlist entries must be Vars"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>target</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>Index</name><operator>)</operator> <name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name><name>path</name><operator>-&gt;</operator><name>info</name><operator>-&gt;</operator><name>compressed_rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type> <name>compressed_attno</name> <init>= <expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>compressed_attno</name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We shouldn't have whole-row vars in the compressed scan tlist,
			 * they are going to be built by final projection of DecompressChunk
			 * custom scan.
			 * See compressed_rel_setup_reltarget().
			 */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"compressed scan targetlist must not have whole-row vars"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>column_name</name> <init>= <expr><call><name>get_attname</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>info</name><operator>-&gt;</operator><name>compressed_rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,
											  <argument><expr><name>compressed_attno</name></expr></argument>,
											  <comment type="block">/* missing_ok = */</comment> <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>AttrNumber</name></type> <name>destination_attno_in_uncompressed_chunk</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>FormData_hypertable_compression</name> <modifier>*</modifier></type><name>compression_info</name> <init>=
			<expr><name><name>compressed_attno_to_compression_info</name><index>[<expr><name>compressed_attno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>compression_info</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Normal column, not a metadata column.
			 */</comment>
			<decl_stmt><decl><type><name>AttrNumber</name></type> <name>hypertable_attno</name> <init>= <expr><call><name>get_attnum</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>info</name><operator>-&gt;</operator><name>ht_rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>column_name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>AttrNumber</name></type> <name>chunk_attno</name> <init>= <expr><call><name>get_attnum</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>info</name><operator>-&gt;</operator><name>chunk_rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>column_name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>hypertable_attno</name> <operator>!=</operator> <name>InvalidAttrNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>chunk_attno</name> <operator>!=</operator> <name>InvalidAttrNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * The versions older than this commit didn't set up the proper
			 * collation and typmod for segmentby columns in compressed chunks,
			 * so we have to determine them from the main hypertable.
			 * Additionally, we have to set the proper type for the compressed
			 * columns. It would be cool to get rid of this code someday and
			 * just use the types from the compressed chunk, but the problem is
			 * that we have to support the chunks created by the older versions
			 * of TimescaleDB.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>compression_info</name><operator>-&gt;</operator><name>algo_id</name></name> <operator>==</operator> <name>_INVALID_COMPRESSION_ALGORITHM</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>get_atttypetypmodcoll</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>info</name><operator>-&gt;</operator><name>ht_rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,
									  <argument><expr><name>hypertable_attno</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name><name>var</name><operator>-&gt;</operator><name>vartype</name></name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name><name>var</name><operator>-&gt;</operator><name>vartypmod</name></name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name><name>var</name><operator>-&gt;</operator><name>varcollid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><literal type="number">0</literal> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>, <argument><expr><name>chunk_attrs_needed</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * attno = 0 means whole-row var. Output all the columns.
				 */</comment>
				<expr_stmt><expr><name>destination_attno_in_uncompressed_chunk</name> <operator>=</operator> <name>chunk_attno</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>chunk_attrs_found</name> <operator>=</operator>
					<call><name>bms_add_member</name><argument_list>(<argument><expr><name>chunk_attrs_found</name></expr></argument>,
								   <argument><expr><name>chunk_attno</name> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>chunk_attno</name> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>,
								   <argument><expr><name>chunk_attrs_needed</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>destination_attno_in_uncompressed_chunk</name> <operator>=</operator> <name>chunk_attno</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>chunk_attrs_found</name> <operator>=</operator>
					<call><name>bms_add_member</name><argument_list>(<argument><expr><name>chunk_attrs_found</name></expr></argument>,
								   <argument><expr><name>chunk_attno</name> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Metadata column.
			 * We always need count column, and sometimes a sequence number
			 * column. We don't output them, but use them for decompression,
			 * hence the special negative destination attnos.
			 * The min/max metadata columns are normally not required for output
			 * or decompression, they are used only as filter for the compressed
			 * scan, so we skip them here.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>strncmp</name><argument_list>(<argument><expr><name>column_name</name></expr></argument>,
						   <argument><expr><name>COMPRESSION_COLUMN_METADATA_PREFIX</name></expr></argument>,
						   <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>COMPRESSION_COLUMN_METADATA_PREFIX</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>column_name</name></expr></argument>, <argument><expr><name>COMPRESSION_COLUMN_METADATA_COUNT_NAME</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>destination_attno_in_uncompressed_chunk</name> <operator>=</operator> <name>DECOMPRESS_CHUNK_COUNT_ID</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>missing_count</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>path</name><operator>-&gt;</operator><name>needs_sequence_num</name></name> <operator>&amp;&amp;</operator>
					 <call><name>strcmp</name><argument_list>(<argument><expr><name>column_name</name></expr></argument>, <argument><expr><name>COMPRESSION_COLUMN_METADATA_SEQUENCE_NUM_NAME</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>destination_attno_in_uncompressed_chunk</name> <operator>=</operator> <name>DECOMPRESS_CHUNK_SEQUENCE_NUM_ID</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>missing_sequence</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>decompression_map</name></name> <operator>=</operator>
			<call><name>lappend_int</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>decompression_map</name></name></expr></argument>, <argument><expr><name>destination_attno_in_uncompressed_chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Check that we have found all the needed columns in the scan targetlist.
	 * We can't conveniently check that we have all columns for all-row vars, so
	 * skip attno 0 in this check.
	 */</comment>
	<decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>attrs_not_found</name> <init>= <expr><call><name>bms_difference</name><argument_list>(<argument><expr><name>chunk_attrs_needed</name></expr></argument>, <argument><expr><name>chunk_attrs_found</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>bit</name> <init>= <expr><call><name>bms_next_member</name><argument_list>(<argument><expr><name>attrs_not_found</name></expr></argument>, <argument><expr><literal type="number">0</literal> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>bit</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			 <argument><expr><literal type="string">"column '%s' (%d) not found in the scan targetlist for compressed chunk '%s'"</literal></expr></argument>,
			 <argument><expr><call><name>get_attname</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>info</name><operator>-&gt;</operator><name>chunk_rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,
						 <argument><expr><name>bit</name> <operator>+</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>,
						 <comment type="block">/* missing_ok = */</comment> <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>,
			 <argument><expr><name>bit</name> <operator>+</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>,
			 <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>info</name><operator>-&gt;</operator><name>compressed_rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>missing_count</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"the count column was not found in the compressed scan targetlist"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>missing_sequence</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"the sequence column was not found in the compressed scan targetlist"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* replace vars that reference the compressed table with ones that reference the
 * uncompressed one. Based on replace_nestloop_params
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>replace_compressed_vars</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>CompressionInfo</name> <modifier>*</modifier></type><name>info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>new_var</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>colname</name></decl>;</decl_stmt>

		<comment type="block">/* constify tableoid in quals */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>Index</name><operator>)</operator> <name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name><name>info</name><operator>-&gt;</operator><name>chunk_rel</name><operator>-&gt;</operator><name>relid</name></name> <operator>&amp;&amp;</operator>
			<name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <name>TableOidAttributeNumber</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator>
				<call><name>makeConst</name><argument_list>(<argument><expr><name>OIDOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <name><name>info</name><operator>-&gt;</operator><name>chunk_rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* Upper-level Vars should be long gone at this point */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* If not to be replaced, we can just return the Var unmodified */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>Index</name><operator>)</operator> <name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>!=</operator> <name><name>info</name><operator>-&gt;</operator><name>compressed_rel</name><operator>-&gt;</operator><name>relid</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>node</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* Create a decompressed Var to replace the compressed one */</comment>
		<expr_stmt><expr><name>colname</name> <operator>=</operator> <call><name>get_attname</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>compressed_rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>new_var</name> <operator>=</operator> <call><name>makeVar</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>chunk_rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,
						  <argument><expr><call><name>get_attnum</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>chunk_rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name><name>var</name><operator>-&gt;</operator><name>vartype</name></name></expr></argument>,
						  <argument><expr><name><name>var</name><operator>-&gt;</operator><name>vartypmod</name></name></expr></argument>,
						  <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varcollid</name></name></expr></argument>,
						  <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AttributeNumberIsValid</name><argument_list>(<argument><expr><name><name>new_var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot find column %s on decompressed chunk"</literal></expr></argument>, <argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* And return the replacement var */</comment>
		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>new_var</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>PlaceHolderVar</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"ignoring placeholders"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><call><name>expression_tree_mutator</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>replace_compressed_vars</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>info</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <name>CompressedAttnoContext</name>
<block>{
	<decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>compressed_attnos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type> <name>compress_relid</name></decl>;</decl_stmt>
}</block></struct></type> <name>CompressedAttnoContext</name>;</typedef>

<comment type="block">/* check if the clause refers to any attributes that are in compressed
 * form.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>clause_has_compressed_attrs</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CompressedAttnoContext</name> <modifier>*</modifier></type><name>cxt</name> <init>= <expr><operator>(</operator><name>CompressedAttnoContext</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>Index</name><operator>)</operator> <name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name><name>cxt</name><operator>-&gt;</operator><name>compress_relid</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>, <argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>compressed_attnos</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>clause_has_compressed_attrs</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Plan</name> <modifier>*</modifier></type>
<name>decompress_chunk_plan_create</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>CustomPath</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
							 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>decompressed_tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>clauses</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>custom_plans</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DecompressChunkPath</name> <modifier>*</modifier></type><name>dcpath</name> <init>= <expr><operator>(</operator><name>DecompressChunkPath</name> <operator>*</operator><operator>)</operator> <name>path</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CustomScan</name> <modifier>*</modifier></type><name>decompress_plan</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CustomScan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Scan</name> <modifier>*</modifier></type><name>compressed_scan</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name>custom_plans</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name> <modifier>*</modifier></type><name>compressed_path</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>custom_paths</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>settings</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>custom_plans</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>custom_paths</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>decompress_plan</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator><name>flags</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>decompress_plan</name><operator>-&gt;</operator><name>methods</name></name> <operator>=</operator> <operator>&amp;</operator><name>decompress_chunk_plan_methods</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>decompress_plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>=</operator> <name><name>dcpath</name><operator>-&gt;</operator><name>info</name><operator>-&gt;</operator><name>chunk_rel</name><operator>-&gt;</operator><name>relid</name></name></expr>;</expr_stmt>

	<comment type="block">/* output target list */</comment>
	<expr_stmt><expr><name><name>decompress_plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <name>decompressed_tlist</name></expr>;</expr_stmt>
	<comment type="block">/* input target list */</comment>
	<expr_stmt><expr><name><name>decompress_plan</name><operator>-&gt;</operator><name>custom_scan_tlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>compressed_path</name></expr></argument>, <argument><expr><name>IndexPath</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* from create_indexscan_plan() */</comment>
		<decl_stmt><decl><type><name>IndexPath</name> <modifier>*</modifier></type><name>ipath</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>IndexPath</name></expr></argument>, <argument><expr><name>compressed_path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>indexqual</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>indexplan</name></decl>;</decl_stmt>
		<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>clauses</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RestrictInfo</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>is_redundant_derived_clause</name><argument_list>(<argument><expr><name>rinfo</name></expr></argument>, <argument><expr><name><name>ipath</name><operator>-&gt;</operator><name>indexclauses</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt> <comment type="block">/* dup or derived from same EquivalenceClass */</comment>
			<expr_stmt><expr><name><name>decompress_plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name> <operator>=</operator>
				<call><name>lappend</name><argument_list>(<argument><expr><name><name>decompress_plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name></expr></argument>, <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<comment type="block">/* joininfo clauses on the compressed chunk rel have to
		 * contain clauses on both compressed and
		 * decompressed attnos. joininfo clauses get translated into
		 * ParamPathInfo for the indexpath. But the index scans can't
		 * handle compressed attributes, so remove them from the
		 * indexscans here. (these are included in the `clauses` passed in
		 * to the function and so were added as filters
		 * for decompress_plan-&gt;scan.plan.qual in the loop above. )
		 */</comment>
		<expr_stmt><expr><name>indexplan</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>custom_plans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>indexplan</name></expr></argument>, <argument><expr><name>IndexScan</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>indexplan</name></expr></argument>, <argument><expr><name>IndexOnlyScan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>indexplan-&gt;qual</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>CompressedAttnoContext</name></type> <name>cxt</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Index</name></type> <name>compress_relid</name> <init>= <expr><name><name>dcpath</name><operator>-&gt;</operator><name>info</name><operator>-&gt;</operator><name>compressed_rel</name><operator>-&gt;</operator><name>relid</name></name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>compress_relid</name></name> <operator>=</operator> <name>compress_relid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>compressed_attnos</name></name> <operator>=</operator> <name><name>dcpath</name><operator>-&gt;</operator><name>info</name><operator>-&gt;</operator><name>compressed_chunk_compressed_attnos</name></name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>clause_has_compressed_attrs</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cxt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>indexqual</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>indexqual</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>
		<expr_stmt><expr><name><name>indexplan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>indexqual</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>clauses</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RestrictInfo</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>decompress_plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name> <operator>=</operator>
				<call><name>lappend</name><argument_list>(<argument><expr><name><name>decompress_plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name></expr></argument>, <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>decompress_plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name> <operator>=</operator>
		<operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>replace_compressed_vars</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>decompress_plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name></expr></argument>, <argument><expr><name><name>dcpath</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Try to use a physical tlist if possible. There's no reason to do the
	 * extra work of projecting the result of compressed chunk scan, because
	 * DecompressChunk can choose only the needed columns itself.
	 * Note that Postgres uses the CP_EXACT_TLIST option when planning the child
	 * paths of the Custom path, so we won't automatically get a phsyical tlist
	 * here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>compressed_path</name><operator>-&gt;</operator><name>pathtype</name></name> <operator>==</operator> <name>T_IndexOnlyScan</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>compressed_scan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>IndexPath</name> <operator>*</operator><operator>)</operator> <name>compressed_path</name><operator>)</operator><operator>-&gt;</operator><name><name>indexinfo</name><operator>-&gt;</operator><name>indextlist</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>physical_tlist</name> <init>= <expr><call><name>build_physical_tlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>dcpath</name><operator>-&gt;</operator><name>info</name><operator>-&gt;</operator><name>compressed_rel</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="block">/* Can be null if the relation has dropped columns. */</comment>
		<if_stmt><if>if <condition>(<expr><name>physical_tlist</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>compressed_scan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <name>physical_tlist</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Determine which columns we have to decompress.
	 * decompressed_tlist is sometimes empty, e.g. for a direct select from
	 * chunk. We have a ProjectionPath above DecompressChunk in this case, and
	 * the targetlist for this path is not built by the planner
	 * (CP_IGNORE_TLIST). This is why we have to examine rel pathtarget.
	 * Looking at the targetlist is not enough, we also have to decompress the
	 * columns participating in quals and in pathkeys.
	 */</comment>
	<decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>chunk_attrs_needed</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>pull_varattnos</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>decompress_plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name></expr></argument>,
				   <argument><expr><name><name>dcpath</name><operator>-&gt;</operator><name>info</name><operator>-&gt;</operator><name>chunk_rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,
				   <argument><expr><operator>&amp;</operator><name>chunk_attrs_needed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pull_varattnos</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>dcpath</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>pathtarget</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>,
				   <argument><expr><name><name>dcpath</name><operator>-&gt;</operator><name>info</name><operator>-&gt;</operator><name>chunk_rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,
				   <argument><expr><operator>&amp;</operator><name>chunk_attrs_needed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Determine which compressed colum goes to which output column.
	 */</comment>
	<expr_stmt><expr><call><name>build_decompression_map</name><argument_list>(<argument><expr><name>dcpath</name></expr></argument>, <argument><expr><name><name>compressed_scan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>, <argument><expr><name>chunk_attrs_needed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Add a sort if the compressed scan is not ordered appropriately.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pathkeys_contained_in</name><argument_list>(<argument><expr><name><name>dcpath</name><operator>-&gt;</operator><name>compressed_pathkeys</name></name></expr></argument>, <argument><expr><name><name>compressed_path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>compressed_pks</name> <init>= <expr><name><name>dcpath</name><operator>-&gt;</operator><name>compressed_pathkeys</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Sort</name> <modifier>*</modifier></type><name>sort</name> <init>= <expr><call><name>ts_make_sort_from_pathkeys</name><argument_list>(<argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>compressed_scan</name></expr></argument>,
												<argument><expr><name>compressed_pks</name></expr></argument>,
												<argument><expr><call><name>bms_make_singleton</name><argument_list>(<argument><expr><name><name>compressed_scan</name><operator>-&gt;</operator><name>scanrelid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>decompress_plan</name><operator>-&gt;</operator><name>custom_plans</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>sort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>decompress_plan</name><operator>-&gt;</operator><name>custom_plans</name></name> <operator>=</operator> <name>custom_plans</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>custom_plans</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>settings</name> <operator>=</operator> <call><name>list_make3_int</name><argument_list>(<argument><expr><name><name>dcpath</name><operator>-&gt;</operator><name>info</name><operator>-&gt;</operator><name>hypertable_id</name></name></expr></argument>,
							  <argument><expr><name><name>dcpath</name><operator>-&gt;</operator><name>info</name><operator>-&gt;</operator><name>chunk_rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,
							  <argument><expr><name><name>dcpath</name><operator>-&gt;</operator><name>reverse</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>decompress_plan</name><operator>-&gt;</operator><name>custom_private</name></name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><name>settings</name></expr></argument>, <argument><expr><name><name>dcpath</name><operator>-&gt;</operator><name>decompression_map</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>&amp;</operator><name><name>decompress_plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name></name></expr>;</return>
</block_content>}</block></function>
</unit>
