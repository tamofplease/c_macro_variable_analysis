<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/timescaledb/tsl/src/nodes/decompress_chunk/decompress_chunk.c"><comment type="block">/*
 * This file and its contents are licensed under the Timescale License.
 * Please see the included NOTICE for copyright information and
 * LICENSE-TIMESCALE for a copy of the license.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postgres.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_operator.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;miscadmin.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/bitmapset.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/makefuncs.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/nodeFuncs.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/cost.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/optimizer.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/pathnode.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/paths.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;parser/parsetree.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/builtins.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/lsyscache.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/typcache.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;planner.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ts_catalog/hypertable_compression.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"import/planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compression/create.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/decompress_chunk/decompress_chunk.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/decompress_chunk/planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/decompress_chunk/qual_pushdown.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DECOMPRESS_CHUNK_CPU_TUPLE_COST</name></cpp:macro> <cpp:value>0.01</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DECOMPRESS_CHUNK_BATCH_SIZE</name></cpp:macro> <cpp:value>1000</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>CustomPathMethods</name></type> <name>decompress_chunk_path_methods</name> <init>= <expr><block>{
	<expr><operator>.</operator><name>CustomName</name> <operator>=</operator> <literal type="string">"DecompressChunk"</literal></expr>,
	<expr><operator>.</operator><name>PlanCustomPath</name> <operator>=</operator> <name>decompress_chunk_plan_create</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<typedef>typedef <type><struct>struct <name>SortInfo</name>
<block>{
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>compressed_pathkeys</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>needs_sequence_num</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>can_pushdown_sort</name></decl>;</decl_stmt> <comment type="block">/* sort can be pushed below DecompressChunk */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>reverse</name></decl>;</decl_stmt>
}</block></struct></type> <name>SortInfo</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>RangeTblEntry</name> <modifier>*</modifier></type><name>decompress_chunk_make_rte</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>compressed_relid</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>create_compressed_scan_paths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>compressed_rel</name></decl></parameter>,
										 <parameter><decl><type><name>int</name></type> <name>parallel_workers</name></decl></parameter>, <parameter><decl><type><name>CompressionInfo</name> <modifier>*</modifier></type><name>info</name></decl></parameter>,
										 <parameter><decl><type><name>SortInfo</name> <modifier>*</modifier></type><name>sort_info</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>DecompressChunkPath</name> <modifier>*</modifier></type><name>decompress_chunk_path_create</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>CompressionInfo</name> <modifier>*</modifier></type><name>info</name></decl></parameter>,
														 <parameter><decl><type><name>int</name></type> <name>parallel_workers</name></decl></parameter>,
														 <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>compressed_path</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>decompress_chunk_add_plannerinfo</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>CompressionInfo</name> <modifier>*</modifier></type><name>info</name></decl></parameter>, <parameter><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>,
											 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>chunk_rel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>needs_sequence_num</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>SortInfo</name></type> <name>build_sortinfo</name><parameter_list>(<parameter><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>chunk_rel</name></decl></parameter>, <parameter><decl><type><name>CompressionInfo</name> <modifier>*</modifier></type><name>info</name></decl></parameter>,
							   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_compressed_column</name><parameter_list>(<parameter><decl><type><name>CompressionInfo</name> <modifier>*</modifier></type><name>info</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>attno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>column_name</name> <init>= <expr><call><name>get_attname</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>compressed_rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>attno</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FormData_hypertable_compression</name> <modifier>*</modifier></type><name>column_info</name> <init>=
		<expr><call><name>get_column_compressioninfo</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>hypertable_compression_info</name></name></expr></argument>, <argument><expr><name>column_name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name><name>column_info</name><operator>-&gt;</operator><name>algo_id</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Like ts_make_pathkey_from_sortop but passes down the compressed relid so that existing
 * equivalence members that are marked as childen are properly checked.
 */</comment>
<function><type><specifier>static</specifier> <name>PathKey</name> <modifier>*</modifier></type>
<name>make_pathkey_from_compressed</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>compressed_relid</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>ordering_op</name></decl></parameter>,
							 <parameter><decl><type><name>bool</name></type> <name>nulls_first</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>opfamily</name></decl>, <decl><type ref="prev"/><name>opcintype</name></decl>, <decl><type ref="prev"/><name>collation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type> <name>strategy</name></decl>;</decl_stmt>

	<comment type="block">/* Find the operator in pg_amop --- failure shouldn't happen */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>get_ordering_op_properties</name><argument_list>(<argument><expr><name>ordering_op</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opfamily</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opcintype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>strategy</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"operator %u is not a valid ordering operator"</literal></expr></argument>, <argument><expr><name>ordering_op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Because SortGroupClause doesn't carry collation, consult the expr */</comment>
	<expr_stmt><expr><name>collation</name> <operator>=</operator> <call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>compressed_relid</name> <operator>&lt;</operator> <operator>(</operator><name>Index</name><operator>)</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rel_array_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>ts_make_pathkey_from_sortinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										 <argument><expr><name>expr</name></expr></argument>,
										 <argument><expr><name>NULL</name></expr></argument>,
										 <argument><expr><name>opfamily</name></expr></argument>,
										 <argument><expr><name>opcintype</name></expr></argument>,
										 <argument><expr><name>collation</name></expr></argument>,
										 <argument><expr><operator>(</operator><name>strategy</name> <operator>==</operator> <name>BTGreaterStrategyNumber</name><operator>)</operator></expr></argument>,
										 <argument><expr><name>nulls_first</name></expr></argument>,
										 <argument><expr><literal type="number">0</literal></expr></argument>,
										 <argument><expr><call><name>bms_make_singleton</name><argument_list>(<argument><expr><name>compressed_relid</name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>prepend_ec_for_seqnum</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>CompressionInfo</name> <modifier>*</modifier></type><name>info</name></decl></parameter>, <parameter><decl><type><name>SortInfo</name> <modifier>*</modifier></type><name>sort_info</name></decl></parameter>, <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name></decl></parameter>,
					  <parameter><decl><type><name>Oid</name></type> <name>sortop</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>nulls_first</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>planner_cxt</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>opfamily</name></decl>, <decl><type ref="prev"/><name>opcintype</name></decl>, <decl><type ref="prev"/><name>equality_op</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type> <name>strategy</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>opfamilies</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>newec</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>EquivalenceClass</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>em</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>EquivalenceMember</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Find the operator in pg_amop --- failure shouldn't happen */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>get_ordering_op_properties</name><argument_list>(<argument><expr><name>sortop</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opfamily</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opcintype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>strategy</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"operator %u is not a valid ordering operator"</literal></expr></argument>, <argument><expr><name>sortop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * EquivalenceClasses need to contain opfamily lists based on the family
	 * membership of mergejoinable equality operators, which could belong to
	 * more than one opfamily.  So we have to look up the opfamily's equality
	 * operator and get its membership.
	 */</comment>
	<expr_stmt><expr><name>equality_op</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>, <argument><expr><name>opcintype</name></expr></argument>, <argument><expr><name>opcintype</name></expr></argument>, <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>equality_op</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* shouldn't happen */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			 <argument><expr><literal type="string">"missing operator %d(%u,%u) in opfamily %u"</literal></expr></argument>,
			 <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
			 <argument><expr><name>opcintype</name></expr></argument>,
			 <argument><expr><name>opcintype</name></expr></argument>,
			 <argument><expr><name>opfamily</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>opfamilies</name> <operator>=</operator> <call><name>get_mergejoin_opfamilies</name><argument_list>(<argument><expr><name>equality_op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>opfamilies</name></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* certainly should find some */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find opfamilies for equality operator %u"</literal></expr></argument>, <argument><expr><name>equality_op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>em</name><operator>-&gt;</operator><name>em_expr</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>var</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>em</name><operator>-&gt;</operator><name>em_relids</name></name> <operator>=</operator> <call><name>bms_make_singleton</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>compressed_rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>em</name><operator>-&gt;</operator><name>em_nullable_relids</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>em</name><operator>-&gt;</operator><name>em_is_const</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>em</name><operator>-&gt;</operator><name>em_is_child</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>em</name><operator>-&gt;</operator><name>em_datatype</name></name> <operator>=</operator> <name>INT4OID</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>newec</name><operator>-&gt;</operator><name>ec_opfamilies</name></name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name>opfamilies</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newec</name><operator>-&gt;</operator><name>ec_collation</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newec</name><operator>-&gt;</operator><name>ec_members</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>em</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newec</name><operator>-&gt;</operator><name>ec_sources</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newec</name><operator>-&gt;</operator><name>ec_derives</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newec</name><operator>-&gt;</operator><name>ec_relids</name></name> <operator>=</operator> <call><name>bms_make_singleton</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>compressed_rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newec</name><operator>-&gt;</operator><name>ec_has_const</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newec</name><operator>-&gt;</operator><name>ec_has_volatile</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newec</name><operator>-&gt;</operator><name>ec_below_outer_join</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newec</name><operator>-&gt;</operator><name>ec_broken</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newec</name><operator>-&gt;</operator><name>ec_sortref</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newec</name><operator>-&gt;</operator><name>ec_min_security</name></name> <operator>=</operator> <name>UINT_MAX</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newec</name><operator>-&gt;</operator><name>ec_max_security</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newec</name><operator>-&gt;</operator><name>ec_merged</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* Prepend the ec */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG13_GE</name></expr></cpp:if>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>eq_classes</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>eq_classes</name></name></expr></argument>, <argument><expr><name>newec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>eq_classes</name></name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>newec</name></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>eq_classes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>build_compressed_scan_pathkeys</name><parameter_list>(<parameter><decl><type><name>SortInfo</name> <modifier>*</modifier></type><name>sort_info</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>chunk_pathkeys</name></decl></parameter>,
							   <parameter><decl><type><name>CompressionInfo</name> <modifier>*</modifier></type><name>info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>varattno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>compressed_pathkeys</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PathKey</name> <modifier>*</modifier></type><name>pk</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * all segmentby columns need to be prefix of pathkeys
	 * except those with equality constraint in baserestrictinfo
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>num_segmentby_columns</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>segmentby_columns</name> <init>= <expr><call><name>bms_copy</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>chunk_segmentby_ri</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>column_name</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>sortop</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>opfamily</name></decl>, <decl><type ref="prev"/><name>opcintype</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int16</name></type> <name>strategy</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>lc</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>chunk_pathkeys</name></expr></argument>)</argument_list></call></expr>;</init>
			 <condition><expr><name>lc</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>bms_num_members</name><argument_list>(<argument><expr><name>segmentby_columns</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name><name>info</name><operator>-&gt;</operator><name>num_segmentby_columns</name></name></expr>;</condition>
			 <incr><expr><name>lc</name> <operator>=</operator> <call><name>lnext_compat</name><argument_list>(<argument><expr><name>chunk_pathkeys</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PathKey</name> <modifier>*</modifier></type><name>pk</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>find_em_expr_for_rel</name><argument_list>(<argument><expr><name><name>pk</name><operator>-&gt;</operator><name>pk_eclass</name></name></expr></argument>, <argument><expr><name><name>info</name><operator>-&gt;</operator><name>chunk_rel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>var</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<comment type="block">/* this should not happen because we validated the pathkeys when creating the path
				 */</comment>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Invalid pathkey for compressed scan"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* not a segmentby column, rest of pathkeys should be handled by compress_orderby */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>, <argument><expr><name><name>info</name><operator>-&gt;</operator><name>chunk_segmentby_attnos</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<comment type="block">/* skip duplicate references */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>, <argument><expr><name>segmentby_columns</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>column_name</name> <operator>=</operator> <call><name>get_attname</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>chunk_rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>segmentby_columns</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>segmentby_columns</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>varattno</name> <operator>=</operator> <call><name>get_attnum</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>compressed_rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>column_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>makeVar</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>compressed_rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,
						  <argument><expr><name>varattno</name></expr></argument>,
						  <argument><expr><name><name>var</name><operator>-&gt;</operator><name>vartype</name></name></expr></argument>,
						  <argument><expr><name><name>var</name><operator>-&gt;</operator><name>vartypmod</name></name></expr></argument>,
						  <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varcollid</name></name></expr></argument>,
						  <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>sortop</name> <operator>=</operator>
				<call><name>get_opfamily_member</name><argument_list>(<argument><expr><name><name>pk</name><operator>-&gt;</operator><name>pk_opfamily</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>vartype</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>vartype</name></name></expr></argument>, <argument><expr><name><name>pk</name><operator>-&gt;</operator><name>pk_strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>get_ordering_op_properties</name><argument_list>(<argument><expr><name>sortop</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opfamily</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opcintype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>strategy</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>type_is_enum</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>vartype</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>sortop</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name><name>pk</name><operator>-&gt;</operator><name>pk_opfamily</name></name></expr></argument>,
												 <argument><expr><name>ANYENUMOID</name></expr></argument>,
												 <argument><expr><name>ANYENUMOID</name></expr></argument>,
												 <argument><expr><name><name>pk</name><operator>-&gt;</operator><name>pk_strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"sort operator lookup failed for column \"%s\""</literal></expr></argument>, <argument><expr><name>column_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>pk</name> <operator>=</operator> <call><name>make_pathkey_from_compressed</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											  <argument><expr><name><name>info</name><operator>-&gt;</operator><name>compressed_rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,
											  <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></argument>,
											  <argument><expr><name>sortop</name></expr></argument>,
											  <argument><expr><name><name>pk</name><operator>-&gt;</operator><name>pk_nulls_first</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>compressed_pathkeys</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>compressed_pathkeys</name></expr></argument>, <argument><expr><name>pk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/* we validated this when we created the Path so only asserting here */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>bms_num_members</name><argument_list>(<argument><expr><name>segmentby_columns</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>info</name><operator>-&gt;</operator><name>num_segmentby_columns</name></name> <operator>||</operator>
			   <call><name>list_length</name><argument_list>(<argument><expr><name>compressed_pathkeys</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>chunk_pathkeys</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If pathkeys contains non-segmentby columns the rest of the ordering
	 * requirements will be satisfied by ordering by sequence_num
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>sort_info</name><operator>-&gt;</operator><name>needs_sequence_num</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>nulls_first</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>sortop</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>varattno</name> <operator>=</operator>
			<call><name>get_attnum</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>compressed_rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>COMPRESSION_COLUMN_METADATA_SEQUENCE_NUM_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>makeVar</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>compressed_rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>varattno</name></expr></argument>, <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>sort_info</name><operator>-&gt;</operator><name>reverse</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>sortop</name> <operator>=</operator> <call><name>get_commutator</name><argument_list>(<argument><expr><name>Int4LessOperator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>nulls_first</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>sortop</name> <operator>=</operator> <name>Int4LessOperator</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>nulls_first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Prepend the ec class for the sequence number. We are prepending
		 * the ec for efficiency in finding it. We are more likely to look for it
		 * then other ec classes */</comment>
		<expr_stmt><expr><call><name>prepend_ec_for_seqnum</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>info</name></expr></argument>, <argument><expr><name>sort_info</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><name>sortop</name></expr></argument>, <argument><expr><name>nulls_first</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>pk</name> <operator>=</operator> <call><name>make_pathkey_from_compressed</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										  <argument><expr><name><name>info</name><operator>-&gt;</operator><name>compressed_rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,
										  <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></argument>,
										  <argument><expr><name>sortop</name></expr></argument>,
										  <argument><expr><name>nulls_first</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>compressed_pathkeys</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>compressed_pathkeys</name></expr></argument>, <argument><expr><name>pk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>sort_info</name><operator>-&gt;</operator><name>compressed_pathkeys</name></name> <operator>=</operator> <name>compressed_pathkeys</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DecompressChunkPath</name> <modifier>*</modifier></type>
<name>copy_decompress_chunk_path</name><parameter_list>(<parameter><decl><type><name>DecompressChunkPath</name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DecompressChunkPath</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DecompressChunkPath</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DecompressChunkPath</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>dst</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>CompressionInfo</name> <modifier>*</modifier></type>
<name>build_compressioninfo</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>chunk_rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CompressionInfo</name> <modifier>*</modifier></type><name>info</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CompressionInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>chunk_rel</name></name> <operator>=</operator> <name>chunk_rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>chunk_rte</name></name> <operator>=</operator> <call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name><name>chunk_rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>chunk_rel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>==</operator> <name>RELOPT_OTHER_MEMBER_REL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>appinfo</name> <operator>=</operator> <call><name>ts_get_appendrelinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>chunk_rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>ht_rte</name></name> <operator>=</operator> <call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name><name>appinfo</name><operator>-&gt;</operator><name>parent_relid</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>chunk_rel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>==</operator> <name>RELOPT_BASEREL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>single_chunk</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>ht_rte</name></name> <operator>=</operator> <name><name>info</name><operator>-&gt;</operator><name>chunk_rte</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>hypertable_id</name></name> <operator>=</operator> <name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>hypertable_compression_info</name></name> <operator>=</operator> <call><name>ts_hypertable_compression_get</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>info-&gt;hypertable_compression_info</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FormData_hypertable_compression</name> <modifier>*</modifier></type><name>fd</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>fd</name><operator>-&gt;</operator><name>orderby_column_index</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>num_orderby_columns</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>fd</name><operator>-&gt;</operator><name>segmentby_column_index</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AttrNumber</name></type> <name>chunk_attno</name> <init>= <expr><call><name>get_attnum</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>chunk_rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>fd</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>chunk_segmentby_attnos</name></name> <operator>=</operator>
				<call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>chunk_segmentby_attnos</name></name></expr></argument>, <argument><expr><name>chunk_attno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>num_segmentby_columns</name></name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>info</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * calculate cost for DecompressChunkPath
 *
 * since we have to read whole batch before producing tuple
 * we put cost of 1 tuple of compressed_scan as startup cost
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>cost_decompress_chunk</name><parameter_list>(<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>compressed_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* startup_cost is cost before fetching first tuple */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>compressed_path</name><operator>-&gt;</operator><name>rows</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>compressed_path</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>/</operator> <name><name>compressed_path</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* total_cost is cost for fetching all tuples */</comment>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>=</operator> <name><name>compressed_path</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>+</operator> <name><name>path</name><operator>-&gt;</operator><name>rows</name></name> <operator>*</operator> <name>DECOMPRESS_CHUNK_CPU_TUPLE_COST</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <name><name>compressed_path</name><operator>-&gt;</operator><name>rows</name></name> <operator>*</operator> <name>DECOMPRESS_CHUNK_BATCH_SIZE</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ts_decompress_chunk_generate_paths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>chunk_rel</name></decl></parameter>, <parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>,
								   <parameter><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>compressed_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>new_row_estimate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type> <name>ht_relid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>CompressionInfo</name> <modifier>*</modifier></type><name>info</name> <init>= <expr><call><name>build_compressioninfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>ht</name></expr></argument>, <argument><expr><name>chunk_rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* double check we don't end up here on single chunk queries with ONLY */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>chunk_rel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>==</operator> <name>RELOPT_OTHER_MEMBER_REL</name> <operator>||</operator>
		   <operator>(</operator><name><name>info</name><operator>-&gt;</operator><name>chunk_rel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>==</operator> <name>RELOPT_BASEREL</name> <operator>&amp;&amp;</operator>
			<call><name>ts_rte_is_marked_for_expansion</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>chunk_rte</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * since we rely on parallel coordination from the scan below
	 * this node it is probably not beneficial to have more
	 * than a single worker per chunk
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>parallel_workers</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SortInfo</name></type> <name>sort_info</name> <init>= <expr><call><name>build_sortinfo</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>chunk_rel</name></expr></argument>, <argument><expr><name>info</name></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>query_pathkeys</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>compressed_chunk_id</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>chunk_rel</name><operator>-&gt;</operator><name>pathlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>chunk_rel</name><operator>-&gt;</operator><name>partial_pathlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<comment type="block">/* add RangeTblEntry and RelOptInfo for compressed chunk */</comment>
	<expr_stmt><expr><call><name>decompress_chunk_add_plannerinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>info</name></expr></argument>, <argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>chunk_rel</name></expr></argument>, <argument><expr><name><name>sort_info</name><operator>.</operator><name>needs_sequence_num</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>compressed_rel</name> <operator>=</operator> <name><name>info</name><operator>-&gt;</operator><name>compressed_rel</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>compressed_rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>=</operator> <name><name>chunk_rel</name><operator>-&gt;</operator><name>consider_parallel</name></name></expr>;</expr_stmt>
	<comment type="block">/* translate chunk_rel-&gt;baserestrictinfo */</comment>
	<expr_stmt><expr><call><name>pushdown_quals</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>chunk_rel</name></expr></argument>, <argument><expr><name>compressed_rel</name></expr></argument>, <argument><expr><name><name>info</name><operator>-&gt;</operator><name>hypertable_compression_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_baserel_size_estimates</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>compressed_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>new_row_estimate</name> <operator>=</operator> <name><name>compressed_rel</name><operator>-&gt;</operator><name>rows</name></name> <operator>*</operator> <name>DECOMPRESS_CHUNK_BATCH_SIZE</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>info</name><operator>-&gt;</operator><name>single_chunk</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* adjust the parent's estimate by the diff of new and old estimate */</comment>
		<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>chunk_info</name> <init>= <expr><call><name>ts_get_appendrelinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>chunk_rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>chunk_info</name><operator>-&gt;</operator><name>parent_reloid</name></name> <operator>==</operator> <name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ht_relid</name> <operator>=</operator> <name><name>chunk_info</name><operator>-&gt;</operator><name>parent_relid</name></name></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>hypertable_rel</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>simple_rel_array</name><index>[<expr><name>ht_relid</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>hypertable_rel</name><operator>-&gt;</operator><name>rows</name></name> <operator>+=</operator> <operator>(</operator><name>new_row_estimate</name> <operator>-</operator> <name><name>chunk_rel</name><operator>-&gt;</operator><name>rows</name></name><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>chunk_rel</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <name>new_row_estimate</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>create_compressed_scan_paths</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
								 <argument><expr><name>compressed_rel</name></expr></argument>,
								 <argument><expr><ternary><condition><expr><name><name>compressed_rel</name><operator>-&gt;</operator><name>consider_parallel</name></name></expr> ?</condition><then> <expr><name>parallel_workers</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>,
								 <argument><expr><name>info</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>sort_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* compute parent relids of the chunk and use it to filter paths*/</comment>
	<decl_stmt><decl><type><name>Relids</name></type> <name>parent_relids</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>info</name><operator>-&gt;</operator><name>single_chunk</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>parent_relids</name> <operator>=</operator> <call><name>find_childrel_parents</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>chunk_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* create non-parallel paths */</comment>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>compressed_rel-&gt;pathlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Path</name> <modifier>*</modifier></type><name>child_path</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DecompressChunkPath</name> <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * We skip any BitmapScan paths here as supporting those
		 * would require fixing up the internal scan. Since we
		 * currently do not do this BitmapScans would be generated
		 * when we have a parameterized path on a compressed column
		 * that would have invalid references due to our
		 * EquivalenceClasses.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>child_path</name></expr></argument>, <argument><expr><name>BitmapHeapPath</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Filter out all paths that try to JOIN the compressed chunk on the
		 * hypertable or the uncompressed chunk
		 * Ideally, we wouldn't create these paths in the first place.
		 * However, create_join_clause code is called by PG while generating paths for the
		 * compressed_rel via generate_implied_equalities_for_column.
		 * create_join_clause ends up creating rinfo's between compressed_rel and ht because
		 * PG does not know that compressed_rel is related to ht in anyway.
		 * The parent-child relationship between chunk_rel and ht is known
		 * to PG and so it does not try to create meaningless rinfos for that case.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>child_path</name><operator>-&gt;</operator><name>param_info</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>chunk_rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name><name>child_path</name><operator>-&gt;</operator><name>param_info</name><operator>-&gt;</operator><name>ppi_req_outer</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<comment type="block">/* check if this is path made with references between
			 * compressed_rel + hypertable or a nesting subquery.
			 * The latter can happen in the case of UNION queries. see github 2917. This
			 * happens since PG is not aware that the nesting
			 * subquery that references the hypertable is a parent of compressed_rel as well.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>bms_overlap</name><argument_list>(<argument><expr><name>parent_relids</name></expr></argument>, <argument><expr><name><name>child_path</name><operator>-&gt;</operator><name>param_info</name><operator>-&gt;</operator><name>ppi_req_outer</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc_ri</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type> <name>references_compressed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<comment type="block">/*
			 * Check if this path is parameterized on a compressed
			 * column. Ideally those paths wouldn't be generated
			 * in the first place but since we create compressed
			 * EquivalenceMembers for all EquivalenceClasses these
			 * Paths can happen and will fail at execution since
			 * the left and right side of the expression are not
			 * compatible. Therefore we skip any Path that is
			 * parameterized on a compressed column here.
			 */</comment>
			<macro><name>foreach</name> <argument_list>(<argument>lc_ri</argument>, <argument>child_path-&gt;param_info-&gt;ppi_clauses</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>ri</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RestrictInfo</name></expr></argument>, <argument><expr><name>lc_ri</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>ri</name><operator>-&gt;</operator><name>right_em</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>ri</name><operator>-&gt;</operator><name>right_em</name><operator>-&gt;</operator><name>em_expr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					<operator>(</operator><name>Index</name><operator>)</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>Var</name></expr></argument>, <argument><expr><name><name>ri</name><operator>-&gt;</operator><name>right_em</name><operator>-&gt;</operator><name>em_expr</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>varno</name> <operator>==</operator>
						<name><name>info</name><operator>-&gt;</operator><name>compressed_rel</name><operator>-&gt;</operator><name>relid</name></name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>Var</name></expr></argument>, <argument><expr><name><name>ri</name><operator>-&gt;</operator><name>right_em</name><operator>-&gt;</operator><name>em_expr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>is_compressed_column</name><argument_list>(<argument><expr><name>info</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>references_compressed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>ri</name><operator>-&gt;</operator><name>left_em</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>ri</name><operator>-&gt;</operator><name>left_em</name><operator>-&gt;</operator><name>em_expr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					<operator>(</operator><name>Index</name><operator>)</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>Var</name></expr></argument>, <argument><expr><name><name>ri</name><operator>-&gt;</operator><name>left_em</name><operator>-&gt;</operator><name>em_expr</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>varno</name> <operator>==</operator>
						<name><name>info</name><operator>-&gt;</operator><name>compressed_rel</name><operator>-&gt;</operator><name>relid</name></name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>Var</name></expr></argument>, <argument><expr><name><name>ri</name><operator>-&gt;</operator><name>left_em</name><operator>-&gt;</operator><name>em_expr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>is_compressed_column</name><argument_list>(<argument><expr><name>info</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>references_compressed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>
			<if_stmt><if>if <condition>(<expr><name>references_compressed</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>decompress_chunk_path_create</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>info</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>child_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* If we can push down the sort below the DecompressChunk node, we set the pathkeys of the
		 * decompress node to the query pathkeys, while remembering the compressed_pathkeys
		 * corresponding to those query_pathkeys. We will determine whether to put a sort between
		 * the decompression node and the scan during plan creation */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>sort_info</name><operator>.</operator><name>can_pushdown_sort</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>DecompressChunkPath</name> <modifier>*</modifier></type><name>dcpath</name> <init>= <expr><call><name>copy_decompress_chunk_path</name><argument_list>(<argument><expr><operator>(</operator><name>DecompressChunkPath</name> <operator>*</operator><operator>)</operator> <name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>dcpath</name><operator>-&gt;</operator><name>reverse</name></name> <operator>=</operator> <name><name>sort_info</name><operator>.</operator><name>reverse</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>dcpath</name><operator>-&gt;</operator><name>needs_sequence_num</name></name> <operator>=</operator> <name><name>sort_info</name><operator>.</operator><name>needs_sequence_num</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>dcpath</name><operator>-&gt;</operator><name>compressed_pathkeys</name></name> <operator>=</operator> <name><name>sort_info</name><operator>.</operator><name>compressed_pathkeys</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>dcpath</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>query_pathkeys</name></name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Add costing for a sort. The standard Postgres pattern is to add the cost during
			 * path creation, but not add the sort path itself, that's done during plan creation.
			 * Examples of this in: create_merge_append_path &amp; create_merge_append_plan
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pathkeys_contained_in</name><argument_list>(<argument><expr><name><name>dcpath</name><operator>-&gt;</operator><name>compressed_pathkeys</name></name></expr></argument>, <argument><expr><name><name>child_path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Path</name></type> <name>sort_path</name></decl>;</decl_stmt> <comment type="block">/* dummy for result of cost_sort */</comment>

				<expr_stmt><expr><call><name>cost_sort</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sort_path</name></expr></argument>,
						  <argument><expr><name>root</name></expr></argument>,
						  <argument><expr><name><name>dcpath</name><operator>-&gt;</operator><name>compressed_pathkeys</name></name></expr></argument>,
						  <argument><expr><name><name>child_path</name><operator>-&gt;</operator><name>total_cost</name></name></expr></argument>,
						  <argument><expr><name><name>child_path</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>,
						  <argument><expr><name><name>child_path</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>width</name></name></expr></argument>,
						  <argument><expr><literal type="number">0.0</literal></expr></argument>,
						  <argument><expr><name>work_mem</name></expr></argument>,
						  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>cost_decompress_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dcpath</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sort_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>chunk_rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dcpath</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* this has to go after the path is copied for the ordered path since path can get freed in
		 * add_path */</comment>
		<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>chunk_rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<comment type="block">/* the chunk_rel now owns the paths, remove them from the compressed_rel so they can't be freed
	 * if it's planned */</comment>
	<expr_stmt><expr><name><name>compressed_rel</name><operator>-&gt;</operator><name>pathlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<comment type="block">/* create parallel paths */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>compressed_rel</name><operator>-&gt;</operator><name>consider_parallel</name></name></expr>)</condition>
	<block>{<block_content>
		<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>compressed_rel-&gt;partial_pathlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Path</name> <modifier>*</modifier></type><name>child_path</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>DecompressChunkPath</name> <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>child_path</name><operator>-&gt;</operator><name>param_info</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
				<operator>(</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>chunk_rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name><name>child_path</name><operator>-&gt;</operator><name>param_info</name><operator>-&gt;</operator><name>ppi_req_outer</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
				 <operator>(</operator><operator>!</operator><name><name>info</name><operator>-&gt;</operator><name>single_chunk</name></name> <operator>&amp;&amp;</operator>
				  <call><name>bms_is_member</name><argument_list>(<argument><expr><name>ht_relid</name></expr></argument>, <argument><expr><name><name>child_path</name><operator>-&gt;</operator><name>param_info</name><operator>-&gt;</operator><name>ppi_req_outer</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>decompress_chunk_path_create</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>info</name></expr></argument>, <argument><expr><name>parallel_workers</name></expr></argument>, <argument><expr><name>child_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>add_partial_path</name><argument_list>(<argument><expr><name>chunk_rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<comment type="block">/* the chunk_rel now owns the paths, remove them from the compressed_rel so they can't be
		 * freed if it's planned */</comment>
		<expr_stmt><expr><name><name>compressed_rel</name><operator>-&gt;</operator><name>partial_pathlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* set reloptkind to RELOPT_DEADREL to prevent postgresql from replanning this relation */</comment>
	<expr_stmt><expr><name><name>compressed_rel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>=</operator> <name>RELOPT_DEADREL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Add a var for a particular column to the reltarget. attrs_used is a bitmap
 * of which columns we already have in reltarget. We do not add the columns that
 * are already there, and update it after adding something.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>compressed_reltarget_add_var_for_column</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>compressed_rel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>compressed_relid</name></decl></parameter>,
										<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>column_name</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier><modifier>*</modifier></type><name>attrs_used</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AttrNumber</name></type> <name>attnum</name> <init>= <expr><call><name>get_attnum</name><argument_list>(<argument><expr><name>compressed_relid</name></expr></argument>, <argument><expr><name>column_name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>attnum</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>, <argument><expr><operator>*</operator><name>attrs_used</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* This column is already in reltarget, we don't need duplicates. */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>attrs_used</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><operator>*</operator><name>attrs_used</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>typid</name></decl>, <decl><type ref="prev"/><name>collid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>typmod</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>get_atttypetypmodcoll</name><argument_list>(<argument><expr><name>compressed_relid</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typmod</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>collid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>compressed_rel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>exprs</name></name> <operator>=</operator>
		<call><name>lappend</name><argument_list>(<argument><expr><name><name>compressed_rel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>,
				<argument><expr><call><name>makeVar</name><argument_list>(<argument><expr><name><name>compressed_rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>typid</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>, <argument><expr><name>collid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* copy over the vars from the chunk_rel-&gt;reltarget to the compressed_rel-&gt;reltarget
 * altering the fields that need it
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>compressed_rel_setup_reltarget</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>compressed_rel</name></decl></parameter>, <parameter><decl><type><name>CompressionInfo</name> <modifier>*</modifier></type><name>info</name></decl></parameter>,
							   <parameter><decl><type><name>bool</name></type> <name>needs_sequence_num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>have_whole_row_var</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>attrs_used</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>compressed_relid</name> <init>= <expr><name><name>info</name><operator>-&gt;</operator><name>compressed_rte</name><operator>-&gt;</operator><name>relid</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We have to decompress three kinds of columns:
	 * 1) output targetlist of the relation,
	 * 2) columns required for the quals (WHERE),
	 * 3) columns required for joins.
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>exprs</name> <init>= <expr><call><name>list_copy</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>chunk_rel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>info-&gt;chunk_rel-&gt;baserestrictinfo</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>exprs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>exprs</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>info-&gt;chunk_rel-&gt;joininfo</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>exprs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>exprs</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Now go over the required expressions we prepared above, and add the
	 * required columns to the compressed reltarget.
	 */</comment>
	<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>compressed_rel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>exprs</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>exprs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>chunk_vars</name> <init>= <expr><call><name>pull_var_clause</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>PVC_RECURSE_PLACEHOLDERS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<macro><name>foreach</name> <argument_list>(<argument>lc2</argument>, <argument>chunk_vars</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>FormData_hypertable_compression</name> <modifier>*</modifier></type><name>column_info</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>column_name</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>chunk_var</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>Var</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* skip vars that aren't from the uncompressed chunk */</comment>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>Index</name><operator>)</operator> <name><name>chunk_var</name><operator>-&gt;</operator><name>varno</name></name> <operator>!=</operator> <name><name>info</name><operator>-&gt;</operator><name>chunk_rel</name><operator>-&gt;</operator><name>relid</name></name></expr>)</condition>
			<block>{<block_content>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * If there's a system column or whole-row reference, add a whole-
			 * row reference, and we're done.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>chunk_var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>have_whole_row_var</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>column_name</name> <operator>=</operator> <call><name>get_attname</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>chunk_rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name><name>chunk_var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>column_info</name> <operator>=</operator>
				<call><name>get_column_compressioninfo</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>hypertable_compression_info</name></name></expr></argument>, <argument><expr><name>column_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>column_info</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>compressed_reltarget_add_var_for_column</name><argument_list>(<argument><expr><name>compressed_rel</name></expr></argument>,
													<argument><expr><name>compressed_relid</name></expr></argument>,
													<argument><expr><name>column_name</name></expr></argument>,
													<argument><expr><operator>&amp;</operator><name>attrs_used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* if the column is an orderby, add it's metadata columns too */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>column_info</name><operator>-&gt;</operator><name>orderby_column_index</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>compressed_reltarget_add_var_for_column</name><argument_list>(<argument><expr><name>compressed_rel</name></expr></argument>,
														<argument><expr><name>compressed_relid</name></expr></argument>,
														<argument><expr><call><name>compression_column_segment_min_name</name><argument_list>(
															<argument><expr><name>column_info</name></expr></argument>)</argument_list></call></expr></argument>,
														<argument><expr><operator>&amp;</operator><name>attrs_used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>compressed_reltarget_add_var_for_column</name><argument_list>(<argument><expr><name>compressed_rel</name></expr></argument>,
														<argument><expr><name>compressed_relid</name></expr></argument>,
														<argument><expr><call><name>compression_column_segment_max_name</name><argument_list>(
															<argument><expr><name>column_info</name></expr></argument>)</argument_list></call></expr></argument>,
														<argument><expr><operator>&amp;</operator><name>attrs_used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block>

	<comment type="block">/* always add the count column */</comment>
	<expr_stmt><expr><call><name>compressed_reltarget_add_var_for_column</name><argument_list>(<argument><expr><name>compressed_rel</name></expr></argument>,
											<argument><expr><name>compressed_relid</name></expr></argument>,
											<argument><expr><name>COMPRESSION_COLUMN_METADATA_COUNT_NAME</name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>attrs_used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* add the segment order column if we may try to order by it */</comment>
	<if_stmt><if>if <condition>(<expr><name>needs_sequence_num</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>compressed_reltarget_add_var_for_column</name><argument_list>(<argument><expr><name>compressed_rel</name></expr></argument>,
												<argument><expr><name>compressed_relid</name></expr></argument>,
												<argument><expr><name>COMPRESSION_COLUMN_METADATA_SEQUENCE_NUM_NAME</name></expr></argument>,
												<argument><expr><operator>&amp;</operator><name>attrs_used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * It doesn't make sense to request a whole-row var from the compressed
	 * chunk scan. If it is requested, just fetch the rest of columns. The
	 * whole-row var will be created by the projection of DecompressChunk node.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>have_whole_row_var</name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name><name>info</name><operator>-&gt;</operator><name>chunk_rel</name><operator>-&gt;</operator><name>max_attr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>column_name</name> <init>= <expr><call><name>get_attname</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>chunk_rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,
											<argument><expr><name>i</name></expr></argument>,
											<comment type="block">/* missing_ok = */</comment> <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>AttrNumber</name></type> <name>chunk_attno</name> <init>= <expr><call><name>get_attnum</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>chunk_rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>column_name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>chunk_attno</name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Skip the dropped column. */</comment>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<decl_stmt><decl><type><name>AttrNumber</name></type> <name>compressed_attno</name> <init>= <expr><call><name>get_attnum</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>compressed_rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>column_name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>compressed_attno</name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					 <argument><expr><literal type="string">"column '%s' not found in the compressed chunk '%s'"</literal></expr></argument>,
					 <argument><expr><name>column_name</name></expr></argument>,
					 <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>compressed_rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>compressed_attno</name></expr></argument>, <argument><expr><name>attrs_used</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>compressed_reltarget_add_var_for_column</name><argument_list>(<argument><expr><name>compressed_rel</name></expr></argument>,
													<argument><expr><name>compressed_relid</name></expr></argument>,
													<argument><expr><name>column_name</name></expr></argument>,
													<argument><expr><operator>&amp;</operator><name>attrs_used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Bitmapset</name> <modifier>*</modifier></type>
<name>decompress_chunk_adjust_child_relids</name><parameter_list>(<parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>chunk_relid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>compressed_chunk_relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>src</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>bms_del_member</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>chunk_relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>compressed_chunk_relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* based on adjust_appendrel_attrs_mutator handling of RestrictInfo */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>chunk_joininfo_mutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>CompressionInfo</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>Var</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>compress_var</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>column_name</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type> <name>compressed_attno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>FormData_hypertable_compression</name> <modifier>*</modifier></type><name>compressioninfo</name></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>Index</name><operator>)</operator> <name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>!=</operator> <name><name>context</name><operator>-&gt;</operator><name>chunk_rel</name><operator>-&gt;</operator><name>relid</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>var</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>column_name</name> <operator>=</operator> <call><name>get_attname</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>chunk_rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>compressioninfo</name> <operator>=</operator>
			<call><name>get_column_compressioninfo</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>hypertable_compression_info</name></name></expr></argument>, <argument><expr><name>column_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>compressed_attno</name> <operator>=</operator>
			<call><name>get_attnum</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>compressed_rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name><name>compressioninfo</name><operator>-&gt;</operator><name>attname</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>compress_var</name><operator>-&gt;</operator><name>varno</name></name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>compressed_rel</name><operator>-&gt;</operator><name>relid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>compress_var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>=</operator> <name>compressed_attno</name></expr>;</expr_stmt>

		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>compress_var</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RestrictInfo</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>oldinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>newinfo</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RestrictInfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Copy all flat-copiable fields */</comment>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>newinfo</name></expr></argument>, <argument><expr><name>oldinfo</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RestrictInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Recursively fix the clause itself */</comment>
		<expr_stmt><expr><name><name>newinfo</name><operator>-&gt;</operator><name>clause</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>chunk_joininfo_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>oldinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* and the modified version, if an OR clause */</comment>
		<expr_stmt><expr><name><name>newinfo</name><operator>-&gt;</operator><name>orclause</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>chunk_joininfo_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>oldinfo</name><operator>-&gt;</operator><name>orclause</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* adjust relid sets too */</comment>
		<expr_stmt><expr><name><name>newinfo</name><operator>-&gt;</operator><name>clause_relids</name></name> <operator>=</operator>
			<call><name>decompress_chunk_adjust_child_relids</name><argument_list>(<argument><expr><name><name>oldinfo</name><operator>-&gt;</operator><name>clause_relids</name></name></expr></argument>,
												 <argument><expr><name><name>context</name><operator>-&gt;</operator><name>chunk_rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,
												 <argument><expr><name><name>context</name><operator>-&gt;</operator><name>compressed_rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newinfo</name><operator>-&gt;</operator><name>required_relids</name></name> <operator>=</operator>
			<call><name>decompress_chunk_adjust_child_relids</name><argument_list>(<argument><expr><name><name>oldinfo</name><operator>-&gt;</operator><name>required_relids</name></name></expr></argument>,
												 <argument><expr><name><name>context</name><operator>-&gt;</operator><name>chunk_rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,
												 <argument><expr><name><name>context</name><operator>-&gt;</operator><name>compressed_rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newinfo</name><operator>-&gt;</operator><name>outer_relids</name></name> <operator>=</operator>
			<call><name>decompress_chunk_adjust_child_relids</name><argument_list>(<argument><expr><name><name>oldinfo</name><operator>-&gt;</operator><name>outer_relids</name></name></expr></argument>,
												 <argument><expr><name><name>context</name><operator>-&gt;</operator><name>chunk_rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,
												 <argument><expr><name><name>context</name><operator>-&gt;</operator><name>compressed_rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newinfo</name><operator>-&gt;</operator><name>nullable_relids</name></name> <operator>=</operator>
			<call><name>decompress_chunk_adjust_child_relids</name><argument_list>(<argument><expr><name><name>oldinfo</name><operator>-&gt;</operator><name>nullable_relids</name></name></expr></argument>,
												 <argument><expr><name><name>context</name><operator>-&gt;</operator><name>chunk_rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,
												 <argument><expr><name><name>context</name><operator>-&gt;</operator><name>compressed_rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newinfo</name><operator>-&gt;</operator><name>left_relids</name></name> <operator>=</operator> <call><name>decompress_chunk_adjust_child_relids</name><argument_list>(<argument><expr><name><name>oldinfo</name><operator>-&gt;</operator><name>left_relids</name></name></expr></argument>,
																	<argument><expr><name><name>context</name><operator>-&gt;</operator><name>chunk_rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,
																	<argument><expr><name><name>context</name><operator>-&gt;</operator><name>compressed_rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newinfo</name><operator>-&gt;</operator><name>right_relids</name></name> <operator>=</operator>
			<call><name>decompress_chunk_adjust_child_relids</name><argument_list>(<argument><expr><name><name>oldinfo</name><operator>-&gt;</operator><name>right_relids</name></name></expr></argument>,
												 <argument><expr><name><name>context</name><operator>-&gt;</operator><name>chunk_rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,
												 <argument><expr><name><name>context</name><operator>-&gt;</operator><name>compressed_rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>newinfo</name><operator>-&gt;</operator><name>eval_cost</name><operator>.</operator><name>startup</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newinfo</name><operator>-&gt;</operator><name>norm_selec</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newinfo</name><operator>-&gt;</operator><name>outer_selec</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newinfo</name><operator>-&gt;</operator><name>left_em</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newinfo</name><operator>-&gt;</operator><name>right_em</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newinfo</name><operator>-&gt;</operator><name>scansel_cache</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newinfo</name><operator>-&gt;</operator><name>left_bucketsize</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newinfo</name><operator>-&gt;</operator><name>right_bucketsize</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newinfo</name><operator>-&gt;</operator><name>left_mcvfreq</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newinfo</name><operator>-&gt;</operator><name>right_mcvfreq</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newinfo</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>expression_tree_mutator</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>chunk_joininfo_mutator</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* translate chunk_rel-&gt;joininfo for compressed_rel
 * this is necessary for create_index_path which gets join clauses from
 * rel-&gt;joininfo and sets up parameterized paths (in rel-&gt;ppilist).
 * ppi_clauses is finally used to add any additional filters on the
 * indexpath when creating a plan in create_indexscan_plan.
 * Otherwise we miss additional filters that need to be applied after
 * the index plan is executed (github issue 1558)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>compressed_rel_setup_joininfo</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>compressed_rel</name></decl></parameter>, <parameter><decl><type><name>CompressionInfo</name> <modifier>*</modifier></type><name>info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>chunk_rel</name> <init>= <expr><name><name>info</name><operator>-&gt;</operator><name>chunk_rel</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>compress_joininfo</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>chunk_rel-&gt;joininfo</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>compress_ri</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>ri</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>chunk_joininfo_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>ri</name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>RestrictInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>compress_ri</name> <operator>=</operator> <operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <name>result</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>compress_joininfo</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>compress_joininfo</name></expr></argument>, <argument><expr><name>compress_ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><name><name>compressed_rel</name><operator>-&gt;</operator><name>joininfo</name></name> <operator>=</operator> <name>compress_joininfo</name></expr>;</expr_stmt>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <name>EMCreationContext</name>
<block>{
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>compression_info</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>uncompressed_relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>compressed_relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type> <name>uncompressed_relid_idx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type> <name>compressed_relid_idx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FormData_hypertable_compression</name> <modifier>*</modifier></type><name>current_col_info</name></decl>;</decl_stmt>
}</block></struct></type> <name>EMCreationContext</name>;</typedef>

<comment type="block">/* get the compression info for an EquivalenceMember (EM) expr,
 * or return NULL if it's not one we can create an EM for
 * This is applicable to segment by and compressed columns
 * of the compressed table.
 */</comment>
<function><type><specifier>static</specifier> <name>FormData_hypertable_compression</name> <modifier>*</modifier></type>
<name>get_compression_info_for_em</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>EMCreationContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* based on adjust_appendrel_attrs_mutator */</comment>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FormData_hypertable_compression</name> <modifier>*</modifier></type><name>col_info</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>column_name</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>Var</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>Index</name><operator>)</operator> <name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>!=</operator> <name><name>context</name><operator>-&gt;</operator><name>uncompressed_relid_idx</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* we can't add an EM for system attributes or whole-row refs */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>column_name</name> <operator>=</operator> <call><name>get_attname</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>uncompressed_relid</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>column_name</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>col_info</name> <operator>=</operator> <call><name>get_column_compressioninfo</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>compression_info</name></name></expr></argument>, <argument><expr><name>column_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>col_info</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

		<return>return <expr><name>col_info</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * we currently ignore non-Var expressions; the EC we care about
	 * (the one relating Hypertable columns to chunk columns)
	 * should not have any
	 */</comment>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>create_var_for_compressed_equivalence_member</name><parameter_list>(<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>EMCreationContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* based on adjust_appendrel_attrs_mutator */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>current_col_info</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>Index</name><operator>)</operator> <name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name><name>context</name><operator>-&gt;</operator><name>uncompressed_relid_idx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>compressed_relid_idx</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>=</operator>
			<call><name>get_attnum</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>compressed_relid</name></name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>current_col_info</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG13_GE</name></expr></cpp:if>
		<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>varnosyn</name></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>varattnosyn</name></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>varnoold</name></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>varoattno</name></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>var</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>add_segmentby_to_equivalence_class</name><parameter_list>(<parameter><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>cur_ec</name></decl></parameter>, <parameter><decl><type><name>CompressionInfo</name> <modifier>*</modifier></type><name>info</name></decl></parameter>,
								   <parameter><decl><type><name>EMCreationContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relids</name></type> <name>uncompressed_chunk_relids</name> <init>= <expr><name><name>info</name><operator>-&gt;</operator><name>chunk_rel</name><operator>-&gt;</operator><name>relids</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>cur_ec-&gt;ec_members</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>child_expr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relids</name></type> <name>new_relids</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relids</name></type> <name>new_nullable_relids</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>cur_em</name> <init>= <expr><operator>(</operator><name>EquivalenceMember</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>bms_overlap</name><argument_list>(<argument><expr><name><name>cur_em</name><operator>-&gt;</operator><name>em_relids</name></name></expr></argument>, <argument><expr><name><name>info</name><operator>-&gt;</operator><name>compressed_rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* only consider EquivalenceMembers that are vars of the uncompressed chunk */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>cur_em</name><operator>-&gt;</operator><name>em_expr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>Var</name></expr></argument>, <argument><expr><name><name>cur_em</name><operator>-&gt;</operator><name>em_expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>Index</name><operator>)</operator> <name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>!=</operator> <name><name>info</name><operator>-&gt;</operator><name>chunk_rel</name><operator>-&gt;</operator><name>relid</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* given that the em is a var of the uncompressed chunk, the relid of the chunk should
		 * be set on the em */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>bms_overlap</name><argument_list>(<argument><expr><name><name>cur_em</name><operator>-&gt;</operator><name>em_relids</name></name></expr></argument>, <argument><expr><name>uncompressed_chunk_relids</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>current_col_info</name></name> <operator>=</operator> <call><name>get_compression_info_for_em</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>cur_em</name><operator>-&gt;</operator><name>em_expr</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>current_col_info</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>child_expr</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>create_var_for_compressed_equivalence_member</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>child_expr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Transform em_relids to match.  Note we do *not* do
		 * pull_varnos(child_expr) here, as for example the
		 * transformation might have substituted a constant, but we
		 * don't want the child member to be marked as constant.
		 */</comment>
		<expr_stmt><expr><name>new_relids</name> <operator>=</operator> <call><name>bms_difference</name><argument_list>(<argument><expr><name><name>cur_em</name><operator>-&gt;</operator><name>em_relids</name></name></expr></argument>, <argument><expr><name>uncompressed_chunk_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>new_relids</name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name>new_relids</name></expr></argument>, <argument><expr><name><name>info</name><operator>-&gt;</operator><name>compressed_rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * And likewise for nullable_relids.  Note this code assumes
		 * parent and child relids are singletons.
		 */</comment>
		<expr_stmt><expr><name>new_nullable_relids</name> <operator>=</operator> <name><name>cur_em</name><operator>-&gt;</operator><name>em_nullable_relids</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>bms_overlap</name><argument_list>(<argument><expr><name>new_nullable_relids</name></expr></argument>, <argument><expr><name>uncompressed_chunk_relids</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>new_nullable_relids</name> <operator>=</operator> <call><name>bms_difference</name><argument_list>(<argument><expr><name>new_nullable_relids</name></expr></argument>, <argument><expr><name>uncompressed_chunk_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>new_nullable_relids</name> <operator>=</operator>
				<call><name>bms_add_members</name><argument_list>(<argument><expr><name>new_nullable_relids</name></expr></argument>, <argument><expr><name><name>info</name><operator>-&gt;</operator><name>compressed_rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* copied from add_eq_member */</comment>
		<block>{<block_content>
			<decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>em</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>EquivalenceMember</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>em</name><operator>-&gt;</operator><name>em_expr</name></name> <operator>=</operator> <name>child_expr</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>em</name><operator>-&gt;</operator><name>em_relids</name></name> <operator>=</operator> <name>new_relids</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>em</name><operator>-&gt;</operator><name>em_nullable_relids</name></name> <operator>=</operator> <name>new_nullable_relids</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>em</name><operator>-&gt;</operator><name>em_is_const</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>em</name><operator>-&gt;</operator><name>em_is_child</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>em</name><operator>-&gt;</operator><name>em_datatype</name></name> <operator>=</operator> <name><name>cur_em</name><operator>-&gt;</operator><name>em_datatype</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cur_ec</name><operator>-&gt;</operator><name>ec_relids</name></name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>cur_ec</name><operator>-&gt;</operator><name>ec_relids</name></name></expr></argument>, <argument><expr><name><name>info</name><operator>-&gt;</operator><name>compressed_rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG13_GE</name></expr></cpp:if>
			<expr_stmt><expr><name><name>cur_ec</name><operator>-&gt;</operator><name>ec_members</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cur_ec</name><operator>-&gt;</operator><name>ec_members</name></name></expr></argument>, <argument><expr><name>em</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<comment type="block">/* Prepend the ec member because it's likely to be accessed soon */</comment>
			<expr_stmt><expr><name><name>cur_ec</name><operator>-&gt;</operator><name>ec_members</name></name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>em</name></expr></argument>, <argument><expr><name><name>cur_ec</name><operator>-&gt;</operator><name>ec_members</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block>
	</block_content>}</block>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>compressed_rel_setup_equivalence_classes</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>CompressionInfo</name> <modifier>*</modifier></type><name>info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EMCreationContext</name></type> <name>context</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>compression_info</name> <operator>=</operator> <name><name>info</name><operator>-&gt;</operator><name>hypertable_compression_info</name></name></expr>,

		<expr><operator>.</operator><name>uncompressed_relid</name> <operator>=</operator> <name><name>info</name><operator>-&gt;</operator><name>chunk_rte</name><operator>-&gt;</operator><name>relid</name></name></expr>,
		<expr><operator>.</operator><name>compressed_relid</name> <operator>=</operator> <name><name>info</name><operator>-&gt;</operator><name>compressed_rte</name><operator>-&gt;</operator><name>relid</name></name></expr>,

		<expr><operator>.</operator><name>uncompressed_relid_idx</name> <operator>=</operator> <name><name>info</name><operator>-&gt;</operator><name>chunk_rel</name><operator>-&gt;</operator><name>relid</name></name></expr>,
		<expr><operator>.</operator><name>compressed_relid_idx</name> <operator>=</operator> <name><name>info</name><operator>-&gt;</operator><name>compressed_rel</name><operator>-&gt;</operator><name>relid</name></name></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>chunk_rte</name><operator>-&gt;</operator><name>relid</name></name> <operator>!=</operator> <name><name>info</name><operator>-&gt;</operator><name>compressed_rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>chunk_rel</name><operator>-&gt;</operator><name>relid</name></name> <operator>!=</operator> <name><name>info</name><operator>-&gt;</operator><name>compressed_rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* based on add_child_rel_equivalences */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG13_GE</name></expr></cpp:if>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>ec_added</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>ec_merging_done</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* use chunk rel's eclass_indexes to avoid traversing all
	 * the root's eq_classes
	 */</comment>
	<while>while <condition>(<expr><operator>(</operator><name>i</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>chunk_rel</name><operator>-&gt;</operator><name>eclass_indexes</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>cur_ec</name> <init>= <expr><operator>(</operator><name>EquivalenceClass</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>eq_classes</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>root-&gt;eq_classes</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>cur_ec</name> <init>= <expr><operator>(</operator><name>EquivalenceClass</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<comment type="block">/*
		 * If this EC contains a volatile expression, then generating child
		 * EMs would be downright dangerous, so skip it.  We rely on a
		 * volatile EC having only one EM.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>cur_ec</name><operator>-&gt;</operator><name>ec_has_volatile</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* if the compressed rel is already part of this EC,
		 * we don't need to re-add it
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>bms_overlap</name><argument_list>(<argument><expr><name><name>cur_ec</name><operator>-&gt;</operator><name>ec_relids</name></name></expr></argument>, <argument><expr><name><name>info</name><operator>-&gt;</operator><name>compressed_rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG13_LT</name></expr></cpp:if>
		<expr_stmt><expr><call><name>add_segmentby_to_equivalence_class</name><argument_list>(<argument><expr><name>cur_ec</name></expr></argument>, <argument><expr><name>info</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><name>ec_added</name> <operator>=</operator> <call><name>add_segmentby_to_equivalence_class</name><argument_list>(<argument><expr><name>cur_ec</name></expr></argument>, <argument><expr><name>info</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Record this EC index for the compressed rel */</comment>
		<if_stmt><if>if <condition>(<expr><name>ec_added</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>compressed_rel</name><operator>-&gt;</operator><name>eclass_indexes</name></name> <operator>=</operator>
				<call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>compressed_rel</name><operator>-&gt;</operator><name>eclass_indexes</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>ec_added</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block>
	<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>compressed_rel</name><operator>-&gt;</operator><name>has_eclass_joins</name></name> <operator>=</operator> <name><name>info</name><operator>-&gt;</operator><name>chunk_rel</name><operator>-&gt;</operator><name>has_eclass_joins</name></name></expr>;</expr_stmt>
</block_content>}</block></while>

<comment type="block">/*
 * create RangeTblEntry and RelOptInfo for the compressed chunk
 * and add it to PlannerInfo
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>decompress_chunk_add_plannerinfo</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>CompressionInfo</name> <modifier>*</modifier></type><name>info</name></decl></parameter>, <parameter><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>,
								 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>chunk_rel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>needs_sequence_num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type> <name>compressed_index</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>simple_rel_array_size</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>compressed_chunk</name> <init>= <expr><call><name>ts_chunk_get_by_id</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>compressed_chunk_id</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>compressed_relid</name> <init>= <expr><name><name>compressed_chunk</name><operator>-&gt;</operator><name>table_id</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>compressed_rel</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>expand_planner_arrays</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>compressed_rte</name></name> <operator>=</operator> <call><name>decompress_chunk_make_rte</name><argument_list>(<argument><expr><name>compressed_relid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>simple_rte_array</name><index>[<expr><name>compressed_index</name></expr>]</index></name> <operator>=</operator> <name><name>info</name><operator>-&gt;</operator><name>compressed_rte</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>, <argument><expr><name><name>info</name><operator>-&gt;</operator><name>compressed_rte</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>simple_rel_array</name><index>[<expr><name>compressed_index</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>compressed_rel</name> <operator>=</operator> <call><name>build_simple_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>compressed_index</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* github issue :1558
	 * set up top_parent_relids for this rel as the same as the
	 * original hypertable, otherwise eq classes are not computed correctly
	 * in generate_join_implied_equalities (called by
	 * get_baserel_parampathinfo &lt;- create_index_paths)
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>single_chunk</name></name> <operator>||</operator> <name><name>chunk_rel</name><operator>-&gt;</operator><name>top_parent_relids</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>compressed_rel</name><operator>-&gt;</operator><name>top_parent_relids</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>chunk_rel</name><operator>-&gt;</operator><name>top_parent_relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>simple_rel_array</name><index>[<expr><name>compressed_index</name></expr>]</index></name> <operator>=</operator> <name>compressed_rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>compressed_rel</name></name> <operator>=</operator> <name>compressed_rel</name></expr>;</expr_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>info-&gt;hypertable_compression_info</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FormData_hypertable_compression</name> <modifier>*</modifier></type><name>fd</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>fd</name><operator>-&gt;</operator><name>segmentby_column_index</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* store attnos for the compressed chunk here */</comment>
			<decl_stmt><decl><type><name>AttrNumber</name></type> <name>compressed_chunk_attno</name> <init>=
				<expr><call><name>get_attnum</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>compressed_rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>fd</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>compressed_chunk_compressed_attnos</name></name> <operator>=</operator>
				<call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>compressed_chunk_compressed_attnos</name></name></expr></argument>, <argument><expr><name>compressed_chunk_attno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>compressed_rel_setup_reltarget</name><argument_list>(<argument><expr><name>compressed_rel</name></expr></argument>, <argument><expr><name>info</name></expr></argument>, <argument><expr><name>needs_sequence_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>compressed_rel_setup_equivalence_classes</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* translate chunk_rel-&gt;joininfo for compressed_rel */</comment>
	<expr_stmt><expr><call><name>compressed_rel_setup_joininfo</name><argument_list>(<argument><expr><name>compressed_rel</name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DecompressChunkPath</name> <modifier>*</modifier></type>
<name>decompress_chunk_path_create</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>CompressionInfo</name> <modifier>*</modifier></type><name>info</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>parallel_workers</name></decl></parameter>,
							 <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>compressed_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DecompressChunkPath</name> <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>DecompressChunkPath</name> <operator>*</operator><operator>)</operator> <call><name>newNode</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DecompressChunkPath</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>T_CustomPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>info</name></name> <operator>=</operator> <name>info</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_CustomScan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name><name>info</name><operator>-&gt;</operator><name>chunk_rel</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>info</name><operator>-&gt;</operator><name>chunk_rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <name><name>compressed_path</name><operator>-&gt;</operator><name>param_info</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>methods</name></name> <operator>=</operator> <operator>&amp;</operator><name>decompress_chunk_path_methods</name></expr>;</expr_stmt>

	<comment type="block">/* To prevent a non-parallel path with this node appearing
	 * in a parallel plan we only set parallel_safe to true
	 * when parallel_workers is greater than 0 which is only
	 * the case when creating partial paths. */</comment>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name>parallel_workers</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <name>parallel_workers</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>custom_paths</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>compressed_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>reverse</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>compressed_pathkeys</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>cost_decompress_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name></name></expr></argument>, <argument><expr><name>compressed_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>path</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* NOTE: this needs to be called strictly after all restrictinfos have been added
 *       to the compressed rel
 */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>create_compressed_scan_paths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>compressed_rel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>parallel_workers</name></decl></parameter>,
							 <parameter><decl><type><name>CompressionInfo</name> <modifier>*</modifier></type><name>info</name></decl></parameter>, <parameter><decl><type><name>SortInfo</name> <modifier>*</modifier></type><name>sort_info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Path</name> <modifier>*</modifier></type><name>compressed_path</name></decl>;</decl_stmt>

	<comment type="block">/* clamp total_table_pages to 10 pages since this is the
	 * minimum estimate for number of pages.
	 * Add the value to any existing estimates
	 */</comment>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>total_table_pages</name></name> <operator>+=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>compressed_rel</name><operator>-&gt;</operator><name>pages</name></name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* create non parallel scan path */</comment>
	<expr_stmt><expr><name>compressed_path</name> <operator>=</operator> <call><name>create_seqscan_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>compressed_rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>compressed_rel</name></expr></argument>, <argument><expr><name>compressed_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* create parallel scan path */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>compressed_rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>&amp;&amp;</operator> <name>parallel_workers</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>compressed_path</name> <operator>=</operator> <call><name>create_seqscan_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>compressed_rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>parallel_workers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>compressed_path</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>add_partial_path</name><argument_list>(<argument><expr><name>compressed_rel</name></expr></argument>, <argument><expr><name>compressed_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>sort_info</name><operator>-&gt;</operator><name>can_pushdown_sort</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If we can push down sort below decompression we temporarily switch
		 * out root-&gt;query_pathkeys to allow matching to pathkeys produces by
		 * decompression
		 */</comment>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>orig_pathkeys</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>query_pathkeys</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>build_compressed_scan_pathkeys</name><argument_list>(<argument><expr><name>sort_info</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>query_pathkeys</name></name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>query_pathkeys</name></name> <operator>=</operator> <name><name>sort_info</name><operator>-&gt;</operator><name>compressed_pathkeys</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>check_index_predicates</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>compressed_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>create_index_paths</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>compressed_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>query_pathkeys</name></name> <operator>=</operator> <name>orig_pathkeys</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>check_index_predicates</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>compressed_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>create_index_paths</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>compressed_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * create RangeTblEntry for compressed chunk
 */</comment>
<function><type><specifier>static</specifier> <name>RangeTblEntry</name> <modifier>*</modifier></type>
<name>decompress_chunk_make_rte</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>compressed_relid</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblEntry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>r</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>compressed_relid</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>varattno</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>=</operator> <name>RTE_RELATION</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <name>compressed_relid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>=</operator> <name><name>r</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>rellockmode</name></name> <operator>=</operator> <name>lockmode</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name></name> <operator>=</operator> <call><name>makeAlias</name><argument_list>(<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * inlined from buildRelationAliases()
	 * alias handling has been stripped because we won't
	 * need alias handling at this level
	 */</comment>
	<for>for <control>(<init><expr><name>varattno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>varattno</name> <operator>&lt;</operator> <name><name>r</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>varattno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>r</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>varattno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="block">/* Always insert an empty string for a dropped column */</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>attrname</name> <init>= <expr><ternary><condition><expr><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>colnames</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>attrname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Drop the rel refcount, but keep the access lock till end of transaction
	 * so that the table can't be deleted or have its schema modified
	 * underneath us.
	 */</comment>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set flags and access permissions.
	 *
	 * The initial default on access checks is always check-for-READ-access,
	 * which is the right thing for all except target tables.
	 */</comment>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>lateral</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>inh</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>inFromCl</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>requiredPerms</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>checkAsUser</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt> <comment type="block">/* not set-uid by default, either */</comment>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>selectedCols</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>insertedCols</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>updatedCols</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<return>return <expr><name>rte</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>FormData_hypertable_compression</name> <modifier>*</modifier></type>
<name>get_column_compressioninfo</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>hypertable_compression_info</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>column_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>hypertable_compression_info</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FormData_hypertable_compression</name> <modifier>*</modifier></type><name>fd</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>namestrcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fd</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>, <argument><expr><name>column_name</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>fd</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"No compression information for column \"%s\" found."</literal></expr></argument>, <argument><expr><name>column_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pg_unreachable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Find toplevel equality constraints of segmentby columns in baserestrictinfo
 *
 * This will detect Var = Const and Var = Param and set the corresponding bit
 * in CompressionInfo-&gt;chunk_segmentby_ri
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>find_restrictinfo_equality</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>chunk_rel</name></decl></parameter>, <parameter><decl><type><name>CompressionInfo</name> <modifier>*</modifier></type><name>info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>segmentby_columns</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>chunk_rel</name><operator>-&gt;</operator><name>baserestrictinfo</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc_ri</name></decl>;</decl_stmt>
		<macro><name>foreach</name> <argument_list>(<argument>lc_ri</argument>, <argument>chunk_rel-&gt;baserestrictinfo</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>ri</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc_ri</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>ri</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>list_length</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>OpExpr</name></expr></argument>, <argument><expr><name><name>ri</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>args</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>OpExpr</name></expr></argument>, <argument><expr><name><name>ri</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>other</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>opretset</name></name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>Var</name></expr></argument>, <argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>other</name> <operator>=</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><call><name>lsecond</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>Var</name></expr></argument>, <argument><expr><call><name>lsecond</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>other</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></else></if_stmt>

				<if_stmt><if>if <condition>(<expr><operator>(</operator><name>Index</name><operator>)</operator> <name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>!=</operator> <name><name>chunk_rel</name><operator>-&gt;</operator><name>relid</name></name> <operator>||</operator> <name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>other</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>other</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>tce</name> <init>= <expr><call><name>lookup_type_cache</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>vartype</name></name></expr></argument>, <argument><expr><name>TYPECACHE_EQ_OPR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>opno</name></name> <operator>!=</operator> <name><name>tce</name><operator>-&gt;</operator><name>eq_opr</name></name></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>, <argument><expr><name><name>info</name><operator>-&gt;</operator><name>chunk_segmentby_attnos</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>segmentby_columns</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>segmentby_columns</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>chunk_segmentby_ri</name></name> <operator>=</operator> <name>segmentby_columns</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Check if we can push down the sort below the DecompressChunk node and fill
 * SortInfo accordingly
 *
 * The following conditions need to be true for pushdown:
 *  - all segmentby columns need to be prefix of pathkeys or have equality constraint
 *  - the rest of pathkeys needs to match compress_orderby
 *
 * If query pathkeys is shorter than segmentby + compress_orderby pushdown can still be done
 */</comment>
<function><type><specifier>static</specifier> <name>SortInfo</name></type>
<name>build_sortinfo</name><parameter_list>(<parameter><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>chunk_rel</name></decl></parameter>, <parameter><decl><type><name>CompressionInfo</name> <modifier>*</modifier></type><name>info</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>pk_index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PathKey</name> <modifier>*</modifier></type><name>pk</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>column_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FormData_hypertable_compression</name> <modifier>*</modifier></type><name>ci</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name> <init>= <expr><call><name>list_head</name><argument_list>(<argument><expr><name>pathkeys</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SortInfo</name></type> <name>sort_info</name> <init>= <expr><block>{ <expr><operator>.</operator><name>can_pushdown_sort</name> <operator>=</operator> <name>false</name></expr>, <expr><operator>.</operator><name>needs_sequence_num</name> <operator>=</operator> <name>false</name></expr> }</block></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>pathkeys</name> <operator>==</operator> <name>NIL</name> <operator>||</operator> <call><name>ts_chunk_is_unordered</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>sort_info</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* all segmentby columns need to be prefix of pathkeys */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>num_segmentby_columns</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>segmentby_columns</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * initialize segmentby with equality constraints from baserestrictinfo because
		 * those columns dont need to be prefix of pathkeys
		 */</comment>
		<expr_stmt><expr><call><name>find_restrictinfo_equality</name><argument_list>(<argument><expr><name>chunk_rel</name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>segmentby_columns</name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>chunk_segmentby_ri</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * loop over pathkeys until we find one that is not a segmentby column
		 * we keep looping even if we found all segmentby columns in case a
		 * columns appears both in baserestrictinfo and in ORDER BY clause
		 */</comment>
		<for>for <control>(<init>;</init> <condition><expr><name>lc</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>lc</name> <operator>=</operator> <call><name>lnext_compat</name><argument_list>(<argument><expr><name>pathkeys</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>bms_num_members</name><argument_list>(<argument><expr><name>segmentby_columns</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name><name>info</name><operator>-&gt;</operator><name>num_segmentby_columns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>pk</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>find_em_expr_for_rel</name><argument_list>(<argument><expr><name><name>pk</name><operator>-&gt;</operator><name>pk_eclass</name></name></expr></argument>, <argument><expr><name><name>info</name><operator>-&gt;</operator><name>chunk_rel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>expr</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>Var</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>column_name</name> <operator>=</operator> <call><name>get_attname</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>chunk_rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ci</name> <operator>=</operator> <call><name>get_column_compressioninfo</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>hypertable_compression_info</name></name></expr></argument>, <argument><expr><name>column_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>ci</name><operator>-&gt;</operator><name>segmentby_column_index</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>segmentby_columns</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>segmentby_columns</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * if pathkeys still has items but we didnt find all segmentby columns
		 * we cannot push down sort
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>lc</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>bms_num_members</name><argument_list>(<argument><expr><name>segmentby_columns</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>info</name><operator>-&gt;</operator><name>num_segmentby_columns</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>sort_info</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * if pathkeys includes columns past segmentby columns
	 * we need sequence_num in the targetlist for ordering
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>lc</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>sort_info</name><operator>.</operator><name>needs_sequence_num</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * loop over the rest of pathkeys
	 * this needs to exactly match the configured compress_orderby
	 */</comment>
	<for>for <control>(<init><expr><name>pk_index</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>lc</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>lc</name> <operator>=</operator> <call><name>lnext_compat</name><argument_list>(<argument><expr><name>pathkeys</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><name>pk_index</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>reverse</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>pk</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>find_em_expr_for_rel</name><argument_list>(<argument><expr><name><name>pk</name><operator>-&gt;</operator><name>pk_eclass</name></name></expr></argument>, <argument><expr><name><name>info</name><operator>-&gt;</operator><name>chunk_rel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>expr</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>sort_info</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>Var</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>sort_info</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>column_name</name> <operator>=</operator> <call><name>get_attname</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>chunk_rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ci</name> <operator>=</operator> <call><name>get_column_compressioninfo</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>hypertable_compression_info</name></name></expr></argument>, <argument><expr><name>column_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>ci</name><operator>-&gt;</operator><name>orderby_column_index</name></name> <operator>!=</operator> <name>pk_index</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>sort_info</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * pk_strategy is either BTLessStrategyNumber (for ASC) or
		 * BTGreaterStrategyNumber (for DESC)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>pk</name><operator>-&gt;</operator><name>pk_strategy</name></name> <operator>==</operator> <name>BTLessStrategyNumber</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>ci</name><operator>-&gt;</operator><name>orderby_asc</name></name> <operator>&amp;&amp;</operator> <name><name>ci</name><operator>-&gt;</operator><name>orderby_nullsfirst</name></name> <operator>==</operator> <name><name>pk</name><operator>-&gt;</operator><name>pk_nulls_first</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>reverse</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>ci</name><operator>-&gt;</operator><name>orderby_asc</name></name> <operator>&amp;&amp;</operator> <name><name>ci</name><operator>-&gt;</operator><name>orderby_nullsfirst</name></name> <operator>!=</operator> <name><name>pk</name><operator>-&gt;</operator><name>pk_nulls_first</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>reverse</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<return>return <expr><name>sort_info</name></expr>;</return></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>pk</name><operator>-&gt;</operator><name>pk_strategy</name></name> <operator>==</operator> <name>BTGreaterStrategyNumber</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ci</name><operator>-&gt;</operator><name>orderby_asc</name></name> <operator>&amp;&amp;</operator> <name><name>ci</name><operator>-&gt;</operator><name>orderby_nullsfirst</name></name> <operator>==</operator> <name><name>pk</name><operator>-&gt;</operator><name>pk_nulls_first</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>reverse</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>ci</name><operator>-&gt;</operator><name>orderby_asc</name></name> <operator>&amp;&amp;</operator> <name><name>ci</name><operator>-&gt;</operator><name>orderby_nullsfirst</name></name> <operator>!=</operator> <name><name>pk</name><operator>-&gt;</operator><name>pk_nulls_first</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>reverse</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<return>return <expr><name>sort_info</name></expr>;</return></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * first pathkey match determines if this is forward or backward scan
		 * any further pathkey items need to have same direction
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>pk_index</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>sort_info</name><operator>.</operator><name>reverse</name></name> <operator>=</operator> <name>reverse</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>reverse</name> <operator>!=</operator> <name><name>sort_info</name><operator>.</operator><name>reverse</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>sort_info</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* all pathkeys should be processed */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>lc</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>sort_info</name><operator>.</operator><name>can_pushdown_sort</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<return>return <expr><name>sort_info</name></expr>;</return>
</block_content>}</block></function></block_content></block></function>
</unit>
