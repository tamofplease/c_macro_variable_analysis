<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/timescaledb/tsl/src/nodes/skip_scan/exec.c"><comment type="block">/*
 * This file and its contents are licensed under the Timescale License.
 * Please see the included NOTICE for copyright information and
 * LICENSE-TIMESCALE for a copy of the license.
 */</comment>

<comment type="block">/*
 * SkipScan is an optimized form of SELECT DISTINCT ON (column)
 * Conceptually, a SkipScan is a regular IndexScan with an additional skip-qual like
 *     WHERE column &gt; [previous value of column]
 *
 * Implementing this qual is complicated by two factors:
 *   1. The first time through the SkipScan there is no previous value for the
 *      DISTINCT column.
 *   2. NULL values don't behave nicely with ordering operators.
 *
 * To get around these issues, we have to special case those two cases. All in
 * all, the SkipScan's state machine evolves according to the following flowchart
 *
 *                        start
 *                          |
 *          +================================+
 *          | search for NULL if NULLS FIRST |
 *          +================================+
 *                  |
 *                  v
 *  +=====================+          +==============================+
 *  | search for non-NULL |--found--&gt;| search for values after prev |
 *  +=====================+  value   +==============================+
 *                  |                   |
 *                  v                   v
 *           +================================+
 *           | search for NULL if NULLS LAST  |
 *           +================================+
 *                          |
 *                          v
 *                    /===========\
 *                    |   DONE    |
 *                    \===========/
 *
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postgres.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/genam.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/extensible.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/pg_list.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/datum.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/skip_scan/skip_scan.h"</cpp:file></cpp:include>

<typedef>typedef <type><enum>enum <name>SkipScanStage</name>
<block>{
	<decl><name>SS_BEGIN</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
	<decl><name>SS_NULLS_FIRST</name></decl>,
	<decl><name>SS_NOT_NULL</name></decl>,
	<decl><name>SS_VALUES</name></decl>,
	<decl><name>SS_NULLS_LAST</name></decl>,
	<decl><name>SS_END</name></decl>,
}</block></enum></type> <name>SkipScanStage</name>;</typedef>

<typedef>typedef <type><struct>struct <name>SkipScanState</name>
<block>{
	<decl_stmt><decl><type><name>CustomScanState</name></type> <name>cscan_state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexScanDesc</name> <modifier>*</modifier></type><name>scan_desc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>ctx</name></decl>;</decl_stmt>

	<comment type="block">/* Interior Index(Only)Scan the SkipScan runs over */</comment>
	<decl_stmt><decl><type><name>ScanState</name> <modifier>*</modifier></type><name>idx</name></decl>;</decl_stmt>

	<comment type="block">/* Pointers into the Index(Only)Scan */</comment>
	<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>num_scan_keys</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKey</name> <modifier>*</modifier></type><name>scan_keys</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKey</name></type> <name>skip_key</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Datum</name></type> <name>prev_datum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>prev_is_null</name></decl>;</decl_stmt>

	<comment type="block">/* Info about the type we are performing DISTINCT on */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>distinct_by_val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>distinct_col_attnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>distinct_typ_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>sk_attno</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>SkipScanStage</name></type> <name>stage</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>nulls_first</name></decl>;</decl_stmt>
	<comment type="block">/* rescan required before getting next tuple */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>needs_rescan</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>idx_scan</name></decl>;</decl_stmt>
}</block></struct></type> <name>SkipScanState</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>has_nulls_first</name><parameter_list>(<parameter><decl><type><name>SkipScanState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>has_nulls_last</name><parameter_list>(<parameter><decl><type><name>SkipScanState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>skip_scan_rescan_index</name><parameter_list>(<parameter><decl><type><name>SkipScanState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>skip_scan_switch_stage</name><parameter_list>(<parameter><decl><type><name>SkipScanState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>SkipScanStage</name></type> <name>new_stage</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>skip_scan_begin</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SkipScanState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><operator>(</operator><name>SkipScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>ctx</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>, <argument><expr><literal type="string">"skipscan"</literal></expr></argument>, <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>idx</name></name> <operator>=</operator> <operator>(</operator><name>ScanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitNode</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>idx_scan</name></name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>custom_ps</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>idx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>idx_scan</name></name></expr></argument>, <argument><expr><name>IndexScan</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>IndexScanState</name> <modifier>*</modifier></type><name>idx</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>IndexScanState</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>idx</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>scan_keys</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>idx</name><operator>-&gt;</operator><name>iss_ScanKeys</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>num_scan_keys</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>idx</name><operator>-&gt;</operator><name>iss_NumScanKeys</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>scan_desc</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>idx</name><operator>-&gt;</operator><name>iss_ScanDesc</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>idx_scan</name></name></expr></argument>, <argument><expr><name>IndexOnlyScan</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>IndexOnlyScanState</name> <modifier>*</modifier></type><name>idx</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>IndexOnlyScanState</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>idx</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>scan_keys</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>idx</name><operator>-&gt;</operator><name>ioss_ScanKeys</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>num_scan_keys</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>idx</name><operator>-&gt;</operator><name>ioss_NumScanKeys</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>scan_desc</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>idx</name><operator>-&gt;</operator><name>ioss_ScanDesc</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unknown subscan type in SkipScan"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* scankeys are not setup for explain only */</comment>
	<if_stmt><if>if <condition>(<expr><name>eflags</name> <operator>&amp;</operator> <name>EXEC_FLAG_EXPLAIN_ONLY</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* find position of our skip key
	 * skip key is put as first key for the respective column in sort_indexquals
	 */</comment>
	<decl_stmt><decl><type><name>ScanKey</name></type> <name>data</name> <init>= <expr><operator>*</operator><name><name>state</name><operator>-&gt;</operator><name>scan_keys</name></name></expr></init></decl>;</decl_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>*</operator><name><name>state</name><operator>-&gt;</operator><name>num_scan_keys</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>data</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sk_flags</name> <operator>==</operator> <name>SK_ISNULL</name> <operator>&amp;&amp;</operator> <name><name>data</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sk_attno</name> <operator>==</operator> <name><name>state</name><operator>-&gt;</operator><name>sk_attno</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>skip_key</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>data</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>skip_key</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"ScanKey for skip qual not found"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>has_nulls_first</name><parameter_list>(<parameter><decl><type><name>SkipScanState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>state</name><operator>-&gt;</operator><name>nulls_first</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>has_nulls_last</name><parameter_list>(<parameter><decl><type><name>SkipScanState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>!</operator><call><name>has_nulls_first</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>skip_scan_rescan_index</name><parameter_list>(<parameter><decl><type><name>SkipScanState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* if the scan in the child scan has not been
	 * setup yet which is true before the first tuple
	 * has been retrieved from child scan we cannot
	 * trigger rescan but since the child scan
	 * has not been initialized it will pick up
	 * any ScanKey changes we did */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>state</name><operator>-&gt;</operator><name>scan_desc</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>index_rescan</name><argument_list>(<argument><expr><operator>*</operator><name><name>state</name><operator>-&gt;</operator><name>scan_desc</name></name></expr></argument>,
					 <argument><expr><operator>*</operator><name><name>state</name><operator>-&gt;</operator><name>scan_keys</name></name></expr></argument>,
					 <argument><expr><operator>*</operator><name><name>state</name><operator>-&gt;</operator><name>num_scan_keys</name></name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument> <comment type="block">/*orderbys*/</comment>,
					 <argument><expr><literal type="number">0</literal></expr></argument> <comment type="block">/*norderbys*/</comment>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>needs_rescan</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Update skip scankey flags according to stage
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>skip_scan_switch_stage</name><parameter_list>(<parameter><decl><type><name>SkipScanState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>SkipScanStage</name></type> <name>new_stage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>new_stage</name> <operator>&gt;</operator> <name><name>state</name><operator>-&gt;</operator><name>stage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name>new_stage</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>SS_NOT_NULL</name></expr>:</case>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>skip_key</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>=</operator> <name>SK_ISNULL</name> <operator>|</operator> <name>SK_SEARCHNOTNULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>skip_key</name><operator>-&gt;</operator><name>sk_argument</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>needs_rescan</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>SS_VALUES</name></expr>:</case>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>skip_key</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>needs_rescan</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>SS_NULLS_LAST</name></expr>:</case>
		<case>case <expr><name>SS_NULLS_FIRST</name></expr>:</case>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>skip_key</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>=</operator> <name>SK_ISNULL</name> <operator>|</operator> <name>SK_SEARCHNULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>skip_key</name><operator>-&gt;</operator><name>sk_argument</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>needs_rescan</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>SS_BEGIN</name></expr>:</case>
		<case>case <expr><name>SS_END</name></expr>:</case>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stage</name></name> <operator>=</operator> <name>new_stage</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>skip_scan_update_key</name><parameter_list>(<parameter><decl><type><name>SkipScanState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>prev_is_null</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>distinct_by_val</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>stage</name></name> <operator>==</operator> <name>SS_VALUES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>prev_datum</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_ctx</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>prev_datum</name></name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>distinct_col_attnum</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>prev_is_null</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>prev_is_null</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>skip_key</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>=</operator> <name>SK_ISNULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>skip_key</name><operator>-&gt;</operator><name>sk_argument</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>prev_datum</name></name> <operator>=</operator>
			<call><name>datumCopy</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>prev_datum</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>distinct_by_val</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>distinct_typ_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>skip_key</name><operator>-&gt;</operator><name>sk_argument</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>prev_datum</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* we need to do a rescan whenever we modify the ScanKey */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>needs_rescan</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>skip_scan_exec</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SkipScanState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><operator>(</operator><name>SkipScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We are not supporting projection here since no plan
	 * we generate will need it as our SkipScan node will
	 * always be below Unique need so our targetlist
	 * will not get modified by postgres.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ProjInfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>needs_rescan</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>skip_scan_rescan_index</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<switch>switch <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>stage</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>SS_BEGIN</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>has_nulls_first</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>skip_scan_switch_stage</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>SS_NULLS_FIRST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>skip_scan_switch_stage</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>SS_NOT_NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<break>break;</break>

			<case>case <expr><name>SS_NULLS_FIRST</name></expr>:</case>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name><name>state</name><operator>-&gt;</operator><name>idx</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ExecProcNode</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>idx</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * if we found a NULL value we return it, otherwise
				 * we restart the scan looking for non-NULL
				 */</comment>
				<expr_stmt><expr><call><name>skip_scan_switch_stage</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>SS_NOT_NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>

				<break>break;</break>

			<case>case <expr><name>SS_NOT_NULL</name></expr>:</case>
			<case>case <expr><name>SS_VALUES</name></expr>:</case>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name><name>state</name><operator>-&gt;</operator><name>idx</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ExecProcNode</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>idx</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * if we found a tuple we update the skip scan key
					 * and look for values greater than the value we just
					 * found. If this is the first non-NULL value we
					 * also switch stage to look for values greater than
					 * that in subsequent calls.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>stage</name></name> <operator>==</operator> <name>SS_NOT_NULL</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>skip_scan_switch_stage</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>SS_VALUES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<expr_stmt><expr><call><name>skip_scan_update_key</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>result</name></expr>;</return>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/*
					 * if there are no more values that satisfy
					 * the skip constraint we are either done
					 * for NULLS FIRST ordering or need to check
					 * for NULLs if we have NULLS LAST ordering
					 */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>has_nulls_last</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>skip_scan_switch_stage</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>SS_NULLS_LAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>skip_scan_switch_stage</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>SS_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></else></if_stmt>
				<break>break;</break>

			<case>case <expr><name>SS_NULLS_LAST</name></expr>:</case>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name><name>state</name><operator>-&gt;</operator><name>idx</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ExecProcNode</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>idx</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>skip_scan_switch_stage</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>SS_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>result</name></expr>;</return>
				<break>break;</break>

			<case>case <expr><name>SS_END</name></expr>:</case>
				<return>return <expr><name>NULL</name></expr>;</return>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>skip_scan_end</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SkipScanState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><operator>(</operator><name>SkipScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ExecEndNode</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>idx</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>skip_scan_rescan</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SkipScanState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><operator>(</operator><name>SkipScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
	<comment type="block">/* reset stage so we can assert in skip_scan_switch_stage that stage always moves forward */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stage</name></name> <operator>=</operator> <name>SS_BEGIN</name></expr>;</expr_stmt>

	<comment type="block">/* Switching state here instead of in the main loop
	 * means we dont have to call skip_scan_rescan_index
	 * as ExecReScan on the child scan takes care of that. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>has_nulls_first</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>skip_scan_switch_stage</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>SS_NULLS_FIRST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>skip_scan_switch_stage</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>SS_NOT_NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>prev_is_null</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>prev_datum</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>needs_rescan</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecReScan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>idx</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>CustomExecMethods</name></type> <name>skip_scan_state_methods</name> <init>= <expr><block>{
	<expr><operator>.</operator><name>CustomName</name> <operator>=</operator> <literal type="string">"SkipScanState"</literal></expr>,
	<expr><operator>.</operator><name>BeginCustomScan</name> <operator>=</operator> <name>skip_scan_begin</name></expr>,
	<expr><operator>.</operator><name>EndCustomScan</name> <operator>=</operator> <name>skip_scan_end</name></expr>,
	<expr><operator>.</operator><name>ExecCustomScan</name> <operator>=</operator> <name>skip_scan_exec</name></expr>,
	<expr><operator>.</operator><name>ReScanCustomScan</name> <operator>=</operator> <name>skip_scan_rescan</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<function><type><name>Node</name> <modifier>*</modifier></type>
<name>tsl_skip_scan_state_create</name><parameter_list>(<parameter><decl><type><name>CustomScan</name> <modifier>*</modifier></type><name>cscan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SkipScanState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><operator>(</operator><name>SkipScanState</name> <operator>*</operator><operator>)</operator> <call><name>newNode</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SkipScanState</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>T_CustomScanState</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>idx_scan</name></name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_plans</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stage</name></name> <operator>=</operator> <name>SS_BEGIN</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>distinct_col_attnum</name></name> <operator>=</operator> <call><name>linitial_int</name><argument_list>(<argument><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_private</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>distinct_by_val</name></name> <operator>=</operator> <call><name>lsecond_int</name><argument_list>(<argument><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_private</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>distinct_typ_len</name></name> <operator>=</operator> <call><name>lthird_int</name><argument_list>(<argument><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_private</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>nulls_first</name></name> <operator>=</operator> <call><name>lfourth_int</name><argument_list>(<argument><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_private</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>sk_attno</name></name> <operator>=</operator> <call><name>list_nth_int</name><argument_list>(<argument><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_private</name></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>prev_is_null</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>cscan_state</name><operator>.</operator><name>methods</name></name> <operator>=</operator> <operator>&amp;</operator><name>skip_scan_state_methods</name></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>state</name></expr>;</return>
</block_content>}</block></function>
</unit>
