<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/timescaledb/tsl/src/nodes/skip_scan/planner.c"><comment type="block">/*
 * This file and its contents are licensed under the Timescale License.
 * Please see the included NOTICE for copyright information and
 * LICENSE-TIMESCALE for a copy of the license.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postgres.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/sysattr.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/extensible.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/nodeFuncs.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/makefuncs.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/pathnodes.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/clauses.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/cost.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/optimizer.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/paths.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/pathnode.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/planmain.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/restrictinfo.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/tlist.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;parser/parse_coerce.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;parser/parsetree.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;rewrite/rewriteManip.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/syscache.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/typcache.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;import/planner.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/skip_scan/skip_scan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/constraint_aware_append/constraint_aware_append.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/chunk_append/chunk_append.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compat/compat.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<typedef>typedef <type><struct>struct <name>SkipScanPath</name>
<block>{
	<decl_stmt><decl><type><name>CustomPath</name></type> <name>cpath</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexPath</name> <modifier>*</modifier></type><name>index_path</name></decl>;</decl_stmt>

	<comment type="block">/* Index clause which we'll use to skip past elements we've already seen */</comment>
	<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>skip_clause</name></decl>;</decl_stmt>
	<comment type="block">/* attribute number of the distinct column on the table/chunk */</comment>
	<decl_stmt><decl><type><name>AttrNumber</name></type> <name>distinct_attno</name></decl>;</decl_stmt>
	<comment type="block">/* The column offset on the index we are calling DISTINCT on */</comment>
	<decl_stmt><decl><type><name>AttrNumber</name></type> <name>scankey_attno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>distinct_typ_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>distinct_by_val</name></decl>;</decl_stmt>
	<comment type="block">/* Var referencing the distinct column on the relation */</comment>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>distinct_var</name></decl>;</decl_stmt>
}</block></struct></type> <name>SkipScanPath</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>get_idx_key</name><parameter_list>(<parameter><decl><type><name>IndexOptInfo</name> <modifier>*</modifier></type><name>idxinfo</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>attno</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>sort_indexquals</name><parameter_list>(<parameter><decl><type><name>IndexOptInfo</name> <modifier>*</modifier></type><name>indexinfo</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>quals</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>OpExpr</name> <modifier>*</modifier></type><name>fix_indexqual</name><parameter_list>(<parameter><decl><type><name>IndexOptInfo</name> <modifier>*</modifier></type><name>index</name></decl></parameter>, <parameter><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>scankey_attno</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>build_skip_qual</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>SkipScanPath</name> <modifier>*</modifier></type><name>skip_scan_path</name></decl></parameter>, <parameter><decl><type><name>IndexPath</name> <modifier>*</modifier></type><name>index_path</name></decl></parameter>,
							<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>build_subpath</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>subpaths</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>ndistinct</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ChunkAppendPath</name> <modifier>*</modifier></type><name>copy_chunk_append_path</name><parameter_list>(<parameter><decl><type><name>ChunkAppendPath</name> <modifier>*</modifier></type><name>ca</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>subpaths</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Var</name> <modifier>*</modifier></type><name>get_distinct_var</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>IndexPath</name> <modifier>*</modifier></type><name>index_path</name></decl></parameter>,
							 <parameter><decl><type><name>SkipScanPath</name> <modifier>*</modifier></type><name>skip_scan_path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TargetEntry</name> <modifier>*</modifier></type><name>tlist_member_match_var</name><parameter_list>(<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetlist</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block" format="doxygen">/**************************
 * SkipScan Plan Creation *
 **************************/</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>CustomScanMethods</name></type> <name>skip_scan_plan_methods</name> <init>= <expr><block>{
	<expr><operator>.</operator><name>CustomName</name> <operator>=</operator> <literal type="string">"SkipScan"</literal></expr>,
	<expr><operator>.</operator><name>CreateCustomScanState</name> <operator>=</operator> <name>tsl_skip_scan_state_create</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<function><type><name>void</name></type>
<name>_skip_scan_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>TryRegisterCustomScanMethods</name><argument_list>(<argument><expr><operator>&amp;</operator><name>skip_scan_plan_methods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type>
<name>skip_scan_plan_create</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>relopt</name></decl></parameter>, <parameter><decl><type><name>CustomPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
					  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>clauses</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>custom_plans</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SkipScanPath</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><operator>(</operator><name>SkipScanPath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CustomScan</name> <modifier>*</modifier></type><name>skip_plan</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CustomScan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexPath</name> <modifier>*</modifier></type><name>index_path</name> <init>= <expr><name><name>path</name><operator>-&gt;</operator><name>index_path</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><call><name>fix_indexqual</name><argument_list>(<argument><expr><name><name>index_path</name><operator>-&gt;</operator><name>indexinfo</name></name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>skip_clause</name></name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>scankey_attno</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name>custom_plans</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>IndexScan</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>IndexScan</name> <modifier>*</modifier></type><name>idx_plan</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>IndexScan</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>skip_plan</name><operator>-&gt;</operator><name>scan</name></name> <operator>=</operator> <name><name>idx_plan</name><operator>-&gt;</operator><name>scan</name></name></expr>;</expr_stmt>

		<comment type="block">/* we prepend skip qual here so sort_indexquals will put it as first qual for that column */</comment>
		<expr_stmt><expr><name><name>idx_plan</name><operator>-&gt;</operator><name>indexqual</name></name> <operator>=</operator>
			<call><name>sort_indexquals</name><argument_list>(<argument><expr><name><name>index_path</name><operator>-&gt;</operator><name>indexinfo</name></name></expr></argument>, <argument><expr><call><name>lcons</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name><name>idx_plan</name><operator>-&gt;</operator><name>indexqual</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>IndexOnlyScan</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>IndexOnlyScan</name> <modifier>*</modifier></type><name>idx_plan</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>IndexOnlyScan</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>skip_plan</name><operator>-&gt;</operator><name>scan</name></name> <operator>=</operator> <name><name>idx_plan</name><operator>-&gt;</operator><name>scan</name></name></expr>;</expr_stmt>
		<comment type="block">/* we prepend skip qual here so sort_indexquals will put it as first qual for that column */</comment>
		<expr_stmt><expr><name><name>idx_plan</name><operator>-&gt;</operator><name>indexqual</name></name> <operator>=</operator>
			<call><name>sort_indexquals</name><argument_list>(<argument><expr><name><name>index_path</name><operator>-&gt;</operator><name>indexinfo</name></name></expr></argument>, <argument><expr><call><name>lcons</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name><name>idx_plan</name><operator>-&gt;</operator><name>indexqual</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"bad subplan type for SkipScan: %d"</literal></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name><name>skip_plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>skip_plan</name><operator>-&gt;</operator><name>custom_scan_tlist</name></name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>skip_plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>skip_plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>T_CustomScan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>skip_plan</name><operator>-&gt;</operator><name>methods</name></name> <operator>=</operator> <operator>&amp;</operator><name>skip_scan_plan_methods</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>skip_plan</name><operator>-&gt;</operator><name>custom_plans</name></name> <operator>=</operator> <name>custom_plans</name></expr>;</expr_stmt>
	<comment type="block">/* get position of skipped column in tuples produced by child scan */</comment>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>tlist_member_match_var</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>distinct_var</name></name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>nulls_first</name> <init>= <expr><name><name>index_path</name><operator>-&gt;</operator><name>indexinfo</name><operator>-&gt;</operator><name>nulls_first</name><index>[<expr><name><name>path</name><operator>-&gt;</operator><name>scankey_attno</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>index_path</name><operator>-&gt;</operator><name>indexscandir</name></name> <operator>==</operator> <name>BackwardScanDirection</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>nulls_first</name> <operator>=</operator> <operator>!</operator><name>nulls_first</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>skip_plan</name><operator>-&gt;</operator><name>custom_private</name></name> <operator>=</operator> <call><name>list_make5_int</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>,
											   <argument><expr><name><name>path</name><operator>-&gt;</operator><name>distinct_by_val</name></name></expr></argument>,
											   <argument><expr><name><name>path</name><operator>-&gt;</operator><name>distinct_typ_len</name></name></expr></argument>,
											   <argument><expr><name>nulls_first</name></expr></argument>,
											   <argument><expr><name><name>path</name><operator>-&gt;</operator><name>scankey_attno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>&amp;</operator><name><name>skip_plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*************************
 * SkipScanPath Creation *
 *************************/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>CustomPathMethods</name></type> <name>skip_scan_path_methods</name> <init>= <expr><block>{
	<expr><operator>.</operator><name>CustomName</name> <operator>=</operator> <literal type="string">"SkipScanPath"</literal></expr>,
	<expr><operator>.</operator><name>PlanCustomPath</name> <operator>=</operator> <name>skip_scan_plan_create</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>SkipScanPath</name> <modifier>*</modifier></type><name>skip_scan_path_create</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>IndexPath</name> <modifier>*</modifier></type><name>index_path</name></decl></parameter>,
										   <parameter><decl><type><name>double</name></type> <name>ndistinct</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Create SkipScan paths based on existing Unique paths.
 * For a Unique path on a simple relation like the following
 *
 *  Unique
 *    -&gt;  Index Scan using skip_scan_dev_name_idx on skip_scan
 *
 * a SkipScan path like this will be created:
 *
 *  Unique
 *    -&gt;  Custom Scan (SkipScan) on skip_scan
 *          -&gt;  Index Scan using skip_scan_dev_name_idx on skip_scan
 *
 * For a Unique path on a hypertable with multiple chunks like the following
 *
 *  Unique
 *    -&gt;  Merge Append
 *          Sort Key: _hyper_2_1_chunk.dev_name
 *          -&gt;  Index Scan using _hyper_2_1_chunk_idx on _hyper_2_1_chunk
 *          -&gt;  Index Scan using _hyper_2_2_chunk_idx on _hyper_2_2_chunk
 *
 * a SkipScan path like this will be created:
 *
 *  Unique
 *    -&gt;  Merge Append
 *          Sort Key: _hyper_2_1_chunk.dev_name
 *          -&gt;  Custom Scan (SkipScan) on _hyper_2_1_chunk
 *                -&gt;  Index Scan using _hyper_2_1_chunk_idx on _hyper_2_1_chunk
 *          -&gt;  Custom Scan (SkipScan) on _hyper_2_2_chunk
 *                -&gt;  Index Scan using _hyper_2_2_chunk_idx on _hyper_2_2_chunk
 */</comment>
<function><type><name>void</name></type>
<name>tsl_skip_scan_paths_add</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>input_rel</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>output_rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UpperUniquePath</name> <modifier>*</modifier></type><name>unique</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ts_guc_enable_skip_scan</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * look for Unique Path so we dont have repeat some of
	 * the calculations done by postgres and can also assume
	 * that the DISTINCT clause is elegible for sort based
	 * DISTINCT
	 */</comment>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>output_rel-&gt;pathlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>UpperUniquePath</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>unique</name> <operator>=</operator> <call><name>lfirst_node</name><argument_list>(<argument><expr><name>UpperUniquePath</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* currently we do not handle DISTINCT on more than one key. To do so,
			 * we would need to break down the SkipScan into subproblems: first
			 * find the minimal tuple then for each prefix find all unique suffix
			 * tuples. For instance, if we are searching over (int, int), we would
			 * first find (0, 0) then find (0, N) for all N in the domain, then
			 * find (1, N), then (2, N), etc
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>unique</name><operator>-&gt;</operator><name>numkeys</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return;</return></block_content></block></if></if_stmt>

			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* no UniquePath found so this query might not be
	 * elegible for sort-based DISTINCT and therefore
	 * not elegible for SkipScan either */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>unique</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Need to make a copy of the unique path here because add_path() in the
	 * pathlist loop below might prune it if the new unique path
	 * (SkipScanPath) dominates the old one. When the unique path is pruned,
	 * the pointer will no longer be valid in the next iteration of the
	 * pathlist loop. Fortunately, the Path object is not deeply freed, so a
	 * shallow copy is enough. */</comment>
	<expr_stmt><expr><name>unique</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>UpperUniquePath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>unique</name></expr></argument>, <argument><expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>UpperUniquePath</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>UpperUniquePath</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>input_rel-&gt;pathlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>project</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>has_caa</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Path</name> <modifier>*</modifier></type><name>subpath</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pathkeys_contained_in</name><argument_list>(<argument><expr><name><name>unique</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name></expr></argument>, <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* If path is a ProjectionPath we strip it off for processing
		 * but also add a ProjectionPath on top of the SKipScanPaths
		 * later.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>, <argument><expr><name>ProjectionPath</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ProjectionPath</name> <modifier>*</modifier></type><name>proj</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>ProjectionPath</name></expr></argument>, <argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>subpath</name> <operator>=</operator> <name><name>proj</name><operator>-&gt;</operator><name>subpath</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>project</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Path might be wrapped in a ConstraintAwareAppendPath if this
		 * is a MergeAppend that could benefit from runtime exclusion.
		 * We treat this similar to ProjectionPath and add it back
		 * later
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>ts_is_constraint_aware_append_path</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>subpath</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>CustomPath</name></expr></argument>, <argument><expr><name>subpath</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>custom_paths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>, <argument><expr><name>MergeAppendPath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>has_caa</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>, <argument><expr><name>IndexPath</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>IndexPath</name> <modifier>*</modifier></type><name>index_path</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>IndexPath</name></expr></argument>, <argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>subpath</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>skip_scan_path_create</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>index_path</name></expr></argument>, <argument><expr><name><name>unique</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>subpath</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>, <argument><expr><name>MergeAppendPath</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>MergeAppendPath</name> <modifier>*</modifier></type><name>merge_path</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>MergeAppendPath</name></expr></argument>, <argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>new_paths</name> <init>= <expr><call><name>build_subpath</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>merge_path</name><operator>-&gt;</operator><name>subpaths</name></name></expr></argument>, <argument><expr><name><name>unique</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* build_subpath returns NULL when no SkipScanPath was created */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>new_paths</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>subpath</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_merge_append_path_compat</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
															   <argument><expr><name><name>merge_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name></expr></argument>,
															   <argument><expr><name>new_paths</name></expr></argument>,
															   <argument><expr><name><name>merge_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name></expr></argument>,
															   <argument><expr><name>NULL</name></expr></argument>,
															   <argument><expr><name><name>merge_path</name><operator>-&gt;</operator><name>partitioned_rels</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>subpath</name><operator>-&gt;</operator><name>pathtarget</name></name> <operator>=</operator> <call><name>copy_pathtarget</name><argument_list>(<argument><expr><name><name>merge_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>ts_is_chunk_append_path</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ChunkAppendPath</name> <modifier>*</modifier></type><name>ca</name> <init>= <expr><operator>(</operator><name>ChunkAppendPath</name> <operator>*</operator><operator>)</operator> <name>subpath</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>new_paths</name> <init>= <expr><call><name>build_subpath</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>ca</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>custom_paths</name></name></expr></argument>, <argument><expr><name><name>unique</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<comment type="block">/* ChunkAppend should never be wrapped in ConstraintAwareAppendPath */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>has_caa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* build_subpath returns NULL when no SkipScanPath was created */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>new_paths</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/* We copy the existing ChunkAppendPath here because we don't have all the
			 * information used for creating the original one and we don't want to
			 * duplicate all the checks done when creating the original one.
			 */</comment>
			<expr_stmt><expr><name>subpath</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>copy_chunk_append_path</name><argument_list>(<argument><expr><name>ca</name></expr></argument>, <argument><expr><name>new_paths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* add ConstraintAwareAppendPath if the original path had one */</comment>
		<if_stmt><if>if <condition>(<expr><name>has_caa</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>subpath</name> <operator>=</operator> <call><name>ts_constraint_aware_append_path_create</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<decl_stmt><decl><type><name>Path</name> <modifier>*</modifier></type><name>new_unique</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
			<call><name>create_upper_unique_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>output_rel</name></expr></argument>, <argument><expr><name>subpath</name></expr></argument>, <argument><expr><name><name>unique</name><operator>-&gt;</operator><name>numkeys</name></name></expr></argument>, <argument><expr><name><name>unique</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>new_unique</name><operator>-&gt;</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>unique</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>project</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>new_unique</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_projection_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
														 <argument><expr><name>output_rel</name></expr></argument>,
														 <argument><expr><name>new_unique</name></expr></argument>,
														 <argument><expr><call><name>copy_pathtarget</name><argument_list>(<argument><expr><name><name>new_unique</name><operator>-&gt;</operator><name>pathtarget</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>output_rel</name></expr></argument>, <argument><expr><name>new_unique</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ChunkAppendPath</name> <modifier>*</modifier></type>
<name>copy_chunk_append_path</name><parameter_list>(<parameter><decl><type><name>ChunkAppendPath</name> <modifier>*</modifier></type><name>ca</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>subpaths</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>total_cost</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>rows</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ChunkAppendPath</name> <modifier>*</modifier></type><name>new</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ChunkAppendPath</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>new</name></expr></argument>, <argument><expr><name>ca</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ChunkAppendPath</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>new</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>custom_paths</name></name> <operator>=</operator> <name>subpaths</name></expr>;</expr_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>subpaths</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Path</name> <modifier>*</modifier></type><name>child</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>total_cost</name> <operator>+=</operator> <name><name>child</name><operator>-&gt;</operator><name>total_cost</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>rows</name> <operator>+=</operator> <name><name>child</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><name><name>new</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <name>total_cost</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>new</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <name>rows</name></expr>;</expr_stmt>

	<return>return <expr><name>new</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SkipScanPath</name> <modifier>*</modifier></type>
<name>skip_scan_path_create</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>IndexPath</name> <modifier>*</modifier></type><name>index_path</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>ndistinct</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type> <name>startup</name> <init>= <expr><name><name>index_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>total</name> <init>= <expr><name><name>index_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>rows</name> <init>= <expr><name><name>index_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* cannot use SkipScan with non-orderable index or IndexPath without pathkeys */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>index_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>||</operator> <operator>!</operator><name><name>index_path</name><operator>-&gt;</operator><name>indexinfo</name><operator>-&gt;</operator><name>sortopfamily</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* orderbyops are not compatible with skipscan */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>index_path</name><operator>-&gt;</operator><name>indexorderbys</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>SkipScanPath</name> <modifier>*</modifier></type><name>skip_scan_path</name> <init>= <expr><operator>(</operator><name>SkipScanPath</name> <operator>*</operator><operator>)</operator> <call><name>newNode</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SkipScanPath</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>T_CustomPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>skip_scan_path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_CustomScan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>skip_scan_path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name><name>index_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>skip_scan_path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>index_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>skip_scan_path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <name><name>index_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>skip_scan_path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name><name>index_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>skip_scan_path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <name>ndistinct</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>skip_scan_path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>custom_paths</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>index_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>skip_scan_path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>methods</name></name> <operator>=</operator> <operator>&amp;</operator><name>skip_scan_path_methods</name></expr>;</expr_stmt>

	<comment type="block">/* We calculate SkipScan cost as ndistinct * startup_cost + (ndistinct/rows) * total_cost
	 * ndistinct * startup_cost is to account for the rescans we have to do and since startup
	 * cost for indexes does not include page access cost we add a fraction of the total cost
	 * accounting for the number of rows we expect to fetch.
	 * If the row estimate for the scan is 1 we assume that the estimate got clamped to 1
	 * and no rows would be returned by this scan and this chunk will most likely be excluded
	 * by runtime exclusion. Otherwise the cost for this path would be highly inflated due
	 * to (ndistinct / rows) * total leading to SkipScan not being chosen for queries on
	 * hypertables with a lot of excluded chunks.
	 */</comment>
	<expr_stmt><expr><name><name>skip_scan_path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name>startup</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rows</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>skip_scan_path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <name>ndistinct</name> <operator>*</operator> <name>startup</name> <operator>+</operator> <operator>(</operator><name>ndistinct</name> <operator>/</operator> <name>rows</name><operator>)</operator> <operator>*</operator> <name>total</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>skip_scan_path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <name>startup</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* While add_path may pfree paths with higher costs
	 * it will never free IndexPaths and only ever do a shallow
	 * free so reusing the IndexPath here is safe. */</comment>
	<expr_stmt><expr><name><name>skip_scan_path</name><operator>-&gt;</operator><name>index_path</name></name> <operator>=</operator> <name>index_path</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><call><name>get_distinct_var</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>index_path</name></expr></argument>, <argument><expr><name>skip_scan_path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>var</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>skip_scan_path</name><operator>-&gt;</operator><name>distinct_var</name></name> <operator>=</operator> <name>var</name></expr>;</expr_stmt>

	<comment type="block">/* build skip qual this may fail if we cannot look up the operator */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>build_skip_qual</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>skip_scan_path</name></expr></argument>, <argument><expr><name>index_path</name></expr></argument>, <argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>skip_scan_path</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Extract the Var to use for the SkipScan and do attno mapping if required. */</comment>
<function><type><specifier>static</specifier> <name>Var</name> <modifier>*</modifier></type>
<name>get_distinct_var</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>IndexPath</name> <modifier>*</modifier></type><name>index_path</name></decl></parameter>, <parameter><decl><type><name>SkipScanPath</name> <modifier>*</modifier></type><name>skip_scan_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>num_vars</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name> <init>= <expr><name><name>index_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>tlexpr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>root-&gt;parse-&gt;distinctClause</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>clause</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>SortGroupClause</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><call><name>get_sortgroupclause_expr</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* we ignore any columns that can be constified to allow for cases like DISTINCT 'abc',
		 * column */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><call><name>estimate_expression_value</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>num_vars</name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/* We ignore binary-compatible relabeling */</comment>
		<expr_stmt><expr><name>tlexpr</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>tlexpr</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>tlexpr</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>tlexpr</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>tlexpr</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></while>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>num_vars</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* SkipScan on expressions not supported */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tlexpr</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>tlexpr</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>Var</name></expr></argument>, <argument><expr><name>tlexpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* If we are dealing with a hypertable Var extracted from distinctClause will point to
	 * the parent hypertable while the IndexPath will be on a Chunk.
	 * For a normal table they point to the same relation and we are done here. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>Index</name><operator>)</operator> <name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>var</name></expr>;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>ht_rte</name> <init>= <expr><call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>chunk_rte</name> <init>= <expr><call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Check for hypertable */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ts_is_hypertable</name><argument_list>(<argument><expr><name><name>ht_rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>top_parent_relids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>ht_rel</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name><name>ht_rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>chunk_rel</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name><name>chunk_rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>found_wholerow</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleConversionMap</name> <modifier>*</modifier></type><name>map</name> <init>=
		<expr><call><name>convert_tuples_by_name_compat</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>chunk_rel</name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>ht_rel</name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"could not convert row type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* attno mapping necessary */</comment>
	<if_stmt><if>if <condition>(<expr><name>map</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>map_variable_attnos_compat</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></argument>,
												 <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>,
												 <argument><expr><literal type="number">0</literal></expr></argument>,
												 <argument><expr><name><name>map</name><operator>-&gt;</operator><name>attrMap</name></name></expr></argument>,
												 <argument><expr><name><name>map</name><operator>-&gt;</operator><name>outdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>,
												 <argument><expr><name>InvalidOid</name></expr></argument>,
												 <argument><expr><operator>&amp;</operator><name>found_wholerow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>free_conversion_map</name><argument_list>(<argument><expr><name>map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* If we found whole row here skipscan wouldn't be applicable
		 * but this should have been caught already in previous checks */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>found_wholerow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>found_wholerow</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>ht_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>chunk_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>ht_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>chunk_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr>;</expr_stmt>

	<return>return <expr><name>var</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Creates SkipScanPath for each path of subpaths that is an IndexPath
 * If no subpath can be changed to SkipScanPath returns NULL
 * otherwise returns list of new paths
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>build_subpath</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>subpaths</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>ndistinct</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>has_skip_path</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>new_paths</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>subpaths</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Path</name> <modifier>*</modifier></type><name>child</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr><name>IndexPath</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SkipScanPath</name> <modifier>*</modifier></type><name>skip_path</name> <init>=
				<expr><call><name>skip_scan_path_create</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>IndexPath</name></expr></argument>, <argument><expr><name>child</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ndistinct</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>skip_path</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>child</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>skip_path</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>has_skip_path</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>new_paths</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>new_paths</name></expr></argument>, <argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>has_skip_path</name> <operator>&amp;&amp;</operator> <name>new_paths</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>new_paths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>new_paths</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>build_skip_qual</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>SkipScanPath</name> <modifier>*</modifier></type><name>skip_scan_path</name></decl></parameter>, <parameter><decl><type><name>IndexPath</name> <modifier>*</modifier></type><name>index_path</name></decl></parameter>, <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexOptInfo</name> <modifier>*</modifier></type><name>info</name> <init>= <expr><name><name>index_path</name><operator>-&gt;</operator><name>indexinfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>column_type</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>column_collation</name> <init>= <expr><call><name>get_typcollation</name><argument_list>(<argument><expr><name>column_type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>tce</name> <init>= <expr><call><name>lookup_type_cache</name><argument_list>(<argument><expr><name>column_type</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>need_coerce</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Skipscan is not applicable for the following case:
	 * We might have a path with an index that produces the correct pathkeys for the target ordering
	 * without actually including all the columns of the ORDER BY. If the path uses an index that
	 * does not include the distinct column, we cannot use it for skipscan and have to discard this
	 * path from skipscan generation. This happens, for instance, when we have an order by clause
	 * (like ORDER BY a, b) with constraints in the WHERE clause (like WHERE a = &lt;constant&gt;) . "a"
	 * can now be removed from the Pathkeys (since it is a constant) and the query can be satisfied
	 * by using an index on just column "b".
	 *
	 * Example query:
	 * SELECT DISTINCT ON (a) * FROM test WHERE a in (2) ORDER BY a ASC, time DESC;
	 * Since a is always 2 due to the WHERE clause we can create the correct ordering for the
	 * ORDER BY with an index that does not include the a column and only includes the time column.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>idx_key</name> <init>= <expr><call><name>get_idx_key</name><argument_list>(<argument><expr><name>info</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>idx_key</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>skip_scan_path</name><operator>-&gt;</operator><name>distinct_attno</name></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>skip_scan_path</name><operator>-&gt;</operator><name>distinct_by_val</name></name> <operator>=</operator> <name><name>tce</name><operator>-&gt;</operator><name>typbyval</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>skip_scan_path</name><operator>-&gt;</operator><name>distinct_typ_len</name></name> <operator>=</operator> <name><name>tce</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt>
	<comment type="block">/* sk_attno of the skip qual */</comment>
	<expr_stmt><expr><name><name>skip_scan_path</name><operator>-&gt;</operator><name>scankey_attno</name></name> <operator>=</operator> <name>idx_key</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>int16</name></type> <name>strategy</name> <init>= <expr><ternary><condition><expr><name><name>info</name><operator>-&gt;</operator><name>reverse_sort</name><index>[<expr><name>idx_key</name></expr>]</index></name></expr> ?</condition><then> <expr><name>BTLessStrategyNumber</name></expr> </then><else>: <expr><name>BTGreaterStrategyNumber</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>index_path</name><operator>-&gt;</operator><name>indexscandir</name></name> <operator>==</operator> <name>BackwardScanDirection</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>strategy</name> <operator>=</operator>
			<ternary><condition><expr><operator>(</operator><name>strategy</name> <operator>==</operator> <name>BTLessStrategyNumber</name><operator>)</operator></expr> ?</condition><then> <expr><name>BTGreaterStrategyNumber</name></expr> </then><else>: <expr><name>BTLessStrategyNumber</name></expr></else></ternary></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>opcintype</name> <init>= <expr><name><name>info</name><operator>-&gt;</operator><name>opcintype</name><index>[<expr><name>idx_key</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>comparator</name> <init>=
		<expr><call><name>get_opfamily_member</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>sortopfamily</name><index>[<expr><name>idx_key</name></expr>]</index></name></expr></argument>, <argument><expr><name>column_type</name></expr></argument>, <argument><expr><name>column_type</name></expr></argument>, <argument><expr><name>strategy</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* If there is no exact operator match for the column type we have here check
	 * if we can coerce to the type of the operator class. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>comparator</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IsBinaryCoercible</name><argument_list>(<argument><expr><name>column_type</name></expr></argument>, <argument><expr><name>opcintype</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>comparator</name> <operator>=</operator>
				<call><name>get_opfamily_member</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>sortopfamily</name><index>[<expr><name>idx_key</name></expr>]</index></name></expr></argument>, <argument><expr><name>opcintype</name></expr></argument>, <argument><expr><name>opcintype</name></expr></argument>, <argument><expr><name>strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>comparator</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>need_coerce</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt> <comment type="block">/* cannot use this index */</comment>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>prev_val</name> <init>= <expr><call><name>makeNullConst</name><argument_list>(<argument><expr><ternary><condition><expr><name>need_coerce</name></expr> ?</condition><then> <expr><name>opcintype</name></expr> </then><else>: <expr><name>column_type</name></expr></else></ternary></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>column_collation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>current_val</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeVar</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument> <comment type="block">/*varno*/</comment>,
										 <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument> <comment type="block">/*varattno*/</comment>,
										 <argument><expr><name>column_type</name></expr></argument> <comment type="block">/*vartype*/</comment>,
										 <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument> <comment type="block">/*vartypmod*/</comment>,
										 <argument><expr><name>column_collation</name></expr></argument> <comment type="block">/*varcollid*/</comment>,
										 <argument><expr><literal type="number">0</literal></expr></argument> <comment type="block">/*varlevelsup*/</comment>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>need_coerce</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CoerceViaIO</name> <modifier>*</modifier></type><name>coerce</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CoerceViaIO</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>coerce</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <name>current_val</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>coerce</name><operator>-&gt;</operator><name>resulttype</name></name> <operator>=</operator> <name>opcintype</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>coerce</name><operator>-&gt;</operator><name>resultcollid</name></name> <operator>=</operator> <name>column_collation</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>coerce</name><operator>-&gt;</operator><name>coerceformat</name></name> <operator>=</operator> <name>COERCE_IMPLICIT_CAST</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>coerce</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name>current_val</name> <operator>=</operator> <operator>&amp;</operator><name><name>coerce</name><operator>-&gt;</operator><name>xpr</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>comparison_expr</name> <init>= <expr><call><name>make_opclause</name><argument_list>(<argument><expr><name>comparator</name></expr></argument>,
										  <argument><expr><name>BOOLOID</name></expr></argument> <comment type="block">/*opresulttype*/</comment>,
										  <argument><expr><name>false</name></expr></argument> <comment type="block">/*opretset*/</comment>,
										  <argument><expr><name>current_val</name></expr></argument> <comment type="block">/*leftop*/</comment>,
										  <argument><expr><operator>&amp;</operator><name><name>prev_val</name><operator>-&gt;</operator><name>xpr</name></name></expr></argument> <comment type="block">/*rightop*/</comment>,
										  <argument><expr><name>InvalidOid</name></expr></argument> <comment type="block">/*opcollid*/</comment>,
										  <argument><expr><name><name>info</name><operator>-&gt;</operator><name>indexcollations</name><index>[<expr><name>idx_key</name></expr>]</index></name></expr></argument> <comment type="block">/*inputcollid*/</comment>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>set_opfuncid</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>OpExpr</name></expr></argument>, <argument><expr><name>comparison_expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>skip_scan_path</name><operator>-&gt;</operator><name>skip_clause</name></name> <operator>=</operator> <call><name>make_simple_restrictinfo_compat</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>comparison_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>get_idx_key</name><parameter_list>(<parameter><decl><type><name>IndexOptInfo</name> <modifier>*</modifier></type><name>idxinfo</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>attno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>idxinfo</name><operator>-&gt;</operator><name>nkeycolumns</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>attno</name> <operator>==</operator> <name><name>idxinfo</name><operator>-&gt;</operator><name>indexkeys</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>i</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Sort quals according to index column order.
 * ScanKeys need to be sorted by the position of the index column
 * they are referencing but since we don't want to adjust actual
 * ScanKey array we presort qual list when creating plan.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>sort_indexquals</name><parameter_list>(<parameter><decl><type><name>IndexOptInfo</name> <modifier>*</modifier></type><name>indexinfo</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>quals</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name><name>indexclauses</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>ordered_list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>quals</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>bms</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>pull_varattnos</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>INDEX_VAR</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>bms_num_members</name><argument_list>(<argument><expr><name>bms</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name>bms</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>+</operator> <name>FirstLowInvalidHeapAttributeNumber</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>indexclauses</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>indexclauses</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>INDEX_MAX_KEYS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>indexclauses</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>ordered_list</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>ordered_list</name></expr></argument>, <argument><expr><name><name>indexclauses</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>ordered_list</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>OpExpr</name> <modifier>*</modifier></type>
<name>fix_indexqual</name><parameter_list>(<parameter><decl><type><name>IndexOptInfo</name> <modifier>*</modifier></type><name>index</name></decl></parameter>, <parameter><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>scankey_attno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* technically our placeholder col &gt; NULL is unsatisfiable, and in some instances
	 * the planner will realize this and use is as an excuse to remove other quals.
	 * in order to prevent this, we prepare this qual ourselves.
	 */</comment>

	<comment type="block">/* fix_indexqual_references */</comment>
	<decl_stmt><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>OpExpr</name></expr></argument>, <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>bms_equal</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>left_relids</name></name></expr></argument>, <argument><expr><name><name>index</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* fix_indexqual_operand */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>indexkeys</name><index>[<expr><name>scankey_attno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>linitial_node</name><argument_list>(<argument><expr><name>Var</name></expr></argument>, <argument><expr><call><name>pull_var_clause</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>Index</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>varno</name> <operator>==</operator> <name><name>index</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>relid</name></name> <operator>&amp;&amp;</operator>
		   <operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>varattno</name> <operator>==</operator> <name><name>index</name><operator>-&gt;</operator><name>indexkeys</name><index>[<expr><name>scankey_attno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>varno</name></name> <operator>=</operator> <name>INDEX_VAR</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>varattno</name></name> <operator>=</operator> <name>scankey_attno</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>=</operator> <name>result</name></expr>;</expr_stmt>

	<return>return <expr><name>op</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * tlist_member_match_var
 *    Same as tlist_member, except that we match the provided Var on the basis
 *    of varno/varattno/varlevelsup/vartype only, rather than full equal().
 *
 * This is needed in some cases where we can't be sure of an exact typmod
 * match.  For safety, though, we insist on vartype match.
 *
 * static function copied from src/backend/optimizer/util/tlist.c
 */</comment>
<function><type><specifier>static</specifier> <name>TargetEntry</name> <modifier>*</modifier></type>
<name>tlist_member_match_var</name><parameter_list>(<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>temp</name></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>temp</argument>, <argument>targetlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tlentry</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>tlvar</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>tlentry</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tlvar</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>tlvar</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name><name>tlvar</name><operator>-&gt;</operator><name>varno</name></name> <operator>&amp;&amp;</operator> <name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <name><name>tlvar</name><operator>-&gt;</operator><name>varattno</name></name> <operator>&amp;&amp;</operator>
			<name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>==</operator> <name><name>tlvar</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>&amp;&amp;</operator> <name><name>var</name><operator>-&gt;</operator><name>vartype</name></name> <operator>==</operator> <name><name>tlvar</name><operator>-&gt;</operator><name>vartype</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>tlentry</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>
</unit>
