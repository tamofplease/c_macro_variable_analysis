<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/timescaledb/tsl/src/nodes/data_node_dispatch.c"><comment type="block">/*
 * This file and its contents are licensed under the Timescale License.
 * Please see the included NOTICE for copyright information and
 * LICENSE-TIMESCALE for a copy of the license.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postgres.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;parser/parsetree.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/execnodes.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/extensible.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/makefuncs.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/nodeFuncs.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/plannodes.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;executor/executor.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;executor/nodeModifyTable.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/lsyscache.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/builtins.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/hsearch.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/tuplestore.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/memutils.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;funcapi.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;miscadmin.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ts_catalog/chunk_data_node.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/chunk_dispatch_plan.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/chunk_dispatch_state.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/chunk_insert_state.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;hypertable_cache.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;compat/compat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;guc.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"data_node_dispatch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fdw/scan_exec.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fdw/deparse.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"remote/utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"remote/dist_txn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"remote/async.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"remote/data_format.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"remote/tuplefactory.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TUPSTORE_MEMSIZE_KB</name></cpp:macro> <cpp:value>work_mem</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TUPSTORE_FLUSH_THRESHOLD</name></cpp:macro> <cpp:value>ts_guc_max_insert_batch_size</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>DataNodeDispatchPath</name>
<block>{
	<decl_stmt><decl><type><name>CustomPath</name></type> <name>cpath</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ModifyTablePath</name> <modifier>*</modifier></type><name>mtpath</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type> <name>hypertable_rti</name></decl>;</decl_stmt> <comment type="block">/* range table index of Hypertable */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>subplan_index</name></decl>;</decl_stmt>
}</block></struct></type> <name>DataNodeDispatchPath</name>;</typedef>

<comment type="block">/*
 * DataNodeDispatch dispatches tuples to data nodes using batching. It inserts
 * itself below a ModifyTable node in the plan and subsequent execution tree,
 * like so:
 *
 *          --------------------   Set "direct modify plans" to
 *          | HypertableInsert |   signal ModifyTable to only
 *          --------------------   handle returning projection.
 *                   |
 *            ----------------     resultRelInfo-&gt;ri_usesFdwDirectModify
 *            |  ModifyTable |     should be TRUE. Handle returning projection.
 *            ----------------
 *                   ^
 *                   | RETURNING tuple or nothing
 *          --------------------
 *          | DataNodeDispatch |    Batch and send tuples to data nodes.
 *          --------------------
 *                   ^
 *                   | Chunk-routed tuple
 *           -----------------
 *           | ChunkDispatch |     Route tuple to chunk.
 *           -----------------     Set es_result_relation.
 *                   ^
 *                   | tuple
 *             --------------
 *             | ValuesScan |     VALUES ('2019-02-23 13:43', 1, 8.9),
 *             --------------            ('2019-02-23 13:46', 2, 1.5);
 *
 *
 * Data node dispatching uses the state machine outlined below:
 *
 * READ: read tuples from the subnode and save in per-node stores until one
 * of them reaches FLUSH_THRESHOLD and then move to FLUSH. If a NULL-tuple is
 * read before the threshold is reached, move to LAST_FLUSH. In case of
 * replication, tuples are split across a primary and a replica tuple store.
 *
 * FLUSH: flush the tuples for the data nodes that reached
 * FLUSH_THRESHOLD.
 *
 * LAST_FLUSH: flush tuples for all data nodes.
 *
 * RETURNING: if there is a RETURNING clause, return the inserted tuples
 * one-by-one from all flushed nodes. When no more tuples remain, move to
 * READ again or DONE if the previous state was LAST_FLUSH. Note, that in case
 * of replication, the tuples are split across a primary and a replica tuple
 * store for each data node. only tuples in the primary tuple store are
 * returned. It is implicitly assumed that the primary tuples are sent on a
 * connection before the replica tuples and thus the data node will also return
 * the primary tuples first (in order of insertion).
 *
 *   read
 *    ==
 *  thresh     -------------
 *      -----&gt; |   FLUSH   |---&gt;----
 *      |      -------------       |       prev_state
 *      |                          |           ==
 *  --------                 ------------- LAST_FLUSH ----------
 *  | READ | &lt;-------------- | RETURNING | ---------&gt; |  DONE  |
 *  --------                 -------------            ----------
 *      |                          ^
 *      |     --------------       |
 *      ----&gt; | LAST_FLUSH | -------
 * read == 0  --------------
 *
 *
 * Potential optimizations
 * =======================
 *
 * - Tuples from both the primary and the replica tuple store are flushed with
 *   a RETURNING clause when such a clause is available. However, tuples from
 *   the replica store need not be returned, so using a separate prepared
 *   statement without RETURNING for the replica store would save bandwidth.
 *
 * - Better asynchronous behavior. When reading tuples, a flush happens as
 *   soon as a tuple store is filled instead of continuing to fill until more
 *   stores can be flushed. Further, after flushing tuples for a data node, the
 *   code immediately waits for a response instead of doing other work while
 *   waiting.
 *
 * - Currently, there is one "global" state machine for the
 *   DataNodeDispatchState executor node. Turning this into per-node state
 *   machines might make the code more asynchronous and/or amenable to
 *   parallel mode support.
 *
 * - COPY instead of INSERT. When there's no RETURNING clause, it is more
 *   efficient to COPY data rather than using a prepared statement.
 *
 * - Binary instead of text format. Send tuples in binary format instead of
 *   text to save bandwidth and reduce latency.
 */</comment>
<typedef>typedef <type><enum>enum <name>DispatchState</name>
<block>{
	<decl><name>SD_READ</name></decl>,
	<decl><name>SD_FLUSH</name></decl>,
	<decl><name>SD_LAST_FLUSH</name></decl>,
	<decl><name>SD_RETURNING</name></decl>,
	<decl><name>SD_DONE</name></decl>,
}</block></enum></type> <name>DispatchState</name>;</typedef>

<typedef>typedef <type><struct>struct <name>DataNodeDispatchState</name>
<block>{
	<decl_stmt><decl><type><name>CustomScanState</name></type> <name>cstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DispatchState</name></type> <name>prevstate</name></decl>;</decl_stmt> <comment type="block">/* Previous state in state machine */</comment>
	<decl_stmt><decl><type><name>DispatchState</name></type> <name>state</name></decl>;</decl_stmt>	 <comment type="block">/* Current state in state machine */</comment>
	<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name></decl>;</decl_stmt>			 <comment type="block">/* The (local) relation we're inserting into */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>set_processed</name></decl>;</decl_stmt>		 <comment type="block">/* Indicates whether to set the number or processed tuples */</comment>
	<decl_stmt><decl><type><name>DeparsedInsertStmt</name></type> <name>stmt</name></decl>;</decl_stmt> <comment type="block">/* Partially deparsed insert statement */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sql_stmt</name></decl>;</decl_stmt>	 <comment type="block">/* Fully deparsed insert statement */</comment>
	<decl_stmt><decl><type><name>TupleFactory</name> <modifier>*</modifier></type><name>tupfactory</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>target_attrs</name></decl>;</decl_stmt>		  <comment type="block">/* The attributes to send to remote data nodes */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>responses</name></decl>;</decl_stmt>		  <comment type="block">/* List of responses to process in RETURNING state */</comment>
	<decl_stmt><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>nodestates</name></decl>;</decl_stmt>		  <comment type="block">/* Hashtable of per-nodestate (tuple stores) */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>mcxt</name></decl>;</decl_stmt>		  <comment type="block">/* Memory context for per-node state */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>batch_mcxt</name></decl>;</decl_stmt> <comment type="block">/* Memory context for batches of data */</comment>
	<decl_stmt><decl><type><name>int64</name></type> <name>num_tuples</name></decl>;</decl_stmt>		  <comment type="block">/* Total number of tuples flushed each round */</comment>
	<decl_stmt><decl><type><name>int64</name></type> <name>next_tuple</name></decl>;</decl_stmt>		  <comment type="block">/* Next tuple to return to the parent node when in
							   * RETURNING state */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>replication_factor</name></decl>;</decl_stmt>	  <comment type="block">/* &gt; 1 if we replicate tuples across data nodes */</comment>
	<decl_stmt><decl><type><name>StmtParams</name> <modifier>*</modifier></type><name>stmt_params</name></decl>;</decl_stmt>  <comment type="block">/* Parameters to send with statement. Format can be binary or text */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>flush_threshold</name></decl>;</decl_stmt>	  <comment type="block">/* Batch size used for this dispatch state */</comment>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>batch_slot</name></decl>;</decl_stmt> <comment type="block">/* Slot used for sending tuples to data
								 * nodes. Note that this needs to be a
								 * MinimalTuple slot, so we cannot use the
								 * standard ScanSlot in the ScanState because
								 * CustomNode sets it up to be a
								 * VirtualTuple. */</comment>
	<decl_stmt><decl><type><name>ChunkDispatchState</name> <modifier>*</modifier></type><name>cds</name></decl>;</decl_stmt>
}</block></struct></type> <name>DataNodeDispatchState</name>;</typedef>

<comment type="block">/*
 * Plan metadata list indexes.
 */</comment>
<enum>enum <name>CustomScanPrivateIndex</name>
<block>{
	<decl><name>CustomScanPrivateSql</name></decl>,
	<decl><name>CustomScanPrivateTargetAttrs</name></decl>,
	<decl><name>CustomScanPrivateDeparsedInsertStmt</name></decl>,
	<decl><name>CustomScanPrivateSetProcessed</name></decl>,
	<decl><name>CustomScanPrivateFlushThreshold</name></decl>
}</block>;</enum>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAS_RETURNING</name><parameter_list>(<parameter><type><name>sds</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((sds)-&gt;stmt.returning != NULL)</cpp:value></cpp:define>

<comment type="block">/*
 * DataNodeState for each data node.
 *
 * Tuples destined for a data node are batched in a tuple store until dispatched
 * using a "flush". A flush happens using the prepared (insert) statement,
 * which can only be used to send a "full" batch of tuples as the number of
 * rows in the statement is predefined. Thus, a flush only happens when the
 * tuple store reaches the predefined size. Once the last tuple is read from
 * the subnode, a final flush occurs. In that case, a flush is "partial" (less
 * than the predefined amount). A partial flush cannot use the prepared
 * statement, since the number of rows do not match, and therefore a one-time
 * statement is created for the last insert.
 *
 * Note that, since we use one DataNodeState per connection, we
 * could technically have multiple DataNodeStates per data node.
 */</comment>
<typedef>typedef <type><struct>struct <name>DataNodeState</name>
<block>{
	<decl_stmt><decl><type><name>TSConnectionId</name></type> <name>id</name></decl>;</decl_stmt> <comment type="block">/* Must be first */</comment>
	<decl_stmt><decl><type><name>TSConnection</name> <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>primary_tupstore</name></decl>;</decl_stmt> <comment type="block">/* Tuples this data node is primary
										* for. These tuples are returned when
										* RETURNING is specified. */</comment>
	<decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>replica_tupstore</name></decl>;</decl_stmt> <comment type="block">/* Tuples this data node is a replica
										* for. These tuples are NOT returned
										* when RETURNING is specified. */</comment>
	<decl_stmt><decl><type><name>PreparedStmt</name> <modifier>*</modifier></type><name>pstmt</name></decl>;</decl_stmt>			   <comment type="block">/* Prepared statement to use in the FLUSH state */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>num_tuples_sent</name></decl>;</decl_stmt>			   <comment type="block">/* Number of tuples sent in the FLUSH or LAST_FLUSH states */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>num_tuples_inserted</name></decl>;</decl_stmt>		   <comment type="block">/* Number of tuples inserted (returned in result)
										* during the FLUSH or LAST_FLUSH states */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>next_tuple</name></decl>;</decl_stmt>					   <comment type="block">/* The next tuple to return in the RETURNING state */</comment>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
}</block></struct></type> <name>DataNodeState</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_STORED_TUPLES</name><parameter_list>(<parameter><type><name>ss</name></type></parameter>)</parameter_list></cpp:macro>                                                                      \
	<cpp:value>(tuplestore_tuple_count((ss)-&gt;primary_tupstore) +                                              \
	 ((ss)-&gt;replica_tupstore != NULL ? tuplestore_tuple_count((ss)-&gt;replica_tupstore) : 0))</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>data_node_state_init</name><parameter_list>(<parameter><decl><type><name>DataNodeState</name> <modifier>*</modifier></type><name>ss</name></decl></parameter>, <parameter><decl><type><name>DataNodeDispatchState</name> <modifier>*</modifier></type><name>sds</name></decl></parameter>, <parameter><decl><type><name>TSConnectionId</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>sds</name><operator>-&gt;</operator><name>mcxt</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DataNodeState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ss</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <name>id</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ss</name><operator>-&gt;</operator><name>primary_tupstore</name></name> <operator>=</operator> <call><name>tuplestore_begin_heap</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>TUPSTORE_MEMSIZE_KB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>sds</name><operator>-&gt;</operator><name>replication_factor</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>ss</name><operator>-&gt;</operator><name>replica_tupstore</name></name> <operator>=</operator> <call><name>tuplestore_begin_heap</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>TUPSTORE_MEMSIZE_KB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>ss</name><operator>-&gt;</operator><name>replica_tupstore</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name><name>ss</name><operator>-&gt;</operator><name>conn</name></name> <operator>=</operator> <call><name>remote_dist_txn_get_connection</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>REMOTE_TXN_USE_PREP_STMT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ss</name><operator>-&gt;</operator><name>pstmt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ss</name><operator>-&gt;</operator><name>next_tuple</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ss</name><operator>-&gt;</operator><name>num_tuples_sent</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ss</name><operator>-&gt;</operator><name>num_tuples_inserted</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DataNodeState</name> <modifier>*</modifier></type>
<name>data_node_state_get_or_create</name><parameter_list>(<parameter><decl><type><name>DataNodeDispatchState</name> <modifier>*</modifier></type><name>sds</name></decl></parameter>, <parameter><decl><type><name>TSConnectionId</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DataNodeState</name> <modifier>*</modifier></type><name>ss</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>found</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ss</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>sds</name><operator>-&gt;</operator><name>nodestates</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>id</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>data_node_state_init</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name>sds</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>ss</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>data_node_state_clear_primary_store</name><parameter_list>(<parameter><decl><type><name>DataNodeState</name> <modifier>*</modifier></type><name>ss</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>tuplestore_clear</name><argument_list>(<argument><expr><name><name>ss</name><operator>-&gt;</operator><name>primary_tupstore</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>tuplestore_tuple_count</name><argument_list>(<argument><expr><name><name>ss</name><operator>-&gt;</operator><name>primary_tupstore</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ss</name><operator>-&gt;</operator><name>next_tuple</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>data_node_state_clear_replica_store</name><parameter_list>(<parameter><decl><type><name>DataNodeState</name> <modifier>*</modifier></type><name>ss</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>ss</name><operator>-&gt;</operator><name>replica_tupstore</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>tuplestore_clear</name><argument_list>(<argument><expr><name><name>ss</name><operator>-&gt;</operator><name>replica_tupstore</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>tuplestore_tuple_count</name><argument_list>(<argument><expr><name><name>ss</name><operator>-&gt;</operator><name>replica_tupstore</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>data_node_state_close</name><parameter_list>(<parameter><decl><type><name>DataNodeState</name> <modifier>*</modifier></type><name>ss</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>ss</name><operator>-&gt;</operator><name>pstmt</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>prepared_stmt_close</name><argument_list>(<argument><expr><name><name>ss</name><operator>-&gt;</operator><name>pstmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>tuplestore_end</name><argument_list>(<argument><expr><name><name>ss</name><operator>-&gt;</operator><name>primary_tupstore</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>ss</name><operator>-&gt;</operator><name>replica_tupstore</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>tuplestore_end</name><argument_list>(<argument><expr><name><name>ss</name><operator>-&gt;</operator><name>replica_tupstore</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>data_node_dispatch_begin</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DataNodeDispatchState</name> <modifier>*</modifier></type><name>sds</name> <init>= <expr><operator>(</operator><name>DataNodeDispatchState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CustomScan</name> <modifier>*</modifier></type><name>cscan</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>CustomScan</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_LT</name></expr></cpp:if>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>rri</name> <init>= <expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>rri</name> <init>= <expr><call><name>linitial_node</name><argument_list>(<argument><expr><name>ResultRelInfo</name></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_opened_result_relations</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name> <init>= <expr><name><name>rri</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupdesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>subplan</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_plans</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cache</name> <modifier>*</modifier></type><name>hcache</name> <init>= <expr><call><name>ts_hypertable_cache_pin</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name> <init>= <expr><call><name>ts_hypertable_cache_get_entry</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>, <argument><expr><name>CACHE_FLAG_NONE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>ps</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>mcxt</name> <init>=
		<expr><call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>, <argument><expr><literal type="string">"DataNodeState"</literal></expr></argument>, <argument><expr><name>ALLOCSET_SMALL_SIZES</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASHCTL</name></type> <name>hctl</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>keysize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TSConnectionId</name></expr></argument>)</argument_list></sizeof></expr>,
		<expr><operator>.</operator><name>entrysize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DataNodeState</name></expr></argument>)</argument_list></sizeof></expr>,
		<expr><operator>.</operator><name>hcxt</name> <operator>=</operator> <name>mcxt</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>available_nodes</name> <init>= <expr><call><name>ts_hypertable_get_available_data_nodes</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>hypertable_is_distributed</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NIL</name> <operator>!=</operator> <name>available_nodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ps</name> <operator>=</operator> <call><name>ExecInitNode</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>ps</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_ResultState</name></expr>:</case>
		<block>{<block_content>
			<comment type="block">/* The planner injected a Result node so we need to get the
			 * ChunkDispatchState from the Result's child */</comment>
			<decl_stmt><decl><type><specifier>const</specifier> <name>ResultState</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>ResultState</name></expr></argument>, <argument><expr><name>ps</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>child</name> <init>= <expr><name><name>result</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>lefttree</name></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>child</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>ts_is_chunk_dispatch_state</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>sds</name><operator>-&gt;</operator><name>cds</name></name> <operator>=</operator> <operator>(</operator><name>ChunkDispatchState</name> <operator>*</operator><operator>)</operator> <name>child</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		</block_content>}</block>
		<case>case <expr><name>T_CustomScanState</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>ts_is_chunk_dispatch_state</name><argument_list>(<argument><expr><name>ps</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>sds</name><operator>-&gt;</operator><name>cds</name></name> <operator>=</operator> <operator>(</operator><name>ChunkDispatchState</name> <operator>*</operator><operator>)</operator> <name>ps</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>sds</name><operator>-&gt;</operator><name>cds</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected child plan node %d for DataNodeDispatch"</literal></expr></argument>, <argument><expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>ps</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>custom_ps</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>ps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sds</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>SD_READ</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sds</name><operator>-&gt;</operator><name>rel</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sds</name><operator>-&gt;</operator><name>replication_factor</name></name> <operator>=</operator> <name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>replication_factor</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sds</name><operator>-&gt;</operator><name>sql_stmt</name></name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_private</name></name></expr></argument>, <argument><expr><name>CustomScanPrivateSql</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sds</name><operator>-&gt;</operator><name>target_attrs</name></name> <operator>=</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_private</name></name></expr></argument>, <argument><expr><name>CustomScanPrivateTargetAttrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sds</name><operator>-&gt;</operator><name>set_processed</name></name> <operator>=</operator> <call><name>intVal</name><argument_list>(<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_private</name></name></expr></argument>, <argument><expr><name>CustomScanPrivateSetProcessed</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sds</name><operator>-&gt;</operator><name>flush_threshold</name></name> <operator>=</operator> <call><name>intVal</name><argument_list>(<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_private</name></name></expr></argument>, <argument><expr><name>CustomScanPrivateFlushThreshold</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>sds</name><operator>-&gt;</operator><name>mcxt</name></name> <operator>=</operator> <name>mcxt</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sds</name><operator>-&gt;</operator><name>batch_mcxt</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>mcxt</name></expr></argument>, <argument><expr><literal type="string">"DataNodeDispatch batch"</literal></expr></argument>, <argument><expr><name>ALLOCSET_SMALL_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sds</name><operator>-&gt;</operator><name>nodestates</name></name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"DataNodeDispatch tuple stores"</literal></expr></argument>,
								  <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>available_nodes</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>hctl</name></expr></argument>,
								  <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_CONTEXT</name> <operator>|</operator> <name>HASH_BLOBS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>deparsed_insert_stmt_from_list</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sds</name><operator>-&gt;</operator><name>stmt</name></name></expr></argument>,
								   <argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_private</name></name></expr></argument>,
											<argument><expr><name>CustomScanPrivateDeparsedInsertStmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Setup output functions to generate string values for each target attribute */</comment>
	<expr_stmt><expr><name><name>sds</name><operator>-&gt;</operator><name>stmt_params</name></name> <operator>=</operator> <call><name>stmt_params_create</name><argument_list>(<argument><expr><name><name>sds</name><operator>-&gt;</operator><name>target_attrs</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name><name>sds</name><operator>-&gt;</operator><name>flush_threshold</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>HAS_RETURNING</name><argument_list>(<argument><expr><name>sds</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>sds</name><operator>-&gt;</operator><name>tupfactory</name></name> <operator>=</operator> <call><name>tuplefactory_create_for_rel</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>sds</name><operator>-&gt;</operator><name>stmt</name><operator>.</operator><name>retrieved_attrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* The tuplestores that hold batches of tuples only allow MinimalTuples so
	 * we need a dedicated slot for getting tuples from the stores since the
	 * CustomScan's ScanTupleSlot is a VirtualTuple. */</comment>
	<expr_stmt><expr><name><name>sds</name><operator>-&gt;</operator><name>batch_slot</name></name> <operator>=</operator> <call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>TTSOpsMinimalTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Store the result of a RETURNING clause.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>store_returning_result</name><parameter_list>(<parameter><decl><type><name>DataNodeDispatchState</name> <modifier>*</modifier></type><name>sds</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>row</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type> <name>newtup</name> <init>= <expr><call><name>tuplefactory_make_tuple</name><argument_list>(<argument><expr><name><name>sds</name><operator>-&gt;</operator><name>tupfactory</name></name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name>row</name></expr></argument>, <argument><expr><call><name>PQbinaryTuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* We need to force the tuple into the slot since it is not of the
		 * right type (conversion to the right type will happen if
		 * necessary) */</comment>
		<expr_stmt><expr><call><name>ExecForceStoreHeapTuple</name><argument_list>(<argument><expr><name>newtup</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>state_names</name><index>[]</index></name> <init>= <expr><block>{
	<expr><index>[<expr><name>SD_READ</name></expr>]</index> <operator>=</operator> <literal type="string">"READ"</literal></expr>,			  <expr><index>[<expr><name>SD_FLUSH</name></expr>]</index> <operator>=</operator> <literal type="string">"FLUSH"</literal></expr>, <expr><index>[<expr><name>SD_LAST_FLUSH</name></expr>]</index> <operator>=</operator> <literal type="string">"LAST_FLUSH"</literal></expr>,
	<expr><index>[<expr><name>SD_RETURNING</name></expr>]</index> <operator>=</operator> <literal type="string">"RETURNING"</literal></expr>, <expr><index>[<expr><name>SD_DONE</name></expr>]</index> <operator>=</operator> <literal type="string">"DONE"</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Move the state machine to a new state.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>data_node_dispatch_set_state</name><parameter_list>(<parameter><decl><type><name>DataNodeDispatchState</name> <modifier>*</modifier></type><name>sds</name></decl></parameter>, <parameter><decl><type><name>DispatchState</name></type> <name>new_state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>sds</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>new_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>,
		 <argument><expr><literal type="string">"DataNodeDispatchState: %s -&gt; %s"</literal></expr></argument>,
		 <argument><expr><name><name>state_names</name><index>[<expr><name><name>sds</name><operator>-&gt;</operator><name>state</name></name></expr>]</index></name></expr></argument>,
		 <argument><expr><name><name>state_names</name><index>[<expr><name>new_state</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>

	<switch>switch <condition>(<expr><name>new_state</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>SD_READ</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>sds</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>SD_RETURNING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SD_FLUSH</name></expr>:</case>
		<case>case <expr><name>SD_LAST_FLUSH</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>sds</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>SD_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SD_RETURNING</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>sds</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>SD_FLUSH</name> <operator>||</operator> <name><name>sds</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>SD_LAST_FLUSH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SD_DONE</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>sds</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>SD_RETURNING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name><name>sds</name><operator>-&gt;</operator><name>prevstate</name></name> <operator>=</operator> <name><name>sds</name><operator>-&gt;</operator><name>state</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sds</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>new_state</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>PreparedStmt</name> <modifier>*</modifier></type>
<name>prepare_data_node_insert_stmt</name><parameter_list>(<parameter><decl><type><name>DataNodeDispatchState</name> <modifier>*</modifier></type><name>sds</name></decl></parameter>, <parameter><decl><type><name>TSConnection</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>total_params</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AsyncRequest</name> <modifier>*</modifier></type><name>req</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PreparedStmt</name> <modifier>*</modifier></type><name>stmt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>sds</name><operator>-&gt;</operator><name>mcxt</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>req</name> <operator>=</operator> <call><name>async_request_send_prepare</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name><name>sds</name><operator>-&gt;</operator><name>sql_stmt</name></name></expr></argument>, <argument><expr><name>total_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>req</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>stmt</name> <operator>=</operator> <call><name>async_request_wait_prepared_statement</name><argument_list>(<argument><expr><name>req</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>stmt</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Send a batch of tuples to a data node.
 *
 * All stored tuples for the given data node are sent on the node's
 * connection. If in FLUSH state (i.e., sending a predefined amount of
 * tuples), use a prepared statement, or construct a custom statement if in
 * LAST_FLUSH state.
 *
 * If there's a RETURNING clause, we reset the read pointer for the store,
 * since the original tuples need to be returned along with the
 * node-returned ones. If there is no RETURNING clause, simply clear the
 * store.
 */</comment>
<function><type><specifier>static</specifier> <name>AsyncRequest</name> <modifier>*</modifier></type>
<name>send_batch_to_data_node</name><parameter_list>(<parameter><decl><type><name>DataNodeDispatchState</name> <modifier>*</modifier></type><name>sds</name></decl></parameter>, <parameter><decl><type><name>DataNodeState</name> <modifier>*</modifier></type><name>ss</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><name><name>sds</name><operator>-&gt;</operator><name>batch_slot</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AsyncRequest</name> <modifier>*</modifier></type><name>req</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sql_stmt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>response_type</name> <init>= <expr><name>FORMAT_TEXT</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>sds</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>SD_FLUSH</name> <operator>||</operator> <name><name>sds</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>SD_LAST_FLUSH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>NUM_STORED_TUPLES</name><argument_list>(<argument><expr><name>ss</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name><name>sds</name><operator>-&gt;</operator><name>flush_threshold</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>NUM_STORED_TUPLES</name><argument_list>(<argument><expr><name>ss</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ss</name><operator>-&gt;</operator><name>num_tuples_sent</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<while>while <condition>(
		<expr><call><name>tuplestore_gettupleslot</name><argument_list>(<argument><expr><name><name>ss</name><operator>-&gt;</operator><name>primary_tupstore</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument> <comment type="block">/* forward */</comment>, <argument><expr><name>false</name></expr></argument> <comment type="block">/* copy */</comment>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* get following parameters from slot */</comment>
		<expr_stmt><expr><call><name>stmt_params_convert_values</name><argument_list>(<argument><expr><name><name>sds</name><operator>-&gt;</operator><name>stmt_params</name></name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ss</name><operator>-&gt;</operator><name>num_tuples_sent</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>ss</name><operator>-&gt;</operator><name>replica_tupstore</name></name></expr>)</condition>
	<block>{<block_content>
		<while>while <condition>(<expr><call><name>tuplestore_gettupleslot</name><argument_list>(<argument><expr><name><name>ss</name><operator>-&gt;</operator><name>replica_tupstore</name></name></expr></argument>,
									   <argument><expr><name>true</name></expr></argument> <comment type="block">/* forward */</comment>,
									   <argument><expr><name>false</name></expr></argument> <comment type="block">/* copy */</comment>,
									   <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* get following parameters from slot */</comment>
			<expr_stmt><expr><call><name>stmt_params_convert_values</name><argument_list>(<argument><expr><name><name>sds</name><operator>-&gt;</operator><name>stmt_params</name></name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ss</name><operator>-&gt;</operator><name>num_tuples_sent</name></name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ss</name><operator>-&gt;</operator><name>num_tuples_sent</name></name> <operator>==</operator> <call><name>NUM_STORED_TUPLES</name><argument_list>(<argument><expr><name>ss</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ss</name><operator>-&gt;</operator><name>num_tuples_sent</name></name> <operator>==</operator> <call><name>stmt_params_converted_tuples</name><argument_list>(<argument><expr><name><name>sds</name><operator>-&gt;</operator><name>stmt_params</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>HAS_RETURNING</name><argument_list>(<argument><expr><name>sds</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>tuplefactory_is_binary</name><argument_list>(<argument><expr><name><name>sds</name><operator>-&gt;</operator><name>tupfactory</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>response_type</name> <operator>=</operator> <name>FORMAT_BINARY</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>ts_guc_enable_connection_binary_data</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>response_type</name> <operator>=</operator> <name>FORMAT_BINARY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Send tuples */</comment>
	<switch>switch <condition>(<expr><name><name>sds</name><operator>-&gt;</operator><name>state</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>SD_FLUSH</name></expr>:</case>
			<comment type="block">/* Lazy initialize the prepared statement */</comment>
			<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>ss</name><operator>-&gt;</operator><name>pstmt</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>ss</name><operator>-&gt;</operator><name>pstmt</name></name> <operator>=</operator>
					<call><name>prepare_data_node_insert_stmt</name><argument_list>(<argument><expr><name>sds</name></expr></argument>,
												  <argument><expr><name><name>ss</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>,
												  <argument><expr><call><name>stmt_params_total_values</name><argument_list>(<argument><expr><name><name>sds</name><operator>-&gt;</operator><name>stmt_params</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ss</name><operator>-&gt;</operator><name>num_tuples_sent</name></name> <operator>==</operator> <name><name>sds</name><operator>-&gt;</operator><name>flush_threshold</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>req</name> <operator>=</operator> <call><name>async_request_send_prepared_stmt_with_params</name><argument_list>(<argument><expr><name><name>ss</name><operator>-&gt;</operator><name>pstmt</name></name></expr></argument>,
															   <argument><expr><name><name>sds</name><operator>-&gt;</operator><name>stmt_params</name></name></expr></argument>,
															   <argument><expr><name>response_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SD_LAST_FLUSH</name></expr>:</case>
			<expr_stmt><expr><name>sql_stmt</name> <operator>=</operator> <call><name>deparsed_insert_stmt_get_sql</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sds</name><operator>-&gt;</operator><name>stmt</name></name></expr></argument>,
													<argument><expr><call><name>stmt_params_converted_tuples</name><argument_list>(<argument><expr><name><name>sds</name><operator>-&gt;</operator><name>stmt_params</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>sql_stmt</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ss</name><operator>-&gt;</operator><name>num_tuples_sent</name></name> <operator>&lt;</operator> <name><name>sds</name><operator>-&gt;</operator><name>flush_threshold</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>req</name> <operator>=</operator>
				<call><name>async_request_send_with_params</name><argument_list>(<argument><expr><name><name>ss</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><name>sql_stmt</name></expr></argument>, <argument><expr><name><name>sds</name><operator>-&gt;</operator><name>stmt_params</name></name></expr></argument>, <argument><expr><name>response_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected data node dispatch state %s"</literal></expr></argument>, <argument><expr><name><name>state_names</name><index>[<expr><name><name>sds</name><operator>-&gt;</operator><name>state</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>req</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>async_request_attach_user_data</name><argument_list>(<argument><expr><name>req</name></expr></argument>, <argument><expr><name>ss</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>sds</name><operator>-&gt;</operator><name>num_tuples</name></name> <operator>+=</operator> <call><name>tuplestore_tuple_count</name><argument_list>(<argument><expr><name><name>ss</name><operator>-&gt;</operator><name>primary_tupstore</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If there's a RETURNING clause, we need to also return the inserted
	   tuples in
	   rri-&gt;ri_projectReturning-&gt;pi_exprContext-&gt;ecxt_scantuple */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>HAS_RETURNING</name><argument_list>(<argument><expr><name>sds</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>tuplestore_rescan</name><argument_list>(<argument><expr><name><name>ss</name><operator>-&gt;</operator><name>primary_tupstore</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>data_node_state_clear_primary_store</name><argument_list>(<argument><expr><name>ss</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* No tuples are returned from the replica store so safe to clear */</comment>
	<expr_stmt><expr><call><name>data_node_state_clear_replica_store</name><argument_list>(<argument><expr><name>ss</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Since we're done with current batch, reset params so they are safe to use in the next
	 * batch/node */</comment>
	<expr_stmt><expr><call><name>stmt_params_reset</name><argument_list>(<argument><expr><name><name>sds</name><operator>-&gt;</operator><name>stmt_params</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>req</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check if we should flush tuples stored for a data node.
 *
 * There are two cases when this happens:
 *
 * 1. State is SD_FLUSH and the flush threshold is reached.
 * 2. State is SD_LAST_FLUSH and there are tuples to send.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>should_flush_data_node</name><parameter_list>(<parameter><decl><type><name>DataNodeDispatchState</name> <modifier>*</modifier></type><name>sds</name></decl></parameter>, <parameter><decl><type><name>DataNodeState</name> <modifier>*</modifier></type><name>ss</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int64</name></type> <name>num_tuples</name> <init>= <expr><call><name>NUM_STORED_TUPLES</name><argument_list>(<argument><expr><name>ss</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>sds</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>SD_FLUSH</name> <operator>||</operator> <name><name>sds</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>SD_LAST_FLUSH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>sds</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>SD_FLUSH</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>num_tuples</name> <operator>&gt;=</operator> <name><name>sds</name><operator>-&gt;</operator><name>flush_threshold</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>num_tuples</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Flush the tuples of data nodes that have a full batch.
 */</comment>
<function><type><specifier>static</specifier> <name>AsyncRequestSet</name> <modifier>*</modifier></type>
<name>flush_data_nodes</name><parameter_list>(<parameter><decl><type><name>DataNodeDispatchState</name> <modifier>*</modifier></type><name>sds</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AsyncRequestSet</name> <modifier>*</modifier></type><name>reqset</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DataNodeState</name> <modifier>*</modifier></type><name>ss</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>hseq</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>sds</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>SD_FLUSH</name> <operator>||</operator> <name><name>sds</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>SD_LAST_FLUSH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hseq</name></expr></argument>, <argument><expr><name><name>sds</name><operator>-&gt;</operator><name>nodestates</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>ss</name> <operator>=</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hseq</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>ss</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>ss</name> <operator>=</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hseq</name></expr></argument>)</argument_list></call></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>should_flush_data_node</name><argument_list>(<argument><expr><name>sds</name></expr></argument>, <argument><expr><name>ss</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AsyncRequest</name> <modifier>*</modifier></type><name>req</name> <init>= <expr><call><name>send_batch_to_data_node</name><argument_list>(<argument><expr><name>sds</name></expr></argument>, <argument><expr><name>ss</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>req</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>reqset</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>reqset</name> <operator>=</operator> <call><name>async_request_set_create</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>async_request_set_add</name><argument_list>(<argument><expr><name>reqset</name></expr></argument>, <argument><expr><name>req</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>reqset</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Wait for responses from data nodes after INSERT.
 *
 * In case of RETURNING, return a list of responses, otherwise NIL.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>await_all_responses</name><parameter_list>(<parameter><decl><type><name>DataNodeDispatchState</name> <modifier>*</modifier></type><name>sds</name></decl></parameter>, <parameter><decl><type><name>AsyncRequestSet</name> <modifier>*</modifier></type><name>reqset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AsyncResponseResult</name> <modifier>*</modifier></type><name>rsp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>results</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>sds</name><operator>-&gt;</operator><name>next_tuple</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>rsp</name> <operator>=</operator> <call><name>async_request_set_wait_any_result</name><argument_list>(<argument><expr><name>reqset</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DataNodeState</name> <modifier>*</modifier></type><name>ss</name> <init>= <expr><call><name>async_response_result_get_user_data</name><argument_list>(<argument><expr><name>rsp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><call><name>async_response_result_get_pg_result</name><argument_list>(<argument><expr><name>rsp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ExecStatusType</name></type> <name>status</name> <init>= <expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>report_error</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><name>status</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>PGRES_TUPLES_OK</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HAS_RETURNING</name><argument_list>(<argument><expr><name>sds</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>results</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>results</name></expr></argument>, <argument><expr><name>rsp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>ss</name><operator>-&gt;</operator><name>num_tuples_inserted</name></name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>sds</name><operator>-&gt;</operator><name>stmt</name><operator>.</operator><name>do_nothing</name></name> <operator>||</operator> <operator>(</operator><name><name>ss</name><operator>-&gt;</operator><name>num_tuples_inserted</name></name> <operator>==</operator> <name><name>ss</name><operator>-&gt;</operator><name>num_tuples_sent</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>report_error</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>PGRES_COMMAND_OK</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>HAS_RETURNING</name><argument_list>(<argument><expr><name>sds</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>

				<expr_stmt><expr><name><name>ss</name><operator>-&gt;</operator><name>num_tuples_inserted</name></name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><call><name>PQcmdTuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>async_response_result_close</name><argument_list>(<argument><expr><name>rsp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>sds</name><operator>-&gt;</operator><name>stmt</name><operator>.</operator><name>do_nothing</name></name> <operator>||</operator> <operator>(</operator><name><name>ss</name><operator>-&gt;</operator><name>num_tuples_inserted</name></name> <operator>==</operator> <name><name>ss</name><operator>-&gt;</operator><name>num_tuples_sent</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>report_error</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<break>break;</break>
		</block_content>}</block></switch>

		<if_stmt><if>if <condition>(<expr><name>report_error</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>async_response_report_error</name><argument_list>(<argument><expr><operator>(</operator><name>AsyncResponse</name> <operator>*</operator><operator>)</operator> <name>rsp</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Unless there is an ON CONFLICT clause, the number of tuples
		 * returned should greater than zero and be the same as the number of
		 * tuples sent.  */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>sds</name><operator>-&gt;</operator><name>stmt</name><operator>.</operator><name>do_nothing</name></name> <operator>||</operator> <name><name>ss</name><operator>-&gt;</operator><name>num_tuples_inserted</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ss</name><operator>-&gt;</operator><name>next_tuple</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>results</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Read tuples from the child scan node.
 *
 * Read until there's a NULL tuple or we've filled a data node's batch. Ideally,
 * we'd continue to read more tuples to fill other data nodes' batches, but since
 * the next tuple might be for the same node that has the full batch, we
 * risk overfilling. This could be mitigated by using two tuple stores per
 * data node (current and next batch) and alternate between them. But that also
 * increases memory requirements and complicates the code, so that's left as a
 * future optimization.
 *
 * Return the number of tuples read.
 */</comment>
<function><type><specifier>static</specifier> <name>int64</name></type>
<name>handle_read</name><parameter_list>(<parameter><decl><type><name>DataNodeDispatchState</name> <modifier>*</modifier></type><name>sds</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>substate</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>sds</name><operator>-&gt;</operator><name>cstate</name><operator>.</operator><name>custom_ps</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ChunkDispatchState</name> <modifier>*</modifier></type><name>cds</name> <init>= <expr><name><name>sds</name><operator>-&gt;</operator><name>cds</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>sds</name><operator>-&gt;</operator><name>cstate</name><operator>.</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_LT</name></expr></cpp:if>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>rri_saved</name> <init>= <expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<decl_stmt><decl><type><name>int64</name></type> <name>num_tuples_read</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>sds</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>SD_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If we are reading new tuples, we either do it for the first batch or we
	 * finished a previous batch. In either case, reset the batch memory
	 * context so that we release the memory after each batch is finished. */</comment>
	<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>sds</name><operator>-&gt;</operator><name>batch_mcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Read tuples from the subnode until flush */</comment>
	<while>while <condition>(<expr><name><name>sds</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>SD_READ</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><call><name>ExecProcNode</name><argument_list>(<argument><expr><name>substate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>data_node_dispatch_set_state</name><argument_list>(<argument><expr><name>sds</name></expr></argument>, <argument><expr><name>SD_LAST_FLUSH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* The previous node should have routed the tuple to the right
			 * chunk and set the corresponding result relation. The FdwState
			 * should also point to the chunk's insert state. */</comment>
			<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>rri</name> <init>= <expr><name><name>cds</name><operator>-&gt;</operator><name>rri</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ChunkInsertState</name> <modifier>*</modifier></type><name>cis</name> <init>= <expr><name><name>rri</name><operator>-&gt;</operator><name>ri_FdwState</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TriggerDesc</name> <modifier>*</modifier></type><name>trigdesc</name> <init>= <expr><name><name>rri</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type> <name>primary_data_node</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TupleDesc</name></type> <name>rri_desc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>rri</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>rri</name><operator>-&gt;</operator><name>ri_projectReturning</name></name> <operator>&amp;&amp;</operator> <name><name>rri_desc</name><operator>-&gt;</operator><name>constr</name></name> <operator>&amp;&amp;</operator>
				<name><name>rri_desc</name><operator>-&gt;</operator><name>constr</name><operator>-&gt;</operator><name>has_generated_stored</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecComputeStoredGeneratedCompat</name><argument_list>(<argument><expr><name>rri</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>CMD_INSERT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>cis</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>GetPerTupleMemoryContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* While we could potentially support triggers on frontend nodes,
			 * the triggers should exists also on the remote node and will be
			 * executed there. For now, the safest bet is to avoid triggers on
			 * the frontend. */</comment>
			<if_stmt><if>if <condition>(<expr><name>trigdesc</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>trigdesc</name><operator>-&gt;</operator><name>trig_insert_after_row</name></name> <operator>||</operator> <name><name>trigdesc</name><operator>-&gt;</operator><name>trig_insert_before_row</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot insert into remote chunk with row triggers"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* Total count */</comment>
			<expr_stmt><expr><name>num_tuples_read</name><operator>++</operator></expr>;</expr_stmt>

			<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>cis-&gt;chunk_data_nodes</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ChunkDataNode</name> <modifier>*</modifier></type><name>cdn</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>TSConnectionId</name></type> <name>id</name> <init>= <expr><call><name>remote_connection_id</name><argument_list>(<argument><expr><name><name>cdn</name><operator>-&gt;</operator><name>foreign_server_oid</name></name></expr></argument>, <argument><expr><name><name>cis</name><operator>-&gt;</operator><name>user_id</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>DataNodeState</name> <modifier>*</modifier></type><name>ss</name> <init>= <expr><call><name>data_node_state_get_or_create</name><argument_list>(<argument><expr><name>sds</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<comment type="block">/* This will store one copy of the tuple per data node, which is
				 * a bit inefficient. Note that we put the tuple in the
				 * primary store for the first data node, but the replica store
				 * for all other data nodes. This is to be able to know which
				 * tuples to return in a RETURNING statement. */</comment>
				<if_stmt><if>if <condition>(<expr><name>primary_data_node</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>tuplestore_puttupleslot</name><argument_list>(<argument><expr><name><name>ss</name><operator>-&gt;</operator><name>primary_tupstore</name></name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>tuplestore_puttupleslot</name><argument_list>(<argument><expr><name><name>ss</name><operator>-&gt;</operator><name>replica_tupstore</name></name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<comment type="block">/* Once one data node has reached the batch size, we stop
				 * reading. */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>sds</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>SD_FLUSH</name> <operator>&amp;&amp;</operator> <call><name>NUM_STORED_TUPLES</name><argument_list>(<argument><expr><name>ss</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name><name>sds</name><operator>-&gt;</operator><name>flush_threshold</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>data_node_dispatch_set_state</name><argument_list>(<argument><expr><name>sds</name></expr></argument>, <argument><expr><name>SD_FLUSH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>primary_data_node</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block>

			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_LT</name></expr></cpp:if>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>rri_saved</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><name>num_tuples_read</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Flush all data nodes and move to the RETURNING state.
 *
 * Note that future optimizations could do this more asynchronously by doing
 * other work until responses are available (e.g., one could start to fill the
 * next batch while waiting for a response). However, the async API currently
 * doesn't expose a way to check for a response without blocking and
 * interleaving different tasks would also complicate the state machine.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>handle_flush</name><parameter_list>(<parameter><decl><type><name>DataNodeDispatchState</name> <modifier>*</modifier></type><name>sds</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AsyncRequestSet</name> <modifier>*</modifier></type><name>reqset</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>sds</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>SD_FLUSH</name> <operator>||</operator> <name><name>sds</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>SD_LAST_FLUSH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Save the requests and responses in the batch memory context since they
	 * need to survive across several iterations of the executor loop when
	 * there is a RETURNING clause. The batch memory context is cleared the
	 * next time we read a batch. */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>sds</name><operator>-&gt;</operator><name>batch_mcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>reqset</name> <operator>=</operator> <call><name>flush_data_nodes</name><argument_list>(<argument><expr><name>sds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>reqset</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>sds</name><operator>-&gt;</operator><name>responses</name></name> <operator>=</operator> <call><name>await_all_responses</name><argument_list>(<argument><expr><name>sds</name></expr></argument>, <argument><expr><name>reqset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>reqset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>data_node_dispatch_set_state</name><argument_list>(<argument><expr><name>sds</name></expr></argument>, <argument><expr><name>SD_RETURNING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get a tuple when there's a RETURNING clause.
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>get_returning_tuple</name><parameter_list>(<parameter><decl><type><name>DataNodeDispatchState</name> <modifier>*</modifier></type><name>sds</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>rri</name> <init>= <expr><name><name>sds</name><operator>-&gt;</operator><name>cds</name><operator>-&gt;</operator><name>rri</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>res_slot</name> <init>= <expr><name><name>sds</name><operator>-&gt;</operator><name>batch_slot</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><name><name>sds</name><operator>-&gt;</operator><name>cstate</name><operator>.</operator><name>ss</name><operator>.</operator><name>ss_ScanTupleSlot</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name><name>rri</name><operator>-&gt;</operator><name>ri_projectReturning</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>econtext</name> <operator>=</operator> <name><name>rri</name><operator>-&gt;</operator><name>ri_projectReturning</name><operator>-&gt;</operator><name>pi_exprContext</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Store a RETURNING tuple.  If HAS_RETURNING() is false, just emit a
	 * dummy tuple.  (has_returning is false when the local query is of the
	 * form "UPDATE/DELETE .. RETURNING 1" for example.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HAS_RETURNING</name><argument_list>(<argument><expr><name>sds</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NIL</name> <operator>==</operator> <name><name>sds</name><operator>-&gt;</operator><name>responses</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExecStoreAllNullTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>res_slot</name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<while>while <condition>(<expr><name>NIL</name> <operator>!=</operator> <name><name>sds</name><operator>-&gt;</operator><name>responses</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AsyncResponseResult</name> <modifier>*</modifier></type><name>rsp</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>sds</name><operator>-&gt;</operator><name>responses</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>DataNodeState</name> <modifier>*</modifier></type><name>ss</name> <init>= <expr><call><name>async_response_result_get_user_data</name><argument_list>(<argument><expr><name>rsp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><call><name>async_response_result_get_pg_result</name><argument_list>(<argument><expr><name>rsp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int64</name></type> <name>num_tuples_to_return</name> <init>= <expr><call><name>tuplestore_tuple_count</name><argument_list>(<argument><expr><name><name>ss</name><operator>-&gt;</operator><name>primary_tupstore</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type> <name>last_tuple</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type> <name>got_tuple</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>num_tuples_to_return</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>last_tuple</name> <operator>=</operator> <operator>(</operator><name><name>ss</name><operator>-&gt;</operator><name>next_tuple</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <name>num_tuples_to_return</name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ss</name><operator>-&gt;</operator><name>next_tuple</name></name> <operator>&lt;</operator> <name><name>ss</name><operator>-&gt;</operator><name>num_tuples_inserted</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ss</name><operator>-&gt;</operator><name>next_tuple</name></name> <operator>&lt;</operator> <name>num_tuples_to_return</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>store_returning_result</name><argument_list>(<argument><expr><name>sds</name></expr></argument>, <argument><expr><name><name>ss</name><operator>-&gt;</operator><name>next_tuple</name></name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Get the next tuple from the store. If it is the last tuple, we
				 * need to make a copy since we will clear the store before
				 * returning. */</comment>
				<expr_stmt><expr><name>got_tuple</name> <operator>=</operator> <call><name>tuplestore_gettupleslot</name><argument_list>(<argument><expr><name><name>ss</name><operator>-&gt;</operator><name>primary_tupstore</name></name></expr></argument>,
													<argument><expr><name>true</name></expr></argument> <comment type="block">/* forward */</comment>,
													<argument><expr><name>last_tuple</name></expr></argument> <comment type="block">/* copy */</comment>,
													<argument><expr><name>res_slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>got_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>res_slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>ss</name><operator>-&gt;</operator><name>next_tuple</name></name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>last_tuple</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>last_tuple</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>sds</name><operator>-&gt;</operator><name>responses</name></name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name><name>sds</name><operator>-&gt;</operator><name>responses</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>async_response_result_close</name><argument_list>(<argument><expr><name>rsp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>data_node_state_clear_primary_store</name><argument_list>(<argument><expr><name>ss</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>got_tuple</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></while>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>

	<return>return <expr><name>res_slot</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get the next tuple slot to return when there's a RETURNING
 * clause. Otherwise, return an empty slot.
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>handle_returning</name><parameter_list>(<parameter><decl><type><name>DataNodeDispatchState</name> <modifier>*</modifier></type><name>sds</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>sds</name><operator>-&gt;</operator><name>cstate</name><operator>.</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>rri</name> <init>= <expr><name><name>sds</name><operator>-&gt;</operator><name>cds</name><operator>-&gt;</operator><name>rri</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><name><name>sds</name><operator>-&gt;</operator><name>cstate</name><operator>.</operator><name>ss</name><operator>.</operator><name>ss_ScanTupleSlot</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>done</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>sds</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>SD_RETURNING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>GetPerTupleMemoryContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * When all chunks are pruned rri will be NULL and there is nothing to do.
	 * Without returning projection, nothing to do here either.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rri</name> <operator>||</operator> <operator>!</operator><name><name>rri</name><operator>-&gt;</operator><name>ri_projectReturning</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>HAS_RETURNING</name><argument_list>(<argument><expr><name>sds</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NIL</name> <operator>==</operator> <name><name>sds</name><operator>-&gt;</operator><name>responses</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>done</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>sds</name><operator>-&gt;</operator><name>set_processed</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name> <operator>+=</operator> <name><name>sds</name><operator>-&gt;</operator><name>num_tuples</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* If we've processed all tuples, then we're also done */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>sds</name><operator>-&gt;</operator><name>next_tuple</name></name> <operator>&gt;=</operator> <name><name>sds</name><operator>-&gt;</operator><name>num_tuples</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>done</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>done</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>sds</name><operator>-&gt;</operator><name>next_tuple</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sds</name><operator>-&gt;</operator><name>num_tuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>sds</name><operator>-&gt;</operator><name>prevstate</name></name> <operator>==</operator> <name>SD_LAST_FLUSH</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>data_node_dispatch_set_state</name><argument_list>(<argument><expr><name>sds</name></expr></argument>, <argument><expr><name>SD_DONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>data_node_dispatch_set_state</name><argument_list>(<argument><expr><name>sds</name></expr></argument>, <argument><expr><name>SD_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>get_returning_tuple</name><argument_list>(<argument><expr><name>sds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sds</name><operator>-&gt;</operator><name>next_tuple</name></name><operator>++</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>sds</name><operator>-&gt;</operator><name>set_processed</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>slot</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Execute the remote INSERT.
 *
 * This is called every time the parent asks for a new tuple. Read the child
 * scan node and buffer until there's a full batch, then flush by sending to
 * data node(s). If there's a returning statement, we return the flushed tuples
 * one-by-one, or continue reading more tuples from the child until there's a
 * NULL tuple.
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>data_node_dispatch_exec</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DataNodeDispatchState</name> <modifier>*</modifier></type><name>sds</name> <init>= <expr><operator>(</operator><name>DataNodeDispatchState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>done</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_LT</name></expr></cpp:if>
	<comment type="block">/* Initially, the result relation should always match the hypertable.  */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>es_result_relation_info</name><operator>-&gt;</operator><name>ri_RelationDesc</name><operator>-&gt;</operator><name>rd_id</name></name> <operator>==</operator> <name><name>sds</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* Read tuples and flush until there's either something to return or no
	 * more tuples to read */</comment>
	<while>while <condition>(<expr><operator>!</operator><name>done</name></expr>)</condition>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name><name>sds</name><operator>-&gt;</operator><name>state</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>SD_READ</name></expr>:</case>
				<expr_stmt><expr><call><name>handle_read</name><argument_list>(<argument><expr><name>sds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>SD_FLUSH</name></expr>:</case>
			<case>case <expr><name>SD_LAST_FLUSH</name></expr>:</case>
				<expr_stmt><expr><call><name>handle_flush</name><argument_list>(<argument><expr><name>sds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>SD_RETURNING</name></expr>:</case>
				<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>handle_returning</name><argument_list>(<argument><expr><name>sds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* If a tuple was read, return it and wait to get called again */</comment>
				<expr_stmt><expr><name>done</name> <operator>=</operator> <operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>SD_DONE</name></expr>:</case>
				<expr_stmt><expr><name>done</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></while>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_LT</name></expr></cpp:if>
	<comment type="block">/* Tuple routing in the ChunkDispatchState subnode sets the result
	 * relation to a chunk when routing, but the read handler should have
	 * ensured the result relation is reset. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>es_result_relation_info</name><operator>-&gt;</operator><name>ri_RelationDesc</name><operator>-&gt;</operator><name>rd_id</name></name> <operator>==</operator> <name><name>sds</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>es_result_relation_info</name><operator>-&gt;</operator><name>ri_usesFdwDirectModify</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><name>slot</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>data_node_dispatch_rescan</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Cannot rescan and start from the beginning since we might already have
	 * sent data to remote nodes */</comment>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot restart inserts to remote nodes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>data_node_dispatch_end</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DataNodeDispatchState</name> <modifier>*</modifier></type><name>sds</name> <init>= <expr><operator>(</operator><name>DataNodeDispatchState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DataNodeState</name> <modifier>*</modifier></type><name>ss</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>hseq</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hseq</name></expr></argument>, <argument><expr><name><name>sds</name><operator>-&gt;</operator><name>nodestates</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>ss</name> <operator>=</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hseq</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>ss</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>ss</name> <operator>=</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hseq</name></expr></argument>)</argument_list></call></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>data_node_state_close</name><argument_list>(<argument><expr><name>ss</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name><name>sds</name><operator>-&gt;</operator><name>nodestates</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name><name>sds</name><operator>-&gt;</operator><name>batch_slot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecEndNode</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>custom_ps</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>data_node_dispatch_explain</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ancestors</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DataNodeDispatchState</name> <modifier>*</modifier></type><name>sds</name> <init>= <expr><operator>(</operator><name>DataNodeDispatchState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Batch size"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>sds</name><operator>-&gt;</operator><name>flush_threshold</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Add remote query, when VERBOSE option is specified.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>verbose</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>explain_sql</name> <init>=
			<expr><call><name>deparsed_insert_stmt_get_sql_explain</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sds</name><operator>-&gt;</operator><name>stmt</name></name></expr></argument>, <argument><expr><name><name>sds</name><operator>-&gt;</operator><name>flush_threshold</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ExplainPropertyText</name><argument_list>(<argument><expr><literal type="string">"Remote SQL"</literal></expr></argument>, <argument><expr><name>explain_sql</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>CustomExecMethods</name></type> <name>data_node_dispatch_state_methods</name> <init>= <expr><block>{
	<expr><operator>.</operator><name>CustomName</name> <operator>=</operator> <literal type="string">"DataNodeDispatchState"</literal></expr>,
	<expr><operator>.</operator><name>BeginCustomScan</name> <operator>=</operator> <name>data_node_dispatch_begin</name></expr>,
	<expr><operator>.</operator><name>EndCustomScan</name> <operator>=</operator> <name>data_node_dispatch_end</name></expr>,
	<expr><operator>.</operator><name>ExecCustomScan</name> <operator>=</operator> <name>data_node_dispatch_exec</name></expr>,
	<expr><operator>.</operator><name>ReScanCustomScan</name> <operator>=</operator> <name>data_node_dispatch_rescan</name></expr>,
	<expr><operator>.</operator><name>ExplainCustomScan</name> <operator>=</operator> <name>data_node_dispatch_explain</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Only allocate the custom scan state. Initialize in the begin handler. */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>data_node_dispatch_state_create</name><parameter_list>(<parameter><decl><type><name>CustomScan</name> <modifier>*</modifier></type><name>cscan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DataNodeDispatchState</name> <modifier>*</modifier></type><name>sds</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>sds</name> <operator>=</operator> <operator>(</operator><name>DataNodeDispatchState</name> <operator>*</operator><operator>)</operator> <call><name>newNode</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DataNodeDispatchState</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>T_CustomScanState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sds</name><operator>-&gt;</operator><name>cstate</name><operator>.</operator><name>methods</name></name> <operator>=</operator> <operator>&amp;</operator><name>data_node_dispatch_state_methods</name></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>sds</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>CustomScanMethods</name></type> <name>data_node_dispatch_plan_methods</name> <init>= <expr><block>{
	<expr><operator>.</operator><name>CustomName</name> <operator>=</operator> <literal type="string">"DataNodeDispatch"</literal></expr>,
	<expr><operator>.</operator><name>CreateCustomScanState</name> <operator>=</operator> <name>data_node_dispatch_state_create</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>get_insert_attrs</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupdesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>attrs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name> <operator>||</operator> <name><name>attr</name><operator>-&gt;</operator><name>attgenerated</name></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>attrs</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>attrs</name></expr></argument>, <argument><expr><call><name>AttrOffsetGetAttrNumber</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>attrs</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Plan a remote INSERT on a hypertable.
 *
 * Create the metadata needed for a remote INSERT. This mostly involves
 * deparsing the INSERT statement.
 *
 * Return the metadata as a list of Nodes that can be saved in a prepared
 * statement.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>plan_remote_insert</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>DataNodeDispatchPath</name> <modifier>*</modifier></type><name>sdpath</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ModifyTablePath</name> <modifier>*</modifier></type><name>mtpath</name> <init>= <expr><name><name>sdpath</name><operator>-&gt;</operator><name>mtpath</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OnConflictAction</name></type> <name>onconflict</name> <init>=
		<expr><ternary><condition><expr><name><name>mtpath</name><operator>-&gt;</operator><name>onconflict</name></name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><name>ONCONFLICT_NONE</name></expr> </then><else>: <expr><name><name>mtpath</name><operator>-&gt;</operator><name>onconflict</name><operator>-&gt;</operator><name>action</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>returning_lists</name> <init>= <expr><name><name>sdpath</name><operator>-&gt;</operator><name>mtpath</name><operator>-&gt;</operator><name>returningLists</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name><name>sdpath</name><operator>-&gt;</operator><name>hypertable_rti</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DeparsedInsertStmt</name></type> <name>stmt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sql</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>target_attrs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>returning_list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>do_nothing</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>flush_threshold</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Core code already has some lock on each rel being planned, so we can
	 * use NoLock here.
	 */</comment>
	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Extract the relevant RETURNING list if any.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>NIL</name> <operator>!=</operator> <name>returning_lists</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>returning_list</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name>returning_lists</name></expr></argument>, <argument><expr><name><name>sdpath</name><operator>-&gt;</operator><name>subplan_index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * ON CONFLICT DO UPDATE and DO NOTHING case with inference specification
	 * should have already been rejected in the optimizer, as presently there
	 * is no way to recognize an arbiter index on a foreign table.  Only DO
	 * NOTHING is supported without an inference specification.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>onconflict</name> <operator>==</operator> <name>ONCONFLICT_NOTHING</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>do_nothing</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>onconflict</name> <operator>!=</operator> <name>ONCONFLICT_NONE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ON CONFLICT DO UPDATE not supported"</literal>
						<literal type="string">" on distributed hypertables"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Construct the SQL command string matching the fixed batch size. We also
	 * save the partially deparsed SQL command so that we can easily create
	 * one with less value parameters later for flushing a partially filled
	 * batch.
	 */</comment>
	<expr_stmt><expr><name>target_attrs</name> <operator>=</operator> <call><name>get_insert_attrs</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>deparse_insert_stmt</name><argument_list>(<argument><expr><operator>&amp;</operator><name>stmt</name></expr></argument>,
						<argument><expr><name>rte</name></expr></argument>,
						<argument><expr><name><name>sdpath</name><operator>-&gt;</operator><name>hypertable_rti</name></name></expr></argument>,
						<argument><expr><name>rel</name></expr></argument>,
						<argument><expr><name>target_attrs</name></expr></argument>,
						<argument><expr><name>do_nothing</name></expr></argument>,
						<argument><expr><name>returning_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set suitable flush threshold value that takes into account the max number
	 * of prepared statement arguments */</comment>
	<expr_stmt><expr><name>flush_threshold</name> <operator>=</operator>
		<call><name>stmt_params_validate_num_tuples</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>target_attrs</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TUPSTORE_FLUSH_THRESHOLD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>sql</name> <operator>=</operator> <call><name>deparsed_insert_stmt_get_sql</name><argument_list>(<argument><expr><operator>&amp;</operator><name>stmt</name></expr></argument>, <argument><expr><name>flush_threshold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>list_make5</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>sql</name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><name>target_attrs</name></expr></argument>,
					  <argument><expr><call><name>deparsed_insert_stmt_to_list</name><argument_list>(<argument><expr><operator>&amp;</operator><name>stmt</name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>makeInteger</name><argument_list>(<argument><expr><name><name>sdpath</name><operator>-&gt;</operator><name>mtpath</name><operator>-&gt;</operator><name>canSetTag</name></name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>makeInteger</name><argument_list>(<argument><expr><name>flush_threshold</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type>
<name>data_node_dispatch_plan_create</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>CustomPath</name></name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
							   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>clauses</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>custom_plans</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DataNodeDispatchPath</name> <modifier>*</modifier></type><name>sdpath</name> <init>= <expr><operator>(</operator><name>DataNodeDispatchPath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CustomScan</name> <modifier>*</modifier></type><name>cscan</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CustomScan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>subplan</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>custom_plans</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>custom_plans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>methods</name></name> <operator>=</operator> <operator>&amp;</operator><name>data_node_dispatch_plan_methods</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_plans</name></name> <operator>=</operator> <name>custom_plans</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_scan_tlist</name></name> <operator>=</operator> <name><name>subplan</name><operator>-&gt;</operator><name>targetlist</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_private</name></name> <operator>=</operator> <call><name>plan_remote_insert</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>sdpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>&amp;</operator><name><name>cscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name></name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>CustomPathMethods</name></type> <name>data_node_dispatch_path_methods</name> <init>= <expr><block>{
	<expr><operator>.</operator><name>CustomName</name> <operator>=</operator> <literal type="string">"DataNodeDispatchPath"</literal></expr>,
	<expr><operator>.</operator><name>PlanCustomPath</name> <operator>=</operator> <name>data_node_dispatch_plan_create</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<function><type><name>Path</name> <modifier>*</modifier></type>
<name>data_node_dispatch_path_create</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>ModifyTablePath</name> <modifier>*</modifier></type><name>mtpath</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>hypertable_rti</name></decl></parameter>,
							   <parameter><decl><type><name>int</name></type> <name>subplan_index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DataNodeDispatchPath</name> <modifier>*</modifier></type><name>sdpath</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DataNodeDispatchPath</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name> <modifier>*</modifier></type><name>subpath</name> <init>= <expr><call><name>ts_chunk_dispatch_path_create</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>mtpath</name></expr></argument>, <argument><expr><name>hypertable_rti</name></expr></argument>, <argument><expr><name>subplan_index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Copy costs, etc. from the subpath */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sdpath</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name></name></expr></argument>, <argument><expr><name>subpath</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Path</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>sdpath</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>T_CustomPath</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sdpath</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_CustomScan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sdpath</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>custom_paths</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sdpath</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>methods</name></name> <operator>=</operator> <operator>&amp;</operator><name>data_node_dispatch_path_methods</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sdpath</name><operator>-&gt;</operator><name>mtpath</name></name> <operator>=</operator> <name>mtpath</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sdpath</name><operator>-&gt;</operator><name>hypertable_rti</name></name> <operator>=</operator> <name>hypertable_rti</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sdpath</name><operator>-&gt;</operator><name>subplan_index</name></name> <operator>=</operator> <name>subplan_index</name></expr>;</expr_stmt>

	<return>return <expr><operator>&amp;</operator><name><name>sdpath</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name></name></expr>;</return>
</block_content>}</block></function>
</unit>
