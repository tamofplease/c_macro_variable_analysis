<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/timescaledb/tsl/src/nodes/gapfill/gapfill_plan.c"><comment type="block">/*
 * This file and its contents are licensed under the Timescale License.
 * Please see the included NOTICE for copyright information and
 * LICENSE-TIMESCALE for a copy of the license.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postgres.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/execnodes.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/extensible.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/nodeFuncs.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/clauses.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/optimizer.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/pathnode.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/paths.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/tlist.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/lsyscache.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;parser/parse_func.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compat/compat.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gapfill.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gapfill_internal.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>static</specifier> <name>CustomScanMethods</name></type> <name>gapfill_plan_methods</name> <init>= <expr><block>{
	<expr><operator>.</operator><name>CustomName</name> <operator>=</operator> <literal type="string">"GapFill"</literal></expr>,
	<expr><operator>.</operator><name>CreateCustomScanState</name> <operator>=</operator> <name>gapfill_state_create</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<typedef>typedef <type><struct>struct <name>gapfill_walker_context</name>
<block>{
	<union>union
	<block>{
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>func</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>WindowFunc</name> <modifier>*</modifier></type><name>window</name></decl>;</decl_stmt>
	}</block> <decl><name>call</name></decl>;</union>
	<decl_stmt><decl><type><name>int</name></type> <name>count</name></decl>;</decl_stmt>
}</block></struct></type> <name>gapfill_walker_context</name>;</typedef>

<comment type="block">/*
 * FuncExpr is time_bucket_gapfill function call
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>is_gapfill_function_call</name><parameter_list>(<parameter><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>call</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>func_name</name> <init>= <expr><call><name>get_func_name</name><argument_list>(<argument><expr><name><name>call</name><operator>-&gt;</operator><name>funcid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>strncmp</name><argument_list>(<argument><expr><name>func_name</name></expr></argument>, <argument><expr><name>GAPFILL_FUNCTION</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * FuncExpr is locf or interpolate function call
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>is_marker_function_call</name><parameter_list>(<parameter><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>call</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>func_name</name> <init>= <expr><call><name>get_func_name</name><argument_list>(<argument><expr><name><name>call</name><operator>-&gt;</operator><name>funcid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>strncmp</name><argument_list>(<argument><expr><name>func_name</name></expr></argument>, <argument><expr><name>GAPFILL_LOCF_FUNCTION</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		   <call><name>strncmp</name><argument_list>(<argument><expr><name>func_name</name></expr></argument>, <argument><expr><name>GAPFILL_INTERPOLATE_FUNCTION</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Find time_bucket_gapfill function call
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>gapfill_function_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>gapfill_walker_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>is_gapfill_function_call</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>FuncExpr</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>call</name><operator>.</operator><name>node</name></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>count</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>gapfill_function_walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check if the given expression contains call to time_bucket_gapfill
 */</comment>
<function><type><name>bool</name></type>
<name>gapfill_in_expression</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>gapfill_walker_context</name></type> <name>context</name> <init>= <expr><block>{ <expr><operator>.</operator><name><name>call</name><operator>.</operator><name>node</name></name> <operator>=</operator> <name>NULL</name></expr>, <expr><operator>.</operator><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>gapfill_function_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>context</name><operator>.</operator><name>count</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Find locf/interpolate function call
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>marker_function_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>gapfill_walker_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>is_marker_function_call</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>FuncExpr</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>call</name><operator>.</operator><name>node</name></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>count</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>marker_function_walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Find window function calls
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>window_function_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>gapfill_walker_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>WindowFunc</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>call</name><operator>.</operator><name>node</name></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>count</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>window_function_walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * check if ordering matches the order we need:
 * all groups need to be part of order
 * pathkeys must consist of group elements only
 * last element of pathkeys needs to be time_bucket_gapfill ASC
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>gapfill_correct_order</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>subpath</name></decl></parameter>, <parameter><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>func</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>group_pathkeys</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PathKey</name> <modifier>*</modifier></type><name>pk</name> <init>= <expr><call><name>llast</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>em</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>pk</name><operator>-&gt;</operator><name>pk_eclass</name><operator>-&gt;</operator><name>ec_members</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* time_bucket_gapfill is last element */</comment>
		<if_stmt><if>if <condition>(<expr><name>BTLessStrategyNumber</name> <operator>==</operator> <name><name>pk</name><operator>-&gt;</operator><name>pk_strategy</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>em</name><operator>-&gt;</operator><name>em_expr</name></name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>(</operator><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name><name>em</name><operator>-&gt;</operator><name>em_expr</name></name><operator>)</operator><operator>-&gt;</operator><name>funcid</name> <operator>==</operator> <name><name>func</name><operator>-&gt;</operator><name>funcid</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

			<comment type="block">/* check all groups are part of subpath pathkeys */</comment>
			<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>root-&gt;group_pathkeys</argument>)</argument_list></macro>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_member</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Create a gapfill plan node in the form of a CustomScan node. The
 * purpose of this plan node is to insert tuples for missing groups.
 *
 * Note that CustomScan nodes cannot be extended (by struct embedding) because
 * they might be copied, therefore we pass any extra info in the custom_private
 * field.
 *
 * The gapfill plan takes the original Agg node and imposes itself on top of the
 * Agg node. During execution, the gapfill node will produce the new tuples.
 */</comment>
<function><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type>
<name>gapfill_plan_create</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>CustomPath</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
					<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>clauses</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>custom_plans</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GapFillPath</name> <modifier>*</modifier></type><name>gfpath</name> <init>= <expr><operator>(</operator><name>GapFillPath</name> <operator>*</operator><operator>)</operator> <name>path</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CustomScan</name> <modifier>*</modifier></type><name>cscan</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CustomScan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name> <init>= <expr><call><name>list_copy</name><argument_list>(<argument><expr><name><name>gfpath</name><operator>-&gt;</operator><name>func</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_plans</name></name> <operator>=</operator> <name>custom_plans</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_scan_tlist</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator><name>flags</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>methods</name></name> <operator>=</operator> <operator>&amp;</operator><name>gapfill_plan_methods</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_private</name></name> <operator>=</operator>
		<call><name>list_make4</name><argument_list>(<argument><expr><name><name>gfpath</name><operator>-&gt;</operator><name>func</name></name></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>&amp;</operator><name><name>cscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name></name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>CustomPathMethods</name></type> <name>gapfill_path_methods</name> <init>= <expr><block>{
	<expr><operator>.</operator><name>CustomName</name> <operator>=</operator> <literal type="string">"GapFill"</literal></expr>,
	<expr><operator>.</operator><name>PlanCustomPath</name> <operator>=</operator> <name>gapfill_plan_create</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>gapfill_expression_walker</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><function_decl><type><name>bool</name></type> (<modifier>*</modifier><name>walker</name>)<parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>gapfill_walker_context</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
						  <parameter><decl><type><name>gapfill_walker_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>call</name><operator>.</operator><name>node</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<return>return <expr><call>(<modifier>*</modifier><name>walker</name>)<argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Build expression lists for the gapfill node and the node below.
 * All marker functions will be top-level function calls in the
 * resulting gapfill node targetlist and will not be included in
 * the subpath expression list
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>gapfill_build_pathtarget</name><parameter_list>(<parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>pt_upper</name></decl></parameter>, <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>pt_path</name></decl></parameter>, <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>pt_subpath</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>pt_upper-&gt;exprs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>gapfill_walker_context</name></type> <name>context</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/* check for locf/interpolate calls */</comment>
		<expr_stmt><expr><call><name>gapfill_expression_walker</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>marker_function_walker</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>.</operator><name>count</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"multiple interpolate/locf function calls per resultset column not "</literal>
							<literal type="string">"supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>.</operator><name>count</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * marker needs to be toplevel for now unless we have a projection capable
			 * node above gapfill node
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>expr</name> <operator>!=</operator> <name><name>context</name><operator>.</operator><name>call</name><operator>.</operator><name>expr</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>contain_window_function</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s must be toplevel function call"</literal></expr></argument>,
								<argument><expr><call><name>get_func_name</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>call</name><operator>.</operator><name>func</name><operator>-&gt;</operator><name>funcid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* if there is an aggregation it needs to be a child of the marker function */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>contain_agg_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<operator>!</operator><call><name>contain_agg_clause</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>call</name><operator>.</operator><name>func</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"aggregate functions must be below %s"</literal></expr></argument>,
								<argument><expr><call><name>get_func_name</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>call</name><operator>.</operator><name>func</name><operator>-&gt;</operator><name>funcid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>contain_window_function</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>call</name><operator>.</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"window functions must not be below %s"</literal></expr></argument>,
								<argument><expr><call><name>get_func_name</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>call</name><operator>.</operator><name>func</name><operator>-&gt;</operator><name>funcid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>add_column_to_pathtarget</name><argument_list>(<argument><expr><name>pt_path</name></expr></argument>, <argument><expr><name><name>context</name><operator>.</operator><name>call</name><operator>.</operator><name>expr</name></name></expr></argument>, <argument><expr><name><name>pt_upper</name><operator>-&gt;</operator><name>sortgrouprefs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>add_column_to_pathtarget</name><argument_list>(<argument><expr><name>pt_subpath</name></expr></argument>,
									 <argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>call</name><operator>.</operator><name>func</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><name><name>pt_upper</name><operator>-&gt;</operator><name>sortgrouprefs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* check for plain window function calls without locf/interpolate */</comment>
		<expr_stmt><expr><call><name>gapfill_expression_walker</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>window_function_walker</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>.</operator><name>count</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"multiple window function calls per column not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>.</operator><name>count</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * window functions without arguments like rank() don't need to
			 * appear in the target list below WindowAgg node
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>.</operator><name>call</name><operator>.</operator><name>window</name><operator>-&gt;</operator><name>args</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc_arg</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * check arguments past first argument dont have Vars
				 */</comment>
				<for>for <control>(<init><expr><name>lc_arg</name> <operator>=</operator> <call><name>lnext_compat</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>call</name><operator>.</operator><name>window</name><operator>-&gt;</operator><name>args</name></name></expr></argument>,
										   <argument><expr><call><name>list_head</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>call</name><operator>.</operator><name>window</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</init>
					 <condition><expr><name>lc_arg</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
					 <incr><expr><name>lc_arg</name> <operator>=</operator> <call><name>lnext_compat</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>call</name><operator>.</operator><name>window</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>lc_arg</name></expr></argument>)</argument_list></call></expr></incr>)</control>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>contain_var_clause</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc_arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"window functions with multiple column "</literal>
										<literal type="string">"references not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></for>

				<if_stmt><if>if <condition>(<expr><call><name>contain_var_clause</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>call</name><operator>.</operator><name>window</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>add_column_to_pathtarget</name><argument_list>(<argument><expr><name>pt_path</name></expr></argument>,
											 <argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>call</name><operator>.</operator><name>window</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><name><name>pt_upper</name><operator>-&gt;</operator><name>sortgrouprefs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>add_column_to_pathtarget</name><argument_list>(<argument><expr><name>pt_subpath</name></expr></argument>,
											 <argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>call</name><operator>.</operator><name>window</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><name><name>pt_upper</name><operator>-&gt;</operator><name>sortgrouprefs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * no locf/interpolate or window functions found so we can
			 * use expression verbatim
			 */</comment>
			<expr_stmt><expr><call><name>add_column_to_pathtarget</name><argument_list>(<argument><expr><name>pt_path</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>pt_upper</name><operator>-&gt;</operator><name>sortgrouprefs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>add_column_to_pathtarget</name><argument_list>(<argument><expr><name>pt_subpath</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>pt_upper</name><operator>-&gt;</operator><name>sortgrouprefs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Create a Gapfill Path node.
 *
 * The gap fill node needs rows to be sorted by time ASC
 * so we insert sort pathes if the query order does not match
 * that
 */</comment>
<function><type><specifier>static</specifier> <name>Path</name> <modifier>*</modifier></type>
<name>gapfill_path_create</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>subpath</name></decl></parameter>, <parameter><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>func</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GapFillPath</name> <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>GapFillPath</name> <operator>*</operator><operator>)</operator> <call><name>newNode</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GapFillPath</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>T_CustomPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_CustomScan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>methods</name></name> <operator>=</operator> <operator>&amp;</operator><name>gapfill_path_methods</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * parallel_safe must be false because it is not safe to execute this node
	 * in parallel, but it is safe for child nodes to be parallel
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>param_info</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <call><name>create_empty_pathtarget</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>subpath</name><operator>-&gt;</operator><name>pathtarget</name></name> <operator>=</operator> <call><name>create_empty_pathtarget</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>gapfill_build_pathtarget</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>upper_targets</name><index>[<expr><name>UPPERREL_FINAL</name></expr>]</index></name></expr></argument>,
							 <argument><expr><name><name>path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>pathtarget</name></name></expr></argument>,
							 <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>pathtarget</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>gapfill_correct_order</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>subpath</name></expr></argument>, <argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>new_order</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PathKey</name> <modifier>*</modifier></type><name>pk_func</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* subpath does not have correct order */</comment>
		<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>root-&gt;group_pathkeys</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PathKey</name> <modifier>*</modifier></type><name>pk</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>em</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>pk</name><operator>-&gt;</operator><name>pk_eclass</name><operator>-&gt;</operator><name>ec_members</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pk_func</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>em</name><operator>-&gt;</operator><name>em_expr</name></name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<operator>(</operator><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name><name>em</name><operator>-&gt;</operator><name>em_expr</name></name><operator>)</operator><operator>-&gt;</operator><name>funcid</name> <operator>==</operator> <name><name>func</name><operator>-&gt;</operator><name>funcid</name></name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>BTLessStrategyNumber</name> <operator>==</operator> <name><name>pk</name><operator>-&gt;</operator><name>pk_strategy</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>pk_func</name> <operator>=</operator> <name>pk</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>pk_func</name> <operator>=</operator> <call><name>make_canonical_pathkey</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
													 <argument><expr><name><name>pk</name><operator>-&gt;</operator><name>pk_eclass</name></name></expr></argument>,
													 <argument><expr><name><name>pk</name><operator>-&gt;</operator><name>pk_opfamily</name></name></expr></argument>,
													 <argument><expr><name>BTLessStrategyNumber</name></expr></argument>,
													 <argument><expr><name><name>pk</name><operator>-&gt;</operator><name>pk_nulls_first</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>new_order</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>new_order</name></expr></argument>, <argument><expr><name>pk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pk_func</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no top level time_bucket_gapfill in group by clause"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>new_order</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>new_order</name></expr></argument>, <argument><expr><name>pk_func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>subpath</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
			<call><name>create_sort_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>parent</name></name></expr></argument>, <argument><expr><name>subpath</name></expr></argument>, <argument><expr><name>new_order</name></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>limit_tuples</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>custom_paths</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>func</name></name> <operator>=</operator> <name>func</name></expr>;</expr_stmt>

	<return>return <expr><operator>&amp;</operator><name><name>path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Prepend GapFill node to every group_rel path.
 * The implementation assumes that TimescaleDB planning hook is called only once
 * per grouping.
 */</comment>
<function><type><name>void</name></type>
<name>plan_add_gapfill</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>group_rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>gapfill_walker_context</name></type> <name>context</name> <init>= <expr><block>{ <expr><operator>.</operator><name><name>call</name><operator>.</operator><name>node</name></name> <operator>=</operator> <name>NULL</name></expr>, <expr><operator>.</operator><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>CMD_SELECT</name> <operator>!=</operator> <name><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>||</operator> <name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Look for time_bucket_gapfill function call in the target list, which
	 * will succeed on every call to plan_add_gapfill, thus it will lead to
	 * incorrect query plan if plan_add_gapfill is called more than once per
	 * grouping.
	 */</comment>
	<expr_stmt><expr><call><name>gapfill_function_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>parse</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>.</operator><name>count</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>.</operator><name>count</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"multiple time_bucket_gapfill calls not allowed"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>.</operator><name>count</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>copy</name> <init>= <expr><name><name>group_rel</name><operator>-&gt;</operator><name>pathlist</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>group_rel</name><operator>-&gt;</operator><name>pathlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>group_rel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>group_rel</name><operator>-&gt;</operator><name>cheapest_startup_path</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>group_rel</name><operator>-&gt;</operator><name>cheapest_unique_path</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<comment type="block">/* Parameterized paths pathlist is currently deleted instead of being processed */</comment>
		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name><name>group_rel</name><operator>-&gt;</operator><name>ppilist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>group_rel</name><operator>-&gt;</operator><name>ppilist</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name><name>group_rel</name><operator>-&gt;</operator><name>cheapest_parameterized_paths</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>group_rel</name><operator>-&gt;</operator><name>cheapest_parameterized_paths</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>copy</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>group_rel</name></expr></argument>, <argument><expr><call><name>gapfill_path_create</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>context</name><operator>.</operator><name>call</name><operator>.</operator><name>func</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>is_gapfill_path</name><parameter_list>(<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>IsA</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>CustomPath</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>CustomPath</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>methods</name> <operator>==</operator> <operator>&amp;</operator><name>gapfill_path_methods</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Since we construct the targetlist for the gapfill node from the
 * final targetlist we need to adjust any intermediate targetlists
 * between toplevel window agg node and gapfill node. This adjustment
 * is only necessary if multiple WindowAgg nodes are present.
 * In that case we need to adjust the targetlists of nodes between
 * toplevel WindowAgg node and Gapfill node
 *
 * Gapfill plan with multiple WindowAgg nodes:
 *
 *  WindowAgg
 *    -&gt;  WindowAgg
 *          -&gt;  Custom Scan (GapFill)
 *                -&gt;  Sort
 *                      Sort Key: (time_bucket_gapfill(1, "time"))
 *                      -&gt;  HashAggregate
 *                            Group Key: time_bucket_gapfill(1, "time")
 *                            -&gt;  Seq Scan on metrics_int
 *
 */</comment>
<function><type><name>void</name></type>
<name>gapfill_adjust_window_targetlist</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>input_rel</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>output_rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_gapfill_path</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>input_rel</name><operator>-&gt;</operator><name>pathlist</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>output_rel-&gt;pathlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WindowAggPath</name> <modifier>*</modifier></type><name>toppath</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * the toplevel WindowAggPath has the highest index. If winref is
		 * 1 we only have one WindowAggPath if its greater then 1 then there
		 * are multiple WindowAgg nodes.
		 *
		 * we skip toplevel WindowAggPath because targetlist of toplevel WindowAggPath
		 * is our starting point for building gapfill targetlist so we don't need to
		 * adjust the toplevel targetlist
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>toppath</name></expr></argument>, <argument><expr><name>WindowAggPath</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>toppath</name><operator>-&gt;</operator><name>winclause</name><operator>-&gt;</operator><name>winref</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>WindowAggPath</name> <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>WindowAggPath</name> <operator>*</operator><operator>)</operator> <name><name>toppath</name><operator>-&gt;</operator><name>subpath</name></name></expr>;</init> <condition><expr><call><name>IsA</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>WindowAggPath</name></expr></argument>)</argument_list></call></expr>;</condition>
				 <incr><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>WindowAggPath</name> <operator>*</operator><operator>)</operator> <name><name>path</name><operator>-&gt;</operator><name>subpath</name></name></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>pt_top</name> <init>= <expr><name><name>toppath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>pt</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc_expr</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>pt</name> <operator>=</operator> <call><name>create_empty_pathtarget</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/*
				 * for each child we build targetlist based on top path
				 * targetlist
				 */</comment>
				<macro><name>foreach</name> <argument_list>(<argument>lc_expr</argument>, <argument>pt_top-&gt;exprs</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>gapfill_walker_context</name></type> <name>context</name></decl>;</decl_stmt>
					<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>gapfill_expression_walker</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc_expr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>window_function_walker</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * we error out on multiple window functions per resultset column
					 * when building gapfill node targetlist so we only assert here
					 */</comment>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>count</name></name> <operator>&lt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>.</operator><name>count</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>.</operator><name>call</name><operator>.</operator><name>window</name><operator>-&gt;</operator><name>winref</name></name> <operator>&lt;=</operator> <name><name>path</name><operator>-&gt;</operator><name>winclause</name><operator>-&gt;</operator><name>winref</name></name></expr>)</condition><block type="pseudo"><block_content>
							<comment type="block">/*
							 * window function of current level or below
							 * so we can put in verbatim
							 */</comment>
							<expr_stmt><expr><call><name>add_column_to_pathtarget</name><argument_list>(<argument><expr><name>pt</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc_expr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>pt_top</name><operator>-&gt;</operator><name>sortgrouprefs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
						<if type="elseif">else if <condition>(<expr><name><name>context</name><operator>.</operator><name>call</name><operator>.</operator><name>window</name><operator>-&gt;</operator><name>args</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
						<block>{<block_content>
							<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc_arg</name></decl>;</decl_stmt>
							<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>call</name><operator>.</operator><name>window</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
								<comment type="block">/*
								 * check arguments past first argument dont have Vars
								 */</comment>
								<for>for <control>(<init><expr><name>lc_arg</name> <operator>=</operator> <call><name>lnext_compat</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>call</name><operator>.</operator><name>window</name><operator>-&gt;</operator><name>args</name></name></expr></argument>,
														   <argument><expr><call><name>list_head</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>call</name><operator>.</operator><name>window</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</init>
									 <condition><expr><name>lc_arg</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
									 <incr><expr><name>lc_arg</name> <operator>=</operator> <call><name>lnext_compat</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>call</name><operator>.</operator><name>window</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>lc_arg</name></expr></argument>)</argument_list></call></expr></incr>)</control>
								<block>{<block_content>
									<if_stmt><if>if <condition>(<expr><call><name>contain_var_clause</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc_arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
										<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
												<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
												 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"window functions with multiple column "</literal>
														<literal type="string">"references not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
								</block_content>}</block></for></block_content></block></if></if_stmt>

							<if_stmt><if>if <condition>(<expr><call><name>contain_var_clause</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>call</name><operator>.</operator><name>window</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>add_column_to_pathtarget</name><argument_list>(<argument><expr><name>pt</name></expr></argument>,
														 <argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>call</name><operator>.</operator><name>window</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>,
														 <argument><expr><name><name>pt_top</name><operator>-&gt;</operator><name>sortgrouprefs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>add_column_to_pathtarget</name><argument_list>(<argument><expr><name>pt</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc_expr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>pt_top</name><operator>-&gt;</operator><name>sortgrouprefs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block>
				<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name>pt</name></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>
</unit>
