<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/timescaledb/tsl/src/nodes/gapfill/gapfill_exec.c"><comment type="block">/*
 * This file and its contents are licensed under the Timescale License.
 * Please see the included NOTICE for copyright information and
 * LICENSE-TIMESCALE for a copy of the license.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;c.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postgres.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/attnum.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/htup_details.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_cast.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_collation.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_type.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;miscadmin.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/extensible.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/makefuncs.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/nodeFuncs.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/primnodes.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/clauses.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/optimizer.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/builtins.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/date.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/datum.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/memutils.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/lsyscache.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/timestamp.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/syscache.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/typcache.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;annotations.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;compat/compat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gapfill.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gapfill_internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"locf.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"interpolate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"time_bucket.h"</cpp:file></cpp:include>

<typedef>typedef <type><enum>enum <name>GapFillBoundary</name>
<block>{
	<decl><name>GAPFILL_START</name></decl>,
	<decl><name>GAPFILL_END</name></decl>,
}</block></enum></type> <name>GapFillBoundary</name>;</typedef>

<typedef>typedef <type><union>union <name>GapFillColumnStateUnion</name>
<block>{
	<decl_stmt><decl><type><name>GapFillColumnState</name> <modifier>*</modifier></type><name>base</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GapFillGroupColumnState</name> <modifier>*</modifier></type><name>group</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GapFillInterpolateColumnState</name> <modifier>*</modifier></type><name>interpolate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GapFillLocfColumnState</name> <modifier>*</modifier></type><name>locf</name></decl>;</decl_stmt>
}</block></union></type> <name>GapFillColumnStateUnion</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>foreach_column</name><parameter_list>(<parameter><type><name>column</name></type></parameter>, <parameter><type><name>index</name></type></parameter>, <parameter><type><name>state</name></type></parameter>)</parameter_list></cpp:macro>                                                       \
	<cpp:value>Assert((state)-&gt;ncolumns &gt; 0);                                                                 \
	for ((index) = 0, (column) = (state)-&gt;columns[index];                                          \
		 (index) &lt; (state)-&gt;ncolumns &amp;&amp; ((column) = (state)-&gt;columns[index], true);                \
		 (index)++)</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>gapfill_begin</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>gapfill_end</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>gapfill_rescan</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>gapfill_exec</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>gapfill_state_reset_group</name><parameter_list>(<parameter><decl><type><name>GapFillState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>gapfill_state_gaptuple_create</name><parameter_list>(<parameter><decl><type><name>GapFillState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>time</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>gapfill_state_is_new_group</name><parameter_list>(<parameter><decl><type><name>GapFillState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>gapfill_state_set_next</name><parameter_list>(<parameter><decl><type><name>GapFillState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>subslot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>gapfill_state_return_subplan_slot</name><parameter_list>(<parameter><decl><type><name>GapFillState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>gapfill_fetch_next_tuple</name><parameter_list>(<parameter><decl><type><name>GapFillState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>gapfill_state_initialize_columns</name><parameter_list>(<parameter><decl><type><name>GapFillState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>GapFillColumnState</name> <modifier>*</modifier></type><name>gapfill_column_state_create</name><parameter_list>(<parameter><decl><type><name>GapFillColumnType</name></type> <name>ctype</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typeid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>gapfill_is_group_column</name><parameter_list>(<parameter><decl><type><name>GapFillState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>gapfill_aggref_mutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <name>CustomExecMethods</name></type> <name>gapfill_state_methods</name> <init>= <expr><block>{
	<expr><operator>.</operator><name>BeginCustomScan</name> <operator>=</operator> <name>gapfill_begin</name></expr>,
	<expr><operator>.</operator><name>ExecCustomScan</name> <operator>=</operator> <name>gapfill_exec</name></expr>,
	<expr><operator>.</operator><name>EndCustomScan</name> <operator>=</operator> <name>gapfill_end</name></expr>,
	<expr><operator>.</operator><name>ReScanCustomScan</name> <operator>=</operator> <name>gapfill_rescan</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * convert Datum to int64 according to type
 * internally we store all times as int64 in the
 * same format postgres does
 */</comment>
<function><type><name>int64</name></type>
<name>gapfill_datum_get_internal</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>type</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>INT2OID</name></expr>:</case>
			<return>return <expr><call><name>DatumGetInt16</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>DATEOID</name></expr>:</case>
		<case>case <expr><name>INT4OID</name></expr>:</case>
			<return>return <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>TIMESTAMPOID</name></expr>:</case>
		<case>case <expr><name>TIMESTAMPTZOID</name></expr>:</case>
		<case>case <expr><name>INT8OID</name></expr>:</case>
			<return>return <expr><call><name>DatumGetInt64</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
		<default>default:</default>

			<comment type="block">/*
			 * should never happen since time_bucket_gapfill is not defined
			 * for other datatypes
			 */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unsupported datatype for time_bucket_gapfill: %s"</literal></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pg_unreachable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * convert int64 to Datum according to type
 * internally we store all times as int64 in the
 * same format postgres does
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>Datum</name></type>
<name>gapfill_internal_get_datum</name><parameter_list>(<parameter><decl><type><name>int64</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>type</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>INT2OID</name></expr>:</case>
			<return>return <expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>DATEOID</name></expr>:</case>
		<case>case <expr><name>INT4OID</name></expr>:</case>
			<return>return <expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>TIMESTAMPOID</name></expr>:</case>
		<case>case <expr><name>TIMESTAMPTZOID</name></expr>:</case>
		<case>case <expr><name>INT8OID</name></expr>:</case>
			<return>return <expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
		<default>default:</default>

			<comment type="block">/*
			 * should never happen since time_bucket_gapfill is not defined
			 * for other datatypes
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type>
<name>get_start_arg</name><parameter_list>(<parameter><decl><type><name>GapFillState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>have_timezone</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>lthird</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><call><name>lfourth</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type>
<name>get_finish_arg</name><parameter_list>(<parameter><decl><type><name>GapFillState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>have_timezone</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>lfourth</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><call><name>lfifth</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type>
<name>get_timezone_arg</name><parameter_list>(<parameter><decl><type><name>GapFillState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>have_timezone</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>lthird</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int64</name></type>
<name>gapfill_period_get_internal</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>timetype</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>argtype</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>Interval</name> <modifier>*</modifier><modifier>*</modifier></type><name>interval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>timetype</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>DATEOID</name></expr>:</case>
		<case>case <expr><name>TIMESTAMPOID</name></expr>:</case>
		<case>case <expr><name>TIMESTAMPTZOID</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>INTERVALOID</name> <operator>==</operator> <name>argtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<decl_stmt><decl><type><name>Interval</name> <modifier>*</modifier></type><name>interval_arg</name> <init>= <expr><call><name>DatumGetIntervalP</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>interval_arg</name><operator>-&gt;</operator><name>time</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>interval_arg</name><operator>-&gt;</operator><name>day</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>interval_arg</name><operator>-&gt;</operator><name>month</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
				<name><name>interval_arg</name><operator>-&gt;</operator><name>time</name></name> <operator>+</operator> <name><name>interval_arg</name><operator>-&gt;</operator><name>day</name></name> <operator>+</operator> <name><name>interval_arg</name><operator>-&gt;</operator><name>month</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid time_bucket_gapfill argument: bucket_width must be "</literal>
								<literal type="string">"greater than 0"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><operator>*</operator><name>interval</name> <operator>=</operator> <name>interval_arg</name></expr>;</expr_stmt>
			<return>return <expr><literal type="number">0</literal></expr>;</return>

			<break>break;</break>
		<case>case <expr><name>INT2OID</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>INT2OID</name> <operator>==</operator> <name>argtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><call><name>DatumGetInt16</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>INT4OID</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>INT4OID</name> <operator>==</operator> <name>argtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>INT8OID</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>INT8OID</name> <operator>==</operator> <name>argtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><call><name>DatumGetInt64</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</return>
		<default>default:</default>

			<comment type="block">/*
			 * should never happen since time_bucket_gapfill is not defined
			 * for other datatypes
			 */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unsupported datatype for time_bucket_gapfill: %s"</literal></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>timetype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pg_unreachable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Create a GapFill node from this plan. This is the full execution
 * state that replaces the plan node as the plan moves from planning to
 * execution.
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>gapfill_state_create</name><parameter_list>(<parameter><decl><type><name>CustomScan</name> <modifier>*</modifier></type><name>cscan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GapFillState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><operator>(</operator><name>GapFillState</name> <operator>*</operator><operator>)</operator> <call><name>newNode</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GapFillState</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>T_CustomScanState</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>csstate</name><operator>.</operator><name>methods</name></name> <operator>=</operator> <operator>&amp;</operator><name>gapfill_state_methods</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>subplan</name></name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_plans</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>lfourth</name><argument_list>(<argument><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_private</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>have_timezone</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">5</literal></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>state</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_const_null</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>constisnull</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * lookup cast func oid in pg_cast
 *
 * throws an error if no cast can be found
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>get_cast_func</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>source</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>target</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>result</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>casttup</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>casttup</name> <operator>=</operator> <call><name>SearchSysCache2</name><argument_list>(<argument><expr><name>CASTSOURCETARGET</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>casttup</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_cast</name></type> <name>castform</name> <init>= <expr><operator>(</operator><name>Form_pg_cast</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>casttup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>castform</name><operator>-&gt;</operator><name>castfunc</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>casttup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not find cast from %s to %s"</literal></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * returns true if v1 and v2 reference the same object
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>var_equal</name><parameter_list>(<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>v1</name></decl></parameter>, <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>v2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>v1</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name><name>v2</name><operator>-&gt;</operator><name>varno</name></name> <operator>&amp;&amp;</operator> <name><name>v1</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <name><name>v2</name><operator>-&gt;</operator><name>varattno</name></name> <operator>&amp;&amp;</operator> <name><name>v1</name><operator>-&gt;</operator><name>vartype</name></name> <operator>==</operator> <name><name>v2</name><operator>-&gt;</operator><name>vartype</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_simple_expr_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * since expression_tree_walker does early exit on true
	 * logic is reverted and return value of true means expression
	 * is not simple, this is reverted in parent
	 */</comment>
	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
			<comment type="block">/*
			 * whitelist expression types we deem safe to execute in a
			 * separate expression context
			 */</comment>
		<case>case <expr><name>T_Const</name></expr>:</case>
		<case>case <expr><name>T_FuncExpr</name></expr>:</case>
		<case>case <expr><name>T_NamedArgExpr</name></expr>:</case>
		<case>case <expr><name>T_OpExpr</name></expr>:</case>
		<case>case <expr><name>T_DistinctExpr</name></expr>:</case>
		<case>case <expr><name>T_NullIfExpr</name></expr>:</case>
		<case>case <expr><name>T_ScalarArrayOpExpr</name></expr>:</case>
		<case>case <expr><name>T_BoolExpr</name></expr>:</case>
		<case>case <expr><name>T_CoerceViaIO</name></expr>:</case>
		<case>case <expr><name>T_CaseExpr</name></expr>:</case>
		<case>case <expr><name>T_CaseWhen</name></expr>:</case>
			<break>break;</break>
		<case>case <expr><name>T_Param</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>castNode</name><argument_list>(<argument><expr><name>Param</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>paramkind</name> <operator>!=</operator> <name>PARAM_EXTERN</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>
		<default>default:</default>
			<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></switch>
	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>is_simple_expr_walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * check if expression is simple expression and contains only simple
 * subexpressions
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_simple_expr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * since expression_tree_walker does early exit on true and we use that to
	 * skip processing on first non-simple expression we invert return value
	 * from expression_tree_walker here
	 */</comment>
	<return>return <expr><operator>!</operator><call><name>is_simple_expr_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * align a value with the bucket boundary
 * even though we use int64 as our internal representation we cannot call
 * ts_int64_bucket here because int variants of time_bucket align differently
 * then non-int variants because the bucket start is on monday for the latter
 */</comment>
<function><type><specifier>static</specifier> <name>int64</name></type>
<name>align_with_time_bucket</name><parameter_list>(<parameter><decl><type><name>GapFillState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CustomScan</name> <modifier>*</modifier></type><name>cscan</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>CustomScan</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>csstate</name><operator>.</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>time_bucket</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_private</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>value</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>isnull</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_simple_expr</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(
					 <argument><expr><literal type="string">"invalid time_bucket_gapfill argument: start must be a simple expression"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>have_timezone</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><call><name>get_timezone_arg</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>castNode</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><call><name>get_timezone_arg</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>constisnull</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid time_bucket_gapfill argument: timezone cannot be NULL"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>time_bucket</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator>
			<call><name>list_make3</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>time_bucket</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><call><name>lthird</name><argument_list>(<argument><expr><name><name>time_bucket</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>time_bucket</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>time_bucket</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>gapfill_exec_expr</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>time_bucket</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* start expression must not evaluate to NULL */</comment>
	<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid time_bucket_gapfill argument: start cannot be NULL"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Specify start and finish as arguments or in the WHERE clause."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><call><name>gapfill_datum_get_internal</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>gapfill_typid</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int64</name></type>
<name>get_boundary_expr_value</name><parameter_list>(<parameter><decl><type><name>GapFillState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>GapFillBoundary</name></type> <name>boundary</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type> <name>arg_value</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>isnull</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * add an explicit cast here if types do not match
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>state</name><operator>-&gt;</operator><name>gapfill_typid</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>cast_oid</name> <init>= <expr><call><name>get_cast_func</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>gapfill_typid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeFuncExpr</name><argument_list>(<argument><expr><name>cast_oid</name></expr></argument>,
									 <argument><expr><name><name>state</name><operator>-&gt;</operator><name>gapfill_typid</name></name></expr></argument>,
									 <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><name>InvalidOid</name></expr></argument>,
									 <argument><expr><name>InvalidOid</name></expr></argument>,
									 <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>arg_value</name> <operator>=</operator> <call><name>gapfill_exec_expr</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid time_bucket_gapfill argument: %s cannot be NULL"</literal></expr></argument>,
						<argument><expr><ternary><condition><expr><name>boundary</name> <operator>==</operator> <name>GAPFILL_START</name></expr> ?</condition><then> <expr><literal type="string">"start"</literal></expr> </then><else>: <expr><literal type="string">"finish"</literal></expr></else></ternary></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Specify start and finish as arguments or in the WHERE clause."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><call><name>gapfill_datum_get_internal</name><argument_list>(<argument><expr><name>arg_value</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>gapfill_typid</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <name>CollectBoundaryContext</name>
<block>{
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>quals</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>ts_var</name></decl>;</decl_stmt>
}</block></struct></type> <name>CollectBoundaryContext</name>;</typedef>

<comment type="block">/*
 * expression references our gapfill time column and could be
 * a boundary expression, more thorough check is in
 * infer_gapfill_boundary
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_boundary_expr</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>CollectBoundaryContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>op</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>left</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>right</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>op</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>OpExpr</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>args</name><operator>-&gt;</operator><name>length</name></name> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>left</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>right</name> <operator>=</operator> <call><name>llast</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Var OP Var is not useful here because we are not yet at a point
	 * where we could evaluate them */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>right</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>var_equal</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>Var</name></expr></argument>, <argument><expr><name>left</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>ts_var</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>right</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>var_equal</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>Var</name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>ts_var</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>collect_boundary_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>CollectBoundaryContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>quals</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>FromExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>quals</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>FromExpr</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>quals</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>JoinExpr</name> <modifier>*</modifier></type><name>j</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>JoinExpr</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* don't descend into outer join */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IS_OUTER_JOIN</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>jointype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>quals</name> <operator>=</operator> <name><name>j</name><operator>-&gt;</operator><name>quals</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>quals</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>castNode(List, quals)</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>is_boundary_expr</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>collect_boundary_walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * traverse jointree to look for expressions referencing
 * the time column of our gapfill call
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>collect_boundary_expressions</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>ts_var</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CollectBoundaryContext</name></type> <name>context</name> <init>= <expr><block>{ <expr><operator>.</operator><name>quals</name> <operator>=</operator> <name>NIL</name></expr>, <expr><operator>.</operator><name>ts_var</name> <operator>=</operator> <name>ts_var</name></expr> }</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>collect_boundary_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>context</name><operator>.</operator><name>quals</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int64</name></type>
<name>infer_gapfill_boundary</name><parameter_list>(<parameter><decl><type><name>GapFillState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>GapFillBoundary</name></type> <name>boundary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CustomScan</name> <modifier>*</modifier></type><name>cscan</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>CustomScan</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>csstate</name><operator>.</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>func</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_private</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FromExpr</name> <modifier>*</modifier></type><name>jt</name> <init>= <expr><call><name>lthird</name><argument_list>(<argument><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_private</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>ts_var</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>tce</name> <init>= <expr><call><name>lookup_type_cache</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>gapfill_typid</name></name></expr></argument>, <argument><expr><name>TYPECACHE_BTREE_OPFAMILY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>strategy</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>lefttype</name></decl>, <decl><type ref="prev"/><name>righttype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>quals</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int64</name></type> <name>boundary_value</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>boundary_found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * if the second argument to time_bucket_gapfill is not a column reference
	 * we cannot match WHERE clause to the time column
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><call><name>lsecond</name><argument_list>(<argument><expr><name><name>func</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid time_bucket_gapfill argument: ts needs to refer to a single "</literal>
						<literal type="string">"column if no start or finish is supplied"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Specify start and finish as arguments or in the WHERE clause."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>ts_var</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>Var</name></expr></argument>, <argument><expr><call><name>lsecond</name><argument_list>(<argument><expr><name><name>func</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>quals</name> <operator>=</operator> <call><name>collect_boundary_expressions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>jt</name></expr></argument>, <argument><expr><name>ts_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>quals</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>opexpr</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>OpExpr</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>op</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int64</name></type> <name>value</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>op</name> <operator>=</operator> <name><name>opexpr</name><operator>-&gt;</operator><name>opno</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><call><name>lsecond</name><argument_list>(<argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>op</name> <operator>=</operator> <call><name>get_commutator</name><argument_list>(<argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* collect_boundary_expressions has filtered those out already */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>op_in_opfamily</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name><name>tce</name><operator>-&gt;</operator><name>btree_opf</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * only allow simple expressions because Params have not been set up
		 * at this stage and Vars will not work either because we execute in
		 * separate execution context
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_simple_expr</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>var_equal</name><argument_list>(<argument><expr><name>ts_var</name></expr></argument>, <argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>get_op_opfamily_properties</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name><name>tce</name><operator>-&gt;</operator><name>btree_opf</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>strategy</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lefttype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>righttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>boundary</name> <operator>==</operator> <name>GAPFILL_START</name> <operator>&amp;&amp;</operator> <name>strategy</name> <operator>!=</operator> <name>BTGreaterStrategyNumber</name> <operator>&amp;&amp;</operator>
			<name>strategy</name> <operator>!=</operator> <name>BTGreaterEqualStrategyNumber</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>boundary</name> <operator>==</operator> <name>GAPFILL_END</name> <operator>&amp;&amp;</operator> <name>strategy</name> <operator>!=</operator> <name>BTLessStrategyNumber</name> <operator>&amp;&amp;</operator>
			<name>strategy</name> <operator>!=</operator> <name>BTLessEqualStrategyNumber</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>get_boundary_expr_value</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>boundary</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * if the boundary expression operator does not match the operator
		 * used by the gapfill node we adjust the value by 1 here
		 *
		 * the operators for the gapfill node are &gt;= for start and &lt; for end
		 * column &gt; value becomes start &gt;= value + 1 column &lt;= value becomes
		 * end &lt; value + 1
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>strategy</name> <operator>==</operator> <name>BTGreaterStrategyNumber</name> <operator>||</operator> <name>strategy</name> <operator>==</operator> <name>BTLessEqualStrategyNumber</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>value</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>boundary_found</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>boundary_found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>boundary_value</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>boundary</name> <operator>==</operator> <name>GAPFILL_START</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>boundary_value</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>boundary_value</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>boundary_value</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>boundary_value</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>boundary_found</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>boundary_value</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"missing time_bucket_gapfill argument: could not infer %s from WHERE clause"</literal></expr></argument>,
					<argument><expr><ternary><condition><expr><name>boundary</name> <operator>==</operator> <name>GAPFILL_START</name></expr> ?</condition><then> <expr><literal type="string">"start"</literal></expr> </then><else>: <expr><literal type="string">"finish"</literal></expr></else></ternary></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Specify start and finish as arguments or in the WHERE clause."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_unreachable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Const</name> <modifier>*</modifier></type>
<name>make_const_value_for_gapfill_internal</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>tce</name> <init>= <expr><call><name>lookup_type_cache</name><argument_list>(<argument><expr><name>typid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>d</name> <init>= <expr><call><name>gapfill_internal_get_datum</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>makeConst</name><argument_list>(<argument><expr><name>typid</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name><name>tce</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>tce</name><operator>-&gt;</operator><name>typbyval</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>gapfill_advance_timestamp</name><parameter_list>(<parameter><decl><type><name>GapFillState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type> <name>next</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>gapfill_typid</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>DATEOID</name></expr>:</case>
			<expr_stmt><expr><name>next</name> <operator>=</operator> <call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>date_pl_interval</name></expr></argument>,
									   <argument><expr><call><name>DateADTGetDatum</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>next_timestamp</name></name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>gapfill_interval</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>next</name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>timestamp_date</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>next_timestamp</name></name> <operator>=</operator> <call><name>DatumGetDateADT</name><argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>TIMESTAMPOID</name></expr>:</case>
			<expr_stmt><expr><name>next</name> <operator>=</operator> <call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>timestamp_pl_interval</name></expr></argument>,
									   <argument><expr><call><name>TimestampGetDatum</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>next_timestamp</name></name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>gapfill_interval</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>next_timestamp</name></name> <operator>=</operator> <call><name>DatumGetTimestamp</name><argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>TIMESTAMPTZOID</name></expr>:</case>
			<comment type="block">/*
			 * To be consistent with time_bucket we do UTC bucketing unless
			 * a different timezone got explicity passed to the function.
			 */</comment>
			<expr_stmt><expr><name>next</name> <operator>=</operator> <call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><ternary><condition><expr><name><name>state</name><operator>-&gt;</operator><name>have_timezone</name></name></expr> ?</condition><then> <expr><name>timestamptz_pl_interval</name></expr> </then><else>:
															  <expr><name>timestamp_pl_interval</name></expr></else></ternary></expr></argument>,
									   <argument><expr><call><name>TimestampTzGetDatum</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>next_timestamp</name></name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>gapfill_interval</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>next_timestamp</name></name> <operator>=</operator> <call><name>DatumGetTimestampTz</name><argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>next_timestamp</name></name> <operator>+=</operator> <name><name>state</name><operator>-&gt;</operator><name>gapfill_period</name></name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize the scan state
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>gapfill_begin</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GapFillState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><operator>(</operator><name>GapFillState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CustomScan</name> <modifier>*</modifier></type><name>cscan</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>CustomScan</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>csstate</name><operator>.</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * this is the time_bucket_gapfill call from the plan which is used to
	 * extract arguments and to align gapfill_start
	 */</comment>
	<decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>func</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_private</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupledesc</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>csstate</name><operator>.</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>targetlist</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>csstate</name><operator>.</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>arg_value</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>gapfill_typid</name></name> <operator>=</operator> <name><name>func</name><operator>-&gt;</operator><name>funcresulttype</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>FETCHED_NONE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>subslot</name></name> <operator>=</operator> <call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><name>tupledesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>TTSOpsVirtual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>scanslot</name></name> <operator>=</operator> <call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><name>tupledesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>TTSOpsVirtual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* bucket_width */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_simple_expr</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid time_bucket_gapfill argument: bucket_width must be a simple "</literal>
						<literal type="string">"expression"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>arg_value</name> <operator>=</operator> <call><name>gapfill_exec_expr</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid time_bucket_gapfill argument: bucket_width cannot be NULL"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>gapfill_period</name></name> <operator>=</operator> <call><name>gapfill_period_get_internal</name><argument_list>(<argument><expr><name><name>func</name><operator>-&gt;</operator><name>funcresulttype</name></name></expr></argument>,
														<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
														<argument><expr><name>arg_value</name></expr></argument>,
														<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>gapfill_interval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * this would error when trying to align start and stop to bucket_width as well below
	 * but checking this explicitly here will make a nicer error message
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>gapfill_period</name></name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>gapfill_interval</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(
					 <argument><expr><literal type="string">"invalid time_bucket_gapfill argument: bucket_width must be greater than 0"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * check if gapfill start was left out so we have to infer from WHERE
	 * clause
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>is_const_null</name><argument_list>(<argument><expr><call><name>get_start_arg</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int64</name></type> <name>start</name> <init>= <expr><call><name>infer_gapfill_boundary</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>GAPFILL_START</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><call><name>make_const_value_for_gapfill_internal</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>gapfill_typid</name></name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>gapfill_start</name></name> <operator>=</operator> <call><name>align_with_time_bucket</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * pass gapfill start through time_bucket so it is aligned with bucket
		 * start
		 */</comment>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>gapfill_start</name></name> <operator>=</operator> <call><name>align_with_time_bucket</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><call><name>get_start_arg</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>next_timestamp</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>gapfill_start</name></name></expr>;</expr_stmt>

	<comment type="block">/* gap fill end */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>is_const_null</name><argument_list>(<argument><expr><call><name>get_finish_arg</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>gapfill_end</name></name> <operator>=</operator> <call><name>infer_gapfill_boundary</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>GAPFILL_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_simple_expr</name><argument_list>(<argument><expr><call><name>get_finish_arg</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid time_bucket_gapfill argument: finish must be a simple "</literal>
							<literal type="string">"expression"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>arg_value</name> <operator>=</operator> <call><name>gapfill_exec_expr</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><call><name>get_finish_arg</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * the default value for finish is NULL but this is checked above,
		 * when a non-Const is passed here that evaluates to NULL we bail
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid time_bucket_gapfill argument: finish cannot be NULL"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Specify start and finish as arguments or in the WHERE clause."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>gapfill_end</name></name> <operator>=</operator> <call><name>gapfill_datum_get_internal</name><argument_list>(<argument><expr><name>arg_value</name></expr></argument>, <argument><expr><name><name>func</name><operator>-&gt;</operator><name>funcresulttype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>gapfill_state_initialize_columns</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Build ProjectionInfo that will be used for gap filled tuples only.
	 *
	 * For every NULL_COLUMN we take the original expression tree from the
	 * subplan and replace Aggref nodes with Const NULL nodes. This is
	 * necessary because the expression might be evaluated below the
	 * aggregation so we need to pull up expression from subplan into
	 * projection for gapfilled tuples so expressions like COALESCE work
	 * correctly for gapfilled tuples.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>ncolumns</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>columns</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>ctype</name> <operator>==</operator> <name>NULL_COLUMN</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_scan_tlist</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>gapfill_aggref_mutator</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>lfirst</name><argument_list>(<argument><expr><call><name>list_nth_cell</name><argument_list>(<argument><expr><name>targetlist</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>=</operator> <name>entry</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>pi</name></name> <operator>=</operator> <call><name>ExecBuildProjectionInfo</name><argument_list>(<argument><expr><name>targetlist</name></expr></argument>,
										<argument><expr><name><name>state</name><operator>-&gt;</operator><name>csstate</name><operator>.</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr></argument>,
										<argument><expr><call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><name>tupledesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>TTSOpsVirtual</name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>csstate</name><operator>.</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>,
										<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>csstate</name><operator>.</operator><name>custom_ps</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>ExecInitNode</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>subplan</name></name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * This is the main loop of the node it is called whenever the upper node
 * wants to consume a new tuple. Returning NULL signals that the tuples
 * are exhausted. All gapfill state transitions happen in this function.
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>gapfill_exec</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GapFillState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><operator>(</operator><name>GapFillState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* fetch next tuple from subplan */</comment>
		<if_stmt><if>if <condition>(<expr><name>FETCHED_NONE</name> <operator>==</operator> <name><name>state</name><operator>-&gt;</operator><name>state</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>gapfill_fetch_next_tuple</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>slot</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>multigroup</name></name> <operator>&amp;&amp;</operator> <call><name>gapfill_state_is_new_group</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>FETCHED_NEXT_GROUP</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>FETCHED_ONE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<expr_stmt><expr><call><name>gapfill_state_set_next</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * if GROUP BY has non time_bucket_gapfill columns but the
				 * query has not initialized the groups there is nothing we
				 * can do here
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>multigroup</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>groups_initialized</name></name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>FETCHED_LAST</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* return any subplan tuples before gapfill_start */</comment>
		<if_stmt><if>if <condition>(<expr><name>FETCHED_ONE</name> <operator>==</operator> <name><name>state</name><operator>-&gt;</operator><name>state</name></name> <operator>&amp;&amp;</operator> <name><name>state</name><operator>-&gt;</operator><name>subslot_time</name></name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>gapfill_start</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>FETCHED_NONE</name></expr>;</expr_stmt>
			<return>return <expr><call><name>gapfill_state_return_subplan_slot</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* if we have tuple from subplan check if it needs to be inserted now */</comment>
		<if_stmt><if>if <condition>(<expr><name>FETCHED_ONE</name> <operator>==</operator> <name><name>state</name><operator>-&gt;</operator><name>state</name></name> <operator>&amp;&amp;</operator> <name><name>state</name><operator>-&gt;</operator><name>subslot_time</name></name> <operator>==</operator> <name><name>state</name><operator>-&gt;</operator><name>next_timestamp</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>FETCHED_NONE</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>gapfill_advance_timestamp</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><call><name>gapfill_state_return_subplan_slot</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* if we are within gapfill boundaries we need to insert tuple */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>next_timestamp</name></name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>gapfill_end</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>FETCHED_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>gapfill_state_gaptuple_create</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>next_timestamp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>gapfill_advance_timestamp</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>slot</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* return any remaining subplan tuples after gapfill_end */</comment>
		<if_stmt><if>if <condition>(<expr><name>FETCHED_ONE</name> <operator>==</operator> <name><name>state</name><operator>-&gt;</operator><name>state</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>FETCHED_NONE</name></expr>;</expr_stmt>
			<return>return <expr><call><name>gapfill_state_return_subplan_slot</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Done with current group, prepare for next
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>FETCHED_NEXT_GROUP</name> <operator>==</operator> <name><name>state</name><operator>-&gt;</operator><name>state</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>FETCHED_ONE</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>next_timestamp</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>gapfill_start</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>gapfill_state_reset_group</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>subslot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>gapfill_end</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>custom_ps</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecEndNode</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>custom_ps</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>gapfill_rescan</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>custom_ps</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecReScan</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>custom_ps</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><operator>(</operator><operator>(</operator><name>GapFillState</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>state</name> <operator>=</operator> <name>FETCHED_NONE</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>gapfill_state_reset_group</name><parameter_list>(<parameter><decl><type><name>GapFillState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GapFillColumnStateUnion</name></type> <name>column</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>value</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>isnull</name></decl>;</decl_stmt>

	<macro><name>foreach_column</name><argument_list>(<argument>column.base</argument>, <argument>i</argument>, <argument>state</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><call><name>AttrOffsetGetAttrNumber</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<switch>switch <condition>(<expr><name><name>column</name><operator>.</operator><name>base</name><operator>-&gt;</operator><name>ctype</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>INTERPOLATE_COLUMN</name></expr>:</case>
				<expr_stmt><expr><call><name>gapfill_interpolate_group_change</name><argument_list>(<argument><expr><name><name>column</name><operator>.</operator><name>interpolate</name></name></expr></argument>,
												 <argument><expr><name><name>state</name><operator>-&gt;</operator><name>subslot_time</name></name></expr></argument>,
												 <argument><expr><name>value</name></expr></argument>,
												 <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>LOCF_COLUMN</name></expr>:</case>
				<expr_stmt><expr><call><name>gapfill_locf_group_change</name><argument_list>(<argument><expr><name><name>column</name><operator>.</operator><name>locf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>GROUP_COLUMN</name></expr>:</case>
			<case>case <expr><name>DERIVED_COLUMN</name></expr>:</case>
				<expr_stmt><expr><name><name>column</name><operator>.</operator><name>group</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name>isnull</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>column</name><operator>.</operator><name>group</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator>
						<call><name>datumCopy</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name><name>column</name><operator>.</operator><name>base</name><operator>-&gt;</operator><name>typbyval</name></name></expr></argument>, <argument><expr><name><name>column</name><operator>.</operator><name>base</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
			<default>default:</default>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Create generated tuple according to column state
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>gapfill_state_gaptuple_create</name><parameter_list>(<parameter><decl><type><name>GapFillState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>time</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>scanslot</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GapFillColumnStateUnion</name></type> <name>column</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * we need to fill in group columns first because locf and interpolation
	 * might reference those columns when doing out of bounds lookup
	 */</comment>
	<macro><name>foreach_column</name><argument_list>(<argument>column.base</argument>, <argument>i</argument>, <argument>state</argument>)</argument_list></macro>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name><name>column</name><operator>.</operator><name>base</name><operator>-&gt;</operator><name>ctype</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>TIME_COLUMN</name></expr>:</case>
				<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>gapfill_internal_get_datum</name><argument_list>(<argument><expr><name>time</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>gapfill_typid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>GROUP_COLUMN</name></expr>:</case>
			<case>case <expr><name>DERIVED_COLUMN</name></expr>:</case>
				<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>column</name><operator>.</operator><name>group</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>column</name><operator>.</operator><name>group</name><operator>-&gt;</operator><name>isnull</name></name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>NULL_COLUMN</name></expr>:</case>
				<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block>

	<comment type="block">/*
	 * mark slot as containing data so it can be used in locf and interpolate
	 * lookup expressions
	 */</comment>
	<expr_stmt><expr><call><name>ExecStoreVirtualTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach_column</name><argument_list>(<argument>column.base</argument>, <argument>i</argument>, <argument>state</argument>)</argument_list></macro>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name><name>column</name><operator>.</operator><name>base</name><operator>-&gt;</operator><name>ctype</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>LOCF_COLUMN</name></expr>:</case>
				<expr_stmt><expr><call><name>gapfill_locf_calculate</name><argument_list>(<argument><expr><name><name>column</name><operator>.</operator><name>locf</name></name></expr></argument>,
									   <argument><expr><name>state</name></expr></argument>,
									   <argument><expr><name>time</name></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>INTERPOLATE_COLUMN</name></expr>:</case>
				<expr_stmt><expr><call><name>gapfill_interpolate_calculate</name><argument_list>(<argument><expr><name><name>column</name><operator>.</operator><name>interpolate</name></name></expr></argument>,
											  <argument><expr><name>state</name></expr></argument>,
											  <argument><expr><name>time</name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block>

	<expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>pi</name><operator>-&gt;</operator><name>pi_exprContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>pi</name><operator>-&gt;</operator><name>pi_exprContext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>
	<return>return <expr><call><name>ExecProject</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>pi</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Returns true if tuple in the TupleTableSlot belongs to the next
 * aggregation group
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>gapfill_state_is_new_group</name><parameter_list>(<parameter><decl><type><name>GapFillState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GapFillColumnStateUnion</name></type> <name>column</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>value</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>isnull</name></decl>;</decl_stmt>

	<comment type="block">/* groups not initialized yet */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>groups_initialized</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>groups_initialized</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>gapfill_state_reset_group</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<macro><name>foreach_column</name><argument_list>(<argument>column.base</argument>, <argument>i</argument>, <argument>state</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>column</name><operator>.</operator><name>base</name><operator>-&gt;</operator><name>ctype</name></name> <operator>==</operator> <name>GROUP_COLUMN</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><call><name>AttrOffsetGetAttrNumber</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>isnull</name> <operator>&amp;&amp;</operator> <name><name>column</name><operator>.</operator><name>group</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>isnull</name> <operator>!=</operator> <name><name>column</name><operator>.</operator><name>group</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2Coll</name><argument_list>(<argument><expr><name><name>column</name><operator>.</operator><name>group</name><operator>-&gt;</operator><name>eq_func</name><operator>.</operator><name>fn_addr</name></name></expr></argument>,
													  <argument><expr><name><name>column</name><operator>.</operator><name>group</name><operator>-&gt;</operator><name>collation</name></name></expr></argument>,
													  <argument><expr><name>value</name></expr></argument>,
													  <argument><expr><name><name>column</name><operator>.</operator><name>group</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Returns subslot tuple and adjusts column state accordingly
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>gapfill_state_return_subplan_slot</name><parameter_list>(<parameter><decl><type><name>GapFillState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GapFillColumnStateUnion</name></type> <name>column</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>CustomScanState</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>value</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>isnull</name></decl>;</decl_stmt>

	<macro><name>foreach_column</name><argument_list>(<argument>column.base</argument>, <argument>i</argument>, <argument>state</argument>)</argument_list></macro>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name><name>column</name><operator>.</operator><name>base</name><operator>-&gt;</operator><name>ctype</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>LOCF_COLUMN</name></expr>:</case>
				<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>subslot</name></name></expr></argument>, <argument><expr><call><name>AttrOffsetGetAttrNumber</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>isnull</name> <operator>&amp;&amp;</operator> <name><name>column</name><operator>.</operator><name>locf</name><operator>-&gt;</operator><name>treat_null_as_missing</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>gapfill_locf_calculate</name><argument_list>(<argument><expr><name><name>column</name><operator>.</operator><name>locf</name></name></expr></argument>,
										   <argument><expr><name>state</name></expr></argument>,
										   <argument><expr><name><name>state</name><operator>-&gt;</operator><name>subslot_time</name></name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>subslot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>subslot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>gapfill_locf_tuple_returned</name><argument_list>(<argument><expr><name><name>column</name><operator>.</operator><name>locf</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>
			<case>case <expr><name>INTERPOLATE_COLUMN</name></expr>:</case>
				<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>subslot</name></name></expr></argument>, <argument><expr><call><name>AttrOffsetGetAttrNumber</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>gapfill_interpolate_tuple_returned</name><argument_list>(<argument><expr><name><name>column</name><operator>.</operator><name>interpolate</name></name></expr></argument>,
												   <argument><expr><name><name>state</name><operator>-&gt;</operator><name>subslot_time</name></name></expr></argument>,
												   <argument><expr><name>value</name></expr></argument>,
												   <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ProjInfo</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>subslot</name></name></expr>;</expr_stmt>
		<return>return <expr><call><name>ExecProject</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ProjInfo</name></name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>state</name><operator>-&gt;</operator><name>subslot</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>gapfill_state_set_next</name><parameter_list>(<parameter><decl><type><name>GapFillState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>subslot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GapFillColumnStateUnion</name></type> <name>column</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>value</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>isnull</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * if this tuple is for next group we dont update column state yet
	 * updating of column state happens in gapfill_state_reset_group instead
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>FETCHED_NEXT_GROUP</name> <operator>==</operator> <name><name>state</name><operator>-&gt;</operator><name>state</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<macro><name>foreach_column</name><argument_list>(<argument>column.base</argument>, <argument>i</argument>, <argument>state</argument>)</argument_list></macro>
	<block>{<block_content>
		<comment type="block">/* nothing to do here for locf */</comment>
		<if_stmt><if>if <condition>(<expr><name>INTERPOLATE_COLUMN</name> <operator>==</operator> <name><name>column</name><operator>.</operator><name>base</name><operator>-&gt;</operator><name>ctype</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>subslot</name></expr></argument>, <argument><expr><call><name>AttrOffsetGetAttrNumber</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>gapfill_interpolate_tuple_fetched</name><argument_list>(<argument><expr><name><name>column</name><operator>.</operator><name>interpolate</name></name></expr></argument>,
											  <argument><expr><name><name>state</name><operator>-&gt;</operator><name>subslot_time</name></name></expr></argument>,
											  <argument><expr><name>value</name></expr></argument>,
											  <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>gapfill_fetch_next_tuple</name><parameter_list>(<parameter><decl><type><name>GapFillState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type> <name>time_value</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>subplan</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>CustomScanState</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>custom_ps</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>subslot</name> <init>= <expr><call><name>ExecProcNode</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>subslot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* we cannot simply treat an arbitrary source slot as virtual,
	 * instead we must copy the data into our own slot in order to be able to
	 * modify it
	 */</comment>
	<expr_stmt><expr><call><name>ExecCopySlot</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>subslot</name></name></expr></argument>, <argument><expr><name>subslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>time_value</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>subslot</name></expr></argument>, <argument><expr><call><name>AttrOffsetGetAttrNumber</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>time_index</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid time_bucket_gapfill argument: ts cannot be NULL"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>subslot_time</name></name> <operator>=</operator> <call><name>gapfill_datum_get_internal</name><argument_list>(<argument><expr><name>time_value</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>gapfill_typid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>state</name><operator>-&gt;</operator><name>subslot</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize column meta data
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>gapfill_state_initialize_columns</name><parameter_list>(<parameter><decl><type><name>GapFillState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupledesc</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>csstate</name><operator>.</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CustomScan</name> <modifier>*</modifier></type><name>cscan</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>CustomScan</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>csstate</name><operator>.</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>ncolumns</name></name> <operator>=</operator> <name><name>tupledesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>columns</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>ncolumns</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GapFillColumnState</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>ncolumns</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_scan_tlist</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>expr</name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name> <operator>&amp;&amp;</operator> <call><name>gapfill_is_group_column</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * if there is time_bucket_gapfill function call this is our time
			 * column
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>strncmp</name><argument_list>(<argument><expr><call><name>get_func_name</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>FuncExpr</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>funcid</name></expr></argument>)</argument_list></call></expr></argument>,
											   <argument><expr><name>GAPFILL_FUNCTION</name></expr></argument>,
											   <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>columns</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator>
					<call><name>gapfill_column_state_create</name><argument_list>(<argument><expr><name>TIME_COLUMN</name></expr></argument>, <argument><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupledesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>time_index</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* otherwise this is a normal group column */</comment>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>columns</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator>
				<call><name>gapfill_column_state_create</name><argument_list>(<argument><expr><name>GROUP_COLUMN</name></expr></argument>, <argument><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupledesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>multigroup</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>groups_initialized</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* locf and interpolate will be toplevel function calls in the gapfill node */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><call><name>get_func_name</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>FuncExpr</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>funcid</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>GAPFILL_LOCF_FUNCTION</name></expr></argument>,
						<argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>columns</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator>
					<call><name>gapfill_column_state_create</name><argument_list>(<argument><expr><name>LOCF_COLUMN</name></expr></argument>, <argument><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupledesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>gapfill_locf_initialize</name><argument_list>(<argument><expr><operator>(</operator><name>GapFillLocfColumnState</name> <operator>*</operator><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>columns</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
										<argument><expr><name>state</name></expr></argument>,
										<argument><expr><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><call><name>get_func_name</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>FuncExpr</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>funcid</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>GAPFILL_INTERPOLATE_FUNCTION</name></expr></argument>,
						<argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>columns</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator>
					<call><name>gapfill_column_state_create</name><argument_list>(<argument><expr><name>INTERPOLATE_COLUMN</name></expr></argument>,
												<argument><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupledesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>gapfill_interpolate_initialize</name><argument_list>(<argument><expr><operator>(</operator><name>GapFillInterpolateColumnState</name> <operator>*</operator><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>columns</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
											   <argument><expr><name>state</name></expr></argument>,
											   <argument><expr><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * any column that does not have an aggregation function and is not
		 * an explicit GROUP BY column has to be derived from a GROUP BY
		 * column so we treat those similar to GROUP BY column for gapfill
		 * purposes.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>contain_agg_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>contain_var_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>columns</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator>
				<call><name>gapfill_column_state_create</name><argument_list>(<argument><expr><name>DERIVED_COLUMN</name></expr></argument>, <argument><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupledesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>multigroup</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>groups_initialized</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* column with no special action from gap fill node */</comment>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>columns</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator>
			<call><name>gapfill_column_state_create</name><argument_list>(<argument><expr><name>NULL_COLUMN</name></expr></argument>, <argument><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupledesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Create GapFillColumnState object, set proper type and fill in datatype information
 */</comment>
<function><type><specifier>static</specifier> <name>GapFillColumnState</name> <modifier>*</modifier></type>
<name>gapfill_column_state_create</name><parameter_list>(<parameter><decl><type><name>GapFillColumnType</name></type> <name>ctype</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typeid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>tce</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>tc_flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GapFillColumnState</name> <modifier>*</modifier></type><name>column</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>size</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>ctype</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>GROUP_COLUMN</name></expr>:</case>
			<expr_stmt><expr><name>tc_flags</name> <operator>|=</operator> <name>TYPECACHE_EQ_OPR</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>TS_FALLTHROUGH</name></expr>;</expr_stmt>
		<case>case <expr><name>DERIVED_COLUMN</name></expr>:</case>
			<expr_stmt><expr><name>size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GapFillGroupColumnState</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>LOCF_COLUMN</name></expr>:</case>
			<expr_stmt><expr><name>size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GapFillLocfColumnState</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>INTERPOLATE_COLUMN</name></expr>:</case>
			<expr_stmt><expr><name>size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GapFillInterpolateColumnState</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><name>size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GapFillColumnState</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
	<expr_stmt><expr><name>tce</name> <operator>=</operator> <call><name>lookup_type_cache</name><argument_list>(<argument><expr><name>typeid</name></expr></argument>, <argument><expr><name>tc_flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>column</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>ctype</name></name> <operator>=</operator> <name>ctype</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>typid</name></name> <operator>=</operator> <name><name>tce</name><operator>-&gt;</operator><name>type_id</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>typbyval</name></name> <operator>=</operator> <name><name>tce</name><operator>-&gt;</operator><name>typbyval</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>typlen</name></name> <operator>=</operator> <name><name>tce</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>ctype</name> <operator>==</operator> <name>GROUP_COLUMN</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>GapFillGroupColumnState</name> <modifier>*</modifier></type><name>gcolumn</name> <init>= <expr><operator>(</operator><name>GapFillGroupColumnState</name> <operator>*</operator><operator>)</operator> <name>column</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>eq_opr_func</name> <init>= <expr><call><name>get_opcode</name><argument_list>(<argument><expr><name><name>tce</name><operator>-&gt;</operator><name>eq_opr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>fmgr_info_cxt</name><argument_list>(<argument><expr><name>eq_opr_func</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>gcolumn</name><operator>-&gt;</operator><name>eq_func</name></name></expr></argument>, <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>gcolumn</name><operator>-&gt;</operator><name>collation</name></name> <operator>=</operator> <name><name>tce</name><operator>-&gt;</operator><name>typcollation</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>column</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * check if the target entry is a GROUP BY column, we need
 * this check because ressortgroupref will be nonzero for
 * ORDER BY and GROUP BY columns but we are only interested
 * in actual GROUP BY columns
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>gapfill_is_group_column</name><parameter_list>(<parameter><decl><type><name>GapFillState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CustomScan</name> <modifier>*</modifier></type><name>cscan</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>CustomScan</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>csstate</name><operator>.</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>groups</name> <init>= <expr><call><name>lsecond</name><argument_list>(<argument><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_private</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>groups</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name> <operator>==</operator> <operator>(</operator><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>tleSortGroupRef</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Replace Aggref with const NULL
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>gapfill_aggref_mutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator>
			<call><name>makeConst</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>aggtype</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><call><name>expression_tree_mutator</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>gapfill_aggref_mutator</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Execute expression and return result of expression
 */</comment>
<function><type><name>Datum</name></type>
<name>gapfill_exec_expr</name><parameter_list>(<parameter><decl><type><name>GapFillState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>exprstate</name> <init>= <expr><call><name>ExecInitExpr</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>csstate</name><operator>.</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>exprcontext</name> <init>= <expr><call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>csstate</name><operator>.</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>exprcontext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>scanslot</name></name></expr>;</expr_stmt>

	<return>return <expr><call><name>ExecEvalExprSwitchContext</name><argument_list>(<argument><expr><name>exprstate</name></expr></argument>, <argument><expr><name>exprcontext</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Adjust attribute number of all Var nodes in an expression to have the
 * proper index into the gap filled tuple. This is necessary to make column
 * references in correlated subqueries in lookup queries work.
 */</comment>
<function><type><name>Expr</name> <modifier>*</modifier></type>
<name>gapfill_adjust_varnos</name><parameter_list>(<parameter><decl><type><name>GapFillState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc_var</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>lc_tle</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>vars</name> <init>= <expr><call><name>pull_var_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>CustomScan</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>csstate</name><operator>.</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>custom_scan_tlist</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc_var</argument>, <argument>vars</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc_var</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name> <argument_list>(<argument>lc_tle</argument>, <argument>tlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc_tle</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * subqueries in aggregate queries can only reference columns so
			 * we only need to look for targetlist toplevel column references
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>Var</name></expr></argument>, <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>varattno</name> <operator>==</operator> <name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block>
	<return>return <expr><name>expr</name></expr>;</return>
</block_content>}</block></function>
</unit>
