<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/timescaledb/tsl/src/chunk.c"><comment type="block">/*
 * This file and its contents are licensed under the Timescale License.
 * Please see the included NOTICE for copyright information and
 * LICENSE-TIMESCALE for a copy of the license.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postgres.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/htup_details.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/xact.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_foreign_server.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_foreign_table.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/dependency.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/namespace.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;foreign/foreign.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/makefuncs.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/parsenodes.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;storage/lmgr.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/acl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/builtins.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/syscache.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/inval.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/tuplestore.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/palloc.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/memutils.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/snapmgr.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;executor/executor.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;parser/parse_func.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;storage/lmgr.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;funcapi.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;miscadmin.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fmgr.h&gt;</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;funcapi.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;compat/compat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;extension.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errors.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;error_utils.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;hypertable_cache.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hypercube.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"chunk.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"chunk_api.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"data_node.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"deparse.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"debug_point.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dist_util.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"remote/dist_commands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ts_catalog/chunk_data_node.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils.h"</cpp:file></cpp:include>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>chunk_match_data_node_by_server</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ForeignServer</name> <modifier>*</modifier></type><name>server</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>server_found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>chunk-&gt;data_nodes</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ChunkDataNode</name> <modifier>*</modifier></type><name>cdn</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>cdn</name><operator>-&gt;</operator><name>foreign_server_oid</name></name> <operator>==</operator> <name><name>server</name><operator>-&gt;</operator><name>serverid</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>server_found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>server_found</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>chunk_set_foreign_server</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ForeignServer</name> <modifier>*</modifier></type><name>new_server</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type> <name>ftrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>copy</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name><name>values</name><index>[<expr><name>Natts_pg_foreign_table</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name><name>nulls</name><index>[<expr><name>Natts_pg_foreign_table</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CatalogSecurityContext</name></type> <name>sec_ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>old_server_id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type> <name>updated</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>chunk_match_data_node_by_server</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>new_server</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"chunk \"%s\" does not exist on data node \"%s\""</literal></expr></argument>,
						<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>table_id</name></name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name><name>new_server</name><operator>-&gt;</operator><name>servername</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>FOREIGNTABLEREL</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>table_id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"chunk \"%s\" is not a foreign table"</literal></expr></argument>, <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>table_id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>ftrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>ForeignTableRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>ftrel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>old_server_id</name> <operator>=</operator>
		<call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_pg_foreign_table_ftserver</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>old_server_id</name> <operator>==</operator> <name><name>new_server</name><operator>-&gt;</operator><name>serverid</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>ftrel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_pg_foreign_table_ftserver</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
		<call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>new_server</name><operator>-&gt;</operator><name>serverid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>copy</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>ftrel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ts_catalog_database_info_become_owner</name><argument_list>(<argument><expr><call><name>ts_catalog_database_info_get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_catalog_update_tid</name><argument_list>(<argument><expr><name>ftrel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_catalog_restore_user</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>ftrel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* invalidate foreign table cache */</comment>
	<expr_stmt><expr><call><name>CacheInvalidateRelcacheByRelid</name><argument_list>(<argument><expr><name>ForeignTableRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* update dependencies between foreign table and foreign server */</comment>
	<expr_stmt><expr><name>updated</name> <operator>=</operator> <call><name>changeDependencyFor</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
								  <argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>table_id</name></name></expr></argument>,
								  <argument><expr><name>ForeignServerRelationId</name></expr></argument>,
								  <argument><expr><name>old_server_id</name></expr></argument>,
								  <argument><expr><name><name>new_server</name><operator>-&gt;</operator><name>serverid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>updated</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not update data node for chunk \"%s\""</literal></expr></argument>, <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>table_id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* make changes visible */</comment>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Change the data node used to query a chunk.
 *
 * Either switch "away" from using the given data node or switch to using it
 * (depending on the "available" parameter). The function will only switch
 * back to using the data node if it is the determined primary/default data
 * node for the chunk according to the partitioning configuration.
 *
 * Return true if the chunk's data node was changed or no change was
 * needed. Return false if a change should have been made but wasn't possible
 * (due to, e.g., lack of replica chunks).
 */</comment>
<function><type><name>bool</name></type>
<name>chunk_update_foreign_server_if_needed</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>data_node_id</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>available</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ForeignTable</name> <modifier>*</modifier></type><name>foreign_table</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ForeignServer</name> <modifier>*</modifier></type><name>server</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>should_switch_data_node</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>foreign_table</name> <operator>=</operator> <call><name>GetForeignTable</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>table_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Cannot switch to other data node if only one or none assigned */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>data_nodes</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Nothing to do if the chunk table already has the requested data node set */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><name>available</name> <operator>&amp;&amp;</operator> <name>data_node_id</name> <operator>!=</operator> <name><name>foreign_table</name><operator>-&gt;</operator><name>serverid</name></name><operator>)</operator> <operator>||</operator>
		<operator>(</operator><name>available</name> <operator>&amp;&amp;</operator> <name>data_node_id</name> <operator>==</operator> <name><name>foreign_table</name><operator>-&gt;</operator><name>serverid</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>available</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Switch to using the given data node, but only on chunks where the
		 * given node is the "default" according to partitioning */</comment>
		<decl_stmt><decl><type><name>Cache</name> <modifier>*</modifier></type><name>htcache</name> <init>= <expr><call><name>ts_hypertable_cache_pin</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>Hypertable</name> <modifier>*</modifier></type><name>ht</name> <init>=
			<expr><call><name>ts_hypertable_cache_get_entry</name><argument_list>(<argument><expr><name>htcache</name></expr></argument>, <argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>hypertable_relid</name></name></expr></argument>, <argument><expr><name>CACHE_FLAG_NONE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type><name>dim</name> <init>= <expr><call><name>hyperspace_get_closed_dimension</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>space</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>dim</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* For space-partitioned tables, use the current partitioning
			 * configuration in that dimension (dimension partition) as a
			 * template for picking the query data node */</comment>
			<decl_stmt><decl><type><specifier>const</specifier> <name>DimensionSlice</name> <modifier>*</modifier></type><name>slice</name> <init>=
				<expr><call><name>ts_hypercube_get_slice_by_dimension_id</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>cube</name></name></expr></argument>, <argument><expr><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>dim</name><operator>-&gt;</operator><name>dimension_partitions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>dim</name><operator>-&gt;</operator><name>dimension_partitions</name><operator>-&gt;</operator><name>num_partitions</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><specifier>const</specifier> <name>DimensionPartition</name> <modifier>*</modifier></type><name>dp</name> <init>= <expr><name><name>dim</name><operator>-&gt;</operator><name>dimension_partitions</name><operator>-&gt;</operator><name>partitions</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* Match the chunk with the dimension partition. Count as a
				 * match if the start of chunk is within the range of the
				 * partition. This captures both the case when the chunk
				 * aligns perfectly with the partition and when it is bigger
				 * or smaller (due to a previous partitioning change). */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>slice</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>range_start</name></name> <operator>&gt;=</operator> <name><name>dp</name><operator>-&gt;</operator><name>range_start</name></name> <operator>&amp;&amp;</operator>
					<name><name>slice</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>range_start</name></name> <operator>&lt;=</operator> <name><name>dp</name><operator>-&gt;</operator><name>range_end</name></name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

					<comment type="block">/* Use the data node for queries if it is the first
					 * available data node in the partition's list (i.e., the
					 * default choice) */</comment>
					<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>dp-&gt;data_nodes</argument>)</argument_list></macro>
					<block>{<block_content>
						<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>node_name</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
						<expr_stmt><expr><name>server</name> <operator>=</operator> <call><name>GetForeignServerByName</name><argument_list>(<argument><expr><name>node_name</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<if_stmt><if>if <condition>(<expr><call><name>ts_data_node_is_available_by_server</name><argument_list>(<argument><expr><name>server</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>should_switch_data_node</name> <operator>=</operator> <operator>(</operator><name><name>server</name><operator>-&gt;</operator><name>serverid</name></name> <operator>==</operator> <name>data_node_id</name><operator>)</operator></expr>;</expr_stmt>
							<break>break;</break>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* For hypertables without a space partition, use the data node
			 * assignment logic to figure out whether to use the data node as
			 * query data node. The "default" query data node is the first in
			 * the list. The chunk assign logic only returns available data
			 * nodes. */</comment>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>datanodes</name> <init>= <expr><call><name>ts_hypertable_assign_chunk_data_nodes</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>cube</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>node_name</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name>datanodes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>server</name> <operator>=</operator> <call><name>GetForeignServerByName</name><argument_list>(<argument><expr><name>node_name</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>server</name><operator>-&gt;</operator><name>serverid</name></name> <operator>==</operator> <name>data_node_id</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>should_switch_data_node</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>htcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Switch "away" from using the given data node. Pick the first
		 * "available" data node referenced by the chunk */</comment>
		<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>chunk-&gt;data_nodes</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>ChunkDataNode</name> <modifier>*</modifier></type><name>cdn</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>cdn</name><operator>-&gt;</operator><name>foreign_server_oid</name></name> <operator>!=</operator> <name>data_node_id</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>server</name> <operator>=</operator> <call><name>GetForeignServer</name><argument_list>(<argument><expr><name><name>cdn</name><operator>-&gt;</operator><name>foreign_server_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>ts_data_node_is_available_by_server</name><argument_list>(<argument><expr><name>server</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>should_switch_data_node</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>should_switch_data_node</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>server</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>chunk_set_foreign_server</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>server</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>should_switch_data_node</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>chunk_set_default_data_node</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>chunk_relid</name> <init>= <expr><ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>InvalidOid</name></expr> </then><else>: <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>node_name</name> <init>= <expr><ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ForeignServer</name> <modifier>*</modifier></type><name>server</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>chunk_relid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid chunk: cannot be NULL"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>chunk</name> <operator>=</operator> <call><name>ts_chunk_get_by_relid</name><argument_list>(<argument><expr><name>chunk_relid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>chunk</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TS_CHUNK_NOT_EXIST</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation \"%s\" is not a chunk"</literal></expr></argument>, <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>chunk_relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ts_hypertable_permissions_check</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>hypertable_relid</name></name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>server</name> <operator>=</operator> <call><name>data_node_get_foreign_server</name><argument_list>(<argument><expr><name>node_name</name></expr></argument>, <argument><expr><name>ACL_USAGE</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>server</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>chunk_set_foreign_server</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>server</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Invoke drop_chunks via fmgr so that the call can be deparsed and sent to
 * remote data nodes.
 *
 * Given that drop_chunks is an SRF, and has pseudo parameter types, we need
 * to provide a FuncExpr with type information for the deparser.
 *
 * Returns the number of dropped chunks.
 */</comment>
<function><type><name>int</name></type>
<name>chunk_invoke_drop_chunks</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>older_than</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>older_than_type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>fexpr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>num_results</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SetExprState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>restype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>func_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name><name>argarr</name><index>[<expr><name>DROP_CHUNKS_NARGS</name></expr>]</index></name> <init>= <expr><block>{
		<expr><call><name>makeConst</name><argument_list>(<argument><expr><name>REGCLASSOID</name></expr></argument>,
				  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
				  <argument><expr><name>InvalidOid</name></expr></argument>,
				  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></sizeof></expr></argument>,
				  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>,
				  <argument><expr><name>false</name></expr></argument>,
				  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>makeConst</name><argument_list>(<argument><expr><name>older_than_type</name></expr></argument>,
				  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
				  <argument><expr><name>InvalidOid</name></expr></argument>,
				  <argument><expr><call><name>get_typlen</name><argument_list>(<argument><expr><name>older_than_type</name></expr></argument>)</argument_list></call></expr></argument>,
				  <argument><expr><name>older_than</name></expr></argument>,
				  <argument><expr><name>false</name></expr></argument>,
				  <argument><expr><call><name>get_typbyval</name><argument_list>(<argument><expr><name>older_than_type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>makeNullConst</name><argument_list>(<argument><expr><name>older_than_type</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>castNode</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><call><name>makeBoolConst</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
	}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name><name>type_id</name><index>[<expr><name>DROP_CHUNKS_NARGS</name></expr>]</index></name> <init>= <expr><block>{ <expr><name>REGCLASSOID</name></expr>, <expr><name>ANYOID</name></expr>, <expr><name>ANYOID</name></expr>, <expr><name>BOOLOID</name></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>schema_name</name> <init>= <expr><call><name>ts_extension_schema_name</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier><specifier>const</specifier></type> <name>fqn</name> <init>= <expr><call><name>list_make2</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>schema_name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>DROP_CHUNKS_FUNCNAME</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>StaticAssertStmt</name><argument_list>(<argument><expr><call><name>lengthof</name><argument_list>(<argument><expr><name>type_id</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>argarr</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><literal type="string">"argarr and type_id should have matching lengths"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>func_oid</name> <operator>=</operator> <call><name>LookupFuncName</name><argument_list>(<argument><expr><name>fqn</name></expr></argument>, <argument><expr><call><name>lengthof</name><argument_list>(<argument><expr><name>type_id</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>type_id</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>func_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* LookupFuncName should not return an invalid OID */</comment>

	<comment type="block">/* Prepare the function expr with argument list */</comment>
	<expr_stmt><expr><call><name>get_func_result_type</name><argument_list>(<argument><expr><name>func_oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>restype</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>argarr</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name><name>argarr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><name>fexpr</name> <operator>=</operator> <call><name>makeFuncExpr</name><argument_list>(<argument><expr><name>func_oid</name></expr></argument>, <argument><expr><name>restype</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>COERCE_EXPLICIT_CALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fexpr</name><operator>-&gt;</operator><name>funcretset</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/* Execute the SRF */</comment>
	<expr_stmt><expr><name>estate</name> <operator>=</operator> <call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>econtext</name> <operator>=</operator> <call><name>CreateExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>ExecInitFunctionResultSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fexpr</name><operator>-&gt;</operator><name>xpr</name></name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ExprDoneCond</name></type> <name>isdone</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>isnull</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ExecMakeFunctionResultSet</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isdone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>isdone</name> <operator>==</operator> <name>ExprEndResult</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>num_results</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/* Cleanup */</comment>
	<expr_stmt><expr><call><name>FreeExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>num_results</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>chunk_is_distributed</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>chunk</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>chunk_create_replica_table</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>chunk_relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>data_node_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ForeignServer</name> <modifier>*</modifier></type><name>server</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cache</name> <modifier>*</modifier></type><name>hcache</name> <init>= <expr><call><name>ts_hypertable_cache_pin</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>TS_PREVENT_FUNC_IF_READ_ONLY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>GETARG_NOTNULL_OID</name><argument_list>(<argument><expr><name>chunk_relid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"chunk"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>GETARG_NOTNULL_NULLABLE</name><argument_list>(<argument><expr><name>data_node_name</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"data node name"</literal></expr></argument>, <argument><expr><name>CSTRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>chunk</name> <operator>=</operator> <call><name>ts_chunk_get_by_relid</name><argument_list>(<argument><expr><name>chunk_relid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>chunk</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>rel_name</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>chunk_relid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>rel_name</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"oid \"%u\" is not a chunk"</literal></expr></argument>, <argument><expr><name>chunk_relid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation \"%s\" is not a chunk"</literal></expr></argument>, <argument><expr><name>rel_name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>chunk_is_distributed</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"chunk \"%s\" doesn't belong to a distributed hypertable"</literal></expr></argument>,
						<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>chunk_relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>ht</name> <operator>=</operator> <call><name>ts_hypertable_cache_get_entry</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>, <argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>hypertable_relid</name></name></expr></argument>, <argument><expr><name>CACHE_FLAG_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_hypertable_permissions_check</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check the given data node exists */</comment>
	<expr_stmt><expr><name>server</name> <operator>=</operator> <call><name>data_node_get_foreign_server</name><argument_list>(<argument><expr><name>data_node_name</name></expr></argument>, <argument><expr><name>ACL_USAGE</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Find if hypertable is attached to the data node and return an error otherwise */</comment>
	<expr_stmt><expr><call><name>data_node_hypertable_get_by_node_name</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>data_node_name</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>chunk_match_data_node_by_server</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>server</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"chunk \"%s\" already exists on data node \"%s\""</literal></expr></argument>,
						<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>chunk_relid</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>data_node_name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>chunk_api_call_create_empty_chunk_table</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>data_node_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * chunk_drop_replica:
 *
 * This function drops a chunk on a specified data node. It then
 * removes the metadata about the association of the chunk to this
 * data node on the access node.
 */</comment>
<function><type><name>Datum</name></type>
<name>chunk_drop_replica</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>chunk_relid</name> <init>= <expr><ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>InvalidOid</name></expr> </then><else>: <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>node_name</name> <init>= <expr><ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><call><name>PG_GETARG_NAME</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ForeignServer</name> <modifier>*</modifier></type><name>server</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>TS_PREVENT_FUNC_IF_READ_ONLY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>chunk_relid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid chunk relation"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>chunk</name> <operator>=</operator> <call><name>ts_chunk_get_by_relid</name><argument_list>(<argument><expr><name>chunk_relid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>chunk</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid chunk relation"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Object with OID %u is not a chunk relation"</literal></expr></argument>, <argument><expr><name>chunk_relid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* It has to be a foreign table chunk */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>chunk</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a valid remote chunk"</literal></expr></argument>, <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>chunk_relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>server</name> <operator>=</operator> <call><name>data_node_get_foreign_server</name><argument_list>(<argument><expr><name>node_name</name></expr></argument>, <argument><expr><name>ACL_USAGE</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>server</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Early abort on missing permissions */</comment>
	<expr_stmt><expr><call><name>ts_hypertable_permissions_check</name><argument_list>(<argument><expr><name>chunk_relid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ts_chunk_has_data_node</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>node_name</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"chunk \"%s\" does not exist on data node \"%s\""</literal></expr></argument>,
						<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>chunk_relid</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>node_name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * There should be at least one surviving replica after the deletion here.
	 *
	 * We could fetch the corresponding hypertable and check its
	 * replication_factor. But the user of this function is using it
	 * to move chunk from one data node to another and is well aware of
	 * the replication_factor requirements
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>data_nodes</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TS_INSUFFICIENT_NUM_DATA_NODES</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot drop the last chunk replica"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Dropping the last chunk replica could lead to data loss."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>chunk_api_call_chunk_drop_replica</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>node_name</name></expr></argument>, <argument><expr><name><name>server</name><operator>-&gt;</operator><name>serverid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Data in a frozen chunk cannot be modified. So any operation
 * that rewrites data for a frozen chunk will be blocked.
 * Note that a frozen chunk can still be dropped.
 */</comment>
<function><type><name>Datum</name></type>
<name>chunk_freeze_chunk</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>chunk_relid</name> <init>= <expr><ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>InvalidOid</name></expr> </then><else>: <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>TS_PREVENT_FUNC_IF_READ_ONLY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name> <init>= <expr><call><name>ts_chunk_get_by_relid</name><argument_list>(<argument><expr><name>chunk_relid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>chunk</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>chunk</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"operation not supported on distributed chunk or foreign table \"%s\""</literal></expr></argument>,
						<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>chunk_relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>ts_chunk_is_frozen</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* get Share lock. will wait for other concurrent transactions that are
	 * modifying the chunk. Does not block SELECTs on the chunk.
	 * Does not block other DDL on the chunk table.
	 */</comment>
	<expr_stmt><expr><call><name>DEBUG_WAITPOINT</name><argument_list>(<argument><expr><literal type="string">"freeze_chunk_before_lock"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name>chunk_relid</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><call><name>ts_chunk_set_frozen</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>chunk_unfreeze_chunk</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>chunk_relid</name> <init>= <expr><ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>InvalidOid</name></expr> </then><else>: <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>TS_PREVENT_FUNC_IF_READ_ONLY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name> <init>= <expr><call><name>ts_chunk_get_by_relid</name><argument_list>(<argument><expr><name>chunk_relid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>chunk</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>chunk</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"operation not supported on distributed chunk or foreign table \"%s\""</literal></expr></argument>,
						<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>chunk_relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ts_chunk_is_frozen</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* This is a previously frozen chunk. Only selects are permitted on this chunk.
	 * This changes the status in the catalog to allow previously blocked operations.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><call><name>ts_chunk_unset_frozen</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>chunk_id_list_create</name><parameter_list>(<parameter><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>array</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* create a sorted list of chunk ids from array */</comment>
	<decl_stmt><decl><type><name>ArrayIterator</name></type> <name>it</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>id_datum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>id_list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>isnull</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>it</name> <operator>=</operator> <call><name>array_create_iterator</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><call><name>array_iterate</name><argument_list>(<argument><expr><name>it</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>id_datum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"chunks array arguments cannot be NULL"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>id_list</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>id_list</name></expr></argument>, <argument><expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>id_datum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>array_free_iterator</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>list_sort_compat</name><argument_list>(<argument><expr><name>id_list</name></expr></argument>, <argument><expr><name>list_int_cmp_compat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>id_list</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>chunk_id_list_exclusive_right_merge_join</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>an_list</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>dn_list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * merge join two sorted list and return only values which exclusively
	 * exists in the right target (dn_list list)
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ListCell</name> <modifier>*</modifier></type><name>l</name> <init>= <expr><call><name>list_head</name><argument_list>(<argument><expr><name>an_list</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ListCell</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><call><name>list_head</name><argument_list>(<argument><expr><name>dn_list</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>l</name> <operator>&amp;&amp;</operator> <name>r</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>compare</name> <init>= <expr><call><name>list_int_cmp_compat</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>compare</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* l = r */</comment>
				<expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>lnext_compat</name><argument_list>(<argument><expr><name>an_list</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>lnext_compat</name><argument_list>(<argument><expr><name>dn_list</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>compare</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* l &lt; r */</comment>
				<comment type="block">/* chunk exists only on the access node */</comment>
				<expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>lnext_compat</name><argument_list>(<argument><expr><name>an_list</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* l &gt; r */</comment>
				<comment type="block">/* chunk exists only on the data node */</comment>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>lnext_compat</name><argument_list>(<argument><expr><name>dn_list</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>l</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* chunk exists only on the access node */</comment>
			<expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>lnext_compat</name><argument_list>(<argument><expr><name>an_list</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>r</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* chunk exists only on the data node */</comment>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>lnext_compat</name><argument_list>(<argument><expr><name>dn_list</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<break>break;</break>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * chunk_drop_stale_chunks:
 *
 * This function drops chunks on a specified data node if those chunks are
 * not known by the access node (chunks array).
 *
 * This function is intended to be used on the access node and data node.
 */</comment>
<function><type><name>void</name></type>
<name>ts_chunk_drop_stale_chunks</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>node_name</name></decl></parameter>, <parameter><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>chunks_array</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DistUtilMembershipStatus</name></type> <name>membership</name></decl>;</decl_stmt>

	<comment type="block">/* execute according to the node membership */</comment>
	<expr_stmt><expr><name>membership</name> <operator>=</operator> <call><name>dist_util_membership</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>membership</name> <operator>==</operator> <name>DIST_MEMBER_ACCESS_NODE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>StringInfo</name></type> <name>cmd</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>node_name</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"node_name argument cannot be NULL"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>chunks_array</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"chunks argument cannot be used on the access node"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* get an exclusive lock on the chunks catalog table to prevent new chunk
		 * creation during this operation */</comment>
		<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><call><name>ts_catalog_get</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name><name>tables</name><index>[<expr><name>CHUNK</name></expr>]</index></name><operator>.</operator><name>id</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* generate query to execute drop_stale_chunks() on the data node */</comment>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="string">"SELECT _timescaledb_internal.drop_stale_chunks(NULL, array["</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* scan for chunks that reference the given data node */</comment>
		<decl_stmt><decl><type><name>ScanIterator</name></type> <name>it</name> <init>= <expr><call><name>ts_chunk_data_nodes_scan_iterator_create</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ts_chunk_data_nodes_scan_iterator_set_node_name</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><name>node_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>ts_scanner_foreach</name><argument_list>(<argument>&amp;it</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><call><name>ts_scan_iterator_slot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name> <name>PG_USED_FOR_ASSERTS_ONLY</name></type> <name>isnull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int32</name></type> <name>node_chunk_id</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>node_chunk_id</name> <operator>=</operator>
				<call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>slot_getattr</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>Anum_chunk_data_node_node_chunk_id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="string">"%s%d"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>first</name></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">","</literal></expr></else></ternary></expr></argument>, <argument><expr><name>node_chunk_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>ts_scan_iterator_close</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="string">"]::integer[])"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* execute command on the data node */</comment>
		<expr_stmt><expr><call><name>ts_dist_cmd_run_on_data_nodes</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>node_name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>membership</name> <operator>==</operator> <name>DIST_MEMBER_DATA_NODE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>an_chunk_id_list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>dn_chunk_id_list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>dn_chunk_id_list_stale</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Cache</name> <modifier>*</modifier></type><name>htcache</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>node_name</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"node_name argument cannot be used on the data node"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>chunks_array</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"chunks argument cannot be NULL"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* get a sorted list of chunk ids from the supplied chunks id argument array */</comment>
		<expr_stmt><expr><name>an_chunk_id_list</name> <operator>=</operator> <call><name>chunk_id_list_create</name><argument_list>(<argument><expr><name>chunks_array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* get a local sorted list of chunk ids */</comment>
		<expr_stmt><expr><name>dn_chunk_id_list</name> <operator>=</operator> <call><name>ts_chunk_get_all_chunk_ids</name><argument_list>(<argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* merge join two sorted list and get chunk ids which exists locally */</comment>
		<expr_stmt><expr><name>dn_chunk_id_list_stale</name> <operator>=</operator>
			<call><name>chunk_id_list_exclusive_right_merge_join</name><argument_list>(<argument><expr><name>an_chunk_id_list</name></expr></argument>, <argument><expr><name>dn_chunk_id_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* drop stale chunks */</comment>
		<expr_stmt><expr><name>htcache</name> <operator>=</operator> <call><name>ts_hypertable_cache_pin</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>dn_chunk_id_list_stale</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>Chunk</name> <modifier>*</modifier></type><name>chunk</name> <init>= <expr><call><name>ts_chunk_get_by_id</name><argument_list>(<argument><expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl>;</decl_stmt>

			<comment type="block">/* chunk might be already dropped by previous drop, if the chunk was compressed */</comment>
			<if_stmt><if>if <condition>(<expr><name>chunk</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/* ensure that we drop only chunks related to distributed hypertables */</comment>
			<expr_stmt><expr><name>ht</name> <operator>=</operator> <call><name>ts_hypertable_cache_get_entry</name><argument_list>(<argument><expr><name>htcache</name></expr></argument>, <argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>hypertable_relid</name></name></expr></argument>, <argument><expr><name>CACHE_FLAG_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>hypertable_is_distributed_member</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ts_chunk_drop</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>DROP_RESTRICT</name></expr></argument>, <argument><expr><name>DEBUG1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>htcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"current server is not an access node or data node"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>chunk_drop_stale_chunks</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>node_name</name> <init>= <expr><ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><call><name>PG_GETARG_NAME</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>chunks_array</name> <init>= <expr><ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>TS_PREVENT_FUNC_IF_READ_ONLY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ts_chunk_drop_stale_chunks</name><argument_list>(<argument><expr><name>node_name</name></expr></argument>, <argument><expr><name>chunks_array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<comment type="block">/*
 * Update and refresh the DN list for a given chunk. We remove metadata for this chunk
 * for unavailable DNs
 */</comment>
<function><type><name>void</name></type>
<name>chunk_update_stale_metadata</name><parameter_list>(<parameter><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>new_chunk</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>chunk_data_nodes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>serveroids</name> <init>= <expr><name>NIL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>removeoids</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ChunkDataNode</name> <modifier>*</modifier></type><name>cdn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* check that at least one data node is available for this chunk on the AN */</comment>
	<if_stmt><if>if <condition>(<expr><name>chunk_data_nodes</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TS_INSUFFICIENT_NUM_DATA_NODES</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"insufficient number of available data nodes"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				  <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Increase the number of available data nodes on hypertable "</literal>
						  <literal type="string">"\"%s\"."</literal></expr></argument>,
						  <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>new_chunk</name><operator>-&gt;</operator><name>hypertable_relid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>chunk_data_nodes</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>cdn</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>serveroids</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>serveroids</name></expr></argument>, <argument><expr><name><name>cdn</name><operator>-&gt;</operator><name>foreign_server_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>new_chunk-&gt;data_nodes</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>cdn</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * check if this DN is a part of chunk_data_nodes. If not
		 * found in chunk_data_nodes, then we need to remove this
		 * chunk id to node name mapping and also update the primary
		 * foreign server if necessary. It's possible that this metadata
		 * might have been already cleared earlier in which case the
		 * data_nodes list for the chunk will be the same as the
		 * "serveroids" list and no unnecesary metadata update function
		 * calls will occur.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_member_oid</name><argument_list>(<argument><expr><name>serveroids</name></expr></argument>, <argument><expr><name><name>cdn</name><operator>-&gt;</operator><name>foreign_server_oid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>chunk_update_foreign_server_if_needed</name><argument_list>(<argument><expr><name>new_chunk</name></expr></argument>, <argument><expr><name><name>cdn</name><operator>-&gt;</operator><name>foreign_server_oid</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ts_chunk_data_node_delete_by_chunk_id_and_node_name</name><argument_list>(<argument><expr><name><name>cdn</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>chunk_id</name></name></expr></argument>,
																<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>cdn</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>node_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>removeoids</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>removeoids</name></expr></argument>, <argument><expr><name><name>cdn</name><operator>-&gt;</operator><name>foreign_server_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* remove entries from new_chunk-&gt;data_nodes matching removeoids */</comment>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>removeoids</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>serveroid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* this contrived code to ensure PG12+ compatible in-place list delete */</comment>
		<macro><name>foreach</name> <argument_list>(<argument>l</argument>, <argument>new_chunk-&gt;data_nodes</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>cdn</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>cdn</name><operator>-&gt;</operator><name>foreign_server_oid</name></name> <operator>==</operator> <name>serveroid</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>new_chunk</name><operator>-&gt;</operator><name>data_nodes</name></name> <operator>=</operator> <call><name>list_delete_ptr</name><argument_list>(<argument><expr><name><name>new_chunk</name><operator>-&gt;</operator><name>data_nodes</name></name></expr></argument>, <argument><expr><name>cdn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block>
</block_content>}</block></function>
</unit>
