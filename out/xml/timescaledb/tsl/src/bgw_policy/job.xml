<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/timescaledb/tsl/src/bgw_policy/job.c"><comment type="block">/*
 * This file and its contents are licensed under the Timescale License.
 * Please see the included NOTICE for copyright information and
 * LICENSE-TIMESCALE for a copy of the license.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postgres.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/xact.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/namespace.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_type.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;funcapi.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;hypertable_cache.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/makefuncs.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/pg_list.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/primnodes.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;parser/parse_func.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;parser/parser.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;tcop/pquery.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/builtins.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/lsyscache.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/portal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/syscache.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/snapmgr.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/timestamp.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;extension.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"bgw/timer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"bgw/job.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"bgw/job_stat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"bgw_policy/chunk_stats.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"bgw_policy/compression_api.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"bgw_policy/continuous_aggregate_api.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"bgw_policy/policy_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"bgw_policy/reorder_api.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"bgw_policy/retention_api.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compat/compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compression/api.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"continuous_aggs/materialize.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"continuous_aggs/refresh.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ts_catalog/continuous_agg.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tsl/src/chunk.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"errors.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"job.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"chunk.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dimension.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dimension_slice.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dimension_vector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"errors.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"job.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"reorder.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REORDER_SKIP_RECENT_DIM_SLICES_N</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>log_retention_boundary</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>, <parameter><decl><type><name>PolicyRetentionData</name> <modifier>*</modifier></type><name>policy_data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>message</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>boundary</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>outfuncid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>isvarlena</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name><name>policy_data</name><operator>-&gt;</operator><name>boundary_type</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>outfuncid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isvarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>relname</name> <operator>=</operator> <call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>policy_data</name><operator>-&gt;</operator><name>object_relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>boundary</name> <operator>=</operator> <name><name>policy_data</name><operator>-&gt;</operator><name>boundary</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>outfuncid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
			 <argument><expr><literal type="string">"%s \"%s\": dropping data older than %s"</literal></expr></argument>,
			 <argument><expr><name>message</name></expr></argument>,
			 <argument><expr><name>relname</name></expr></argument>,
			 <argument><expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>OidFunctionCall1</name><argument_list>(<argument><expr><name>outfuncid</name></expr></argument>, <argument><expr><name>boundary</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>enable_fast_restart</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>job_id</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>job_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BgwJobStat</name> <modifier>*</modifier></type><name>job_stat</name> <init>= <expr><call><name>ts_bgw_job_stat_find</name><argument_list>(<argument><expr><name>job_id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>job_stat</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* job might not have a valid last_start if it was not
		 * run by the bgw framework.
		 */</comment>
		<expr_stmt><expr><call><name>ts_bgw_job_stat_set_next_start</name><argument_list>(<argument><expr><name>job_id</name></expr></argument>,
									   <argument><expr><ternary><condition><expr><name><name>job_stat</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>last_start</name></name> <operator>!=</operator> <name>DT_NOBEGIN</name></expr> ?</condition><then>
										   <expr><name><name>job_stat</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>last_start</name></name></expr> </then><else>:
										   <expr><call><name>GetCurrentTransactionStartTimestamp</name><argument_list>()</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ts_bgw_job_stat_upsert_next_start</name><argument_list>(<argument><expr><name>job_id</name></expr></argument>, <argument><expr><call><name>GetCurrentTransactionStartTimestamp</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"the %s job is scheduled to run again immediately"</literal></expr></argument>, <argument><expr><name>job_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Returns the ID of a chunk to reorder. Eligible chunks must be at least the
 * 3rd newest chunk in the hypertable (not entirely exact because we use the number
 * of dimension slices as a proxy for the number of chunks),
 * not compressed, not dropped and hasn't been reordered recently.
 * For this version of automatic reordering, "not reordered
 * recently" means the chunk has not been reordered at all. This information
 * is available in the bgw_policy_chunk_stats metadata table.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>get_chunk_id_to_reorder</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>job_id</name></decl></parameter>, <parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type><name>time_dimension</name> <init>= <expr><call><name>hyperspace_get_open_dimension</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>space</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>DimensionSlice</name> <modifier>*</modifier></type><name>nth_dimension</name> <init>=
		<expr><call><name>ts_dimension_slice_nth_latest_slice</name><argument_list>(<argument><expr><name><name>time_dimension</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>,
											<argument><expr><name>REORDER_SKIP_RECENT_DIM_SLICES_N</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>nth_dimension</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>time_dimension</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>ts_dimension_slice_oldest_valid_chunk_for_reorder</name><argument_list>(<argument><expr><name>job_id</name></expr></argument>,
															 <argument><expr><name><name>time_dimension</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>,
															 <argument><expr><name>BTLessEqualStrategyNumber</name></expr></argument>,
															 <argument><expr><name><name>nth_dimension</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>range_start</name></name></expr></argument>,
															 <argument><expr><name>InvalidStrategy</name></expr></argument>,
															 <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * returns now() - window as partitioning type datum
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>get_window_boundary</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type><name>dim</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Jsonb</name> <modifier>*</modifier></type><name>config</name></decl></parameter>, <parameter><function_decl><type><name>int64</name></type> (<modifier>*</modifier><name>int_getter</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Jsonb</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
					<parameter><function_decl><type><name>Interval</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>interval_getter</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Jsonb</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter> )</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>partitioning_type</name> <init>= <expr><call><name>ts_dimension_get_partition_type</name><argument_list>(<argument><expr><name>dim</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IS_INTEGER_TYPE</name><argument_list>(<argument><expr><name>partitioning_type</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int64</name></type> <name>res</name></decl>, <decl><type ref="prev"/><name>lag</name> <init>= <expr><call><name>int_getter</name><argument_list>(<argument><expr><name>config</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>now_func</name> <init>= <expr><call><name>ts_get_integer_now_func</name><argument_list>(<argument><expr><name>dim</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>now_func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ts_sub_integer_from_now</name><argument_list>(<argument><expr><name>lag</name></expr></argument>, <argument><expr><name>partitioning_type</name></expr></argument>, <argument><expr><name>now_func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>Interval</name> <modifier>*</modifier></type><name>lag</name> <init>= <expr><call><name>interval_getter</name><argument_list>(<argument><expr><name>config</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<return>return <expr><call><name>subtract_interval_from_now</name><argument_list>(<argument><expr><name>lag</name></expr></argument>, <argument><expr><name>partitioning_type</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>get_chunk_to_recompress</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type><name>dim</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Jsonb</name> <modifier>*</modifier></type><name>config</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>partitioning_type</name> <init>= <expr><call><name>ts_dimension_get_partition_type</name><argument_list>(<argument><expr><name>dim</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StrategyNumber</name></type> <name>end_strategy</name> <init>= <expr><name>BTLessStrategyNumber</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>numchunks</name> <init>= <expr><call><name>policy_compression_get_maxchunks_per_job</name><argument_list>(<argument><expr><name>config</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Datum</name></type> <name>boundary</name> <init>= <expr><call><name>get_window_boundary</name><argument_list>(<argument><expr><name>dim</name></expr></argument>,
										 <argument><expr><name>config</name></expr></argument>,
										 <argument><expr><name>policy_recompression_get_recompress_after_int</name></expr></argument>,
										 <argument><expr><name>policy_recompression_get_recompress_after_interval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>ts_dimension_slice_get_chunkids_to_compress</name><argument_list>(<argument><expr><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>,
													   <argument><expr><name>InvalidStrategy</name></expr></argument>, <comment type="block">/*start_strategy*/</comment>
													   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,				<comment type="block">/*start_value*/</comment>
													   <argument><expr><name>end_strategy</name></expr></argument>,
													   <argument><expr><call><name>ts_time_value_to_internal</name><argument_list>(<argument><expr><name>boundary</name></expr></argument>,
																				 <argument><expr><name>partitioning_type</name></expr></argument>)</argument_list></call></expr></argument>,
													   <argument><expr><name>false</name></expr></argument>,
													   <argument><expr><name>true</name></expr></argument>,
													   <argument><expr><name>numchunks</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_valid_index</name><parameter_list>(<parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>index_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>index_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>idxtuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_index</name></type> <name>index_form</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>index_oid</name> <operator>=</operator>
		<call><name>get_relname_relid</name><argument_list>(<argument><expr><name>index_name</name></expr></argument>, <argument><expr><call><name>get_namespace_oid</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>schema_name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>idxtuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>index_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>idxtuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"reorder index not found"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The index \"%s\" could not be found"</literal></expr></argument>, <argument><expr><name>index_name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>index_form</name> <operator>=</operator> <operator>(</operator><name>Form_pg_index</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>idxtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>index_form</name><operator>-&gt;</operator><name>indrelid</name></name> <operator>!=</operator> <name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid reorder index"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"The reorder index must by an index on hypertable \"%s\"."</literal></expr></argument>,
						 <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>idxtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>policy_reorder_execute</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>job_id</name></decl></parameter>, <parameter><decl><type><name>Jsonb</name> <modifier>*</modifier></type><name>config</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>chunk_id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PolicyReorderData</name></type> <name>policy</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>policy_reorder_read_and_validate_config</name><argument_list>(<argument><expr><name>config</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>policy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Find a chunk to reorder in the selected hypertable */</comment>
	<expr_stmt><expr><name>chunk_id</name> <operator>=</operator> <call><name>get_chunk_id_to_reorder</name><argument_list>(<argument><expr><name>job_id</name></expr></argument>, <argument><expr><name><name>policy</name><operator>.</operator><name>hypertable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>chunk_id</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
			 <argument><expr><literal type="string">"no chunks need reordering for hypertable %s.%s"</literal></expr></argument>,
			 <argument><expr><name><name>policy</name><operator>.</operator><name>hypertable</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>schema_name</name><operator>.</operator><name>data</name></name></expr></argument>,
			 <argument><expr><name><name>policy</name><operator>.</operator><name>hypertable</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>table_name</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * NOTE: We pass the Oid of the hypertable's index, and the true reorder
	 * function should translate this to the Oid of the index on the specific
	 * chunk.
	 */</comment>
	<expr_stmt><expr><name>chunk</name> <operator>=</operator> <call><name>ts_chunk_get_by_id</name><argument_list>(<argument><expr><name>chunk_id</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"reordering chunk %s.%s"</literal></expr></argument>, <argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>schema_name</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>table_name</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>reorder_chunk</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>table_id</name></name></expr></argument>, <argument><expr><name><name>policy</name><operator>.</operator><name>index_relid</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
		 <argument><expr><literal type="string">"completed reordering chunk %s.%s"</literal></expr></argument>,
		 <argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>schema_name</name><operator>.</operator><name>data</name></name></expr></argument>,
		 <argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>table_name</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now update chunk_stats table */</comment>
	<expr_stmt><expr><call><name>ts_bgw_policy_chunk_stats_record_job_run</name><argument_list>(<argument><expr><name>job_id</name></expr></argument>, <argument><expr><name>chunk_id</name></expr></argument>, <argument><expr><call><name>ts_timer_get_current_timestamp</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>get_chunk_id_to_reorder</name><argument_list>(<argument><expr><name>job_id</name></expr></argument>, <argument><expr><name><name>policy</name><operator>.</operator><name>hypertable</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>enable_fast_restart</name><argument_list>(<argument><expr><name>job_id</name></expr></argument>, <argument><expr><literal type="string">"reorder"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>policy_reorder_read_and_validate_config</name><parameter_list>(<parameter><decl><type><name>Jsonb</name> <modifier>*</modifier></type><name>config</name></decl></parameter>, <parameter><decl><type><name>PolicyReorderData</name> <modifier>*</modifier></type><name>policy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type> <name>htid</name> <init>= <expr><call><name>policy_reorder_get_hypertable_id</name><argument_list>(<argument><expr><name>config</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name> <init>= <expr><call><name>ts_hypertable_get_by_id</name><argument_list>(<argument><expr><name>htid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ht</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"configuration hypertable id %d not found"</literal></expr></argument>, <argument><expr><name>htid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>index_name</name> <init>= <expr><call><name>policy_reorder_get_index_name</name><argument_list>(<argument><expr><name>config</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>check_valid_index</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>index_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>policy</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>policy</name><operator>-&gt;</operator><name>hypertable</name></name> <operator>=</operator> <name>ht</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>policy</name><operator>-&gt;</operator><name>index_relid</name></name> <operator>=</operator>
			<call><name>get_relname_relid</name><argument_list>(<argument><expr><name>index_name</name></expr></argument>, <argument><expr><call><name>get_namespace_oid</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>schema_name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>policy_retention_execute</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>job_id</name></decl></parameter>, <parameter><decl><type><name>Jsonb</name> <modifier>*</modifier></type><name>config</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PolicyRetentionData</name></type> <name>policy_data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>verbose_log</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>policy_retention_read_and_validate_config</name><argument_list>(<argument><expr><name>config</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>policy_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>verbose_log</name> <operator>=</operator> <call><name>policy_get_verbose_log</name><argument_list>(<argument><expr><name>config</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>verbose_log</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>log_retention_boundary</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>policy_data</name></expr></argument>, <argument><expr><literal type="string">"applying retention policy to hypertable"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>chunk_invoke_drop_chunks</name><argument_list>(<argument><expr><name><name>policy_data</name><operator>.</operator><name>object_relid</name></name></expr></argument>,
							 <argument><expr><name><name>policy_data</name><operator>.</operator><name>boundary</name></name></expr></argument>,
							 <argument><expr><name><name>policy_data</name><operator>.</operator><name>boundary_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>policy_retention_read_and_validate_config</name><parameter_list>(<parameter><decl><type><name>Jsonb</name> <modifier>*</modifier></type><name>config</name></decl></parameter>, <parameter><decl><type><name>PolicyRetentionData</name> <modifier>*</modifier></type><name>policy_data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>object_relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>hypertable</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cache</name> <modifier>*</modifier></type><name>hcache</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type><name>open_dim</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>boundary</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>boundary_type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ContinuousAgg</name> <modifier>*</modifier></type><name>cagg</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>object_relid</name> <operator>=</operator> <call><name>ts_hypertable_id_to_relid</name><argument_list>(<argument><expr><call><name>policy_retention_get_hypertable_id</name><argument_list>(<argument><expr><name>config</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>hypertable</name> <operator>=</operator> <call><name>ts_hypertable_cache_get_cache_and_entry</name><argument_list>(<argument><expr><name>object_relid</name></expr></argument>, <argument><expr><name>CACHE_FLAG_NONE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>open_dim</name> <operator>=</operator> <call><name>get_open_dimension_for_hypertable</name><argument_list>(<argument><expr><name>hypertable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>boundary</name> <operator>=</operator> <call><name>get_window_boundary</name><argument_list>(<argument><expr><name>open_dim</name></expr></argument>,
								   <argument><expr><name>config</name></expr></argument>,
								   <argument><expr><name>policy_retention_get_drop_after_int</name></expr></argument>,
								   <argument><expr><name>policy_retention_get_drop_after_interval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>boundary_type</name> <operator>=</operator> <call><name>ts_dimension_get_partition_type</name><argument_list>(<argument><expr><name>open_dim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We need to do a reverse lookup here since the given hypertable might be
	   a materialized hypertable, and thus need to call drop_chunks on the
	   continuous aggregate instead. */</comment>
	<expr_stmt><expr><name>cagg</name> <operator>=</operator> <call><name>ts_continuous_agg_find_by_mat_hypertable_id</name><argument_list>(<argument><expr><name><name>hypertable</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>cagg</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>view_name</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>user_view_name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>schema_name</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>user_view_schema</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>object_relid</name> <operator>=</operator> <call><name>get_relname_relid</name><argument_list>(<argument><expr><name>view_name</name></expr></argument>, <argument><expr><call><name>get_namespace_oid</name><argument_list>(<argument><expr><name>schema_name</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>policy_data</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>policy_data</name><operator>-&gt;</operator><name>object_relid</name></name> <operator>=</operator> <name>object_relid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>policy_data</name><operator>-&gt;</operator><name>boundary</name></name> <operator>=</operator> <name>boundary</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>policy_data</name><operator>-&gt;</operator><name>boundary_type</name></name> <operator>=</operator> <name>boundary_type</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>policy_refresh_cagg_execute</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>job_id</name></decl></parameter>, <parameter><decl><type><name>Jsonb</name> <modifier>*</modifier></type><name>config</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PolicyContinuousAggData</name></type> <name>policy_data</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>policy_refresh_cagg_read_and_validate_config</name><argument_list>(<argument><expr><name>config</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>policy_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>continuous_agg_refresh_internal</name><argument_list>(<argument><expr><name><name>policy_data</name><operator>.</operator><name>cagg</name></name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name><name>policy_data</name><operator>.</operator><name>refresh_window</name></name></expr></argument>,
									<argument><expr><name>CAGG_REFRESH_POLICY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>policy_refresh_cagg_read_and_validate_config</name><parameter_list>(<parameter><decl><type><name>Jsonb</name> <modifier>*</modifier></type><name>config</name></decl></parameter>, <parameter><decl><type><name>PolicyContinuousAggData</name> <modifier>*</modifier></type><name>policy_data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type> <name>materialization_id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>mat_ht</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type><name>open_dim</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>dim_type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>refresh_start</name></decl>, <decl><type ref="prev"/><name>refresh_end</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>materialization_id</name> <operator>=</operator> <call><name>policy_continuous_aggregate_get_mat_hypertable_id</name><argument_list>(<argument><expr><name>config</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>mat_ht</name> <operator>=</operator> <call><name>ts_hypertable_get_by_id</name><argument_list>(<argument><expr><name>materialization_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>mat_ht</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"configuration materialization hypertable id %d not found"</literal></expr></argument>,
						<argument><expr><name>materialization_id</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>open_dim</name> <operator>=</operator> <call><name>get_open_dimension_for_hypertable</name><argument_list>(<argument><expr><name>mat_ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dim_type</name> <operator>=</operator> <call><name>ts_dimension_get_partition_type</name><argument_list>(<argument><expr><name>open_dim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>refresh_start</name> <operator>=</operator> <call><name>policy_refresh_cagg_get_refresh_start</name><argument_list>(<argument><expr><name>open_dim</name></expr></argument>, <argument><expr><name>config</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>refresh_end</name> <operator>=</operator> <call><name>policy_refresh_cagg_get_refresh_end</name><argument_list>(<argument><expr><name>open_dim</name></expr></argument>, <argument><expr><name>config</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>refresh_start</name> <operator>&gt;=</operator> <name>refresh_end</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid refresh window"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"start_offset: %s, end_offset: %s"</literal></expr></argument>,
						   <argument><expr><call><name>ts_internal_to_time_string</name><argument_list>(<argument><expr><name>refresh_start</name></expr></argument>, <argument><expr><name>dim_type</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><call><name>ts_internal_to_time_string</name><argument_list>(<argument><expr><name>refresh_end</name></expr></argument>, <argument><expr><name>dim_type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"The start of the window must be before the end."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>policy_data</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>policy_data</name><operator>-&gt;</operator><name>refresh_window</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>dim_type</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>policy_data</name><operator>-&gt;</operator><name>refresh_window</name><operator>.</operator><name>start</name></name> <operator>=</operator> <name>refresh_start</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>policy_data</name><operator>-&gt;</operator><name>refresh_window</name><operator>.</operator><name>end</name></name> <operator>=</operator> <name>refresh_end</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>policy_data</name><operator>-&gt;</operator><name>cagg</name></name> <operator>=</operator> <call><name>ts_continuous_agg_find_by_mat_hypertable_id</name><argument_list>(<argument><expr><name>materialization_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Invoke recompress_chunk via fmgr so that the call can be deparsed and sent to
 * remote data nodes.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>policy_invoke_recompress_chunk</name><parameter_list>(<parameter><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>fexpr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relid</name> <init>= <expr><name><name>chunk</name><operator>-&gt;</operator><name>table_id</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>restype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>func_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name><name>argarr</name><index>[<expr><name>RECOMPRESS_CHUNK_NARGS</name></expr>]</index></name> <init>= <expr><block>{
		<expr><call><name>makeConst</name><argument_list>(<argument><expr><name>REGCLASSOID</name></expr></argument>,
				  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
				  <argument><expr><name>InvalidOid</name></expr></argument>,
				  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></sizeof></expr></argument>,
				  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>,
				  <argument><expr><name>false</name></expr></argument>,
				  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>castNode</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><call><name>makeBoolConst</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
	}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name><name>type_id</name><index>[<expr><name>RECOMPRESS_CHUNK_NARGS</name></expr>]</index></name> <init>= <expr><block>{ <expr><name>REGCLASSOID</name></expr>, <expr><name>BOOLOID</name></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>schema_name</name> <init>= <expr><call><name>ts_extension_schema_name</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>fqn</name> <init>= <expr><call><name>list_make2</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>schema_name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>RECOMPRESS_CHUNK_FUNCNAME</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>StaticAssertStmt</name><argument_list>(<argument><expr><call><name>lengthof</name><argument_list>(<argument><expr><name>type_id</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>argarr</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><literal type="string">"argarr and type_id should have matching lengths"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>func_oid</name> <operator>=</operator> <call><name>LookupFuncName</name><argument_list>(<argument><expr><name>fqn</name></expr></argument>, <argument><expr><call><name>lengthof</name><argument_list>(<argument><expr><name>type_id</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>type_id</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>func_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* LookupFuncName should not return an invalid OID */</comment>

	<comment type="block">/* Prepare the function expr with argument list */</comment>
	<expr_stmt><expr><call><name>get_func_result_type</name><argument_list>(<argument><expr><name>func_oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>restype</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>argarr</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name><name>argarr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><name>fexpr</name> <operator>=</operator> <call><name>makeFuncExpr</name><argument_list>(<argument><expr><name>func_oid</name></expr></argument>, <argument><expr><name>restype</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>COERCE_EXPLICIT_CALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fexpr</name><operator>-&gt;</operator><name>funcretset</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>estate</name> <operator>=</operator> <call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>econtext</name> <operator>=</operator> <call><name>CreateExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>exprstate</name> <init>= <expr><call><name>ExecInitExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fexpr</name><operator>-&gt;</operator><name>xpr</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ExecEvalExprSwitchContext</name><argument_list>(<argument><expr><name>exprstate</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Cleanup */</comment>
	<expr_stmt><expr><call><name>FreeExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Read configuration for compression job from config object. */</comment>
<function><type><name>void</name></type>
<name>policy_compression_read_and_validate_config</name><parameter_list>(<parameter><decl><type><name>Jsonb</name> <modifier>*</modifier></type><name>config</name></decl></parameter>, <parameter><decl><type><name>PolicyCompressionData</name> <modifier>*</modifier></type><name>policy_data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>table_relid</name> <init>= <expr><call><name>ts_hypertable_id_to_relid</name><argument_list>(<argument><expr><call><name>policy_compression_get_hypertable_id</name><argument_list>(<argument><expr><name>config</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cache</name> <modifier>*</modifier></type><name>hcache</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>hypertable</name> <init>=
		<expr><call><name>ts_hypertable_cache_get_cache_and_entry</name><argument_list>(<argument><expr><name>table_relid</name></expr></argument>, <argument><expr><name>CACHE_FLAG_NONE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hcache</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>policy_data</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>policy_data</name><operator>-&gt;</operator><name>hypertable</name></name> <operator>=</operator> <name>hypertable</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>policy_data</name><operator>-&gt;</operator><name>hcache</name></name> <operator>=</operator> <name>hcache</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>policy_recompression_read_and_validate_config</name><parameter_list>(<parameter><decl><type><name>Jsonb</name> <modifier>*</modifier></type><name>config</name></decl></parameter>, <parameter><decl><type><name>PolicyCompressionData</name> <modifier>*</modifier></type><name>policy_data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>table_relid</name> <init>= <expr><call><name>ts_hypertable_id_to_relid</name><argument_list>(<argument><expr><call><name>policy_compression_get_hypertable_id</name><argument_list>(<argument><expr><name>config</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cache</name> <modifier>*</modifier></type><name>hcache</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>hypertable</name> <init>=
		<expr><call><name>ts_hypertable_cache_get_cache_and_entry</name><argument_list>(<argument><expr><name>table_relid</name></expr></argument>, <argument><expr><name>CACHE_FLAG_NONE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hcache</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>policy_data</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>policy_data</name><operator>-&gt;</operator><name>hypertable</name></name> <operator>=</operator> <name>hypertable</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>policy_data</name><operator>-&gt;</operator><name>hcache</name></name> <operator>=</operator> <name>hcache</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>policy_recompression_execute</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>job_id</name></decl></parameter>, <parameter><decl><type><name>Jsonb</name> <modifier>*</modifier></type><name>config</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>chunkid_lst</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type><name>dim</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PolicyCompressionData</name></type> <name>policy_data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>distributed</name></decl>, <decl><type ref="prev"/><name>used_portalcxt</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>saved_cxt</name></decl>, <decl><type ref="prev"/><name>multitxn_cxt</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>policy_recompression_read_and_validate_config</name><argument_list>(<argument><expr><name>config</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>policy_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dim</name> <operator>=</operator> <call><name>hyperspace_get_open_dimension</name><argument_list>(<argument><expr><name><name>policy_data</name><operator>.</operator><name>hypertable</name><operator>-&gt;</operator><name>space</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>distributed</name> <operator>=</operator> <call><name>hypertable_is_distributed</name><argument_list>(<argument><expr><name><name>policy_data</name><operator>.</operator><name>hypertable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* we want the chunk id list to survive across transactions. So alloc in
	 * a different context
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>PortalContext</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*if we have a portal context use that - it will get freed automatically*/</comment>
		<expr_stmt><expr><name>multitxn_cxt</name> <operator>=</operator> <name>PortalContext</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>used_portalcxt</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* background worker job does not go via usual CALL path, so we do
		 * not have a PortalContext */</comment>
		<expr_stmt><expr><name>multitxn_cxt</name> <operator>=</operator>
			<call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>, <argument><expr><literal type="string">"CompressionJobCxt"</literal></expr></argument>, <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name>saved_cxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>multitxn_cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>chunkid_lst</name> <operator>=</operator> <call><name>get_chunk_to_recompress</name><argument_list>(<argument><expr><name>dim</name></expr></argument>, <argument><expr><name>config</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>saved_cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>chunkid_lst</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
			 <argument><expr><literal type="string">"no chunks for hypertable \"%s.%s\" that satisfy recompress chunk policy"</literal></expr></argument>,
			 <argument><expr><name><name>policy_data</name><operator>.</operator><name>hypertable</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>schema_name</name><operator>.</operator><name>data</name></name></expr></argument>,
			 <argument><expr><name><name>policy_data</name><operator>.</operator><name>hypertable</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>table_name</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name><name>policy_data</name><operator>.</operator><name>hcache</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>used_portalcxt</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>multitxn_cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name><name>policy_data</name><operator>.</operator><name>hcache</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>ActiveSnapshotSet</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* process each chunk in a new transaction */</comment>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>chunkid_lst</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>int32</name></type> <name>chunkid</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name> <init>= <expr><call><name>ts_chunk_get_by_id</name><argument_list>(<argument><expr><name>chunkid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>chunk</name> <operator>||</operator> <operator>!</operator><call><name>ts_chunk_is_unordered</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>distributed</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>policy_invoke_recompress_chunk</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>tsl_recompress_chunk_wrapper</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
			 <argument><expr><literal type="string">"completed recompressing chunk \"%s.%s\""</literal></expr></argument>,
			 <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>schema_name</name></name></expr></argument>)</argument_list></call></expr></argument>,
			 <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"job %d completed recompressing chunk"</literal></expr></argument>, <argument><expr><name>job_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>job_execute_function</name><parameter_list>(<parameter><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>funcexpr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>isnull</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name> <init>= <expr><call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><call><name>CreateExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>es</name> <init>= <expr><call><name>ExecPrepareExpr</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>funcexpr</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ExecEvalExpr</name><argument_list>(<argument><expr><name>es</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FreeExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>job_execute_procedure</name><parameter_list>(<parameter><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>funcexpr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CallStmt</name> <modifier>*</modifier></type><name>call</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CallStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>call</name><operator>-&gt;</operator><name>funcexpr</name></name> <operator>=</operator> <name>funcexpr</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name> <init>= <expr><call><name>CreateDestReceiver</name><argument_list>(<argument><expr><name>DestNone</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="block">/* we don't need to create proper param list cause we pass in all arguments as Const */</comment>
	<decl_stmt><decl><type><name>ParamListInfo</name></type> <name>params</name> <init>= <expr><call><name>makeParamList</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ExecuteCallStmt</name><argument_list>(<argument><expr><name>call</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>job_execute</name><parameter_list>(<parameter><decl><type><name>BgwJob</name> <modifier>*</modifier></type><name>job</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>arg1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>arg2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>portal_created</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name>prokind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>proc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectWithArgs</name> <modifier>*</modifier></type><name>object</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>funcexpr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>parent_ctx</name> <init>= <expr><name>CurrentMemoryContext</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Portal</name></type> <name>portal</name> <init>= <expr><name>ActivePortal</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>config</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
			 <argument><expr><literal type="string">"Executing %s with parameters %s"</literal></expr></argument>,
			 <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>proc_name</name></name></expr></argument>)</argument_list></call></expr></argument>,
			 <argument><expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>jsonb_out</name></expr></argument>, <argument><expr><call><name>JsonbPGetDatum</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>config</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Executing %s with no parameters"</literal></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>proc_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<comment type="block">/* Create a portal if there's no active */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PortalIsValid</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>portal_created</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>portal</name> <operator>=</operator> <call><name>CreatePortal</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>visible</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>resowner</name></name> <operator>=</operator> <name>CurrentResourceOwner</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ActivePortal</name> <operator>=</operator> <name>portal</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>PG12</name> <operator>&amp;&amp;</operator> <name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">120008</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>PG13</name> <operator>&amp;&amp;</operator> <name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">130004</literal><operator>)</operator> <operator>||</operator> <name>PG14_GE</name></expr></cpp:if>
		<expr_stmt><expr><call><name>EnsurePortalSnapshotExists</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>object</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ObjectWithArgs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>object</name><operator>-&gt;</operator><name>objname</name></name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>proc_schema</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>proc_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>object</name><operator>-&gt;</operator><name>objargs</name></name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><call><name>SystemTypeName</name><argument_list>(<argument><expr><literal type="string">"int4"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SystemTypeName</name><argument_list>(<argument><expr><literal type="string">"jsonb"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>proc</name> <operator>=</operator> <call><name>LookupFuncWithArgs</name><argument_list>(<argument><expr><name>OBJECT_ROUTINE</name></expr></argument>, <argument><expr><name>object</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>prokind</name> <operator>=</operator> <call><name>get_func_prokind</name><argument_list>(<argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We need to switch back to parent MemoryContext as StartTransactionCommand
	 * switched to CurTransactionContext and this context will be destroyed
	 * on CommitTransactionCommand which may be too short-lived if a policy
	 * has its own transaction handling.
	 */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>parent_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>arg1</name> <operator>=</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>config</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>arg2</name> <operator>=</operator> <call><name>makeNullConst</name><argument_list>(<argument><expr><name>JSONBOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>arg2</name> <operator>=</operator>
			<call><name>makeConst</name><argument_list>(<argument><expr><name>JSONBOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>JsonbPGetDatum</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>config</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>funcexpr</name> <operator>=</operator> <call><name>makeFuncExpr</name><argument_list>(<argument><expr><name>proc</name></expr></argument>,
							<argument><expr><name>VOIDOID</name></expr></argument>,
							<argument><expr><call><name>list_make2</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>InvalidOid</name></expr></argument>,
							<argument><expr><name>InvalidOid</name></expr></argument>,
							<argument><expr><name>COERCE_EXPLICIT_CALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Here we create a query string from the function/procedure name that we
	 * are calling. We do not update the status after the execution has
	 * finished since this is wrapped inside the code that starts and stops
	 * any job, not just custom jobs. We just provide more detailed
	 * information here that we are actually calling a specific custom
	 * function. */</comment>
	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
					 <argument><expr><literal type="string">"CALL %s.%s()"</literal></expr></argument>,
					 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>proc_schema</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>proc_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgstat_report_activity</name><argument_list>(<argument><expr><name>STATE_RUNNING</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name>prokind</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PROKIND_FUNCTION</name></expr>:</case>
			<expr_stmt><expr><call><name>job_execute_function</name><argument_list>(<argument><expr><name>funcexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>PROKIND_PROCEDURE</name></expr>:</case>
			<expr_stmt><expr><call><name>job_execute_procedure</name><argument_list>(<argument><expr><name>funcexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unsupported function type"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* Drop portal if it was created */</comment>
	<if_stmt><if>if <condition>(<expr><name>portal_created</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>ActiveSnapshotSet</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PortalDrop</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ActivePortal</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>
</unit>
