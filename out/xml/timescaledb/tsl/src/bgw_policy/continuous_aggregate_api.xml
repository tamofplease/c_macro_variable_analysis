<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/timescaledb/tsl/src/bgw_policy/continuous_aggregate_api.c"><comment type="block">/*
 * This file and its contents are licensed under the Timescale License.
 * Please see the included NOTICE for copyright information and
 * LICENSE-TIMESCALE for a copy of the license.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postgres.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/xact.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;common/int128.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;miscadmin.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;parser/parse_coerce.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/acl.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;jsonb_utils.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/builtins.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"bgw_policy/continuous_aggregate_api.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"bgw_policy/job.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"bgw_policy/policy_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"bgw/job.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ts_catalog/continuous_agg.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"continuous_aggs/materialize.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dimension.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hypertable_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"time_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"policy_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"time_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"bgw_policy/policies_v2.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"bgw/job_stat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"bgw/timer.h"</cpp:file></cpp:include>

<comment type="block">/* Default max runtime for a continuous aggregate jobs is unlimited for now */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_MAX_RUNTIME</name></cpp:macro>                                                                        \
	<cpp:value>DatumGetIntervalP(DirectFunctionCall3(interval_in, CStringGetDatum("0"), InvalidOid, -1))</cpp:value></cpp:define>

<comment type="block">/* infinite number of retries for continuous aggregate jobs */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_MAX_RETRIES</name></cpp:macro> <cpp:value>(-1)</cpp:value></cpp:define>

<function><type><name>int32</name></type>
<name>policy_continuous_aggregate_get_mat_hypertable_id</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Jsonb</name> <modifier>*</modifier></type><name>config</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>mat_hypertable_id</name> <init>=
		<expr><call><name>ts_jsonb_get_int32_field</name><argument_list>(<argument><expr><name>config</name></expr></argument>, <argument><expr><name>POL_REFRESH_CONF_KEY_MAT_HYPERTABLE_ID</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not find \"%s\" in config for job"</literal></expr></argument>,
						<argument><expr><name>POL_REFRESH_CONF_KEY_MAT_HYPERTABLE_ID</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>mat_hypertable_id</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int64</name></type>
<name>get_time_from_interval</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type><name>dim</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>interval</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>partitioning_type</name> <init>= <expr><call><name>ts_dimension_get_partition_type</name><argument_list>(<argument><expr><name>dim</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IS_INTEGER_TYPE</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>now_func</name> <init>= <expr><call><name>ts_get_integer_now_func</name><argument_list>(<argument><expr><name>dim</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int64</name></type> <name>value</name> <init>= <expr><call><name>ts_interval_value_to_internal</name><argument_list>(<argument><expr><name>interval</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>now_func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><call><name>ts_subtract_integer_from_now_saturating</name><argument_list>(<argument><expr><name>now_func</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>partitioning_type</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>INTERVALOID</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type> <name>res</name> <init>= <expr><call><name>subtract_interval_from_now</name><argument_list>(<argument><expr><call><name>DatumGetIntervalP</name><argument_list>(<argument><expr><name>interval</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>partitioning_type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<return>return <expr><call><name>ts_time_value_to_internal</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>partitioning_type</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unsupported offset type for continuous aggregate policy"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>pg_unreachable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int64</name></type>
<name>get_time_from_config</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type><name>dim</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Jsonb</name> <modifier>*</modifier></type><name>config</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>json_label</name></decl></parameter>,
					 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>partitioning_type</name> <init>= <expr><call><name>ts_dimension_get_partition_type</name><argument_list>(<argument><expr><name>dim</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><operator>*</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IS_INTEGER_TYPE</name><argument_list>(<argument><expr><name>partitioning_type</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>found</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int64</name></type> <name>interval_val</name> <init>= <expr><call><name>ts_jsonb_get_int64_field</name><argument_list>(<argument><expr><name>config</name></expr></argument>, <argument><expr><name>json_label</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>isnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<return>return <expr><literal type="number">0</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><call><name>get_time_from_interval</name><argument_list>(<argument><expr><name>dim</name></expr></argument>, <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>interval_val</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>INT8OID</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>Interval</name> <modifier>*</modifier></type><name>interval_val</name> <init>= <expr><call><name>ts_jsonb_get_interval_field</name><argument_list>(<argument><expr><name>config</name></expr></argument>, <argument><expr><name>json_label</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>interval_val</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>isnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<return>return <expr><literal type="number">0</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><call><name>get_time_from_interval</name><argument_list>(<argument><expr><name>dim</name></expr></argument>, <argument><expr><call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><name>interval_val</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>INTERVALOID</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>int64</name></type>
<name>policy_refresh_cagg_get_refresh_start</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type><name>dim</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Jsonb</name> <modifier>*</modifier></type><name>config</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>start_isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>res</name> <init>= <expr><call><name>get_time_from_config</name><argument_list>(<argument><expr><name>dim</name></expr></argument>, <argument><expr><name>config</name></expr></argument>, <argument><expr><name>POL_REFRESH_CONF_KEY_START_OFFSET</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>start_isnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="block">/* interpret NULL as min value for that type */</comment>
	<if_stmt><if>if <condition>(<expr><name>start_isnull</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>ts_time_get_min</name><argument_list>(<argument><expr><call><name>ts_dimension_get_partition_type</name><argument_list>(<argument><expr><name>dim</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int64</name></type>
<name>policy_refresh_cagg_get_refresh_end</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type><name>dim</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Jsonb</name> <modifier>*</modifier></type><name>config</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>end_isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>res</name> <init>= <expr><call><name>get_time_from_config</name><argument_list>(<argument><expr><name>dim</name></expr></argument>, <argument><expr><name>config</name></expr></argument>, <argument><expr><name>POL_REFRESH_CONF_KEY_END_OFFSET</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end_isnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>end_isnull</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>ts_time_get_end_or_max</name><argument_list>(<argument><expr><call><name>ts_dimension_get_partition_type</name><argument_list>(<argument><expr><name>dim</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* returns false if a policy could not be found */</comment>
<function><type><name>bool</name></type>
<name>policy_refresh_cagg_exists</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>materialization_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>mat_ht</name> <init>= <expr><call><name>ts_hypertable_get_by_id</name><argument_list>(<argument><expr><name>materialization_id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>mat_ht</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"configuration materialization hypertable id %d not found"</literal></expr></argument>,
						<argument><expr><name>materialization_id</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>jobs</name> <init>= <expr><call><name>ts_bgw_job_find_by_proc_and_hypertable_id</name><argument_list>(<argument><expr><name>POLICY_REFRESH_CAGG_PROC_NAME</name></expr></argument>,
														   <argument><expr><name>INTERNAL_SCHEMA_NAME</name></expr></argument>,
														   <argument><expr><name>materialization_id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>jobs</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* only 1 cont. aggregate policy job allowed */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>jobs</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Compare passed in interval value with refresh_start parameter
 * of cagg policy.
 */</comment>
<function><type><name>bool</name></type>
<name>policy_refresh_cagg_refresh_start_lt</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>materialization_id</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>cmp_type</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>cmp_interval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>mat_ht</name> <init>= <expr><call><name>ts_hypertable_get_by_id</name><argument_list>(<argument><expr><name>materialization_id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>mat_ht</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"configuration materialization hypertable id %d not found"</literal></expr></argument>,
						<argument><expr><name>materialization_id</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>jobs</name> <init>= <expr><call><name>ts_bgw_job_find_by_proc_and_hypertable_id</name><argument_list>(<argument><expr><name>POLICY_REFRESH_CAGG_PROC_NAME</name></expr></argument>,
														   <argument><expr><name>INTERNAL_SCHEMA_NAME</name></expr></argument>,
														   <argument><expr><name>materialization_id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>jobs</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* only 1 cont. aggregate policy job allowed */</comment>
	<decl_stmt><decl><type><name>BgwJob</name> <modifier>*</modifier></type><name>cagg_job</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name>jobs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Jsonb</name> <modifier>*</modifier></type><name>cagg_config</name> <init>= <expr><name><name>cagg_job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>config</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type><name>open_dim</name> <init>= <expr><call><name>get_open_dimension_for_hypertable</name><argument_list>(<argument><expr><name>mat_ht</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>dim_type</name> <init>= <expr><call><name>ts_dimension_get_partition_type</name><argument_list>(<argument><expr><name>open_dim</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IS_INTEGER_TYPE</name><argument_list>(<argument><expr><name>dim_type</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>found</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IS_INTEGER_TYPE</name><argument_list>(<argument><expr><name>cmp_type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>int64</name></type> <name>cmpval</name> <init>= <expr><call><name>ts_interval_value_to_internal</name><argument_list>(<argument><expr><name>cmp_interval</name></expr></argument>, <argument><expr><name>cmp_type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int64</name></type> <name>refresh_start</name> <init>=
			<expr><call><name>ts_jsonb_get_int64_field</name><argument_list>(<argument><expr><name>cagg_config</name></expr></argument>, <argument><expr><name>POL_REFRESH_CONF_KEY_START_OFFSET</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/*this is a null value */</comment>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><name>refresh_start</name> <operator>&lt;</operator> <name>cmpval</name><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cmp_type</name> <operator>==</operator> <name>INTERVALOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>Interval</name> <modifier>*</modifier></type><name>refresh_start</name> <init>=
			<expr><call><name>ts_jsonb_get_interval_field</name><argument_list>(<argument><expr><name>cagg_config</name></expr></argument>, <argument><expr><name>POL_REFRESH_CONF_KEY_START_OFFSET</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>refresh_start</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* NULL refresh_start */</comment>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<decl_stmt><decl><type><name>Datum</name></type> <name>res</name> <init>=
			<expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>interval_lt</name></expr></argument>, <argument><expr><call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><name>refresh_start</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cmp_interval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>DatumGetBool</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>policy_refresh_cagg_proc</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>PG_NARGS</name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="number">2</literal> <operator>||</operator> <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>TS_PREVENT_FUNC_IF_READ_ONLY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>policy_refresh_cagg_execute</name><argument_list>(<argument><expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PG_GETARG_JSONB_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>policy_refresh_cagg_check</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"config must not be NULL"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>policy_refresh_cagg_read_and_validate_config</name><argument_list>(<argument><expr><call><name>PG_GETARG_JSONB_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>json_add_dim_interval_value</name><parameter_list>(<parameter><decl><type><name>JsonbParseState</name> <modifier>*</modifier></type><name>parse_state</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>json_label</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>dim_type</name></decl></parameter>,
							<parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>dim_type</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>INTERVALOID</name></expr>:</case>
			<expr_stmt><expr><call><name>ts_jsonb_add_interval</name><argument_list>(<argument><expr><name>parse_state</name></expr></argument>, <argument><expr><name>json_label</name></expr></argument>, <argument><expr><call><name>DatumGetIntervalP</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>INT2OID</name></expr>:</case>
			<expr_stmt><expr><call><name>ts_jsonb_add_int64</name><argument_list>(<argument><expr><name>parse_state</name></expr></argument>, <argument><expr><name>json_label</name></expr></argument>, <argument><expr><call><name>DatumGetInt16</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>INT4OID</name></expr>:</case>
			<expr_stmt><expr><call><name>ts_jsonb_add_int64</name><argument_list>(<argument><expr><name>parse_state</name></expr></argument>, <argument><expr><name>json_label</name></expr></argument>, <argument><expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>INT8OID</name></expr>:</case>
			<expr_stmt><expr><call><name>ts_jsonb_add_int64</name><argument_list>(<argument><expr><name>parse_state</name></expr></argument>, <argument><expr><name>json_label</name></expr></argument>, <argument><expr><call><name>DatumGetInt64</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unsupported interval argument type, expected type : %s"</literal></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>dim_type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>convert_interval_arg</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>dim_type</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>interval</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>interval_type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str_msg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>convert_to</name> <init>= <expr><name>dim_type</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>converted</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IS_TIMESTAMP_TYPE</name><argument_list>(<argument><expr><name>dim_type</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>convert_to</name> <operator>=</operator> <name>INTERVALOID</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>interval_type</name> <operator>!=</operator> <name>convert_to</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>can_coerce_type</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>interval_type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>convert_to</name></expr></argument>, <argument><expr><name>COERCION_IMPLICIT</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>IS_INTEGER_TYPE</name><argument_list>(<argument><expr><name>dim_type</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid parameter value for %s"</literal></expr></argument>, <argument><expr><name>str_msg</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use time interval of type %s with the continuous aggregate."</literal></expr></argument>,
								 <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>dim_type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>IS_TIMESTAMP_TYPE</name><argument_list>(<argument><expr><name>dim_type</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid parameter value for %s"</literal></expr></argument>, <argument><expr><name>str_msg</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use time interval with a continuous aggregate using "</literal>
								 <literal type="string">"timestamp-based time "</literal>
								 <literal type="string">"bucket."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>converted</name> <operator>=</operator> <call><name>ts_time_datum_convert_arg</name><argument_list>(<argument><expr><name>interval</name></expr></argument>, <argument><expr><name>interval_type</name></expr></argument>, <argument><expr><name>convert_to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* For integer types, first convert all types to int64 to get on a common
	 * type. Then check valid time ranges against the partition/dimension
	 * type */</comment>
	<switch>switch <condition>(<expr><operator>*</operator><name>interval_type</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>INT2OID</name></expr>:</case>
			<expr_stmt><expr><name>converted</name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><operator>(</operator><name>int64</name><operator>)</operator> <call><name>DatumGetInt16</name><argument_list>(<argument><expr><name>converted</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>INT4OID</name></expr>:</case>
			<expr_stmt><expr><name>converted</name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><operator>(</operator><name>int64</name><operator>)</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>converted</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>INT8OID</name></expr>:</case>
			<break>break;</break>
		<case>case <expr><name>INTERVALOID</name></expr>:</case>
			<comment type="block">/* For timestamp types, we only support Interval, so nothing further
			 * to do. */</comment>
			<return>return <expr><name>converted</name></expr>;</return>
		<default>default:</default>
			<expr_stmt><expr><call><name>pg_unreachable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* Cap at min and max */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>DatumGetInt64</name><argument_list>(<argument><expr><name>converted</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>ts_time_get_min</name><argument_list>(<argument><expr><name>dim_type</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>converted</name> <operator>=</operator> <call><name>ts_time_get_min</name><argument_list>(<argument><expr><name>dim_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>DatumGetInt64</name><argument_list>(<argument><expr><name>converted</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <call><name>ts_time_get_max</name><argument_list>(<argument><expr><name>dim_type</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>converted</name> <operator>=</operator> <call><name>ts_time_get_max</name><argument_list>(<argument><expr><name>dim_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Convert to the desired integer type */</comment>
	<switch>switch <condition>(<expr><name>dim_type</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>INT2OID</name></expr>:</case>
			<expr_stmt><expr><name>converted</name> <operator>=</operator> <call><name>Int16GetDatum</name><argument_list>(<argument><expr><operator>(</operator><name>int16</name><operator>)</operator> <call><name>DatumGetInt64</name><argument_list>(<argument><expr><name>converted</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>INT4OID</name></expr>:</case>
			<expr_stmt><expr><name>converted</name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><operator>(</operator><name>int32</name><operator>)</operator> <call><name>DatumGetInt64</name><argument_list>(<argument><expr><name>converted</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>INT8OID</name></expr>:</case>
			<comment type="block">/* Already int64, so nothing to do. */</comment>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>pg_unreachable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><operator>*</operator><name>interval_type</name> <operator>=</operator> <name>dim_type</name></expr>;</expr_stmt>

	<return>return <expr><name>converted</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Convert an interval to a 128 integer value.
 *
 * Based on PostgreSQL's interval_cmp_value().
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>INT128</name></type>
<name>interval_to_int128</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Interval</name> <modifier>*</modifier></type><name>interval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>INT128</name></type> <name>span</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>dayfraction</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>days</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Separate time field into days and dayfraction, then add the month and
	 * day fields to the days part.  We cannot overflow int64 days here.
	 */</comment>
	<expr_stmt><expr><name>dayfraction</name> <operator>=</operator> <name><name>interval</name><operator>-&gt;</operator><name>time</name></name> <operator>%</operator> <name>USECS_PER_DAY</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>days</name> <operator>=</operator> <name><name>interval</name><operator>-&gt;</operator><name>time</name></name> <operator>/</operator> <name>USECS_PER_DAY</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>days</name> <operator>+=</operator> <name><name>interval</name><operator>-&gt;</operator><name>month</name></name> <operator>*</operator> <call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">30</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>days</name> <operator>+=</operator> <name><name>interval</name><operator>-&gt;</operator><name>day</name></name></expr>;</expr_stmt>

	<comment type="block">/* Widen dayfraction to 128 bits */</comment>
	<expr_stmt><expr><name>span</name> <operator>=</operator> <call><name>int64_to_int128</name><argument_list>(<argument><expr><name>dayfraction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Scale up days to microseconds, forming a 128-bit product */</comment>
	<expr_stmt><expr><call><name>int128_add_int64_mul_int64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>span</name></expr></argument>, <argument><expr><name>days</name></expr></argument>, <argument><expr><name>USECS_PER_DAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>span</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int64</name></type>
<name>interval_to_int64</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>interval</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>type</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>INT2OID</name></expr>:</case>
			<return>return <expr><call><name>DatumGetInt16</name><argument_list>(<argument><expr><name>interval</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>INT4OID</name></expr>:</case>
			<return>return <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>interval</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>INT8OID</name></expr>:</case>
			<return>return <expr><call><name>DatumGetInt64</name><argument_list>(<argument><expr><name>interval</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>INTERVALOID</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>int64</name></type> <name>max</name> <init>= <expr><call><name>ts_time_get_max</name><argument_list>(<argument><expr><name>TIMESTAMPTZOID</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>const</specifier> <name>int64</name></type> <name>min</name> <init>= <expr><call><name>ts_time_get_min</name><argument_list>(<argument><expr><name>TIMESTAMPTZOID</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>INT128</name></type> <name>bigres</name> <init>= <expr><call><name>interval_to_int128</name><argument_list>(<argument><expr><call><name>DatumGetIntervalP</name><argument_list>(<argument><expr><name>interval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>int128_compare</name><argument_list>(<argument><expr><name>bigres</name></expr></argument>, <argument><expr><call><name>int64_to_int128</name><argument_list>(<argument><expr><name>max</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>max</name></expr>;</return></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>int128_compare</name><argument_list>(<argument><expr><name>bigres</name></expr></argument>, <argument><expr><call><name>int64_to_int128</name><argument_list>(<argument><expr><name>min</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>min</name></expr>;</return></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<return>return <expr><call><name>int128_to_int64</name><argument_list>(<argument><expr><name>bigres</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
		</block_content>}</block>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>pg_unreachable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Enforce that a policy has a refresh window of at least two buckets to
 * ensure we materialize at least one bucket each run.
 *
 * Why two buckets? Note that the policy probably won't execute at at time
 * that exactly aligns with a bucket boundary, so a window of one bucket
 * might not cover a full bucket that we want to materialize:
 *
 * Refresh window:                   [-----)
 * Materialized buckets:   |-----|-----|-----|
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>validate_window_size</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ContinuousAgg</name> <modifier>*</modifier></type><name>cagg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CaggPolicyConfig</name> <modifier>*</modifier></type><name>config</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int64</name></type> <name>start_offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>end_offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>bucket_width</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>config</name><operator>-&gt;</operator><name>offset_start</name><operator>.</operator><name>isnull</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>start_offset</name> <operator>=</operator> <call><name>ts_time_get_max</name><argument_list>(<argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>partition_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>start_offset</name> <operator>=</operator> <call><name>interval_to_int64</name><argument_list>(<argument><expr><name><name>config</name><operator>-&gt;</operator><name>offset_start</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><name><name>config</name><operator>-&gt;</operator><name>offset_start</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>config</name><operator>-&gt;</operator><name>offset_end</name><operator>.</operator><name>isnull</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>end_offset</name> <operator>=</operator> <call><name>ts_time_get_min</name><argument_list>(<argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>partition_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>end_offset</name> <operator>=</operator> <call><name>interval_to_int64</name><argument_list>(<argument><expr><name><name>config</name><operator>-&gt;</operator><name>offset_end</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><name><name>config</name><operator>-&gt;</operator><name>offset_end</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ts_continuous_agg_bucket_width_variable</name><argument_list>(<argument><expr><name>cagg</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * There are several cases of variable-sized buckets:
		 * 1. Monthly buckets
		 * 2. Buckets with timezones
		 * 3. Cases 1 and 2 at the same time
		 *
		 * For months we simply take 31 days as the worst case scenario and
		 * multiply this number by the number of months in the bucket. This
		 * reduces the task to days/hours/minutes scenario.
		 *
		 * Days/hours/minutes case is handled the same way as for fixed-sized
		 * buckets. The refresh window at least two buckets in size is adequate
		 * for such corner cases as DST.
		 */</comment>

		<comment type="block">/* bucket_function should always be specified for variable-sized buckets */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>bucket_function</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* ... and bucket_function-&gt;bucket_width too */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>bucket_function</name><operator>-&gt;</operator><name>bucket_width</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Make a temporary copy of bucket_width */</comment>
		<decl_stmt><decl><type><name>Interval</name></type> <name>interval</name> <init>= <expr><operator>*</operator><name><name>cagg</name><operator>-&gt;</operator><name>bucket_function</name><operator>-&gt;</operator><name>bucket_width</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>interval</name><operator>.</operator><name>day</name></name> <operator>+=</operator> <literal type="number">31</literal> <operator>*</operator> <name><name>interval</name><operator>.</operator><name>month</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>interval</name><operator>.</operator><name>month</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>bucket_width</name> <operator>=</operator> <call><name>ts_interval_value_to_internal</name><argument_list>(<argument><expr><call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>interval</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>INTERVALOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>bucket_width</name> <operator>=</operator> <call><name>ts_continuous_agg_bucket_width</name><argument_list>(<argument><expr><name>cagg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ts_time_saturating_add</name><argument_list>(<argument><expr><name>end_offset</name></expr></argument>, <argument><expr><name>bucket_width</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>INT8OID</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>start_offset</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"policy refresh window too small"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The start and end offsets must cover at least"</literal>
						   <literal type="string">" two buckets in the valid time range of type \"%s\"."</literal></expr></argument>,
						   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>partition_type</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>parse_offset_arg</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ContinuousAgg</name> <modifier>*</modifier></type><name>cagg</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>offset_type</name></decl></parameter>, <parameter><decl><type><name>NullableDatum</name></type> <name>arg</name></decl></parameter>,
				 <parameter><decl><type><name>CaggPolicyOffset</name> <modifier>*</modifier></type><name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>offset</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name><name>arg</name><operator>.</operator><name>isnull</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>offset</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>offset</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator>
			<call><name>convert_interval_arg</name><argument_list>(<argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>partition_type</name></name></expr></argument>, <argument><expr><name><name>arg</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offset_type</name></expr></argument>, <argument><expr><name><name>offset</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>offset</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>offset_type</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>parse_cagg_policy_config</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ContinuousAgg</name> <modifier>*</modifier></type><name>cagg</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>start_offset_type</name></decl></parameter>,
						 <parameter><decl><type><name>NullableDatum</name></type> <name>start_offset</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>end_offset_type</name></decl></parameter>, <parameter><decl><type><name>NullableDatum</name></type> <name>end_offset</name></decl></parameter>,
						 <parameter><decl><type><name>CaggPolicyConfig</name> <modifier>*</modifier></type><name>config</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>config</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CaggPolicyConfig</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>config</name><operator>-&gt;</operator><name>partition_type</name></name> <operator>=</operator> <name><name>cagg</name><operator>-&gt;</operator><name>partition_type</name></name></expr>;</expr_stmt>
	<comment type="block">/* This might seem backwards, but since we are dealing with offsets, start
	 * actually translates to max and end to min for maximum window. */</comment>
	<expr_stmt><expr><name><name>config</name><operator>-&gt;</operator><name>offset_start</name><operator>.</operator><name>value</name></name> <operator>=</operator> <call><name>ts_time_datum_get_max</name><argument_list>(<argument><expr><name><name>config</name><operator>-&gt;</operator><name>partition_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>config</name><operator>-&gt;</operator><name>offset_end</name><operator>.</operator><name>value</name></name> <operator>=</operator> <call><name>ts_time_datum_get_min</name><argument_list>(<argument><expr><name><name>config</name><operator>-&gt;</operator><name>partition_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>config</name><operator>-&gt;</operator><name>offset_start</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name><name>config</name><operator>-&gt;</operator><name>offset_end</name><operator>.</operator><name>type</name></name> <operator>=</operator>
		<ternary><condition><expr><call><name>IS_TIMESTAMP_TYPE</name><argument_list>(<argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>partition_type</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>INTERVALOID</name></expr> </then><else>: <expr><name><name>cagg</name><operator>-&gt;</operator><name>partition_type</name></name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>config</name><operator>-&gt;</operator><name>offset_start</name><operator>.</operator><name>name</name></name> <operator>=</operator> <name>POL_REFRESH_CONF_KEY_START_OFFSET</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>config</name><operator>-&gt;</operator><name>offset_end</name><operator>.</operator><name>name</name></name> <operator>=</operator> <name>POL_REFRESH_CONF_KEY_END_OFFSET</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>parse_offset_arg</name><argument_list>(<argument><expr><name>cagg</name></expr></argument>, <argument><expr><name>start_offset_type</name></expr></argument>, <argument><expr><name>start_offset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>config</name><operator>-&gt;</operator><name>offset_start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>parse_offset_arg</name><argument_list>(<argument><expr><name>cagg</name></expr></argument>, <argument><expr><name>end_offset_type</name></expr></argument>, <argument><expr><name>end_offset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>config</name><operator>-&gt;</operator><name>offset_end</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>config</name><operator>-&gt;</operator><name>offset_start</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name><name>config</name><operator>-&gt;</operator><name>offset_end</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>validate_window_size</name><argument_list>(<argument><expr><name>cagg</name></expr></argument>, <argument><expr><name>config</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>policy_refresh_cagg_add_internal</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>cagg_oid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>start_offset_type</name></decl></parameter>, <parameter><decl><type><name>NullableDatum</name></type> <name>start_offset</name></decl></parameter>,
								 <parameter><decl><type><name>Oid</name></type> <name>end_offset_type</name></decl></parameter>, <parameter><decl><type><name>NullableDatum</name></type> <name>end_offset</name></decl></parameter>,
								 <parameter><decl><type><name>Interval</name></type> <name>refresh_interval</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>if_not_exists</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>fixed_schedule</name></decl></parameter>,
								 <parameter><decl><type><name>TimestampTz</name></type> <name>initial_start</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>timezone</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NameData</name></type> <name>application_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NameData</name></type> <name>proc_name</name></decl>, <decl><type ref="prev"/><name>proc_schema</name></decl>, <decl><type ref="prev"/><name>check_name</name></decl>, <decl><type ref="prev"/><name>check_schema</name></decl>, <decl><type ref="prev"/><name>owner</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ContinuousAgg</name> <modifier>*</modifier></type><name>cagg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CaggPolicyConfig</name></type> <name>policyconf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>job_id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>owner_id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>jobs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonbParseState</name> <modifier>*</modifier></type><name>parse_state</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Verify that the owner can create a background worker */</comment>
	<expr_stmt><expr><name>owner_id</name> <operator>=</operator> <call><name>ts_cagg_permissions_check</name><argument_list>(<argument><expr><name>cagg_oid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_bgw_job_validate_job_owner</name><argument_list>(<argument><expr><name>owner_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>cagg</name> <operator>=</operator> <call><name>ts_continuous_agg_find_by_relid</name><argument_list>(<argument><expr><name>cagg_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cagg</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a continuous aggregate"</literal></expr></argument>, <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>cagg_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>start_offset</name><operator>.</operator><name>isnull</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>start_offset</name><operator>.</operator><name>isnull</name></name> <operator>=</operator>
			<call><name>ts_if_offset_is_infinity</name><argument_list>(<argument><expr><name><name>start_offset</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><name>start_offset_type</name></expr></argument>, <argument><expr><name>true</name></expr></argument> <comment type="block">/* is_start */</comment>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>end_offset</name><operator>.</operator><name>isnull</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>end_offset</name><operator>.</operator><name>isnull</name></name> <operator>=</operator>
			<call><name>ts_if_offset_is_infinity</name><argument_list>(<argument><expr><name><name>end_offset</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><name>end_offset_type</name></expr></argument>, <argument><expr><name>false</name></expr></argument> <comment type="block">/* is_start */</comment>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>parse_cagg_policy_config</name><argument_list>(<argument><expr><name>cagg</name></expr></argument>,
							 <argument><expr><name>start_offset_type</name></expr></argument>,
							 <argument><expr><name>start_offset</name></expr></argument>,
							 <argument><expr><name>end_offset_type</name></expr></argument>,
							 <argument><expr><name>end_offset</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>policyconf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make sure there is only 1 refresh policy on the cagg */</comment>
	<expr_stmt><expr><name>jobs</name> <operator>=</operator> <call><name>ts_bgw_job_find_by_proc_and_hypertable_id</name><argument_list>(<argument><expr><name>POLICY_REFRESH_CAGG_PROC_NAME</name></expr></argument>,
													 <argument><expr><name>INTERNAL_SCHEMA_NAME</name></expr></argument>,
													 <argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>mat_hypertable_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>jobs</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>jobs</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>if_not_exists</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"continuous aggregate policy already exists for \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>cagg_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Only one continuous aggregate policy can be created per continuous "</literal>
							   <literal type="string">"aggregate and a policy with job id %d already exists for \"%s\"."</literal></expr></argument>,
							   <argument><expr><operator>(</operator><operator>(</operator><name>BgwJob</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>jobs</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>,
							   <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>cagg_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<decl_stmt><decl><type><name>BgwJob</name> <modifier>*</modifier></type><name>existing</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name>jobs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>policy_config_check_hypertable_lag_equality</name><argument_list>(<argument><expr><name><name>existing</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>config</name></name></expr></argument>,
														<argument><expr><name>POL_REFRESH_CONF_KEY_START_OFFSET</name></expr></argument>,
														<argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>partition_type</name></name></expr></argument>,
														<argument><expr><name><name>policyconf</name><operator>.</operator><name>offset_start</name><operator>.</operator><name>type</name></name></expr></argument>,
														<argument><expr><name><name>policyconf</name><operator>.</operator><name>offset_start</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>policy_config_check_hypertable_lag_equality</name><argument_list>(<argument><expr><name><name>existing</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>config</name></name></expr></argument>,
														<argument><expr><name>POL_REFRESH_CONF_KEY_END_OFFSET</name></expr></argument>,
														<argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>partition_type</name></name></expr></argument>,
														<argument><expr><name><name>policyconf</name><operator>.</operator><name>offset_end</name><operator>.</operator><name>type</name></name></expr></argument>,
														<argument><expr><name><name>policyconf</name><operator>.</operator><name>offset_end</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* If all arguments are the same, do nothing */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"continuous aggregate policy already exists for \"%s\", "</literal>
							<literal type="string">"skipping"</literal></expr></argument>,
							<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>cagg_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"continuous aggregate policy already exists for \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>cagg_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"A policy already exists with different arguments."</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Remove the existing policy before adding a new one."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Next, insert a new job into jobs table */</comment>
	<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>application_name</name></expr></argument>, <argument><expr><literal type="string">"Refresh Continuous Aggregate Policy"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>proc_name</name></expr></argument>, <argument><expr><name>POLICY_REFRESH_CAGG_PROC_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>proc_schema</name></expr></argument>, <argument><expr><name>INTERNAL_SCHEMA_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>check_name</name></expr></argument>, <argument><expr><name>POLICY_REFRESH_CAGG_CHECK_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>check_schema</name></expr></argument>, <argument><expr><name>INTERNAL_SCHEMA_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>owner</name></expr></argument>, <argument><expr><call><name>GetUserNameFromId</name><argument_list>(<argument><expr><name>owner_id</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pushJsonbValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>parse_state</name></expr></argument>, <argument><expr><name>WJB_BEGIN_OBJECT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_jsonb_add_int32</name><argument_list>(<argument><expr><name>parse_state</name></expr></argument>,
					   <argument><expr><name>POL_REFRESH_CONF_KEY_MAT_HYPERTABLE_ID</name></expr></argument>,
					   <argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>mat_hypertable_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>policyconf</name><operator>.</operator><name>offset_start</name><operator>.</operator><name>isnull</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>json_add_dim_interval_value</name><argument_list>(<argument><expr><name>parse_state</name></expr></argument>,
									<argument><expr><name>POL_REFRESH_CONF_KEY_START_OFFSET</name></expr></argument>,
									<argument><expr><name><name>policyconf</name><operator>.</operator><name>offset_start</name><operator>.</operator><name>type</name></name></expr></argument>,
									<argument><expr><name><name>policyconf</name><operator>.</operator><name>offset_start</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ts_jsonb_add_null</name><argument_list>(<argument><expr><name>parse_state</name></expr></argument>, <argument><expr><name>POL_REFRESH_CONF_KEY_START_OFFSET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>policyconf</name><operator>.</operator><name>offset_end</name><operator>.</operator><name>isnull</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>json_add_dim_interval_value</name><argument_list>(<argument><expr><name>parse_state</name></expr></argument>,
									<argument><expr><name>POL_REFRESH_CONF_KEY_END_OFFSET</name></expr></argument>,
									<argument><expr><name><name>policyconf</name><operator>.</operator><name>offset_end</name><operator>.</operator><name>type</name></name></expr></argument>,
									<argument><expr><name><name>policyconf</name><operator>.</operator><name>offset_end</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ts_jsonb_add_null</name><argument_list>(<argument><expr><name>parse_state</name></expr></argument>, <argument><expr><name>POL_REFRESH_CONF_KEY_END_OFFSET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<decl_stmt><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>pushJsonbValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>parse_state</name></expr></argument>, <argument><expr><name>WJB_END_OBJECT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Jsonb</name> <modifier>*</modifier></type><name>config</name> <init>= <expr><call><name>JsonbValueToJsonb</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>job_id</name> <operator>=</operator> <call><name>ts_bgw_job_insert_relation</name><argument_list>(<argument><expr><operator>&amp;</operator><name>application_name</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>refresh_interval</name></expr></argument>,
										<argument><expr><name>DEFAULT_MAX_RUNTIME</name></expr></argument>,
										<argument><expr><name>DEFAULT_MAX_RETRIES</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>refresh_interval</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>proc_schema</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>proc_name</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>check_schema</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>check_name</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>owner</name></expr></argument>,
										<argument><expr><name>true</name></expr></argument>,
										<argument><expr><name>fixed_schedule</name></expr></argument>,
										<argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>mat_hypertable_id</name></name></expr></argument>,
										<argument><expr><name>config</name></expr></argument>,
										<argument><expr><name>initial_start</name></expr></argument>,
										<argument><expr><name>timezone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><name>job_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>policy_refresh_cagg_add</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>cagg_oid</name></decl>, <decl><type ref="prev"/><name>start_offset_type</name></decl>, <decl><type ref="prev"/><name>end_offset_type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name></type> <name>refresh_interval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>if_not_exists</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NullableDatum</name></type> <name>start_offset</name></decl>, <decl><type ref="prev"/><name>end_offset</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>cagg_oid</name> <operator>=</operator> <call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use NULL refresh_schedule_interval"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>start_offset_type</name> <operator>=</operator> <call><name>get_fn_expr_argtype</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>start_offset</name><operator>.</operator><name>value</name></name> <operator>=</operator> <call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>start_offset</name><operator>.</operator><name>isnull</name></name> <operator>=</operator> <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>end_offset_type</name> <operator>=</operator> <call><name>get_fn_expr_argtype</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>end_offset</name><operator>.</operator><name>value</name></name> <operator>=</operator> <call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>end_offset</name><operator>.</operator><name>isnull</name></name> <operator>=</operator> <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>refresh_interval</name> <operator>=</operator> <operator>*</operator><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>if_not_exists</name> <operator>=</operator> <call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>initial_start</name> <init>= <expr><ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>DT_NOBEGIN</name></expr> </then><else>: <expr><call><name>PG_GETARG_TIMESTAMPTZ</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>fixed_schedule</name> <init>= <expr><operator>!</operator><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>timezone</name> <init>= <expr><ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>valid_timezone</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Datum</name></type> <name>retval</name></decl>;</decl_stmt>
	<comment type="block">/* if users pass in -infinity for initial_start, then use the current_timestamp instead */</comment>
	<if_stmt><if>if <condition>(<expr><name>fixed_schedule</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ts_bgw_job_validate_schedule_interval</name><argument_list>(<argument><expr><operator>&amp;</operator><name>refresh_interval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>TIMESTAMP_NOT_FINITE</name><argument_list>(<argument><expr><name>initial_start</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>initial_start</name> <operator>=</operator> <call><name>ts_timer_get_current_timestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>timezone</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>valid_timezone</name> <operator>=</operator> <call><name>ts_bgw_job_validate_timezone</name><argument_list>(<argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>policy_refresh_cagg_add_internal</name><argument_list>(<argument><expr><name>cagg_oid</name></expr></argument>,
											  <argument><expr><name>start_offset_type</name></expr></argument>,
											  <argument><expr><name>start_offset</name></expr></argument>,
											  <argument><expr><name>end_offset_type</name></expr></argument>,
											  <argument><expr><name>end_offset</name></expr></argument>,
											  <argument><expr><name>refresh_interval</name></expr></argument>,
											  <argument><expr><name>if_not_exists</name></expr></argument>,
											  <argument><expr><name>fixed_schedule</name></expr></argument>,
											  <argument><expr><name>initial_start</name></expr></argument>,
											  <argument><expr><name>valid_timezone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TIMESTAMP_NOT_FINITE</name><argument_list>(<argument><expr><name>initial_start</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int32</name></type> <name>job_id</name> <init>= <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ts_bgw_job_stat_upsert_next_start</name><argument_list>(<argument><expr><name>job_id</name></expr></argument>, <argument><expr><name>initial_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>policy_refresh_cagg_remove_internal</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>cagg_oid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>if_exists</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type> <name>mat_htid</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ContinuousAgg</name> <modifier>*</modifier></type><name>cagg</name> <init>= <expr><call><name>ts_continuous_agg_find_by_relid</name><argument_list>(<argument><expr><name>cagg_oid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cagg</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a continuous aggregate"</literal></expr></argument>, <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>cagg_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ts_cagg_permissions_check</name><argument_list>(<argument><expr><name>cagg_oid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>mat_htid</name> <operator>=</operator> <name><name>cagg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>mat_hypertable_id</name></name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>jobs</name> <init>= <expr><call><name>ts_bgw_job_find_by_proc_and_hypertable_id</name><argument_list>(<argument><expr><name>POLICY_REFRESH_CAGG_PROC_NAME</name></expr></argument>,
														   <argument><expr><name>INTERNAL_SCHEMA_NAME</name></expr></argument>,
														   <argument><expr><name>mat_htid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>jobs</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>if_exists</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"continuous aggregate policy not found for \"%s\""</literal></expr></argument>,
							 <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>cagg_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"continuous aggregate policy not found for \"%s\", skipping"</literal></expr></argument>,
							<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>cagg_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>jobs</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>BgwJob</name> <modifier>*</modifier></type><name>job</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name>jobs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ts_bgw_job_delete_by_id</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>policy_refresh_cagg_remove</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>cagg_oid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>if_not_exists</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="block">/* Deprecating this argument */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>if_exists</name></decl>;</decl_stmt>

	<comment type="block">/* For backward compatibility, we use IF_NOT_EXISTS when IF_EXISTS is not given */</comment>
	<expr_stmt><expr><name>if_exists</name> <operator>=</operator> <ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>if_not_exists</name></expr> </then><else>: <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>policy_refresh_cagg_remove_internal</name><argument_list>(<argument><expr><name>cagg_oid</name></expr></argument>, <argument><expr><name>if_exists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
