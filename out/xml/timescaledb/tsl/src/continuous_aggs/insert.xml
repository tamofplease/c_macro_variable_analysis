<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/timescaledb/tsl/src/continuous_aggs/insert.c"><comment type="block">/*
 * This file and its contents are licensed under the Timescale License.
 * Please see the included NOTICE for copyright information and
 * LICENSE-TIMESCALE for a copy of the license.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postgres.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_type.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;executor/spi.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fmgr.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;commands/dbcommands.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;commands/trigger.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;lib/stringinfo.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;miscadmin.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/hsearch.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/tupconvert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;storage/lmgr.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/builtins.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/rel.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/relcache.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/xact.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;scanner.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compat/compat.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"chunk.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dimension.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hypertable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hypertable_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"invalidation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"export.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"partitioning.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"time_bucket.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ts_catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ts_catalog/continuous_agg.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"continuous_aggs/insert.h"</cpp:file></cpp:include>

<comment type="block">/*
 * When tuples in a hypertable that has a continuous aggregate are modified, the
 * lowest modified value and the greatest modified value must be tracked over
 * the course of a transaction or statement. At the end of the statement these
 * values will be inserted into the proper cache invalidation log table for
 * their associated hypertable if they are below the speculative materialization
 * watermark (or, if in REPEATABLE_READ isolation level or higher, they will be
 * inserted no matter what as we cannot see if a materialization transaction has
 * started and moved the watermark during our transaction in that case).
 *
 * We accomplish this at the transaction level by keeping a hash table of each
 * hypertable that has been modified in the transaction and the lowest and
 * greatest modified values. The hashtable will be updated via a trigger that
 * will be called for every row that is inserted, updated or deleted. We use a
 * hashtable because we need to keep track of this on a per hypertable basis and
 * multiple can have tuples modified during a single transaction. (And if we
 * move to per-chunk cache-invalidation it makes it even easier).
 *
 */</comment>
<typedef>typedef <type><struct>struct <name>ContinuousAggsCacheInvalEntry</name>
<block>{
	<decl_stmt><decl><type><name>int32</name></type> <name>hypertable_id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>hypertable_relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>entry_id</name></decl>;</decl_stmt> <comment type="block">/*
					 * This is what actually gets written to the hypertable log. It can be the same
					 * as the hypertable_id for normal hypertables. In the distributed case it is
					 * the ID of the parent hypertable in the Access Node.
					 */</comment>
	<decl_stmt><decl><type><name>Dimension</name></type> <name>hypertable_open_dimension</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>previous_chunk_relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type> <name>previous_chunk_open_dimension</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>value_is_set</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>lowest_modified_value</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>greatest_modified_value</name></decl>;</decl_stmt>
}</block></struct></type> <name>ContinuousAggsCacheInvalEntry</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>int64</name></type> <name>get_lowest_invalidated_time_for_hypertable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>hypertable_relid</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CA_CACHE_INVAL_INIT_HTAB_SIZE</name></cpp:macro> <cpp:value>64</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>continuous_aggs_cache_inval_htab</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>MemoryContext</name></type> <name>continuous_aggs_trigger_mctx</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<function_decl><type><name>void</name></type> <name>_continuous_aggs_cache_inval_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>_continuous_aggs_cache_inval_fini</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>cache_inval_init</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASHCTL</name></type> <name>ctl</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>continuous_aggs_trigger_mctx</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>continuous_aggs_trigger_mctx</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopTransactionContext</name></expr></argument>,
														 <argument><expr><literal type="string">"ContinuousAggsTriggerCtx"</literal></expr></argument>,
														 <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ContinuousAggsCacheInvalEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <name>continuous_aggs_trigger_mctx</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>continuous_aggs_cache_inval_htab</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"TS Continuous Aggs Cache Inval"</literal></expr></argument>,
												   <argument><expr><name>CA_CACHE_INVAL_INIT_HTAB_SIZE</name></expr></argument>,
												   <argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>,
												   <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name> <operator>|</operator> <name>HASH_CONTEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function><empty_stmt>;</empty_stmt>

<function><type><specifier>static</specifier> <name>int64</name></type>
<name>tuple_get_time</name><parameter_list>(<parameter><decl><type><name>Dimension</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>col</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type> <name>datum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>dimtype</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>col</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>d</name><operator>-&gt;</operator><name>partitioning</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>collation</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>col</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attcollation</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>ts_partitioning_func_apply</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>partitioning</name></name></expr></argument>, <argument><expr><name>collation</name></expr></argument>, <argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>DIMENSION_TYPE_OPEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>dimtype</name> <operator>=</operator> <call><name>ts_dimension_get_partition_type</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NOT_NULL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"NULL value in column \"%s\" violates not-null constraint"</literal></expr></argument>,
						<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>column_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Columns used for time partitioning cannot be NULL"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><call><name>ts_time_value_to_internal</name><argument_list>(<argument><expr><name>datum</name></expr></argument>, <argument><expr><name>dimtype</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>cache_inval_entry_init</name><parameter_list>(<parameter><decl><type><name>ContinuousAggsCacheInvalEntry</name> <modifier>*</modifier></type><name>cache_entry</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>hypertable_id</name></decl></parameter>,
					   <parameter><decl><type><name>int32</name></type> <name>entry_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cache</name> <modifier>*</modifier></type><name>ht_cache</name> <init>= <expr><call><name>ts_hypertable_cache_pin</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="block">/* NOTE: we can remove the id=&gt;relid scan, if it becomes an issue, by getting the
	 * hypertable_relid directly from the Chunk*/</comment>
	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name> <init>= <expr><call><name>ts_hypertable_cache_get_entry_by_id</name><argument_list>(<argument><expr><name>ht_cache</name></expr></argument>, <argument><expr><name>hypertable_id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>cache_entry</name><operator>-&gt;</operator><name>hypertable_id</name></name> <operator>=</operator> <name>hypertable_id</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cache_entry</name><operator>-&gt;</operator><name>entry_id</name></name> <operator>=</operator> <name>entry_id</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cache_entry</name><operator>-&gt;</operator><name>hypertable_relid</name></name> <operator>=</operator> <name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cache_entry</name><operator>-&gt;</operator><name>hypertable_open_dimension</name></name> <operator>=</operator> <operator>*</operator><call><name>hyperspace_get_open_dimension</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>space</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>cache_entry</name><operator>-&gt;</operator><name>hypertable_open_dimension</name><operator>.</operator><name>partitioning</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartitioningInfo</name> <modifier>*</modifier></type><name>open_dim_part_info</name> <init>=
			<expr><call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>continuous_aggs_trigger_mctx</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>open_dim_part_info</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><operator>*</operator><name>open_dim_part_info</name> <operator>=</operator> <operator>*</operator><name><name>cache_entry</name><operator>-&gt;</operator><name>hypertable_open_dimension</name><operator>.</operator><name>partitioning</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cache_entry</name><operator>-&gt;</operator><name>hypertable_open_dimension</name><operator>.</operator><name>partitioning</name></name> <operator>=</operator> <name>open_dim_part_info</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>cache_entry</name><operator>-&gt;</operator><name>previous_chunk_relid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cache_entry</name><operator>-&gt;</operator><name>value_is_set</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cache_entry</name><operator>-&gt;</operator><name>lowest_modified_value</name></name> <operator>=</operator> <name>INVAL_POS_INFINITY</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cache_entry</name><operator>-&gt;</operator><name>greatest_modified_value</name></name> <operator>=</operator> <name>INVAL_NEG_INFINITY</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>ht_cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>cache_entry_switch_to_chunk</name><parameter_list>(<parameter><decl><type><name>ContinuousAggsCacheInvalEntry</name> <modifier>*</modifier></type><name>cache_entry</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>chunk_id</name></decl></parameter>,
							<parameter><decl><type><name>Relation</name></type> <name>chunk_relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>modified_tuple_chunk</name> <init>= <expr><call><name>ts_chunk_get_by_relid</name><argument_list>(<argument><expr><name>chunk_id</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>modified_tuple_chunk</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"continuous agg trigger function must be called on hypertable chunks only"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>cache_entry</name><operator>-&gt;</operator><name>previous_chunk_relid</name></name> <operator>=</operator> <name><name>modified_tuple_chunk</name><operator>-&gt;</operator><name>table_id</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cache_entry</name><operator>-&gt;</operator><name>previous_chunk_open_dimension</name></name> <operator>=</operator>
		<call><name>get_attnum</name><argument_list>(<argument><expr><name><name>chunk_relation</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>,
				   <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>cache_entry</name><operator>-&gt;</operator><name>hypertable_open_dimension</name><operator>.</operator><name>fd</name><operator>.</operator><name>column_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cache_entry</name><operator>-&gt;</operator><name>previous_chunk_open_dimension</name></name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"continuous agg trigger function must be called on hypertable chunks only"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>update_cache_entry</name><parameter_list>(<parameter><decl><type><name>ContinuousAggsCacheInvalEntry</name> <modifier>*</modifier></type><name>cache_entry</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>timeval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>cache_entry</name><operator>-&gt;</operator><name>value_is_set</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>timeval</name> <operator>&lt;</operator> <name><name>cache_entry</name><operator>-&gt;</operator><name>lowest_modified_value</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>cache_entry</name><operator>-&gt;</operator><name>lowest_modified_value</name></name> <operator>=</operator> <name>timeval</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>timeval</name> <operator>&gt;</operator> <name><name>cache_entry</name><operator>-&gt;</operator><name>greatest_modified_value</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>cache_entry</name><operator>-&gt;</operator><name>greatest_modified_value</name></name> <operator>=</operator> <name>timeval</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Trigger to store what the max/min updated values are for a function.
 * This is used by continuous aggregates to ensure that the aggregated values
 * are updated correctly. Upon creating a continuous aggregate for a hypertable,
 * this trigger should be registered, if it does not already exist.
 */</comment>
<function><type><name>Datum</name></type>
<name>continuous_agg_trigfn</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Use TriggerData to determine which row to return/work with, in the case
	 * of updates, we'll need to call the functions twice, once with the old
	 * rows (which act like deletes) and once with the new rows.
	 */</comment>
	<decl_stmt><decl><type><name>TriggerData</name> <modifier>*</modifier></type><name>trigdata</name> <init>= <expr><operator>(</operator><name>TriggerData</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>hypertable_id_str</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>parent_hypertable_id_str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>hypertable_id</name></decl>, <decl><type ref="prev"/><name>parent_hypertable_id</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>is_distributed_hypertable_trigger</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_trigger</name><operator>-&gt;</operator><name>tgnargs</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"must supply hypertable id"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>hypertable_id_str</name> <operator>=</operator> <name><name>trigdata</name><operator>-&gt;</operator><name>tg_trigger</name><operator>-&gt;</operator><name>tgargs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>hypertable_id</name> <operator>=</operator> <call><name>atol</name><argument_list>(<argument><expr><name>hypertable_id_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_trigger</name><operator>-&gt;</operator><name>tgnargs</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>parent_hypertable_id_str</name> <operator>=</operator> <name><name>trigdata</name><operator>-&gt;</operator><name>tg_trigger</name><operator>-&gt;</operator><name>tgargs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>parent_hypertable_id</name> <operator>=</operator> <call><name>atol</name><argument_list>(<argument><expr><name>parent_hypertable_id_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>is_distributed_hypertable_trigger</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CALLED_AS_TRIGGER</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"continuous agg trigger function must be called by trigger manager"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TRIGGER_FIRED_AFTER</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>TRIGGER_FIRED_FOR_ROW</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"continuous agg trigger function must be called in per row after trigger"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>execute_cagg_trigger</name><argument_list>(<argument><expr><name>hypertable_id</name></expr></argument>,
						 <argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_relation</name></name></expr></argument>,
						 <argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_trigtuple</name></name></expr></argument>,
						 <argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_newtuple</name></name></expr></argument>,
						 <argument><expr><call><name>TRIGGER_FIRED_BY_UPDATE</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name>is_distributed_hypertable_trigger</name></expr></argument>,
						 <argument><expr><name>parent_hypertable_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TRIGGER_FIRED_BY_UPDATE</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_trigtuple</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_newtuple</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * chunk_tuple is the tuple from trigdata-&gt;tg_trigtuple
 * i.e. the one being/inserts/deleted/updated.
 * (for updates: this is the row before modification)
 * chunk_newtuple is the tuple from trigdata-&gt;tg_newtuple.
 */</comment>
<function><type><name>void</name></type>
<name>execute_cagg_trigger</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>hypertable_id</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>chunk_rel</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>chunk_tuple</name></decl></parameter>,
					 <parameter><decl><type><name>HeapTuple</name></type> <name>chunk_newtuple</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>update</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_distributed_hypertable_trigger</name></decl></parameter>,
					 <parameter><decl><type><name>int32</name></type> <name>parent_hypertable_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ContinuousAggsCacheInvalEntry</name> <modifier>*</modifier></type><name>cache_entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>timeval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>chunk_relid</name> <init>= <expr><name><name>chunk_rel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></init></decl>;</decl_stmt>
	<comment type="block">/* On first call, init the mctx and hash table */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>continuous_aggs_cache_inval_htab</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>cache_inval_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>cache_entry</name> <operator>=</operator> <operator>(</operator><name>ContinuousAggsCacheInvalEntry</name> <operator>*</operator><operator>)</operator>
		<call><name>hash_search</name><argument_list>(<argument><expr><name>continuous_aggs_cache_inval_htab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hypertable_id</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>cache_inval_entry_init</name><argument_list>(<argument><expr><name>cache_entry</name></expr></argument>,
							   <argument><expr><name>hypertable_id</name></expr></argument>,
							   <argument><expr><ternary><condition><expr><name>is_distributed_hypertable_trigger</name></expr> ?</condition><then> <expr><name>parent_hypertable_id</name></expr> </then><else>:
																   <expr><name>hypertable_id</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* handle the case where we need to repopulate the cached chunk data */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cache_entry</name><operator>-&gt;</operator><name>previous_chunk_relid</name></name> <operator>!=</operator> <name>chunk_relid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>cache_entry_switch_to_chunk</name><argument_list>(<argument><expr><name>cache_entry</name></expr></argument>, <argument><expr><name>chunk_relid</name></expr></argument>, <argument><expr><name>chunk_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>timeval</name> <operator>=</operator> <call><name>tuple_get_time</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cache_entry</name><operator>-&gt;</operator><name>hypertable_open_dimension</name></name></expr></argument>,
							 <argument><expr><name>chunk_tuple</name></expr></argument>,
							 <argument><expr><name><name>cache_entry</name><operator>-&gt;</operator><name>previous_chunk_open_dimension</name></name></expr></argument>,
							 <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>chunk_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>update_cache_entry</name><argument_list>(<argument><expr><name>cache_entry</name></expr></argument>, <argument><expr><name>timeval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>update</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* on update we need to invalidate the new time value as well as the old one */</comment>
	<expr_stmt><expr><name>timeval</name> <operator>=</operator> <call><name>tuple_get_time</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cache_entry</name><operator>-&gt;</operator><name>hypertable_open_dimension</name></name></expr></argument>,
							 <argument><expr><name>chunk_newtuple</name></expr></argument>,
							 <argument><expr><name><name>cache_entry</name><operator>-&gt;</operator><name>previous_chunk_open_dimension</name></name></expr></argument>,
							 <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>chunk_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>update_cache_entry</name><argument_list>(<argument><expr><name>cache_entry</name></expr></argument>, <argument><expr><name>timeval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>cache_inval_entry_write</name><parameter_list>(<parameter><decl><type><name>ContinuousAggsCacheInvalEntry</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int64</name></type> <name>liv</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>entry</name><operator>-&gt;</operator><name>value_is_set</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>Cache</name> <modifier>*</modifier></type><name>ht_cache</name> <init>= <expr><call><name>ts_hypertable_cache_pin</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name> <init>= <expr><call><name>ts_hypertable_cache_get_entry_by_id</name><argument_list>(<argument><expr><name>ht_cache</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>hypertable_id</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>is_distributed_member</name> <init>= <expr><call><name>hypertable_is_distributed_member</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>ht_cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* The materialization worker uses a READ COMMITTED isolation level by default. Therefore, if we
	 * use a stronger isolation level, the isolation thereshold could update without us seeing the
	 * new value. In order to prevent serialization errors, we always append invalidation entries in
	 * the case when we're using a strong enough isolation level that we won't see the new
	 * threshold. The same applies for distributed member invalidation triggers of hypertables.
	 * The materializer can handle invalidations that are beyond the threshold gracefully.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsolationUsesXactSnapshot</name><argument_list>()</argument_list></call> <operator>||</operator> <name>is_distributed_member</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>invalidation_hyper_log_add_entry</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>entry_id</name></name></expr></argument>,
										 <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>lowest_modified_value</name></name></expr></argument>,
										 <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>greatest_modified_value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>liv</name> <operator>=</operator> <call><name>get_lowest_invalidated_time_for_hypertable</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>hypertable_relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>lowest_modified_value</name></name> <operator>&lt;</operator> <name>liv</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>invalidation_hyper_log_add_entry</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>entry_id</name></name></expr></argument>,
										 <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>lowest_modified_value</name></name></expr></argument>,
										 <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>greatest_modified_value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function><empty_stmt>;</empty_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>cache_inval_cleanup</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>continuous_aggs_cache_inval_htab</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name>continuous_aggs_cache_inval_htab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>continuous_aggs_trigger_mctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>continuous_aggs_cache_inval_htab</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>continuous_aggs_trigger_mctx</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function><empty_stmt>;</empty_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>cache_inval_htab_write</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>hash_seq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ContinuousAggsCacheInvalEntry</name> <modifier>*</modifier></type><name>current_entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Catalog</name> <modifier>*</modifier></type><name>catalog</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>hash_get_num_entries</name><argument_list>(<argument><expr><name>continuous_aggs_cache_inval_htab</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>catalog</name> <operator>=</operator> <call><name>ts_catalog_get</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* The invalidation threshold must remain locked until the end of
	 * the transaction to ensure the materializer will see our updates,
	 * so we explicitly lock it here
	 */</comment>
	<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><call><name>catalog_get_table_id</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>CONTINUOUS_AGGS_INVALIDATION_THRESHOLD</name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_seq</name></expr></argument>, <argument><expr><name>continuous_aggs_cache_inval_htab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>current_entry</name> <operator>=</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_seq</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>cache_inval_entry_write</name><argument_list>(<argument><expr><name>current_entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></function><empty_stmt>;</empty_stmt>

<comment type="block">/*
 * We use TopTransactionContext for our cached invalidations.
 * We need to make sure cache_inval_cleanup() is always called after cache_inval_htab_write().
 * We need this memory context to survive the transaction lifetime so that cache_inval_cleanup()
 * does not attempt to tear down memory that has already been freed due to a transaction ending.
 *
 * The order of operations in postgres can be this:
 * CallXactCallbacks(XACT_EVENT_PRE_PREPARE);
 * ...
 * CallXactCallbacks(XACT_EVENT_PREPARE);
 * ...
 * MemoryContextDelete(TopTransactionContext);
 *
 * or that:
 * CallXactCallbacks(XACT_EVENT_PRE_COMMIT);
 * ...
 * CallXactCallbacks(XACT_EVENT_COMMIT);
 * ...
 * MemoryContextDelete(TopTransactionContext);
 *
 * In the case of a 2PC transaction, we need to make sure to apply the invalidations at
 * XACT_EVENT_PRE_PREPARE time, before TopTransactionContext is torn down by PREPARE TRANSACTION.
 * Otherwise, we are unable to call cache_inval_cleanup() without corrupting the memory. For
 * this reason, we also deallocate at XACT_EVENT_PREPARE time.
 *
 * For local transactions we apply the invalidations at XACT_EVENT_PRE_COMMIT time.
 * Similar care is taken of parallel workers and aborting transactions.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>continuous_agg_xact_invalidation_callback</name><parameter_list>(<parameter><decl><type><name>XactEvent</name></type> <name>event</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Return quickly if we never initialize the hashtable */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>continuous_aggs_cache_inval_htab</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><name>event</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>XACT_EVENT_PRE_PREPARE</name></expr>:</case>
		<case>case <expr><name>XACT_EVENT_PRE_COMMIT</name></expr>:</case>
		<case>case <expr><name>XACT_EVENT_PARALLEL_PRE_COMMIT</name></expr>:</case>
			<expr_stmt><expr><call><name>cache_inval_htab_write</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>XACT_EVENT_PREPARE</name></expr>:</case>
		<case>case <expr><name>XACT_EVENT_COMMIT</name></expr>:</case>
		<case>case <expr><name>XACT_EVENT_PARALLEL_COMMIT</name></expr>:</case>
		<case>case <expr><name>XACT_EVENT_ABORT</name></expr>:</case>
		<case>case <expr><name>XACT_EVENT_PARALLEL_ABORT</name></expr>:</case>
			<expr_stmt><expr><call><name>cache_inval_cleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>_continuous_aggs_cache_inval_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>RegisterXactCallback</name><argument_list>(<argument><expr><name>continuous_agg_xact_invalidation_callback</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>_continuous_aggs_cache_inval_fini</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>UnregisterXactCallback</name><argument_list>(<argument><expr><name>continuous_agg_xact_invalidation_callback</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ScanTupleResult</name></type>
<name>invalidation_tuple_found</name><parameter_list>(<parameter><decl><type><name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>min</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>watermark</name> <init>=
		<expr><call><name>slot_getattr</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>slot</name></name></expr></argument>, <argument><expr><name>Anum_continuous_aggs_invalidation_threshold_watermark</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>DatumGetInt64</name><argument_list>(<argument><expr><name>watermark</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>int64</name> <operator>*</operator><operator>)</operator> <name>min</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>int64</name> <operator>*</operator><operator>)</operator> <name>min</name><operator>)</operator> <operator>=</operator> <call><name>DatumGetInt64</name><argument_list>(<argument><expr><name>watermark</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Return SCAN_CONTINUE because we check for multiple tuples as an error
	 * condition.
	 */</comment>
	<return>return <expr><name>SCAN_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int64</name></type>
<name>get_lowest_invalidated_time_for_hypertable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>hypertable_relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int64</name></type> <name>min_val</name> <init>= <expr><name>INVAL_POS_INFINITY</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Catalog</name> <modifier>*</modifier></type><name>catalog</name> <init>= <expr><call><name>ts_catalog_get</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scankey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScannerCtx</name></type> <name>scanctx</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scankey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_continuous_aggs_invalidation_threshold_pkey_hypertable_id</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
				<argument><expr><name>F_INT4EQ</name></expr></argument>,
				<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><call><name>ts_hypertable_relid_to_id</name><argument_list>(<argument><expr><name>hypertable_relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scanctx</name> <operator>=</operator> <operator>(</operator><name>ScannerCtx</name><operator>)</operator><block>{
		<expr><operator>.</operator><name>table</name> <operator>=</operator> <call><name>catalog_get_table_id</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>CONTINUOUS_AGGS_INVALIDATION_THRESHOLD</name></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>index</name> <operator>=</operator> <call><name>catalog_get_index</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>,
								   <argument><expr><name>CONTINUOUS_AGGS_INVALIDATION_THRESHOLD</name></expr></argument>,
								   <argument><expr><name>CONTINUOUS_AGGS_INVALIDATION_THRESHOLD_PKEY</name></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>nkeys</name> <operator>=</operator> <literal type="number">1</literal></expr>,
		<expr><operator>.</operator><name>scankey</name> <operator>=</operator> <name>scankey</name></expr>,
		<expr><operator>.</operator><name>tuple_found</name> <operator>=</operator> <operator>&amp;</operator><name>invalidation_tuple_found</name></expr>,
		<expr><operator>.</operator><name>filter</name> <operator>=</operator> <name>NULL</name></expr>,
		<expr><operator>.</operator><name>data</name> <operator>=</operator> <operator>&amp;</operator><name>min_val</name></expr>,
		<expr><operator>.</operator><name>lockmode</name> <operator>=</operator> <name>AccessShareLock</name></expr>,
		<expr><operator>.</operator><name>scandirection</name> <operator>=</operator> <name>ForwardScanDirection</name></expr>,
		<expr><operator>.</operator><name>result_mctx</name> <operator>=</operator> <name>NULL</name></expr>,
	}</block></expr>;</expr_stmt>

	<comment type="block">/* if we don't find any watermark, then we've never done any materialization
	 * we'll treat this as if the invalidation timestamp is at min value, since
	 * the first materialization needs to scan the entire table anyway; the
	 * invalidations are redundant.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ts_scanner_scan_one</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scanctx</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">"invalidation watermark"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>INVAL_NEG_INFINITY</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>min_val</name></expr>;</return>
</block_content>}</block></function>
</unit>
