<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/timescaledb/tsl/src/continuous_aggs/materialize.c"><comment type="block">/*
 * This file and its contents are licensed under the Timescale License.
 * Please see the included NOTICE for copyright information and
 * LICENSE-TIMESCALE for a copy of the license.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postgres.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;executor/spi.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fmgr.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;lib/stringinfo.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/builtins.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/rel.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/relcache.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/date.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/snapmgr.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;scanner.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;compat/compat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;scan_iterator.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ts_catalog/continuous_agg.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time_utils.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"materialize.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ranges_overlap</name><parameter_list>(<parameter><decl><type><name>InternalTimeRange</name></type> <name>invalidation_range</name></decl></parameter>,
						   <parameter><decl><type><name>InternalTimeRange</name></type> <name>new_materialization_range</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TimeRange</name></type> <name>internal_time_range_to_time_range</name><parameter_list>(<parameter><decl><type><name>InternalTimeRange</name></type> <name>internal</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int64</name></type> <name>range_length</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>InternalTimeRange</name></type> <name>range</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>internal_to_time_value_or_infinite</name><parameter_list>(<parameter><decl><type><name>int64</name></type> <name>internal</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>time_type</name></decl></parameter>,
												<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_infinite_out</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block" format="doxygen">/***************************
 * materialization support *
 ***************************/</comment>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>spi_update_materializations</name><parameter_list>(<parameter><decl><type><name>SchemaAndName</name></type> <name>partial_view</name></decl></parameter>,
										<parameter><decl><type><name>SchemaAndName</name></type> <name>materialization_table</name></decl></parameter>,
										<parameter><decl><type><specifier>const</specifier> <name>NameData</name> <modifier>*</modifier></type><name>time_column_name</name></decl></parameter>,
										<parameter><decl><type><name>TimeRange</name></type> <name>invalidation_range</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int32</name></type> <name>chunk_id</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>spi_delete_materializations</name><parameter_list>(<parameter><decl><type><name>SchemaAndName</name></type> <name>materialization_table</name></decl></parameter>,
										<parameter><decl><type><specifier>const</specifier> <name>NameData</name> <modifier>*</modifier></type><name>time_column_name</name></decl></parameter>,
										<parameter><decl><type><name>TimeRange</name></type> <name>invalidation_range</name></decl></parameter>,
										<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>chunk_condition</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>spi_insert_materializations</name><parameter_list>(<parameter><decl><type><name>SchemaAndName</name></type> <name>partial_view</name></decl></parameter>,
										<parameter><decl><type><name>SchemaAndName</name></type> <name>materialization_table</name></decl></parameter>,
										<parameter><decl><type><specifier>const</specifier> <name>NameData</name> <modifier>*</modifier></type><name>time_column_name</name></decl></parameter>,
										<parameter><decl><type><name>TimeRange</name></type> <name>materialization_range</name></decl></parameter>,
										<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>chunk_condition</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>void</name></type>
<name>continuous_agg_update_materialization</name><parameter_list>(<parameter><decl><type><name>SchemaAndName</name></type> <name>partial_view</name></decl></parameter>,
									  <parameter><decl><type><name>SchemaAndName</name></type> <name>materialization_table</name></decl></parameter>,
									  <parameter><decl><type><specifier>const</specifier> <name>NameData</name> <modifier>*</modifier></type><name>time_column_name</name></decl></parameter>,
									  <parameter><decl><type><name>InternalTimeRange</name></type> <name>new_materialization_range</name></decl></parameter>,
									  <parameter><decl><type><name>InternalTimeRange</name></type> <name>invalidation_range</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>chunk_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>InternalTimeRange</name></type> <name>combined_materialization_range</name> <init>= <expr><name>new_materialization_range</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>materialize_invalidations_separately</name> <init>= <expr><call><name>range_length</name><argument_list>(<argument><expr><name>invalidation_range</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>SPI_connect</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>!=</operator> <name>SPI_OK_CONNECT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not connect to SPI in materializer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* pin the start of new_materialization to the end of new_materialization,
	 * we are not allowed to materialize beyond that point
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>new_materialization_range</name><operator>.</operator><name>start</name></name> <operator>&gt;</operator> <name><name>new_materialization_range</name><operator>.</operator><name>end</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>new_materialization_range</name><operator>.</operator><name>start</name></name> <operator>=</operator> <name><name>new_materialization_range</name><operator>.</operator><name>end</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>range_length</name><argument_list>(<argument><expr><name>invalidation_range</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>invalidation_range</name><operator>.</operator><name>start</name></name> <operator>&lt;=</operator> <name><name>invalidation_range</name><operator>.</operator><name>end</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* we never materialize beyond the new materialization range */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>invalidation_range</name><operator>.</operator><name>start</name></name> <operator>&gt;=</operator> <name><name>new_materialization_range</name><operator>.</operator><name>end</name></name> <operator>||</operator>
			<name><name>invalidation_range</name><operator>.</operator><name>end</name></name> <operator>&gt;</operator> <name><name>new_materialization_range</name><operator>.</operator><name>end</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"internal error: invalidation range ahead of new materialization range"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* If the invalidation and new materialization ranges overlap, materialize in one go */</comment>
		<expr_stmt><expr><name>materialize_invalidations_separately</name> <operator>=</operator>
			<operator>!</operator><call><name>ranges_overlap</name><argument_list>(<argument><expr><name>invalidation_range</name></expr></argument>, <argument><expr><name>new_materialization_range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>combined_materialization_range</name><operator>.</operator><name>start</name></name> <operator>=</operator>
			<call><name>int64_min</name><argument_list>(<argument><expr><name><name>invalidation_range</name><operator>.</operator><name>start</name></name></expr></argument>, <argument><expr><name><name>new_materialization_range</name><operator>.</operator><name>start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Then insert the materializations.
	 * We insert them in two groups:
	 * [lowest_invalidated, greatest_invalidated] and
	 * [start_of_new_materialization, end_of_new_materialization]
	 * eventually, we may want more precise deletions and insertions for the invalidated ranges.
	 * if greatest_invalidated == end_of_new_materialization then we only perform 1 insertion.
	 * to prevent values from being inserted multiple times.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>range_length</name><argument_list>(<argument><expr><name>invalidation_range</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>!</operator><name>materialize_invalidations_separately</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>spi_update_materializations</name><argument_list>(<argument><expr><name>partial_view</name></expr></argument>,
									<argument><expr><name>materialization_table</name></expr></argument>,
									<argument><expr><name>time_column_name</name></expr></argument>,
									<argument><expr><call><name>internal_time_range_to_time_range</name><argument_list>(
										<argument><expr><name>combined_materialization_range</name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><name>chunk_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>spi_update_materializations</name><argument_list>(<argument><expr><name>partial_view</name></expr></argument>,
									<argument><expr><name>materialization_table</name></expr></argument>,
									<argument><expr><name>time_column_name</name></expr></argument>,
									<argument><expr><call><name>internal_time_range_to_time_range</name><argument_list>(<argument><expr><name>invalidation_range</name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><name>chunk_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>spi_update_materializations</name><argument_list>(<argument><expr><name>partial_view</name></expr></argument>,
									<argument><expr><name>materialization_table</name></expr></argument>,
									<argument><expr><name>time_column_name</name></expr></argument>,
									<argument><expr><call><name>internal_time_range_to_time_range</name><argument_list>(<argument><expr><name>new_materialization_range</name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><name>chunk_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>SPI_finish</name><argument_list>()</argument_list></call><operator>)</operator> <operator>!=</operator> <name>SPI_OK_FINISH</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_finish failed: %s"</literal></expr></argument>, <argument><expr><call><name>SPI_result_code_string</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ranges_overlap</name><parameter_list>(<parameter><decl><type><name>InternalTimeRange</name></type> <name>invalidation_range</name></decl></parameter>, <parameter><decl><type><name>InternalTimeRange</name></type> <name>new_materialization_range</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>invalidation_range</name><operator>.</operator><name>start</name></name> <operator>&lt;=</operator> <name><name>invalidation_range</name><operator>.</operator><name>end</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>new_materialization_range</name><operator>.</operator><name>start</name></name> <operator>&lt;=</operator> <name><name>new_materialization_range</name><operator>.</operator><name>end</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>!</operator><operator>(</operator><name><name>invalidation_range</name><operator>.</operator><name>end</name></name> <operator>&lt;</operator> <name><name>new_materialization_range</name><operator>.</operator><name>start</name></name> <operator>||</operator>
			 <name><name>new_materialization_range</name><operator>.</operator><name>end</name></name> <operator>&lt;</operator> <name><name>invalidation_range</name><operator>.</operator><name>start</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int64</name></type>
<name>range_length</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>InternalTimeRange</name></type> <name>range</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>range</name><operator>.</operator><name>end</name></name> <operator>&gt;=</operator> <name><name>range</name><operator>.</operator><name>start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>int64_saturating_sub</name><argument_list>(<argument><expr><name><name>range</name><operator>.</operator><name>end</name></name></expr></argument>, <argument><expr><name><name>range</name><operator>.</operator><name>start</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>time_range_internal_to_min_time_value</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>type</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>TIMESTAMPOID</name></expr>:</case>
			<return>return <expr><call><name>TimestampGetDatum</name><argument_list>(<argument><expr><name>DT_NOBEGIN</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>TIMESTAMPTZOID</name></expr>:</case>
			<return>return <expr><call><name>TimestampTzGetDatum</name><argument_list>(<argument><expr><name>DT_NOBEGIN</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>DATEOID</name></expr>:</case>
			<return>return <expr><call><name>DateADTGetDatum</name><argument_list>(<argument><expr><name>DATEVAL_NOBEGIN</name></expr></argument>)</argument_list></call></expr>;</return>
		<default>default:</default>
			<return>return <expr><call><name>ts_internal_to_time_value</name><argument_list>(<argument><expr><name>PG_INT64_MIN</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>time_range_internal_to_max_time_value</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>type</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>TIMESTAMPOID</name></expr>:</case>
			<return>return <expr><call><name>TimestampGetDatum</name><argument_list>(<argument><expr><name>DT_NOEND</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>TIMESTAMPTZOID</name></expr>:</case>
			<return>return <expr><call><name>TimestampTzGetDatum</name><argument_list>(<argument><expr><name>DT_NOEND</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>DATEOID</name></expr>:</case>
			<return>return <expr><call><name>DateADTGetDatum</name><argument_list>(<argument><expr><name>DATEVAL_NOEND</name></expr></argument>)</argument_list></call></expr>;</return>
			<break>break;</break>
		<default>default:</default>
			<return>return <expr><call><name>ts_internal_to_time_value</name><argument_list>(<argument><expr><name>PG_INT64_MAX</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>internal_to_time_value_or_infinite</name><parameter_list>(<parameter><decl><type><name>int64</name></type> <name>internal</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>time_type</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_infinite_out</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* MIN and MAX can occur due to NULL thresholds, or due to a lack of invalidations. Since our
	 * regular conversion function errors in those cases, and we want to use those as markers for an
	 * open threshold in one direction, we special case this here*/</comment>
	<if_stmt><if>if <condition>(<expr><name>internal</name> <operator>==</operator> <name>PG_INT64_MIN</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>is_infinite_out</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>is_infinite_out</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><call><name>time_range_internal_to_min_time_value</name><argument_list>(<argument><expr><name>time_type</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>internal</name> <operator>==</operator> <name>PG_INT64_MAX</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>is_infinite_out</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>is_infinite_out</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><call><name>time_range_internal_to_max_time_value</name><argument_list>(<argument><expr><name>time_type</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>is_infinite_out</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>is_infinite_out</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><call><name>ts_internal_to_time_value</name><argument_list>(<argument><expr><name>internal</name></expr></argument>, <argument><expr><name>time_type</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TimeRange</name></type>
<name>internal_time_range_to_time_range</name><parameter_list>(<parameter><decl><type><name>InternalTimeRange</name></type> <name>internal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeRange</name></type> <name>range</name></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>range</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name><name>internal</name><operator>.</operator><name>type</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>range</name><operator>.</operator><name>start</name></name> <operator>=</operator> <call><name>internal_to_time_value_or_infinite</name><argument_list>(<argument><expr><name><name>internal</name><operator>.</operator><name>start</name></name></expr></argument>, <argument><expr><name><name>internal</name><operator>.</operator><name>type</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>range</name><operator>.</operator><name>end</name></name> <operator>=</operator> <call><name>internal_to_time_value_or_infinite</name><argument_list>(<argument><expr><name><name>internal</name><operator>.</operator><name>end</name></name></expr></argument>, <argument><expr><name><name>internal</name><operator>.</operator><name>type</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>range</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>spi_update_materializations</name><parameter_list>(<parameter><decl><type><name>SchemaAndName</name></type> <name>partial_view</name></decl></parameter>, <parameter><decl><type><name>SchemaAndName</name></type> <name>materialization_table</name></decl></parameter>,
							<parameter><decl><type><specifier>const</specifier> <name>NameData</name> <modifier>*</modifier></type><name>time_column_name</name></decl></parameter>, <parameter><decl><type><name>TimeRange</name></type> <name>invalidation_range</name></decl></parameter>,
							<parameter><decl><type><specifier>const</specifier> <name>int32</name></type> <name>chunk_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>chunk_condition</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * chunk_id is valid if the materializaion update should be done only on the given chunk.
	 * This is used currently for refresh on chunk drop only. In other cases, manual
	 * call to refresh_continuous_aggregate or call from a refresh policy, chunk_id is
	 * not provided, i.e., invalid.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>chunk_id</name> <operator>!=</operator> <name>INVALID_CHUNK_ID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>chunk_condition</name></expr></argument>, <argument><expr><literal type="string">"AND chunk_id = %d"</literal></expr></argument>, <argument><expr><name>chunk_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>spi_delete_materializations</name><argument_list>(<argument><expr><name>materialization_table</name></expr></argument>,
								<argument><expr><name>time_column_name</name></expr></argument>,
								<argument><expr><name>invalidation_range</name></expr></argument>,
								<argument><expr><name><name>chunk_condition</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>spi_insert_materializations</name><argument_list>(<argument><expr><name>partial_view</name></expr></argument>,
								<argument><expr><name>materialization_table</name></expr></argument>,
								<argument><expr><name>time_column_name</name></expr></argument>,
								<argument><expr><name>invalidation_range</name></expr></argument>,
								<argument><expr><name><name>chunk_condition</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>spi_delete_materializations</name><parameter_list>(<parameter><decl><type><name>SchemaAndName</name></type> <name>materialization_table</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NameData</name> <modifier>*</modifier></type><name>time_column_name</name></decl></parameter>,
							<parameter><decl><type><name>TimeRange</name></type> <name>invalidation_range</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>chunk_condition</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>command</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>out_fn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>type_is_varlena</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>invalidation_start</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>invalidation_end</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name><name>invalidation_range</name><operator>.</operator><name>type</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>out_fn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type_is_varlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>invalidation_start</name> <operator>=</operator> <call><name>OidOutputFunctionCall</name><argument_list>(<argument><expr><name>out_fn</name></expr></argument>, <argument><expr><name><name>invalidation_range</name><operator>.</operator><name>start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>invalidation_end</name> <operator>=</operator> <call><name>OidOutputFunctionCall</name><argument_list>(<argument><expr><name>out_fn</name></expr></argument>, <argument><expr><name><name>invalidation_range</name><operator>.</operator><name>end</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>command</name></expr></argument>,
					 <argument><expr><literal type="string">"DELETE FROM %s.%s AS D WHERE "</literal>
					 <literal type="string">"D.%s &gt;= %s AND D.%s &lt; %s %s;"</literal></expr></argument>,
					 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name><name>materialization_table</name><operator>.</operator><name>schema</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name><name>materialization_table</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>time_column_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>invalidation_start</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>time_column_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>invalidation_end</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name>chunk_condition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>SPI_execute_with_args</name><argument_list>(<argument><expr><name><name>command</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
								<argument><expr><literal type="number">0</literal></expr></argument> <comment type="block">/*=nargs*/</comment>,
								<argument><expr><name>NULL</name></expr></argument>,
								<argument><expr><name>NULL</name></expr></argument>,
								<argument><expr><name>NULL</name></expr></argument> <comment type="block">/*=Nulls*/</comment>,
								<argument><expr><name>false</name></expr></argument> <comment type="block">/*=read_only*/</comment>,
								<argument><expr><literal type="number">0</literal></expr></argument> <comment type="block">/*count*/</comment>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not delete old values from materialization table"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>spi_insert_materializations</name><parameter_list>(<parameter><decl><type><name>SchemaAndName</name></type> <name>partial_view</name></decl></parameter>, <parameter><decl><type><name>SchemaAndName</name></type> <name>materialization_table</name></decl></parameter>,
							<parameter><decl><type><specifier>const</specifier> <name>NameData</name> <modifier>*</modifier></type><name>time_column_name</name></decl></parameter>, <parameter><decl><type><name>TimeRange</name></type> <name>materialization_range</name></decl></parameter>,
							<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>chunk_condition</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>command</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>out_fn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>type_is_varlena</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>materialization_start</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>materialization_end</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name><name>materialization_range</name><operator>.</operator><name>type</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>out_fn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type_is_varlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>materialization_start</name> <operator>=</operator> <call><name>OidOutputFunctionCall</name><argument_list>(<argument><expr><name>out_fn</name></expr></argument>, <argument><expr><name><name>materialization_range</name><operator>.</operator><name>start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>materialization_end</name> <operator>=</operator> <call><name>OidOutputFunctionCall</name><argument_list>(<argument><expr><name>out_fn</name></expr></argument>, <argument><expr><name><name>materialization_range</name><operator>.</operator><name>end</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>command</name></expr></argument>,
					 <argument><expr><literal type="string">"INSERT INTO %s.%s SELECT * FROM %s.%s AS I "</literal>
					 <literal type="string">"WHERE I.%s &gt;= %s AND I.%s &lt; %s %s;"</literal></expr></argument>,
					 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name><name>materialization_table</name><operator>.</operator><name>schema</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name><name>materialization_table</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name><name>partial_view</name><operator>.</operator><name>schema</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name><name>partial_view</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>time_column_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>materialization_start</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>time_column_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>materialization_end</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name>chunk_condition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>SPI_execute_with_args</name><argument_list>(<argument><expr><name><name>command</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
								<argument><expr><literal type="number">0</literal></expr></argument> <comment type="block">/*=nargs*/</comment>,
								<argument><expr><name>NULL</name></expr></argument> <comment type="block">/*=argtypes*/</comment>,
								<argument><expr><name>NULL</name></expr></argument> <comment type="block">/*=Values*/</comment>,
								<argument><expr><name>NULL</name></expr></argument> <comment type="block">/*=Nulls*/</comment>,
								<argument><expr><name>false</name></expr></argument> <comment type="block">/*=read_only*/</comment>,
								<argument><expr><literal type="number">0</literal></expr></argument> <comment type="block">/*count*/</comment>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not materialize values into the materialization table"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
</unit>
