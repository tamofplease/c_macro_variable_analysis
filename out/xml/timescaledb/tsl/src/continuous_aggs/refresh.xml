<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/timescaledb/tsl/src/continuous_aggs/refresh.c"><comment type="block">/*
 * This file and its contents are licensed under the Timescale License.
 * Please see the included NOTICE for copyright information and
 * LICENSE-TIMESCALE for a copy of the license.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postgres.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/acl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/lsyscache.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/fmgrprotos.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/snapmgr.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/guc.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/builtins.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/xact.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;storage/lmgr.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;miscadmin.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fmgr.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;executor/spi.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ts_catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ts_catalog/continuous_agg.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dimension.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;hypertable.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;hypertable_cache.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time_bucket.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time_utils.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"refresh.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"materialize.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"invalidation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"invalidation_threshold.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"guc.h"</cpp:file></cpp:include>

<typedef>typedef <type><struct>struct <name>CaggRefreshState</name>
<block>{
	<decl_stmt><decl><type><name>ContinuousAgg</name></type> <name>cagg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>cagg_ht</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>InternalTimeRange</name></type> <name>refresh_window</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SchemaAndName</name></type> <name>partial_view</name></decl>;</decl_stmt>
}</block></struct></type> <name>CaggRefreshState</name>;</typedef>

<function><type><specifier>static</specifier> <name>Hypertable</name> <modifier>*</modifier></type>
<name>cagg_get_hypertable_or_fail</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>hypertable_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name> <init>= <expr><call><name>ts_hypertable_get_by_id</name><argument_list>(<argument><expr><name>hypertable_id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>ht</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid continuous aggregate state"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"A continuous aggregate references a hypertable that does not exist."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>ht</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Compute the largest possible bucketed window given the time type and
 * internal restrictions.
 *
 * The largest bucketed window is governed by restrictions set by the type and
 * internal, TimescaleDB-specific legacy details (see get_max_window above for
 * further explanation).
 */</comment>
<function><type><specifier>static</specifier> <name>InternalTimeRange</name></type>
<name>get_largest_bucketed_window</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>timetype</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>bucket_width</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>InternalTimeRange</name></type> <name>maxwindow</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>timetype</name></expr>,
		<expr><operator>.</operator><name>start</name> <operator>=</operator> <call><name>ts_time_get_min</name><argument_list>(<argument><expr><name>timetype</name></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>end</name> <operator>=</operator> <call><name>ts_time_get_end_or_max</name><argument_list>(<argument><expr><name>timetype</name></expr></argument>)</argument_list></call></expr>,
	}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>InternalTimeRange</name></type> <name>maxbuckets</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>timetype</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<comment type="block">/* For the MIN value, the corresponding bucket either falls on the exact
	 * MIN or it will be below it. Therefore, we add (bucket_width - 1) to
	 * move to the next bucket to be within the allowed range. */</comment>
	<expr_stmt><expr><name><name>maxwindow</name><operator>.</operator><name>start</name></name> <operator>=</operator> <call><name>ts_time_saturating_add</name><argument_list>(<argument><expr><name><name>maxwindow</name><operator>.</operator><name>start</name></name></expr></argument>, <argument><expr><name>bucket_width</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>timetype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>maxbuckets</name><operator>.</operator><name>start</name></name> <operator>=</operator> <call><name>ts_time_bucket_by_type</name><argument_list>(<argument><expr><name>bucket_width</name></expr></argument>, <argument><expr><name><name>maxwindow</name><operator>.</operator><name>start</name></name></expr></argument>, <argument><expr><name>timetype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>maxbuckets</name><operator>.</operator><name>end</name></name> <operator>=</operator> <call><name>ts_time_get_end_or_max</name><argument_list>(<argument><expr><name>timetype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>maxbuckets</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Adjust the refresh window to align with inscribed buckets, so it includes buckets, which are
 * fully covered by the refresh window.
 *
 * Bucketing refresh window is necessary for a continuous aggregate refresh, which can refresh only
 * entire buckets. The result of the function is a bucketed window, where its start is at the start
 * of the first bucket, which is  fully inside the refresh window, and its end is at the end of the
 * last fully covered bucket.
 *
 * Example1, the window needs to shrink:
 *    [---------)      - given refresh window
 * .|....|....|....|.  - buckets
 *       [----)        - inscribed bucketed window
 *
 * Example2, the window is already aligned:
 *       [----)        - given refresh window
 * .|....|....|....|.  - buckets
 *       [----)        - inscribed bucketed window
 *
 * This function is called for the continuous aggregate policy and manual refresh. In such case
 * excluding buckets, which are not fully covered by the refresh window, avoids refreshing a bucket,
 * where part of its data were dropped by a retention policy. See #2198 for details.
 */</comment>
<function><type><specifier>static</specifier> <name>InternalTimeRange</name></type>
<name>compute_inscribed_bucketed_refresh_window</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>InternalTimeRange</name> <modifier>*</modifier><specifier>const</specifier></type> <name>refresh_window</name></decl></parameter>,
										  <parameter><decl><type><specifier>const</specifier> <name>int64</name></type> <name>bucket_width</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>InternalTimeRange</name></type> <name>result</name> <init>= <expr><operator>*</operator><name>refresh_window</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>InternalTimeRange</name></type> <name>largest_bucketed_window</name> <init>=
		<expr><call><name>get_largest_bucketed_window</name><argument_list>(<argument><expr><name><name>refresh_window</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name>bucket_width</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>refresh_window</name><operator>-&gt;</operator><name>start</name></name> <operator>&lt;=</operator> <name><name>largest_bucketed_window</name><operator>.</operator><name>start</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>result</name><operator>.</operator><name>start</name></name> <operator>=</operator> <name><name>largest_bucketed_window</name><operator>.</operator><name>start</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* The start time needs to be aligned with the first fully enclosed bucket.
		 * So the original window start is moved to next bucket, except if the start is
		 * already aligned with a bucket, thus 1 is subtracted to avoid moving into next
		 * bucket in the aligned case. */</comment>
		<decl_stmt><decl><type><name>int64</name></type> <name>included_bucket</name> <init>=
			<expr><call><name>ts_time_saturating_add</name><argument_list>(<argument><expr><name><name>refresh_window</name><operator>-&gt;</operator><name>start</name></name></expr></argument>, <argument><expr><name>bucket_width</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>refresh_window</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="block">/* Get the start of the included bucket. */</comment>
		<expr_stmt><expr><name><name>result</name><operator>.</operator><name>start</name></name> <operator>=</operator> <call><name>ts_time_bucket_by_type</name><argument_list>(<argument><expr><name>bucket_width</name></expr></argument>, <argument><expr><name>included_bucket</name></expr></argument>, <argument><expr><name><name>refresh_window</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>refresh_window</name><operator>-&gt;</operator><name>end</name></name> <operator>&gt;=</operator> <name><name>largest_bucketed_window</name><operator>.</operator><name>end</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>result</name><operator>.</operator><name>end</name></name> <operator>=</operator> <name><name>largest_bucketed_window</name><operator>.</operator><name>end</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* The window is reduced to the beginning of the bucket, which contains the exclusive
		 * end of the refresh window. */</comment>
		<expr_stmt><expr><name><name>result</name><operator>.</operator><name>end</name></name> <operator>=</operator>
			<call><name>ts_time_bucket_by_type</name><argument_list>(<argument><expr><name>bucket_width</name></expr></argument>, <argument><expr><name><name>refresh_window</name><operator>-&gt;</operator><name>end</name></name></expr></argument>, <argument><expr><name><name>refresh_window</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Adjust the refresh window to align with circumscribed buckets, so it includes buckets, which
 * fully cover the refresh window.
 *
 * Bucketing refresh window is necessary for a continuous aggregate refresh, which can refresh only
 * entire buckets. The result of the function is a bucketed window, where its start is at the start
 * of a bucket, which contains the start of the refresh window, and its end is at the end of a
 * bucket, which contains the end of the refresh window.
 *
 * Example1, the window needs to expand:
 *    [---------)      - given refresh window
 * .|....|....|....|.  - buckets
 *  [--------------)   - circumscribed bucketed window
 *
 * Example2, the window is already aligned:
 *       [----)        - given refresh window
 * .|....|....|....|.  - buckets
 *       [----)        - inscribed bucketed window
 *
 * This function is called for an invalidation window before refreshing it and after the
 * invalidation window was adjusted to be fully inside a refresh window. In the case of a
 * continuous aggregate policy or manual refresh, the refresh window is the inscribed bucketed
 * window.
 *
 * The circumscribed behaviour is also used for a refresh on drop, when the refresh is called during
 * dropping chunks manually or as part of retention policy.
 */</comment>
<function><type><specifier>static</specifier> <name>InternalTimeRange</name></type>
<name>compute_circumscribed_bucketed_refresh_window</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>InternalTimeRange</name> <modifier>*</modifier><specifier>const</specifier></type> <name>refresh_window</name></decl></parameter>,
											  <parameter><decl><type><specifier>const</specifier> <name>int64</name></type> <name>bucket_width</name></decl></parameter>,
											  <parameter><decl><type><specifier>const</specifier> <name>ContinuousAggsBucketFunction</name> <modifier>*</modifier></type><name>bucket_function</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>bucket_width</name> <operator>==</operator> <name>BUCKET_WIDTH_VARIABLE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>InternalTimeRange</name></type> <name>result</name> <init>= <expr><operator>*</operator><name>refresh_window</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ts_compute_circumscribed_bucketed_refresh_window_variable</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>start</name></name></expr></argument>,
																  <argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>end</name></name></expr></argument>,
																  <argument><expr><name>bucket_function</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>InternalTimeRange</name></type> <name>result</name> <init>= <expr><operator>*</operator><name>refresh_window</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>InternalTimeRange</name></type> <name>largest_bucketed_window</name> <init>=
		<expr><call><name>get_largest_bucketed_window</name><argument_list>(<argument><expr><name><name>refresh_window</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name>bucket_width</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>refresh_window</name><operator>-&gt;</operator><name>start</name></name> <operator>&lt;=</operator> <name><name>largest_bucketed_window</name><operator>.</operator><name>start</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>result</name><operator>.</operator><name>start</name></name> <operator>=</operator> <name><name>largest_bucketed_window</name><operator>.</operator><name>start</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* For alignment with a bucket, which includes the start of the refresh window, we just
		 * need to get start of the bucket. */</comment>
		<expr_stmt><expr><name><name>result</name><operator>.</operator><name>start</name></name> <operator>=</operator>
			<call><name>ts_time_bucket_by_type</name><argument_list>(<argument><expr><name>bucket_width</name></expr></argument>, <argument><expr><name><name>refresh_window</name><operator>-&gt;</operator><name>start</name></name></expr></argument>, <argument><expr><name><name>refresh_window</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>refresh_window</name><operator>-&gt;</operator><name>end</name></name> <operator>&gt;=</operator> <name><name>largest_bucketed_window</name><operator>.</operator><name>end</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>result</name><operator>.</operator><name>end</name></name> <operator>=</operator> <name><name>largest_bucketed_window</name><operator>.</operator><name>end</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>int64</name></type> <name>exclusive_end</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int64</name></type> <name>bucketed_end</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>refresh_window</name><operator>-&gt;</operator><name>end</name></name> <operator>&gt;</operator> <name><name>result</name><operator>.</operator><name>start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* The end of the window is non-inclusive so subtract one before
		 * bucketing in case we're already at the end of the bucket (we don't
		 * want to add an extra bucket).  */</comment>
		<expr_stmt><expr><name>exclusive_end</name> <operator>=</operator> <call><name>ts_time_saturating_sub</name><argument_list>(<argument><expr><name><name>refresh_window</name><operator>-&gt;</operator><name>end</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>refresh_window</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bucketed_end</name> <operator>=</operator> <call><name>ts_time_bucket_by_type</name><argument_list>(<argument><expr><name>bucket_width</name></expr></argument>, <argument><expr><name>exclusive_end</name></expr></argument>, <argument><expr><name><name>refresh_window</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* We get the time value for the start of the bucket, so need to add
		 * bucket_width to get the end of it. */</comment>
		<expr_stmt><expr><name><name>result</name><operator>.</operator><name>end</name></name> <operator>=</operator> <call><name>ts_time_saturating_add</name><argument_list>(<argument><expr><name>bucketed_end</name></expr></argument>, <argument><expr><name>bucket_width</name></expr></argument>, <argument><expr><name><name>refresh_window</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize the refresh state for a continuous aggregate.
 *
 * The state holds information for executing a refresh of a continuous aggregate.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>continuous_agg_refresh_init</name><parameter_list>(<parameter><decl><type><name>CaggRefreshState</name> <modifier>*</modifier></type><name>refresh</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ContinuousAgg</name> <modifier>*</modifier></type><name>cagg</name></decl></parameter>,
							<parameter><decl><type><specifier>const</specifier> <name>InternalTimeRange</name> <modifier>*</modifier></type><name>refresh_window</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>refresh</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>refresh</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>refresh</name><operator>-&gt;</operator><name>cagg</name></name> <operator>=</operator> <operator>*</operator><name>cagg</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>refresh</name><operator>-&gt;</operator><name>cagg_ht</name></name> <operator>=</operator> <call><name>cagg_get_hypertable_or_fail</name><argument_list>(<argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>mat_hypertable_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>refresh</name><operator>-&gt;</operator><name>refresh_window</name></name> <operator>=</operator> <operator>*</operator><name>refresh_window</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>refresh</name><operator>-&gt;</operator><name>partial_view</name><operator>.</operator><name>schema</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>refresh</name><operator>-&gt;</operator><name>cagg</name><operator>.</operator><name>data</name><operator>.</operator><name>partial_view_schema</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>refresh</name><operator>-&gt;</operator><name>partial_view</name><operator>.</operator><name>name</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>refresh</name><operator>-&gt;</operator><name>cagg</name><operator>.</operator><name>data</name><operator>.</operator><name>partial_view_name</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Execute a refresh.
 *
 * The refresh will materialize the area given by the refresh window in the
 * refresh state.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>continuous_agg_refresh_execute</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CaggRefreshState</name> <modifier>*</modifier></type><name>refresh</name></decl></parameter>,
							   <parameter><decl><type><specifier>const</specifier> <name>InternalTimeRange</name> <modifier>*</modifier></type><name>bucketed_refresh_window</name></decl></parameter>,
							   <parameter><decl><type><specifier>const</specifier> <name>int32</name></type> <name>chunk_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SchemaAndName</name></type> <name>cagg_hypertable_name</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>schema</name> <operator>=</operator> <operator>&amp;</operator><name><name>refresh</name><operator>-&gt;</operator><name>cagg_ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>schema_name</name></name></expr>,
		<expr><operator>.</operator><name>name</name> <operator>=</operator> <operator>&amp;</operator><name><name>refresh</name><operator>-&gt;</operator><name>cagg_ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>table_name</name></name></expr>,
	}</block></expr></init></decl>;</decl_stmt>
	<comment type="block">/* The materialization function takes two ranges, one for new data and one
	 * for invalidated data. A refresh just uses one of them so the other one
	 * has a zero range. */</comment>
	<decl_stmt><decl><type><name>InternalTimeRange</name></type> <name>unused_invalidation_range</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>type</name> <operator>=</operator> <name><name>refresh</name><operator>-&gt;</operator><name>refresh_window</name><operator>.</operator><name>type</name></name></expr>,
		<expr><operator>.</operator><name>start</name> <operator>=</operator> <literal type="number">0</literal></expr>,
		<expr><operator>.</operator><name>end</name> <operator>=</operator> <literal type="number">0</literal></expr>,
	}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type><name>time_dim</name> <init>= <expr><call><name>hyperspace_get_open_dimension</name><argument_list>(<argument><expr><name><name>refresh</name><operator>-&gt;</operator><name>cagg_ht</name><operator>-&gt;</operator><name>space</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>time_dim</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>continuous_agg_update_materialization</name><argument_list>(<argument><expr><name><name>refresh</name><operator>-&gt;</operator><name>partial_view</name></name></expr></argument>,
										  <argument><expr><name>cagg_hypertable_name</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name><name>time_dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>column_name</name></name></expr></argument>,
										  <argument><expr><operator>*</operator><name>bucketed_refresh_window</name></expr></argument>,
										  <argument><expr><name>unused_invalidation_range</name></expr></argument>,
										  <argument><expr><name>chunk_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>log_refresh_window</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ContinuousAgg</name> <modifier>*</modifier></type><name>cagg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>InternalTimeRange</name> <modifier>*</modifier></type><name>refresh_window</name></decl></parameter>,
				   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type> <name>start_ts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>end_ts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>outfuncid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>isvarlena</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>start_ts</name> <operator>=</operator> <call><name>ts_internal_to_time_value</name><argument_list>(<argument><expr><name><name>refresh_window</name><operator>-&gt;</operator><name>start</name></name></expr></argument>, <argument><expr><name><name>refresh_window</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>end_ts</name> <operator>=</operator> <call><name>ts_internal_to_time_value</name><argument_list>(<argument><expr><name><name>refresh_window</name><operator>-&gt;</operator><name>end</name></name></expr></argument>, <argument><expr><name><name>refresh_window</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name><name>refresh_window</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>outfuncid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isvarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isvarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
		 <argument><expr><literal type="string">"%s \"%s\" in window [ %s, %s ]"</literal></expr></argument>,
		 <argument><expr><name>msg</name></expr></argument>,
		 <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>user_view_name</name></name></expr></argument>)</argument_list></call></expr></argument>,
		 <argument><expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>OidFunctionCall1</name><argument_list>(<argument><expr><name>outfuncid</name></expr></argument>, <argument><expr><name>start_ts</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
		 <argument><expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>OidFunctionCall1</name><argument_list>(<argument><expr><name>outfuncid</name></expr></argument>, <argument><expr><name>end_ts</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get the limit on number of invalidation-based refreshes we allow per
 * refresh call. If this limit is exceeded, fall back to a single refresh that
 * covers the range decided by the min and max invalidated time.
 *
 * Use a session variable for debugging and testing. In other words, this
 * purposefully not a user-visible GUC. Might be promoted to official GUC in
 * the future.
 */</comment>
<function><type><specifier>static</specifier> <name>long</name></type>
<name>materialization_per_refresh_window</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_MATERIALIZATIONS_PER_REFRESH_WINDOW</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MATERIALIZATIONS_PER_REFRESH_WINDOW_OPT_NAME</name></cpp:macro>                                               \
	<cpp:value>"timescaledb.materializations_per_refresh_window"</cpp:value></cpp:define>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>max_materializations_setting</name> <init>=
		<expr><call><name>GetConfigOption</name><argument_list>(<argument><expr><name>MATERIALIZATIONS_PER_REFRESH_WINDOW_OPT_NAME</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type> <name>max_materializations</name> <init>= <expr><name>DEFAULT_MATERIALIZATIONS_PER_REFRESH_WINDOW</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>max_materializations_setting</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>endptr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Not using pg_strtol here since we don't want to throw error in case
		 * of parsing issue */</comment>
		<expr_stmt><expr><name>max_materializations</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>max_materializations_setting</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Accept trailing whitespaces */</comment>
		<while>while <condition>(<expr><operator>*</operator><name>endptr</name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>endptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>endptr</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid value for session variable \"%s\""</literal></expr></argument>,
							<argument><expr><name>MATERIALIZATIONS_PER_REFRESH_WINDOW_OPT_NAME</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Expected an integer but current value is \"%s\"."</literal></expr></argument>,
							   <argument><expr><name>max_materializations_setting</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>max_materializations</name> <operator>=</operator> <name>DEFAULT_MATERIALIZATIONS_PER_REFRESH_WINDOW</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>max_materializations</name></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>scan_refresh_ranges_funct_t</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>InternalTimeRange</name> <modifier>*</modifier></type><name>bucketed_refresh_window</name></decl></parameter>,
											<parameter><decl><type><specifier>const</specifier> <name>long</name></type> <name>iteration</name></decl></parameter>, <comment type="block">/* 0 is first range */</comment>
											<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg1</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg2</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>continuous_agg_refresh_execute_wrapper</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>InternalTimeRange</name> <modifier>*</modifier></type><name>bucketed_refresh_window</name></decl></parameter>,
									   <parameter><decl><type><specifier>const</specifier> <name>long</name></type> <name>iteration</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg1_refresh</name></decl></parameter>,
									   <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg2_chunk_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>CaggRefreshState</name> <modifier>*</modifier></type><name>refresh</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>CaggRefreshState</name> <operator>*</operator><operator>)</operator> <name>arg1_refresh</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int32</name></type> <name>chunk_id</name> <init>= <expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>int32</name> <operator>*</operator><operator>)</operator> <name>arg2_chunk_id</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>iteration</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>log_refresh_window</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>refresh</name><operator>-&gt;</operator><name>cagg</name></name></expr></argument>, <argument><expr><name>bucketed_refresh_window</name></expr></argument>, <argument><expr><literal type="string">"invalidation refresh on"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>continuous_agg_refresh_execute</name><argument_list>(<argument><expr><name>refresh</name></expr></argument>, <argument><expr><name>bucketed_refresh_window</name></expr></argument>, <argument><expr><name>chunk_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>update_merged_refresh_window</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>InternalTimeRange</name> <modifier>*</modifier></type><name>bucketed_refresh_window</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>long</name></type> <name>iteration</name></decl></parameter>,
							 <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg1_merged_refresh_window</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>InternalTimeRange</name> <modifier>*</modifier></type><name>merged_refresh_window</name> <init>= <expr><operator>(</operator><name>InternalTimeRange</name> <operator>*</operator><operator>)</operator> <name>arg1_merged_refresh_window</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>arg2</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>iteration</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>merged_refresh_window</name> <operator>=</operator> <operator>*</operator><name>bucketed_refresh_window</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>bucketed_refresh_window</name><operator>-&gt;</operator><name>start</name></name> <operator>&lt;</operator> <name><name>merged_refresh_window</name><operator>-&gt;</operator><name>start</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>merged_refresh_window</name><operator>-&gt;</operator><name>start</name></name> <operator>=</operator> <name><name>bucketed_refresh_window</name><operator>-&gt;</operator><name>start</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>bucketed_refresh_window</name><operator>-&gt;</operator><name>end</name></name> <operator>&gt;</operator> <name><name>merged_refresh_window</name><operator>-&gt;</operator><name>end</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>merged_refresh_window</name><operator>-&gt;</operator><name>end</name></name> <operator>=</operator> <name><name>bucketed_refresh_window</name><operator>-&gt;</operator><name>end</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>long</name></type>
<name>continuous_agg_scan_refresh_window_ranges</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>InternalTimeRange</name> <modifier>*</modifier></type><name>refresh_window</name></decl></parameter>,
										  <parameter><decl><type><specifier>const</specifier> <name>InvalidationStore</name> <modifier>*</modifier></type><name>invalidations</name></decl></parameter>,
										  <parameter><decl><type><specifier>const</specifier> <name>int64</name></type> <name>bucket_width</name></decl></parameter>,
										  <parameter><decl><type><specifier>const</specifier> <name>ContinuousAggsBucketFunction</name> <modifier>*</modifier></type><name>bucket_function</name></decl></parameter>,
										  <parameter><decl><type><name>scan_refresh_ranges_funct_t</name></type> <name>exec_func</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>func_arg1</name></decl></parameter>,
										  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>func_arg2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><name><name>invalidations</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>TTSOpsMinimalTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>tuplestore_gettupleslot</name><argument_list>(<argument><expr><name><name>invalidations</name><operator>-&gt;</operator><name>tupstore</name></name></expr></argument>,
								   <argument><expr><name>true</name></expr></argument> <comment type="block">/* forward */</comment>,
								   <argument><expr><name>false</name></expr></argument> <comment type="block">/* copy */</comment>,
								   <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>isnull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type> <name>start</name> <init>= <expr><call><name>slot_getattr</name><argument_list>(
			<argument><expr><name>slot</name></expr></argument>,
			<argument><expr><name>Anum_continuous_aggs_materialization_invalidation_log_lowest_modified_value</name></expr></argument>,
			<argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type> <name>end</name> <init>= <expr><call><name>slot_getattr</name><argument_list>(
			<argument><expr><name>slot</name></expr></argument>,
			<argument><expr><name>Anum_continuous_aggs_materialization_invalidation_log_greatest_modified_value</name></expr></argument>,
			<argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>InternalTimeRange</name></type> <name>invalidation</name> <init>= <expr><block>{
			<expr><operator>.</operator><name>type</name> <operator>=</operator> <name><name>refresh_window</name><operator>-&gt;</operator><name>type</name></name></expr>,
			<expr><operator>.</operator><name>start</name> <operator>=</operator> <call><name>DatumGetInt64</name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>,
			<comment type="block">/* Invalidations are inclusive at the end, while refresh windows
			 * aren't, so add one to the end of the invalidated region */</comment>
			<expr><operator>.</operator><name>end</name> <operator>=</operator> <call><name>ts_time_saturating_add</name><argument_list>(<argument><expr><call><name>DatumGetInt64</name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>refresh_window</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>,
		}</block></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>InternalTimeRange</name></type> <name>bucketed_refresh_window</name> <init>=
			<expr><call><name>compute_circumscribed_bucketed_refresh_window</name><argument_list>(<argument><expr><operator>&amp;</operator><name>invalidation</name></expr></argument>,
														  <argument><expr><name>bucket_width</name></expr></argument>,
														  <argument><expr><name>bucket_function</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call>(<modifier>*</modifier><name>exec_func</name>)<argument_list>(<argument><expr><operator>&amp;</operator><name>bucketed_refresh_window</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>func_arg1</name></expr></argument>, <argument><expr><name>func_arg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>count</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Execute refreshes based on the processed invalidations.
 *
 * The given refresh window covers a set of buckets, some of which are
 * out-of-date (invalid) and some which are up-to-date (valid). Invalid
 * buckets that are adjacent form larger ranges, as shown below.
 *
 * Refresh window:  [-----------------------------------------)
 * Invalid ranges:           [-----] [-]   [--] [-] [---]
 * Merged range:             [---------------------------)
 *
 * The maximum number of individual (non-mergable) ranges are
 * #buckets_in_window/2 (i.e., every other bucket is invalid).
 *
 * Since it might not be efficient to materialize a lot buckets separately
 * when there are many invalid (non-adjecent) buckets/ranges, we put a limit
 * on the number of individual materializations we do. This limit is
 * determined by the MATERIALIZATIONS_PER_REFRESH_WINDOW setting.
 *
 * Thus, if the refresh window covers a large number of buckets, but only a
 * few of them are invalid, it is likely beneficial to materialized these
 * separately to avoid materializing a lot of buckets that are already
 * up-to-date. But if the number of invalid buckets/ranges go above the
 * threshold, we materialize all of them in one go using the "merged range",
 * as illustrated above.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>continuous_agg_refresh_with_window</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ContinuousAgg</name> <modifier>*</modifier></type><name>cagg</name></decl></parameter>,
								   <parameter><decl><type><specifier>const</specifier> <name>InternalTimeRange</name> <modifier>*</modifier></type><name>refresh_window</name></decl></parameter>,
								   <parameter><decl><type><specifier>const</specifier> <name>InvalidationStore</name> <modifier>*</modifier></type><name>invalidations</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int64</name></type> <name>bucket_width</name></decl></parameter>,
								   <parameter><decl><type><name>int32</name></type> <name>chunk_id</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>is_raw_ht_distributed</name></decl></parameter>,
								   <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>do_merged_refresh</name></decl></parameter>,
								   <parameter><decl><type><specifier>const</specifier> <name>InternalTimeRange</name></type> <name>merged_refresh_window</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CaggRefreshState</name></type> <name>refresh</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>old_per_data_node_queries</name> <init>= <expr><name>ts_guc_enable_per_data_node_queries</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>continuous_agg_refresh_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>refresh</name></expr></argument>, <argument><expr><name>cagg</name></expr></argument>, <argument><expr><name>refresh_window</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Disable per-data-node optimization so that 'tableoid' system column is evaluated in the
	 * Access Node to generate Access Node chunk-IDs for the materialization table. */</comment>
	<expr_stmt><expr><name>ts_guc_enable_per_data_node_queries</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we're refreshing a finalized CAgg then we should force
	 * the `chunk_id` to be `INVALID_CHUNK_ID` because this column
	 * does not exist anymore in the materialization hypertable.
	 *
	 * The underlying function `spi_update_materialization` that
	 * actually will DELETE and INSERT data into the materialization
	 * hypertable is responsible for check if the `chunk_id` is valid
	 * and then use it or not during the refresh.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>ContinuousAggIsFinalized</name><argument_list>(<argument><expr><name>cagg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>chunk_id</name> <operator>=</operator> <name>INVALID_CHUNK_ID</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>do_merged_refresh</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>merged_refresh_window</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name><name>refresh_window</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>merged_refresh_window</name><operator>.</operator><name>start</name></name> <operator>&gt;=</operator> <name><name>refresh_window</name><operator>-&gt;</operator><name>start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>bucket_width</name> <operator>==</operator> <name>BUCKET_WIDTH_VARIABLE</name><operator>)</operator> <operator>||</operator>
			   <operator>(</operator><name><name>merged_refresh_window</name><operator>.</operator><name>end</name></name> <operator>-</operator> <name>bucket_width</name> <operator>&lt;=</operator> <name><name>refresh_window</name><operator>-&gt;</operator><name>end</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>log_refresh_window</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
						   <argument><expr><name>cagg</name></expr></argument>,
						   <argument><expr><operator>&amp;</operator><name>merged_refresh_window</name></expr></argument>,
						   <argument><expr><literal type="string">"merged invalidations for refresh on"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>continuous_agg_refresh_execute</name><argument_list>(<argument><expr><operator>&amp;</operator><name>refresh</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>merged_refresh_window</name></expr></argument>, <argument><expr><name>chunk_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<function_decl><type><name>long</name> <name>count</name></type> <name>pg_attribute_unused</name><parameter_list>()</parameter_list>;</function_decl>
		<expr_stmt><expr><name>count</name> <operator>=</operator> <call><name>continuous_agg_scan_refresh_window_ranges</name><argument_list>(<argument><expr><name>refresh_window</name></expr></argument>,
														  <argument><expr><name>invalidations</name></expr></argument>,
														  <argument><expr><name>bucket_width</name></expr></argument>,
														  <argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>bucket_function</name></name></expr></argument>,
														  <argument><expr><name>continuous_agg_refresh_execute_wrapper</name></expr></argument>,
														  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>refresh</name></expr></argument> <comment type="block">/* arg1 */</comment>,
														  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>chunk_id</name></expr></argument> <comment type="block">/* arg2 */</comment>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name>ts_guc_enable_per_data_node_queries</name> <operator>=</operator> <name>old_per_data_node_queries</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ContinuousAgg</name> <modifier>*</modifier></type>
<name>get_cagg_by_relid</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Oid</name></type> <name>cagg_relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ContinuousAgg</name> <modifier>*</modifier></type><name>cagg</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>cagg_relid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid continuous aggregate"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>cagg</name> <operator>=</operator> <call><name>ts_continuous_agg_find_by_relid</name><argument_list>(<argument><expr><name>cagg_relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>cagg</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relname</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>cagg_relid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>relname</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"continuous aggregate does not exist"</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation \"%s\" is not a continuous aggregate"</literal></expr></argument>, <argument><expr><name>relname</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>cagg</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REFRESH_FUNCTION_NAME</name></cpp:macro> <cpp:value>"refresh_continuous_aggregate()"</cpp:value></cpp:define>
<comment type="block">/*
 * Refresh a continuous aggregate across the given window.
 */</comment>
<function><type><name>Datum</name></type>
<name>continuous_agg_refresh</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>cagg_relid</name> <init>= <expr><ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>InvalidOid</name></expr> </then><else>: <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ContinuousAgg</name> <modifier>*</modifier></type><name>cagg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>InternalTimeRange</name></type> <name>refresh_window</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>InvalidOid</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>cagg</name> <operator>=</operator> <call><name>get_cagg_by_relid</name><argument_list>(<argument><expr><name>cagg_relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>refresh_window</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name><name>cagg</name><operator>-&gt;</operator><name>partition_type</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>refresh_window</name><operator>.</operator><name>start</name></name> <operator>=</operator> <call><name>ts_time_value_from_arg</name><argument_list>(<argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
													  <argument><expr><call><name>get_fn_expr_argtype</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
													  <argument><expr><name><name>refresh_window</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>refresh_window</name><operator>.</operator><name>start</name></name> <operator>=</operator> <call><name>ts_time_get_min</name><argument_list>(<argument><expr><name><name>refresh_window</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>refresh_window</name><operator>.</operator><name>end</name></name> <operator>=</operator> <call><name>ts_time_value_from_arg</name><argument_list>(<argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>,
													<argument><expr><call><name>get_fn_expr_argtype</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>,
													<argument><expr><name><name>refresh_window</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>refresh_window</name><operator>.</operator><name>end</name></name> <operator>=</operator> <call><name>ts_time_get_noend_or_max</name><argument_list>(<argument><expr><name><name>refresh_window</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>continuous_agg_refresh_internal</name><argument_list>(<argument><expr><name>cagg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>refresh_window</name></expr></argument>, <argument><expr><name>CAGG_REFRESH_WINDOW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>emit_up_to_date_notice</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ContinuousAgg</name> <modifier>*</modifier></type><name>cagg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CaggRefreshCallContext</name></type> <name>callctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>callctx</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>CAGG_REFRESH_CHUNK</name></expr>:</case>
		<case>case <expr><name>CAGG_REFRESH_WINDOW</name></expr>:</case>
		<case>case <expr><name>CAGG_REFRESH_CREATION</name></expr>:</case>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
				 <argument><expr><literal type="string">"continuous aggregate \"%s\" is already up-to-date"</literal></expr></argument>,
				 <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>user_view_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>CAGG_REFRESH_POLICY</name></expr>:</case>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>continuous_agg_calculate_merged_refresh_window</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>InternalTimeRange</name> <modifier>*</modifier></type><name>refresh_window</name></decl></parameter>,
											   <parameter><decl><type><specifier>const</specifier> <name>InvalidationStore</name> <modifier>*</modifier></type><name>invalidations</name></decl></parameter>,
											   <parameter><decl><type><specifier>const</specifier> <name>int64</name></type> <name>bucket_width</name></decl></parameter>,
											   <parameter><decl><type><specifier>const</specifier> <name>ContinuousAggsBucketFunction</name> <modifier>*</modifier></type><name>bucket_function</name></decl></parameter>,
											   <parameter><decl><type><name>InternalTimeRange</name> <modifier>*</modifier></type><name>merged_refresh_window</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<function_decl><type><name>long</name> <name>count</name></type> <name>pg_attribute_unused</name><parameter_list>()</parameter_list>;</function_decl>
	<expr_stmt><expr><name>count</name> <operator>=</operator> <call><name>continuous_agg_scan_refresh_window_ranges</name><argument_list>(<argument><expr><name>refresh_window</name></expr></argument>,
													  <argument><expr><name>invalidations</name></expr></argument>,
													  <argument><expr><name>bucket_width</name></expr></argument>,
													  <argument><expr><name>bucket_function</name></expr></argument>,
													  <argument><expr><name>update_merged_refresh_window</name></expr></argument>,
													  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>merged_refresh_window</name></expr></argument>,
													  <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* arg2 */</comment>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>process_cagg_invalidations_and_refresh</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ContinuousAgg</name> <modifier>*</modifier></type><name>cagg</name></decl></parameter>,
									   <parameter><decl><type><specifier>const</specifier> <name>InternalTimeRange</name> <modifier>*</modifier></type><name>refresh_window</name></decl></parameter>,
									   <parameter><decl><type><specifier>const</specifier> <name>CaggRefreshCallContext</name></type> <name>callctx</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>chunk_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>InvalidationStore</name> <modifier>*</modifier></type><name>invalidations</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>hyper_relid</name> <init>= <expr><call><name>ts_hypertable_id_to_relid</name><argument_list>(<argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>mat_hypertable_id</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>do_merged_refresh</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>InternalTimeRange</name></type> <name>merged_refresh_window</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type> <name>max_materializations</name></decl>;</decl_stmt>

	<comment type="block">/* Lock the continuous aggregate's materialized hypertable to protect
	 * against concurrent refreshes. Only concurrent reads will be
	 * allowed. This is a heavy lock that serializes all refreshes on the same
	 * continuous aggregate. We might want to consider relaxing this in the
	 * future, e.g., we'd like to at least allow concurrent refreshes on the
	 * same continuous aggregate when they don't have overlapping refresh
	 * windows.
	 */</comment>
	<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name>hyper_relid</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name> <init>= <expr><call><name>cagg_get_hypertable_or_fail</name><argument_list>(<argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>raw_hypertable_id</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>is_raw_ht_distributed</name> <init>= <expr><call><name>hypertable_is_distributed</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>CaggsInfo</name></type> <name>all_caggs_info</name> <init>=
		<expr><call><name>ts_continuous_agg_get_all_caggs_info</name><argument_list>(<argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>raw_hypertable_id</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>max_materializations</name> <operator>=</operator> <call><name>materialization_per_refresh_window</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>is_raw_ht_distributed</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>invalidations</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<comment type="block">/* Force to always merge the refresh ranges in the distributed raw HyperTable case.
		 * Session variable MATERIALIZATIONS_PER_REFRESH_WINDOW_OPT_NAME was checked for
		 * validity in materialization_per_refresh_window().
		 */</comment>
		<expr_stmt><expr><name>max_materializations</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>remote_invalidation_process_cagg_log</name><argument_list>(<argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>mat_hypertable_id</name></name></expr></argument>,
											 <argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>raw_hypertable_id</name></name></expr></argument>,
											 <argument><expr><name>refresh_window</name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name>all_caggs_info</name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name>do_merged_refresh</name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name>merged_refresh_window</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>invalidations</name> <operator>=</operator> <call><name>invalidation_process_cagg_log</name><argument_list>(<argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>mat_hypertable_id</name></name></expr></argument>,
													  <argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>raw_hypertable_id</name></name></expr></argument>,
													  <argument><expr><name>refresh_window</name></expr></argument>,
													  <argument><expr><operator>&amp;</operator><name>all_caggs_info</name></expr></argument>,
													  <argument><expr><name>max_materializations</name></expr></argument>,
													  <argument><expr><operator>&amp;</operator><name>do_merged_refresh</name></expr></argument>,
													  <argument><expr><operator>&amp;</operator><name>merged_refresh_window</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>invalidations</name> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <name>do_merged_refresh</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>callctx</name> <operator>==</operator> <name>CAGG_REFRESH_CREATION</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"refreshing continuous aggregate \"%s\""</literal></expr></argument>, <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use WITH NO DATA if you do not want to refresh the continuous "</literal>
							 <literal type="string">"aggregate on creation."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>int64</name></type> <name>bucket_width</name> <init>= <expr><ternary><condition><expr><call><name>ts_continuous_agg_bucket_width_variable</name><argument_list>(<argument><expr><name>cagg</name></expr></argument>)</argument_list></call></expr> ?</condition><then>
								 <expr><name>BUCKET_WIDTH_VARIABLE</name></expr> </then><else>:
								 <expr><call><name>ts_continuous_agg_bucket_width</name><argument_list>(<argument><expr><name>cagg</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>continuous_agg_refresh_with_window</name><argument_list>(<argument><expr><name>cagg</name></expr></argument>,
										   <argument><expr><name>refresh_window</name></expr></argument>,
										   <argument><expr><name>invalidations</name></expr></argument>,
										   <argument><expr><name>bucket_width</name></expr></argument>,
										   <argument><expr><name>chunk_id</name></expr></argument>,
										   <argument><expr><name>is_raw_ht_distributed</name></expr></argument>,
										   <argument><expr><name>do_merged_refresh</name></expr></argument>,
										   <argument><expr><name>merged_refresh_window</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>invalidations</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>invalidation_store_free</name><argument_list>(<argument><expr><name>invalidations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>continuous_agg_refresh_internal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ContinuousAgg</name> <modifier>*</modifier></type><name>cagg</name></decl></parameter>,
								<parameter><decl><type><specifier>const</specifier> <name>InternalTimeRange</name> <modifier>*</modifier></type><name>refresh_window_arg</name></decl></parameter>,
								<parameter><decl><type><specifier>const</specifier> <name>CaggRefreshCallContext</name></type> <name>callctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Catalog</name> <modifier>*</modifier></type><name>catalog</name> <init>= <expr><call><name>ts_catalog_get</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>mat_id</name> <init>= <expr><name><name>cagg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>mat_hypertable_id</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>InternalTimeRange</name></type> <name>refresh_window</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>computed_invalidation_threshold</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>invalidation_threshold</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>is_raw_ht_distributed</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

	<comment type="block">/* Connect to SPI manager due to the underlying SPI calls */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>SPI_connect_ext</name><argument_list>(<argument><expr><name>SPI_OPT_NONATOMIC</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>SPI_OK_CONNECT</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_connect failed: %s"</literal></expr></argument>, <argument><expr><call><name>SPI_result_code_string</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Like regular materialized views, require owner to refresh. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_class_ownercheck</name><argument_list>(<argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>,
					   <argument><expr><call><name>get_relkind_objtype</name><argument_list>(<argument><expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PreventCommandIfReadOnly</name><argument_list>(<argument><expr><name>REFRESH_FUNCTION_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Prevent running refresh if we're in a transaction block since a refresh
	 * can run two transactions and might take a long time to release locks if
	 * there's a lot to materialize. Strictly, it is optional to prohibit
	 * transaction blocks since there will be only one transaction if the
	 * invalidation threshold needs no update. However, materialization might
	 * still take a long time and it is probably best for consistency to always
	 * prevent transaction blocks.  */</comment>
	<expr_stmt><expr><call><name>PreventInTransactionBlock</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>REFRESH_FUNCTION_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name> <init>= <expr><call><name>cagg_get_hypertable_or_fail</name><argument_list>(<argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>raw_hypertable_id</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>is_raw_ht_distributed</name> <operator>=</operator> <call><name>hypertable_is_distributed</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ts_continuous_agg_bucket_width_variable</name><argument_list>(<argument><expr><name>cagg</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>refresh_window</name> <operator>=</operator> <operator>*</operator><name>refresh_window_arg</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ts_compute_inscribed_bucketed_refresh_window_variable</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>refresh_window</name><operator>.</operator><name>start</name></name></expr></argument>,
															  <argument><expr><operator>&amp;</operator><name><name>refresh_window</name><operator>.</operator><name>end</name></name></expr></argument>,
															  <argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>bucket_function</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>refresh_window</name> <operator>=</operator>
			<call><name>compute_inscribed_bucketed_refresh_window</name><argument_list>(<argument><expr><name>refresh_window_arg</name></expr></argument>,
													  <argument><expr><call><name>ts_continuous_agg_bucket_width</name><argument_list>(<argument><expr><name>cagg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>refresh_window</name><operator>.</operator><name>start</name></name> <operator>&gt;=</operator> <name><name>refresh_window</name><operator>.</operator><name>end</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"refresh window too small"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The refresh window must cover at least one bucket of data."</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Align the refresh window with the bucket"</literal>
						 <literal type="string">" time zone or use at least two buckets."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>log_refresh_window</name><argument_list>(<argument><expr><ternary><condition><expr><name>callctx</name> <operator>==</operator> <name>CAGG_REFRESH_POLICY</name></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>DEBUG1</name></expr></else></ternary></expr></argument>,
					   <argument><expr><name>cagg</name></expr></argument>,
					   <argument><expr><operator>&amp;</operator><name>refresh_window</name></expr></argument>,
					   <argument><expr><literal type="string">"refreshing continuous aggregate"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Perform the refresh across two transactions.
	 *
	 * The first transaction moves the invalidation threshold (if needed) and
	 * copies over invalidations from the hypertable log to the cagg
	 * invalidation log. Doing the threshold and copying as part of the first
	 * transaction ensures that the threshold and new invalidations will be
	 * visible as soon as possible to concurrent refreshes and that we keep
	 * locks for only a short period. Note that the first transaction
	 * serializes around the threshold table lock, which protects both the
	 * threshold and the invalidation processing against concurrent refreshes.
	 *
	 * The second transaction processes the cagg invalidation log and then
	 * performs the actual refresh (materialization of data). This transaction
	 * serializes around a lock on the materialized hypertable for the
	 * continuous aggregate that gets refreshed.
	 */</comment>
	<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><call><name>catalog_get_table_id</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>CONTINUOUS_AGGS_INVALIDATION_THRESHOLD</name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Compute new invalidation threshold. Note that this computation caps the
	 * threshold at the end of the last bucket that holds data in the
	 * underlying hypertable. */</comment>
	<expr_stmt><expr><name>computed_invalidation_threshold</name> <operator>=</operator> <call><name>invalidation_threshold_compute</name><argument_list>(<argument><expr><name>cagg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>refresh_window</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set the new invalidation threshold. Note that this only updates the
	 * threshold if the new value is greater than the old one. Otherwise, the
	 * existing threshold is returned. */</comment>
	<expr_stmt><expr><name>invalidation_threshold</name> <operator>=</operator> <call><name>invalidation_threshold_set_or_get</name><argument_list>(<argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>raw_hypertable_id</name></name></expr></argument>,
															   <argument><expr><name>computed_invalidation_threshold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We must also cap the refresh window at the invalidation threshold. If
	 * we process invalidations after the threshold, the continuous aggregates
	 * won't be refreshed when the threshold is moved forward in the
	 * future. The invalidation threshold should already be aligned on bucket
	 * boundary. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>refresh_window</name><operator>.</operator><name>end</name></name> <operator>&gt;</operator> <name>invalidation_threshold</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>refresh_window</name><operator>.</operator><name>end</name></name> <operator>=</operator> <name>invalidation_threshold</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Capping the end might have made the window 0, or negative, so
	 * nothing to refresh in that case */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>refresh_window</name><operator>.</operator><name>start</name></name> <operator>&gt;=</operator> <name><name>refresh_window</name><operator>.</operator><name>end</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>emit_up_to_date_notice</name><argument_list>(<argument><expr><name>cagg</name></expr></argument>, <argument><expr><name>callctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>SPI_finish</name><argument_list>()</argument_list></call><operator>)</operator> <operator>!=</operator> <name>SPI_OK_FINISH</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_finish failed: %s"</literal></expr></argument>, <argument><expr><call><name>SPI_result_code_string</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Process invalidations in the hypertable invalidation log */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>CaggsInfo</name></type> <name>all_caggs_info</name> <init>=
		<expr><call><name>ts_continuous_agg_get_all_caggs_info</name><argument_list>(<argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>raw_hypertable_id</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>is_raw_ht_distributed</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>remote_invalidation_process_hypertable_log</name><argument_list>(<argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>mat_hypertable_id</name></name></expr></argument>,
												   <argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>raw_hypertable_id</name></name></expr></argument>,
												   <argument><expr><name><name>refresh_window</name><operator>.</operator><name>type</name></name></expr></argument>,
												   <argument><expr><operator>&amp;</operator><name>all_caggs_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>invalidation_process_hypertable_log</name><argument_list>(<argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>mat_hypertable_id</name></name></expr></argument>,
											<argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>raw_hypertable_id</name></name></expr></argument>,
											<argument><expr><name><name>refresh_window</name><operator>.</operator><name>type</name></name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>all_caggs_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Commit and Start a new transaction */</comment>
	<expr_stmt><expr><call><name>SPI_commit_and_chain</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>cagg</name> <operator>=</operator> <call><name>ts_continuous_agg_find_by_mat_hypertable_id</name><argument_list>(<argument><expr><name>mat_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>process_cagg_invalidations_and_refresh</name><argument_list>(<argument><expr><name>cagg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>refresh_window</name></expr></argument>, <argument><expr><name>callctx</name></expr></argument>, <argument><expr><name>INVALID_CHUNK_ID</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>emit_up_to_date_notice</name><argument_list>(<argument><expr><name>cagg</name></expr></argument>, <argument><expr><name>callctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>SPI_finish</name><argument_list>()</argument_list></call><operator>)</operator> <operator>!=</operator> <name>SPI_OK_FINISH</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_finish failed: %s"</literal></expr></argument>, <argument><expr><call><name>SPI_result_code_string</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
</unit>
