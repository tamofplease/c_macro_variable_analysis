<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/timescaledb/tsl/src/continuous_aggs/create.c"><comment type="block">/*
 * This file and its contents are licensed under the Timescale License.
 * Please see the included NOTICE for copyright information and
 * LICENSE-TIMESCALE for a copy of the license.
 */</comment>

<comment type="block">/* This file contains the code for processing continuous aggregate
 * DDL statements which are of the form:
 *
 * CREATE MATERIALIZED VIEW &lt;name&gt; WITH (ts_continuous = [option] )
 * AS  &lt;select query&gt;
 * The entry point for the code is
 * tsl_process_continuous_agg_viewstmt
 * The bulk of the code that creates the underlying tables/views etc. is in
 * cagg_create.
 *
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postgres.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/reloptions.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/sysattr.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/xact.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/index.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/indexing.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_aggregate.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_collation.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_namespace.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_trigger.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_type.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/toasting.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;commands/defrem.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;commands/tablecmds.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;commands/tablespace.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;commands/trigger.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;commands/view.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;miscadmin.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/makefuncs.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/nodeFuncs.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/nodes.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/parsenodes.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/pg_list.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/clauses.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/optimizer.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/tlist.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;parser/analyze.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;parser/parse_func.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;parser/parse_oper.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;parser/parse_relation.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;parser/parse_type.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;rewrite/rewriteHandler.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;rewrite/rewriteManip.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/acl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/rel.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/builtins.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/catcache.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/regproc.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/ruleutils.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/syscache.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/typcache.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"create.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ts_catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ts_catalog/continuous_agg.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dimension.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"extension_constants.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"func_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hypertable_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hypertable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"invalidation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dimension.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ts_catalog/continuous_agg.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"options.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"time_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"errors.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"refresh.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"remote/dist_commands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ts_catalog/hypertable_data_node.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"deparse.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"timezones.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FINALFN</name></cpp:macro> <cpp:value>"finalize_agg"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARTIALFN</name></cpp:macro> <cpp:value>"partialize_agg"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHUNKIDFROMRELID</name></cpp:macro> <cpp:value>"chunk_id_from_relid"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_MATPARTCOLUMN_NAME</name></cpp:macro> <cpp:value>"time_partition_col"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MATPARTCOL_INTERVAL_FACTOR</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HT_DEFAULT_CHUNKFN</name></cpp:macro> <cpp:value>"calculate_chunk_interval"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CAGG_INVALIDATION_TRIGGER</name></cpp:macro> <cpp:value>"continuous_agg_invalidation_trigger"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BOUNDARY_FUNCTION</name></cpp:macro> <cpp:value>"cagg_watermark"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INTERNAL_TO_DATE_FUNCTION</name></cpp:macro> <cpp:value>"to_date"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INTERNAL_TO_TSTZ_FUNCTION</name></cpp:macro> <cpp:value>"to_timestamp"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INTERNAL_TO_TS_FUNCTION</name></cpp:macro> <cpp:value>"to_timestamp_without_timezone"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRINT_MATCOLNAME</name><parameter_list>(<parameter><type><name>colbuf</name></type></parameter>, <parameter><type><name>type</name></type></parameter>, <parameter><type><name>original_query_resno</name></type></parameter>, <parameter><type><name>colno</name></type></parameter>)</parameter_list></cpp:macro>                                \
	<cpp:value>do                                                                                             \
	{                                                                                              \
		int ret = snprintf(colbuf, NAMEDATALEN, "%s_%d_%d", type, original_query_resno, colno);    \
		if (ret &lt; 0 || ret &gt;= NAMEDATALEN)                                                         \
			ereport(ERROR,                                                                         \
					(errcode(ERRCODE_INTERNAL_ERROR),                                              \
					 errmsg("bad materialization table column name")));                            \
	} while (0);</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRINT_MATINTERNAL_NAME</name><parameter_list>(<parameter><type><name>buf</name></type></parameter>, <parameter><type><name>prefix</name></type></parameter>, <parameter><type><name>hypertable_id</name></type></parameter>)</parameter_list></cpp:macro>                                         \
	<cpp:value>do                                                                                             \
	{                                                                                              \
		int ret = snprintf(buf, NAMEDATALEN, prefix, hypertable_id);                               \
		if (ret &lt; 0 || ret &gt; NAMEDATALEN)                                                          \
		{                                                                                          \
			ereport(ERROR,                                                                         \
					(errcode(ERRCODE_INTERNAL_ERROR),                                              \
					 errmsg("bad materialization internal name")));                                \
		}                                                                                          \
	} while (0);</cpp:value></cpp:define>

<comment type="block">/* Note that we set rowsecurity to false here */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CAGG_MAKEQUERY</name><parameter_list>(<parameter><type><name>selquery</name></type></parameter>, <parameter><type><name>srcquery</name></type></parameter>)</parameter_list></cpp:macro>                                                         \
	<cpp:value>do                                                                                             \
	{                                                                                              \
		(selquery) = makeNode(Query);                                                              \
		(selquery)-&gt;commandType = CMD_SELECT;                                                      \
		(selquery)-&gt;querySource = (srcquery)-&gt;querySource;                                         \
		(selquery)-&gt;queryId = (srcquery)-&gt;queryId;                                                 \
		(selquery)-&gt;canSetTag = (srcquery)-&gt;canSetTag;                                             \
		(selquery)-&gt;utilityStmt = copyObject((srcquery)-&gt;utilityStmt);                             \
		(selquery)-&gt;resultRelation = 0;                                                            \
		(selquery)-&gt;hasAggs = true;                                                                \
		(selquery)-&gt;hasRowSecurity = false;                                                        \
	} while (0);</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>MatTableColumnInfo</name>
<block>{
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>matcollist</name></decl>;</decl_stmt>		 <comment type="block">/* column defns for materialization tbl*/</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>partial_seltlist</name></decl>;</decl_stmt>	 <comment type="block">/* tlist entries for populating the materialization table columns */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>partial_grouplist</name></decl>;</decl_stmt> <comment type="block">/* group clauses used for populating the materialization table */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>mat_groupcolname_list</name></decl>;</decl_stmt> <comment type="block">/* names of columns that are populated by the group-by clause
									correspond to the partial_grouplist.
									time_bucket column is not included here: it is the
									matpartcolname */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>matpartcolno</name></decl>;</decl_stmt>			 <comment type="block">/*index of partitioning column in matcollist */</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>matpartcolname</name></decl>;</decl_stmt>		 <comment type="block">/*name of the partition column */</comment>
}</block></struct></type> <name>MatTableColumnInfo</name>;</typedef>

<typedef>typedef <type><struct>struct <name>FinalizeQueryInfo</name>
<block>{
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>final_seltlist</name></decl>;</decl_stmt>	<comment type="block">/* select target list for finalize query */</comment>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>final_havingqual</name></decl>;</decl_stmt> <comment type="block">/* having qual for finalize query */</comment>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>final_userquery</name></decl>;</decl_stmt> <comment type="block">/* user query used to compute the finalize_query */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>finalized</name></decl>;</decl_stmt>			<comment type="block">/* finalized form? */</comment>
}</block></struct></type> <name>FinalizeQueryInfo</name>;</typedef>

<typedef>typedef <type><struct>struct <name>CAggTimebucketInfo</name>
<block>{
	<decl_stmt><decl><type><name>int32</name></type> <name>htid</name></decl>;</decl_stmt>						<comment type="block">/* hypertable id */</comment>
	<decl_stmt><decl><type><name>int32</name></type> <name>parent_mat_hypertable_id</name></decl>;</decl_stmt> <comment type="block">/* parent materialization hypertable id */</comment>
	<decl_stmt><decl><type><name>Oid</name></type> <name>htoid</name></decl>;</decl_stmt>						<comment type="block">/* hypertable oid */</comment>
	<decl_stmt><decl><type><name>AttrNumber</name></type> <name>htpartcolno</name></decl>;</decl_stmt>			<comment type="block">/* primary partitioning column of raw hypertable */</comment>
									<comment type="block">/* This should also be the column used by time_bucket */</comment>
	<decl_stmt><decl><type><name>Oid</name></type> <name>htpartcoltype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>htpartcol_interval_len</name></decl>;</decl_stmt> <comment type="block">/* interval length setting for primary partitioning column */</comment>
	<decl_stmt><decl><type><name>int64</name></type> <name>bucket_width</name></decl>;</decl_stmt>			  <comment type="block">/* bucket_width of time_bucket, stores BUCKET_WIDTH_VARIABLE for
									 variable-sized buckets */</comment>
	<decl_stmt><decl><type><name>Interval</name> <modifier>*</modifier></type><name>interval</name></decl>;</decl_stmt>			  <comment type="block">/* stores the interval, NULL if not specified */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>timezone</name></decl>;</decl_stmt>		  <comment type="block">/* the name of the timezone, NULL if not specified */</comment>

	<decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>bucket_func</name></decl>;</decl_stmt> <comment type="block">/* function call expr of the bucketing function */</comment>
	<comment type="block">/*
	 * Custom origin value stored as UTC timestamp.
	 * If not specified, stores infinity.
	 */</comment>
	<decl_stmt><decl><type><name>Timestamp</name></type> <name>origin</name></decl>;</decl_stmt>
}</block></struct></type> <name>CAggTimebucketInfo</name>;</typedef>

<typedef>typedef <type><struct>struct <name>AggPartCxt</name>
<block>{
	<decl_stmt><decl><type><name><name>struct</name> <name>MatTableColumnInfo</name></name> <modifier>*</modifier></type><name>mattblinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>added_aggref_col</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>var_outside_of_aggref</name></decl>;</decl_stmt> <comment type="block">/* Set to true when you come across a Var that is not inside an
								   Aggref node */</comment>
	<decl_stmt><decl><type><name>Oid</name></type> <name>ignore_aggoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>original_query_resno</name></decl>;</decl_stmt>
	<comment type="block">/*
	 * "Original variables" are the Var nodes of the target list of the original
	 * CREATE MATERIALIZED VIEW query. "Mapped variables" are the Var nodes of the materialization
	 * table columns. The partialization query is the one that populates those columns. The
	 * finalization query should use the "mapped variables" to populate the user view.
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>orig_vars</name></decl>;</decl_stmt> <comment type="block">/* List of Var nodes that have been mapped to materialization table columns */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>mapped_vars</name></decl>;</decl_stmt> <comment type="block">/* List of Var nodes of the corresponding materialization table columns */</comment>
					   <comment type="block">/* orig_vars and mapped_vars lists are mapped 1 to 1 */</comment>
}</block></struct></type> <name>AggPartCxt</name>;</typedef>

<comment type="block">/* STATIC functions defined on the structs above */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>mattablecolumninfo_init</name><parameter_list>(<parameter><decl><type><name>MatTableColumnInfo</name> <modifier>*</modifier></type><name>matcolinfo</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>grouplist</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Var</name> <modifier>*</modifier></type><name>mattablecolumninfo_addentry</name><parameter_list>(<parameter><decl><type><name>MatTableColumnInfo</name> <modifier>*</modifier></type><name>out</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>input</name></decl></parameter>,
										<parameter><decl><type><name>int</name></type> <name>original_query_resno</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>finalized</name></decl></parameter>,
										<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>skip_adding</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>mattablecolumninfo_addinternal</name><parameter_list>(<parameter><decl><type><name>MatTableColumnInfo</name> <modifier>*</modifier></type><name>matcolinfo</name></decl></parameter>,
										   <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>usertbl_rte</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>usertbl_htid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int32</name></type> <name>mattablecolumninfo_create_materialization_table</name><parameter_list>(
	<parameter><decl><type><name>MatTableColumnInfo</name> <modifier>*</modifier></type><name>matcolinfo</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>hypertable_id</name></decl></parameter>, <parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>mat_rel</name></decl></parameter>,
	<parameter><decl><type><name>CAggTimebucketInfo</name> <modifier>*</modifier></type><name>origquery_tblinfo</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>create_addl_index</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>tablespacename</name></decl></parameter>,
	<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>table_access_method</name></decl></parameter>, <parameter><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>mataddress</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>mattablecolumninfo_get_partial_select_query</name><parameter_list>(<parameter><decl><type><name>MatTableColumnInfo</name> <modifier>*</modifier></type><name>mattblinfo</name></decl></parameter>,
														  <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>userview_query</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>finalized</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>caggtimebucketinfo_init</name><parameter_list>(<parameter><decl><type><name>CAggTimebucketInfo</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>hypertable_id</name></decl></parameter>,
									<parameter><decl><type><name>Oid</name></type> <name>hypertable_oid</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>hypertable_partition_colno</name></decl></parameter>,
									<parameter><decl><type><name>Oid</name></type> <name>hypertable_partition_coltype</name></decl></parameter>,
									<parameter><decl><type><name>int64</name></type> <name>hypertable_partition_col_interval</name></decl></parameter>,
									<parameter><decl><type><name>int32</name></type> <name>parent_mat_hypertable_id</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>caggtimebucket_validate</name><parameter_list>(<parameter><decl><type><name>CAggTimebucketInfo</name> <modifier>*</modifier></type><name>tbinfo</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClause</name></decl></parameter>,
									<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>finalizequery_init</name><parameter_list>(<parameter><decl><type><name>FinalizeQueryInfo</name> <modifier>*</modifier></type><name>inp</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>orig_query</name></decl></parameter>,
							   <parameter><decl><type><name>MatTableColumnInfo</name> <modifier>*</modifier></type><name>mattblinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>finalizequery_get_select_query</name><parameter_list>(<parameter><decl><type><name>FinalizeQueryInfo</name> <modifier>*</modifier></type><name>inp</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>matcollist</name></decl></parameter>,
											 <parameter><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>mattbladdress</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>function_allowed_in_cagg_definition</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>funcid</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>Const</name> <modifier>*</modifier></type><name>cagg_boundary_make_lower_bound</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>type</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type> <name>cagg_get_boundary_converter_funcoid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typoid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type> <name>relation_oid</name><parameter_list>(<parameter><decl><type><name>NameData</name></type> <name>schema</name></decl></parameter>, <parameter><decl><type><name>NameData</name></type> <name>name</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>build_union_query</name><parameter_list>(<parameter><decl><type><name>CAggTimebucketInfo</name> <modifier>*</modifier></type><name>tbinfo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>matpartcolno</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>q1</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>q2</name></decl></parameter>,
								<parameter><decl><type><name>int</name></type> <name>materialize_htid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>destroy_union_query</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>q</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* create a entry for the materialization table in table CONTINUOUS_AGGS */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>create_cagg_catalog_entry</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>matht_id</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>rawht_id</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>user_schema</name></decl></parameter>,
						  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>user_view</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>partial_schema</name></decl></parameter>,
						  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>partial_view</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>bucket_width</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>materialized_only</name></decl></parameter>,
						  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>direct_schema</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>direct_view</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>finalized</name></decl></parameter>,
						  <parameter><decl><type><specifier>const</specifier> <name>int32</name></type> <name>parent_mat_hypertable_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Catalog</name> <modifier>*</modifier></type><name>catalog</name> <init>= <expr><call><name>ts_catalog_get</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>desc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NameData</name></type> <name>user_schnm</name></decl>, <decl><type ref="prev"/><name>user_viewnm</name></decl>, <decl><type ref="prev"/><name>partial_schnm</name></decl>, <decl><type ref="prev"/><name>partial_viewnm</name></decl>, <decl><type ref="prev"/><name>direct_schnm</name></decl>, <decl><type ref="prev"/><name>direct_viewnm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name><name>values</name><index>[<expr><name>Natts_continuous_agg</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name><name>nulls</name><index>[<expr><name>Natts_continuous_agg</name></expr>]</index></name> <init>= <expr><block>{ <expr><name>false</name></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CatalogSecurityContext</name></type> <name>sec_ctx</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>user_schnm</name></expr></argument>, <argument><expr><name>user_schema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>user_viewnm</name></expr></argument>, <argument><expr><name>user_view</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>partial_schnm</name></expr></argument>, <argument><expr><name>partial_schema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>partial_viewnm</name></expr></argument>, <argument><expr><name>partial_view</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>direct_schnm</name></expr></argument>, <argument><expr><name>direct_schema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>direct_viewnm</name></expr></argument>, <argument><expr><name>direct_view</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><call><name>catalog_get_table_id</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>CONTINUOUS_AGG</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>desc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_continuous_agg_mat_hypertable_id</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>matht_id</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_continuous_agg_raw_hypertable_id</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>rawht_id</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>parent_mat_hypertable_id</name> <operator>==</operator> <name>INVALID_HYPERTABLE_ID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_continuous_agg_parent_mat_hypertable_id</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_continuous_agg_parent_mat_hypertable_id</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
			<name>parent_mat_hypertable_id</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_continuous_agg_user_view_schema</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
		<call><name>NameGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>user_schnm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_continuous_agg_user_view_name</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
		<call><name>NameGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>user_viewnm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_continuous_agg_partial_view_schema</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
		<call><name>NameGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>partial_schnm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_continuous_agg_partial_view_name</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
		<call><name>NameGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>partial_viewnm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_continuous_agg_bucket_width</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>bucket_width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_continuous_agg_direct_view_schema</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
		<call><name>NameGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>direct_schnm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_continuous_agg_direct_view_name</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
		<call><name>NameGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>direct_viewnm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_continuous_agg_materialize_only</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
		<call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>materialized_only</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_continuous_agg_finalized</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>finalized</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ts_catalog_database_info_become_owner</name><argument_list>(<argument><expr><call><name>ts_catalog_database_info_get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_catalog_insert_values</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_catalog_restore_user</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* create a entry for the materialization table in table CONTINUOUS_AGGS_BUCKET_FUNCTION */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>create_bucket_function_catalog_entry</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>matht_id</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>experimental</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
									 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>bucket_width</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>origin</name></decl></parameter>,
									 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>timezone</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Catalog</name> <modifier>*</modifier></type><name>catalog</name> <init>= <expr><call><name>ts_catalog_get</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>desc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name><name>values</name><index>[<expr><name>Natts_continuous_aggs_bucket_function</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name><name>nulls</name><index>[<expr><name>Natts_continuous_aggs_bucket_function</name></expr>]</index></name> <init>= <expr><block>{ <expr><name>false</name></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CatalogSecurityContext</name></type> <name>sec_ctx</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><call><name>catalog_get_table_id</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>CONTINUOUS_AGGS_BUCKET_FUNCTION</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>desc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_continuous_agg_mat_hypertable_id</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>matht_id</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_continuous_aggs_bucket_function_experimental</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
		<call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>experimental</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_continuous_aggs_bucket_function_name</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
		<call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_continuous_aggs_bucket_function_bucket_width</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
		<call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>bucket_width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_continuous_aggs_bucket_function_origin</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
		<call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>origin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_continuous_aggs_bucket_function_timezone</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
		<call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><ternary><condition><expr><name>timezone</name></expr> ?</condition><then> <expr><name>timezone</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ts_catalog_database_info_become_owner</name><argument_list>(<argument><expr><call><name>ts_catalog_database_info_get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_catalog_insert_values</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_catalog_restore_user</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* create hypertable for the table referred by mat_tbloid
 * matpartcolname - partition column for hypertable
 * timecol_interval - is the partitioning column's interval for hypertable partition
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>cagg_create_hypertable</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>hypertable_id</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>mat_tbloid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>matpartcolname</name></decl></parameter>,
					   <parameter><decl><type><name>int64</name></type> <name>mat_tbltimecol_interval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>created</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NameData</name></type> <name>mat_tbltimecol</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DimensionInfo</name> <modifier>*</modifier></type><name>time_dim_info</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ChunkSizingInfo</name> <modifier>*</modifier></type><name>chunk_sizing_info</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mat_tbltimecol</name></expr></argument>, <argument><expr><name>matpartcolname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>time_dim_info</name> <operator>=</operator> <call><name>ts_dimension_info_create_open</name><argument_list>(<argument><expr><name>mat_tbloid</name></expr></argument>,
												  <argument><expr><operator>&amp;</operator><name>mat_tbltimecol</name></expr></argument>,
												  <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>mat_tbltimecol_interval</name></expr></argument>)</argument_list></call></expr></argument>,
												  <argument><expr><name>INT8OID</name></expr></argument>,
												  <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Ideally would like to change/expand the API so setting the column name manually is
	 * unnecessary, but not high priority */</comment>
	<expr_stmt><expr><name>chunk_sizing_info</name> <operator>=</operator> <call><name>ts_chunk_sizing_info_get_default_disabled</name><argument_list>(<argument><expr><name>mat_tbloid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>chunk_sizing_info</name><operator>-&gt;</operator><name>colname</name></name> <operator>=</operator> <name>matpartcolname</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>created</name> <operator>=</operator> <call><name>ts_hypertable_create_from_info</name><argument_list>(<argument><expr><name>mat_tbloid</name></expr></argument>,
											 <argument><expr><name>hypertable_id</name></expr></argument>,
											 <argument><expr><name>flags</name></expr></argument>,
											 <argument><expr><name>time_dim_info</name></expr></argument>,
											 <argument><expr><name>NULL</name></expr></argument>,
											 <argument><expr><name>NULL</name></expr></argument>,
											 <argument><expr><name>NULL</name></expr></argument>,
											 <argument><expr><name>chunk_sizing_info</name></expr></argument>,
											 <argument><expr><name>HYPERTABLE_REGULAR</name></expr></argument>,
											 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>created</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create materialization hypertable"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_trigger_exists_hypertable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>trigname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type> <name>tgrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>tgscan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>trg_found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>tgrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>TriggerRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_trigger_tgrelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
				<argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tgscan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>tgrel</name></expr></argument>, <argument><expr><name>TriggerRelidNameIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>tgscan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_trigger</name></type> <name>trig</name> <init>= <expr><operator>(</operator><name>Form_pg_trigger</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>namestrcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>trig</name><operator>-&gt;</operator><name>tgname</name></name><operator>)</operator></expr></argument>, <argument><expr><name>trigname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>trg_found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>tgscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>tgrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>trg_found</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* add continuous agg invalidation trigger to hypertable
 * relid - oid of hypertable
 * hypertableid - argument to pass to trigger (the hypertable id from timescaledb catalog)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>cagg_add_trigger_hypertable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>hypertable_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type> <name><name>hypertable_id_str</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>objaddr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relname</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>schemaid</name> <init>= <expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>schema</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>schemaid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cache</name> <modifier>*</modifier></type><name>hcache</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>CreateTrigStmt</name></type> <name>stmt_template</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>T_CreateTrigStmt</name></expr>,
		<expr><operator>.</operator><name>row</name> <operator>=</operator> <name>true</name></expr>,
		<expr><operator>.</operator><name>timing</name> <operator>=</operator> <name>TRIGGER_TYPE_AFTER</name></expr>,
		<expr><operator>.</operator><name>trigname</name> <operator>=</operator> <name>CAGGINVAL_TRIGGER_NAME</name></expr>,
		<expr><operator>.</operator><name>relation</name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><name>schema</name></expr></argument>, <argument><expr><name>relname</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>funcname</name> <operator>=</operator>
			<call><name>list_make2</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>INTERNAL_SCHEMA_NAME</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>CAGG_INVALIDATION_TRIGGER</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>args</name> <operator>=</operator> <name>NIL</name></expr>, <comment type="block">/* to be filled in later */</comment>
		<expr><operator>.</operator><name>events</name> <operator>=</operator> <name>TRIGGER_TYPE_INSERT</name> <operator>|</operator> <name>TRIGGER_TYPE_UPDATE</name> <operator>|</operator> <name>TRIGGER_TYPE_DELETE</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>check_trigger_exists_hypertable</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>CAGGINVAL_TRIGGER_NAME</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>ht</name> <operator>=</operator> <call><name>ts_hypertable_cache_get_cache_and_entry</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>CACHE_FLAG_NONE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>hypertable_is_distributed</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DistCmdResult</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>data_node_list</name> <init>= <expr><call><name>ts_hypertable_get_data_node_name_list</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>cmd_descriptors</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt> <comment type="block">/* same order as ht-&gt;data_nodes */</comment>
		<decl_stmt><decl><type><name>DistCmdDescr</name> <modifier>*</modifier></type><name>cmd_descr_data</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>cmd_descr_data</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>data_node_list</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>cmd_descr_data</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>foreach</name> <argument_list>(<argument>cell</argument>, <argument>ht-&gt;data_nodes</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>HypertableDataNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name></type> <name><name>node_hypertable_id_str</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>CreateTrigStmt</name></type> <name>remote_stmt</name> <init>= <expr><name>stmt_template</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>pg_ltoa</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>node_hypertable_id</name></name></expr></argument>, <argument><expr><name>node_hypertable_id_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pg_ltoa</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>hypertable_id</name></name></expr></argument>, <argument><expr><name>hypertable_id_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>remote_stmt</name><operator>.</operator><name>args</name></name> <operator>=</operator>
				<call><name>list_make2</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>node_hypertable_id_str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>hypertable_id_str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cmd_descr_data</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sql</name> <operator>=</operator> <call><name>deparse_create_trigger</name><argument_list>(<argument><expr><operator>&amp;</operator><name>remote_stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cmd_descr_data</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>params</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>cmd_descriptors</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>cmd_descriptors</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cmd_descr_data</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><name>result</name> <operator>=</operator>
			<call><name>ts_dist_multi_cmds_params_invoke_on_data_nodes</name><argument_list>(<argument><expr><name>cmd_descriptors</name></expr></argument>, <argument><expr><name>data_node_list</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ts_dist_cmd_close_response</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/*
		 * FALL-THROUGH
		 * We let the Access Node create a trigger as well, even though it is not used for data
		 * modifications. We use the Access Node trigger as a check for existence of the remote
		 * triggers.
		 */</comment>
	</block_content>}</block></if></if_stmt>
	<decl_stmt><decl><type><name>CreateTrigStmt</name></type> <name>local_stmt</name> <init>= <expr><name>stmt_template</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>pg_ltoa</name><argument_list>(<argument><expr><name>hypertable_id</name></expr></argument>, <argument><expr><name>hypertable_id_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>local_stmt</name><operator>.</operator><name>args</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>hypertable_id_str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>objaddr</name> <operator>=</operator> <call><name>ts_hypertable_create_trigger</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>local_stmt</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>objaddr</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create continuous aggregate trigger"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* add additional indexes to materialization table for the columns derived from
 * the group-by column list of the partial select query
 * if partial select query has:
 * GROUP BY timebucket_expr, &lt;grpcol1, grpcol2, grpcol3 ...&gt;
 * index on mattable is &lt;grpcol1, timebucketcol&gt;, &lt;grpcol2, timebucketcol&gt; ... and so on.
 * i.e. #indexes =(  #grp-cols - 1)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>mattablecolumninfo_add_mattable_index</name><parameter_list>(<parameter><decl><type><name>MatTableColumnInfo</name> <modifier>*</modifier></type><name>matcolinfo</name></decl></parameter>, <parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexStmt</name></type> <name>stmt</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>T_IndexStmt</name></expr>,
		<expr><operator>.</operator><name>accessMethod</name> <operator>=</operator> <name>DEFAULT_INDEX_TYPE</name></expr>,
		<expr><operator>.</operator><name>idxname</name> <operator>=</operator> <name>NULL</name></expr>,
		<expr><operator>.</operator><name>relation</name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>schema_name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>tableSpace</name> <operator>=</operator> <call><name>get_tablespace_name</name><argument_list>(<argument><expr><call><name>get_rel_tablespace</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
	}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexElem</name></type> <name>timeelem</name> <init>= <expr><block>{ <expr><operator>.</operator><name>type</name> <operator>=</operator> <name>T_IndexElem</name></expr>,
						   <expr><operator>.</operator><name>name</name> <operator>=</operator> <name><name>matcolinfo</name><operator>-&gt;</operator><name>matpartcolname</name></name></expr>,
						   <expr><operator>.</operator><name>ordering</name> <operator>=</operator> <name>SORTBY_DESC</name></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>le</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>le</argument>, <argument>matcolinfo-&gt;mat_groupcolname_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>NameData</name></type> <name>indxname</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>indxaddr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type> <name>indxtuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>grpcolname</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>le</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>IndexElem</name></type> <name>grpelem</name> <init>= <expr><block>{ <expr><operator>.</operator><name>type</name> <operator>=</operator> <name>T_IndexElem</name></expr>, <expr><operator>.</operator><name>name</name> <operator>=</operator> <name>grpcolname</name></expr> }</block></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>stmt</name><operator>.</operator><name>indexParams</name></name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><operator>&amp;</operator><name>grpelem</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>timeelem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>indxaddr</name> <operator>=</operator> <call><name>DefineIndex</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>stmt</name></expr></argument>,
							   <argument><expr><name>InvalidOid</name></expr></argument>, <comment type="block">/* indexRelationId */</comment>
							   <argument><expr><name>InvalidOid</name></expr></argument>, <comment type="block">/* parentIndexId */</comment>
							   <argument><expr><name>InvalidOid</name></expr></argument>, <comment type="block">/* parentConstraintId */</comment>
							   <argument><expr><name>false</name></expr></argument>,	   <comment type="block">/* is_alter_table */</comment>
							   <argument><expr><name>false</name></expr></argument>,	   <comment type="block">/* check_rights */</comment>
							   <argument><expr><name>false</name></expr></argument>,	   <comment type="block">/* check_not_in_use */</comment>
							   <argument><expr><name>false</name></expr></argument>,	   <comment type="block">/* skip_build */</comment>
							   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	   <comment type="block">/* quiet */</comment>
		<expr_stmt><expr><name>indxtuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>indxaddr</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>indxtuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for index relid %u"</literal></expr></argument>, <argument><expr><name><name>indxaddr</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>indxname</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>indxtuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>relname</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
			 <argument><expr><literal type="string">"adding index %s ON %s.%s USING BTREE(%s, %s)"</literal></expr></argument>,
			 <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name>indxname</name></expr></argument>)</argument_list></call></expr></argument>,
			 <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>schema_name</name></name></expr></argument>)</argument_list></call></expr></argument>,
			 <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr></argument>,
			 <argument><expr><name>grpcolname</name></expr></argument>,
			 <argument><expr><name><name>matcolinfo</name><operator>-&gt;</operator><name>matpartcolname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>indxtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Create the materialization hypertable root by faking up a
 * CREATE TABLE parsetree and passing it to DefineRelation.
 * Reuse the information from ViewStmt:
 *   Remove the options on the into clause that we will not honour
 *   Modify the relname to ts_internal_&lt;name&gt;
 *
 *  Parameters:
 *    mat_rel: relation information for the materialization table
 *    origquery_tblinfo: - user query's tbale information. used for setting up
 *        thr partitioning of the hypertable.
 *    tablespace_name: Name of the tablespace for the materialization table.
 *    table_access_method: Name of the table access method to use for the
 *        materialization table.
 *    mataddress: return the ObjectAddress RETURNS: hypertable id of the
 *        materialization table
 */</comment>
<function><type><specifier>static</specifier> <name>int32</name></type>
<name>mattablecolumninfo_create_materialization_table</name><parameter_list>(<parameter><decl><type><name>MatTableColumnInfo</name> <modifier>*</modifier></type><name>matcolinfo</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>hypertable_id</name></decl></parameter>,
												<parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>mat_rel</name></decl></parameter>,
												<parameter><decl><type><name>CAggTimebucketInfo</name> <modifier>*</modifier></type><name>origquery_tblinfo</name></decl></parameter>,
												<parameter><decl><type><name>bool</name></type> <name>create_addl_index</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>tablespacename</name></decl></parameter>,
												<parameter><decl><type><name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>table_access_method</name></decl></parameter>,
												<parameter><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>mataddress</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>uid</name></decl>, <decl><type ref="prev"/><name>saved_uid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>sec_ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>matpartcolname</name> <init>= <expr><name><name>matcolinfo</name><operator>-&gt;</operator><name>matpartcolname</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CreateStmt</name> <modifier>*</modifier></type><name>create</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>toast_options</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>matpartcol_interval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name><name>validnsps</name><index>[]</index></name> <init>= <expr><name>HEAP_RELOPT_NAMESPACES</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>mat_htid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>mat_relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cache</name> <modifier>*</modifier></type><name>hcache</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>mat_ht</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>orig_ht</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>owner</name> <init>= <expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>create</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CreateStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>create</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <name>mat_rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>create</name><operator>-&gt;</operator><name>tableElts</name></name> <operator>=</operator> <name><name>matcolinfo</name><operator>-&gt;</operator><name>matcollist</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>create</name><operator>-&gt;</operator><name>inhRelations</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>create</name><operator>-&gt;</operator><name>ofTypename</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>create</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>create</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>create</name><operator>-&gt;</operator><name>oncommit</name></name> <operator>=</operator> <name>ONCOMMIT_NOOP</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>create</name><operator>-&gt;</operator><name>tablespacename</name></name> <operator>=</operator> <name>tablespacename</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>create</name><operator>-&gt;</operator><name>accessMethod</name></name> <operator>=</operator> <name>table_access_method</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>create</name><operator>-&gt;</operator><name>if_not_exists</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*  Create the materialization table.  */</comment>
	<expr_stmt><expr><call><name>SWITCH_TO_TS_USER</name><argument_list>(<argument><expr><name><name>mat_rel</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>, <argument><expr><name>uid</name></expr></argument>, <argument><expr><name>saved_uid</name></expr></argument>, <argument><expr><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>mataddress</name> <operator>=</operator> <call><name>DefineRelation</name><argument_list>(<argument><expr><name>create</name></expr></argument>, <argument><expr><name>RELKIND_RELATION</name></expr></argument>, <argument><expr><name>owner</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>mat_relid</name> <operator>=</operator> <name><name>mataddress</name><operator>-&gt;</operator><name>objectId</name></name></expr>;</expr_stmt>

	<comment type="block">/* NewRelationCreateToastTable calls CommandCounterIncrement */</comment>
	<expr_stmt><expr><name>toast_options</name> <operator>=</operator>
		<call><name>transformRelOptions</name><argument_list>(<argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name><name>create</name><operator>-&gt;</operator><name>options</name></name></expr></argument>, <argument><expr><literal type="string">"toast"</literal></expr></argument>, <argument><expr><name>validnsps</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>heap_reloptions</name><argument_list>(<argument><expr><name>RELKIND_TOASTVALUE</name></expr></argument>, <argument><expr><name>toast_options</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>NewRelationCreateToastTable</name><argument_list>(<argument><expr><name>mat_relid</name></expr></argument>, <argument><expr><name>toast_options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RESTORE_USER</name><argument_list>(<argument><expr><name>uid</name></expr></argument>, <argument><expr><name>saved_uid</name></expr></argument>, <argument><expr><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*convert the mat. table to a hypertable */</comment>
	<expr_stmt><expr><name>matpartcol_interval</name> <operator>=</operator> <name>MATPARTCOL_INTERVAL_FACTOR</name> <operator>*</operator> <operator>(</operator><name><name>origquery_tblinfo</name><operator>-&gt;</operator><name>htpartcol_interval_len</name></name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>cagg_create_hypertable</name><argument_list>(<argument><expr><name>hypertable_id</name></expr></argument>, <argument><expr><name>mat_relid</name></expr></argument>, <argument><expr><name>matpartcolname</name></expr></argument>, <argument><expr><name>matpartcol_interval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* retrieve the hypertable id from the cache */</comment>
	<expr_stmt><expr><name>mat_ht</name> <operator>=</operator> <call><name>ts_hypertable_cache_get_cache_and_entry</name><argument_list>(<argument><expr><name>mat_relid</name></expr></argument>, <argument><expr><name>CACHE_FLAG_NONE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>mat_htid</name> <operator>=</operator> <name><name>mat_ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr>;</expr_stmt>

	<comment type="block">/* create additional index on the group-by columns for the materialization table */</comment>
	<if_stmt><if>if <condition>(<expr><name>create_addl_index</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>mattablecolumninfo_add_mattable_index</name><argument_list>(<argument><expr><name>matcolinfo</name></expr></argument>, <argument><expr><name>mat_ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Initialize the invalidation log for the cagg. Initially, everything is
	 * invalid. Add an infinite invalidation for the continuous
	 * aggregate. This is the initial state of the aggregate before any
	 * refreshes. */</comment>
	<expr_stmt><expr><name>orig_ht</name> <operator>=</operator> <call><name>ts_hypertable_cache_get_entry</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>, <argument><expr><name><name>origquery_tblinfo</name><operator>-&gt;</operator><name>htoid</name></name></expr></argument>, <argument><expr><name>CACHE_FLAG_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>continuous_agg_invalidate_mat_ht</name><argument_list>(<argument><expr><name>orig_ht</name></expr></argument>, <argument><expr><name>mat_ht</name></expr></argument>, <argument><expr><name>TS_TIME_NOBEGIN</name></expr></argument>, <argument><expr><name>TS_TIME_NOEND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>mat_htid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Use the userview query to create the partial query to populate
 * the materialization columns and remove HAVING clause and ORDER BY
 */</comment>
<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type>
<name>mattablecolumninfo_get_partial_select_query</name><parameter_list>(<parameter><decl><type><name>MatTableColumnInfo</name> <modifier>*</modifier></type><name>mattblinfo</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>userview_query</name></decl></parameter>,
											<parameter><decl><type><name>bool</name></type> <name>finalized</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>partial_selquery</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CAGG_MAKEQUERY</name><argument_list>(<argument><expr><name>partial_selquery</name></expr></argument>, <argument><expr><name>userview_query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>partial_selquery</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>userview_query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>partial_selquery</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>userview_query</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>partial_selquery</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <name><name>mattblinfo</name><operator>-&gt;</operator><name>partial_seltlist</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>partial_selquery</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>=</operator> <name><name>mattblinfo</name><operator>-&gt;</operator><name>partial_grouplist</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>finalized</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>partial_selquery</name><operator>-&gt;</operator><name>havingQual</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>userview_query</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>partial_selquery</name><operator>-&gt;</operator><name>sortClause</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>userview_query</name><operator>-&gt;</operator><name>sortClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>partial_selquery</name><operator>-&gt;</operator><name>havingQual</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>partial_selquery</name><operator>-&gt;</operator><name>sortClause</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>partial_selquery</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* create a  view for the query using the SELECt stmt sqlquery
 * and view name from RangeVar viewrel
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>create_view_for_query</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>selquery</name></decl></parameter>, <parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>viewrel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>uid</name></decl>, <decl><type ref="prev"/><name>saved_uid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>sec_ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CreateStmt</name> <modifier>*</modifier></type><name>create</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>selcollist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>owner</name> <init>= <expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>selquery-&gt;targetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ColumnDef</name> <modifier>*</modifier></type><name>col</name> <init>= <expr><call><name>makeColumnDef</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>resname</name></name></expr></argument>,
										   <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>,
										   <argument><expr><call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>,
										   <argument><expr><call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>selcollist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>selcollist</name></expr></argument>, <argument><expr><name>col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name>create</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CreateStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>create</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <name>viewrel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>create</name><operator>-&gt;</operator><name>tableElts</name></name> <operator>=</operator> <name>selcollist</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>create</name><operator>-&gt;</operator><name>inhRelations</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>create</name><operator>-&gt;</operator><name>ofTypename</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>create</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>create</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>create</name><operator>-&gt;</operator><name>oncommit</name></name> <operator>=</operator> <name>ONCOMMIT_NOOP</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>create</name><operator>-&gt;</operator><name>tablespacename</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>create</name><operator>-&gt;</operator><name>if_not_exists</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*  Create the view. viewname is in viewrel.
	 */</comment>
	<expr_stmt><expr><call><name>SWITCH_TO_TS_USER</name><argument_list>(<argument><expr><name><name>viewrel</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>, <argument><expr><name>uid</name></expr></argument>, <argument><expr><name>saved_uid</name></expr></argument>, <argument><expr><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>DefineRelation</name><argument_list>(<argument><expr><name>create</name></expr></argument>, <argument><expr><name>RELKIND_VIEW</name></expr></argument>, <argument><expr><name>owner</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>StoreViewQuery</name><argument_list>(<argument><expr><name><name>address</name><operator>.</operator><name>objectId</name></name></expr></argument>, <argument><expr><name>selquery</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RESTORE_USER</name><argument_list>(<argument><expr><name>uid</name></expr></argument>, <argument><expr><name>saved_uid</name></expr></argument>, <argument><expr><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* initialize caggtimebucket */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>caggtimebucketinfo_init</name><parameter_list>(<parameter><decl><type><name>CAggTimebucketInfo</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>hypertable_id</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>hypertable_oid</name></decl></parameter>,
						<parameter><decl><type><name>AttrNumber</name></type> <name>hypertable_partition_colno</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>hypertable_partition_coltype</name></decl></parameter>,
						<parameter><decl><type><name>int64</name></type> <name>hypertable_partition_col_interval</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>parent_mat_hypertable_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>src</name><operator>-&gt;</operator><name>htid</name></name> <operator>=</operator> <name>hypertable_id</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>src</name><operator>-&gt;</operator><name>parent_mat_hypertable_id</name></name> <operator>=</operator> <name>parent_mat_hypertable_id</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>src</name><operator>-&gt;</operator><name>htoid</name></name> <operator>=</operator> <name>hypertable_oid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>src</name><operator>-&gt;</operator><name>htpartcolno</name></name> <operator>=</operator> <name>hypertable_partition_colno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>src</name><operator>-&gt;</operator><name>htpartcoltype</name></name> <operator>=</operator> <name>hypertable_partition_coltype</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>src</name><operator>-&gt;</operator><name>htpartcol_interval_len</name></name> <operator>=</operator> <name>hypertable_partition_col_interval</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>src</name><operator>-&gt;</operator><name>bucket_width</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>			<comment type="block">/* invalid value */</comment>
	<expr_stmt><expr><name><name>src</name><operator>-&gt;</operator><name>interval</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>			<comment type="block">/* not specified by default */</comment>
	<expr_stmt><expr><name><name>src</name><operator>-&gt;</operator><name>timezone</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>			<comment type="block">/* not specified by default */</comment>
	<expr_stmt><expr><call><name>TIMESTAMP_NOBEGIN</name><argument_list>(<argument><expr><name><name>src</name><operator>-&gt;</operator><name>origin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* origin is not specified by default */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Const</name> <modifier>*</modifier></type>
<name>check_time_bucket_argument</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>position</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>NamedArgExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>arg</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>NamedArgExpr</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><call><name>eval_const_expressions</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"only immutable expressions allowed in time bucket function"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use an immutable expression as %s argument to the time bucket function."</literal></expr></argument>,
						 <argument><expr><name>position</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><call><name>castNode</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check if the group-by clauses has exactly 1 time_bucket(.., &lt;col&gt;) where
 * &lt;col&gt; is the hypertable's partitioning column and other invariants. Then fill
 * the `bucket_width` and other fields of `tbinfo`.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>caggtimebucket_validate</name><parameter_list>(<parameter><decl><type><name>CAggTimebucketInfo</name> <modifier>*</modifier></type><name>tbinfo</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClause</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>custom_origin</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Make sure tbinfo was initialized. This assumption is used below. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>bucket_width</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>timezone</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TIMESTAMP_NOT_FINITE</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>origin</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>l</argument>, <argument>groupClause</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sgc</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>get_sortgroupclause_tle</name><argument_list>(<argument><expr><name>sgc</name></expr></argument>, <argument><expr><name>targetList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>fe</name> <init>= <expr><operator>(</operator><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>width_arg</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>col_arg</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>function_allowed_in_cagg_definition</name><argument_list>(<argument><expr><name><name>fe</name><operator>-&gt;</operator><name>funcid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * offset variants of time_bucket functions are not
			 * supported at the moment.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>fe</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">5</literal> <operator>||</operator>
				<operator>(</operator><call><name>list_length</name><argument_list>(<argument><expr><name><name>fe</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <call><name>exprType</name><argument_list>(<argument><expr><call><name>lfourth</name><argument_list>(<argument><expr><name><name>fe</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>INTERVALOID</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"continuous aggregate view cannot contain"</literal>
								<literal type="string">" multiple time bucket functions"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>bucket_func</name></name> <operator>=</operator> <name>fe</name></expr>;</expr_stmt>

			<comment type="block">/* only column allowed : time_bucket('1day', &lt;column&gt; ) */</comment>
			<expr_stmt><expr><name>col_arg</name> <operator>=</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>fe</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>IsA</name><argument_list>(<argument><expr><name>col_arg</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator> <operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>col_arg</name><operator>)</operator><operator>-&gt;</operator><name>varattno</name> <operator>!=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>htpartcolno</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(
							 <argument><expr><literal type="string">"time bucket function must reference a hypertable dimension column"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>fe</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>check_time_bucket_argument</name><argument_list>(<argument><expr><call><name>lthird</name><argument_list>(<argument><expr><name><name>fe</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"third"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>TEXTOID</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tz_name</name> <init>= <expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name><name>arg</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ts_is_valid_timezone_name</name><argument_list>(<argument><expr><name>tz_name</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid timezone name \"%s\""</literal></expr></argument>, <argument><expr><name>tz_name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>timezone</name></name> <operator>=</operator> <name>tz_name</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>bucket_width</name></name> <operator>=</operator> <name>BUCKET_WIDTH_VARIABLE</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>fe</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">4</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>check_time_bucket_argument</name><argument_list>(<argument><expr><call><name>lfourth</name><argument_list>(<argument><expr><name><name>fe</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"fourth"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>TEXTOID</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tz_name</name> <init>= <expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name><name>arg</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ts_is_valid_timezone_name</name><argument_list>(<argument><expr><name>tz_name</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid timezone name \"%s\""</literal></expr></argument>, <argument><expr><name>tz_name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>timezone</name></name> <operator>=</operator> <name>tz_name</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>bucket_width</name></name> <operator>=</operator> <name>BUCKET_WIDTH_VARIABLE</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* check for custom origin */</comment>
			<switch>switch <condition>(<expr><call><name>exprType</name><argument_list>(<argument><expr><name>col_arg</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>DATEOID</name></expr>:</case>
					<comment type="block">/* origin is always 3rd arg for date variants */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>fe</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">3</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>custom_origin</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>origin</name></name> <operator>=</operator> <call><name>DatumGetTimestamp</name><argument_list>(
							<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>date_timestamp</name></expr></argument>,
												<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><call><name>lthird</name><argument_list>(<argument><expr><name><name>fe</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>constvalue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<break>break;</break>
				<case>case <expr><name>TIMESTAMPOID</name></expr>:</case>
					<comment type="block">/* origin is always 3rd arg for timestamp variants */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>fe</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">3</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>custom_origin</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>origin</name></name> <operator>=</operator>
							<call><name>DatumGetTimestamp</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><call><name>lthird</name><argument_list>(<argument><expr><name><name>fe</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>constvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<break>break;</break>
				<case>case <expr><name>TIMESTAMPTZOID</name></expr>:</case>
					<comment type="block">/* origin can be 3rd or 4th arg for timestamptz variants */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>fe</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator> <call><name>exprType</name><argument_list>(<argument><expr><call><name>lthird</name><argument_list>(<argument><expr><name><name>fe</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>TIMESTAMPTZOID</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>custom_origin</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>origin</name></name> <operator>=</operator>
							<call><name>DatumGetTimestampTz</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><call><name>lthird</name><argument_list>(<argument><expr><name><name>fe</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>constvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>fe</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator>
							 <call><name>exprType</name><argument_list>(<argument><expr><call><name>lfourth</name><argument_list>(<argument><expr><name><name>fe</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>TIMESTAMPTZOID</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>custom_origin</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>origin</name></name> <operator>=</operator>
							<call><name>DatumGetTimestampTz</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><call><name>lfourth</name><argument_list>(<argument><expr><name><name>fe</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>constvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
			</block_content>}</block></switch>
			<if_stmt><if>if <condition>(<expr><name>custom_origin</name> <operator>&amp;&amp;</operator> <call><name>TIMESTAMP_NOT_FINITE</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>origin</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid origin value: infinity"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * We constify width expression here so any immutable expression will be allowed
			 * otherwise it would make it harder to create caggs for hypertables with e.g. int8
			 * partitioning column as int constants default to int4 and so expression would
			 * have a cast and not be a Const.
			 */</comment>
			<expr_stmt><expr><name>width_arg</name> <operator>=</operator> <call><name>eval_const_expressions</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>fe</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>width_arg</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>width</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><name>width_arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>width</name><operator>-&gt;</operator><name>consttype</name></name> <operator>==</operator> <name>INTERVALOID</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>interval</name></name> <operator>=</operator> <call><name>DatumGetIntervalP</name><argument_list>(<argument><expr><name><name>width</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>interval</name><operator>-&gt;</operator><name>month</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>bucket_width</name></name> <operator>=</operator> <name>BUCKET_WIDTH_VARIABLE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>bucket_width</name></name> <operator>!=</operator> <name>BUCKET_WIDTH_VARIABLE</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* The bucket size is fixed */</comment>
					<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>bucket_width</name></name> <operator>=</operator>
						<call><name>ts_interval_value_to_internal</name><argument_list>(<argument><expr><name><name>width</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>, <argument><expr><name><name>width</name><operator>-&gt;</operator><name>consttype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"only immutable expressions allowed in time bucket function"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use an immutable expression as first argument"</literal>
								 <literal type="string">" to the time bucket function."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>interval</name></name> <operator>&amp;&amp;</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>interval</name><operator>-&gt;</operator><name>month</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>bucket_width</name></name> <operator>=</operator> <name>BUCKET_WIDTH_VARIABLE</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>bucket_width</name></name> <operator>==</operator> <name>BUCKET_WIDTH_VARIABLE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* variable-sized buckets can be used only with intervals */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>interval</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>interval</name><operator>-&gt;</operator><name>month</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>(</operator><operator>(</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>interval</name><operator>-&gt;</operator><name>day</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>interval</name><operator>-&gt;</operator><name>time</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid interval specified"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use either months or days and hours, but not months, days and hours "</literal>
							 <literal type="string">"together"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"continuous aggregate view must include a valid time bucket function"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>cagg_agg_validate</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>agg</name> <init>= <expr><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type> <name>aggtuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_aggregate</name></type> <name>aggform</name></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>agg</name><operator>-&gt;</operator><name>aggorder</name></name> <operator>||</operator> <name><name>agg</name><operator>-&gt;</operator><name>aggdistinct</name></name> <operator>||</operator> <name><name>agg</name><operator>-&gt;</operator><name>aggfilter</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"aggregates with FILTER / DISTINCT / ORDER BY are not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Fetch the pg_aggregate row */</comment>
		<expr_stmt><expr><name>aggtuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>AGGFNOID</name></expr></argument>, <argument><expr><name><name>agg</name><operator>-&gt;</operator><name>aggfnoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>aggtuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for aggregate %u"</literal></expr></argument>, <argument><expr><name><name>agg</name><operator>-&gt;</operator><name>aggfnoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>aggform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_aggregate</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>aggtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>aggform</name><operator>-&gt;</operator><name>aggkind</name></name> <operator>!=</operator> <literal type="char">'n'</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>aggtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ordered set/hypothetical aggregates are not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>aggform</name><operator>-&gt;</operator><name>aggcombinefn</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
			<operator>(</operator><name><name>aggform</name><operator>-&gt;</operator><name>aggtranstype</name></name> <operator>==</operator> <name>INTERNALOID</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>aggform</name><operator>-&gt;</operator><name>aggdeserialfn</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>aggtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"aggregates which are not parallelizable are not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>aggtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>cagg_agg_validate</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check query and extract error details and error hints.
 *
 * Returns:
 *   True if the query is supported, false otherwise with hints and errors
 *   added.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>cagg_query_supported</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>hint</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>detail</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>finalized</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<comment type="block">/*
 * For now deprecate partial aggregates on release builds only.
 * Once migration tests are made compatible with PG15 enable deprecation
 * on debug builds as well.
 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>DEBUG</name></cpp:ifndef>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG15_GE</name></expr></cpp:if>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>finalized</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* continuous aggregates with old format will not be allowed */</comment>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>detail</name></expr></argument>,
							   <argument><expr><literal type="string">"Continuous Aggregates with partials is not supported anymore."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>hint</name></expr></argument>,
							   <argument><expr><literal type="string">"Define the Continuous Aggregate with \"finalized\" parameter set "</literal>
							   <literal type="string">"to true."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_SELECT</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>hint</name></expr></argument>, <argument><expr><literal type="string">"Use a SELECT query in the continuous aggregate view."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>hasWindowFuncs</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>detail</name></expr></argument>,
							   <argument><expr><literal type="string">"Window functions are not supported by continuous aggregates."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>hasDistinctOn</name></name> <operator>||</operator> <name><name>query</name><operator>-&gt;</operator><name>distinctClause</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>detail</name></expr></argument>,
							   <argument><expr><literal type="string">"DISTINCT / DISTINCT ON queries are not supported by continuous "</literal>
							   <literal type="string">"aggregates."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>limitOffset</name></name> <operator>||</operator> <name><name>query</name><operator>-&gt;</operator><name>limitCount</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>detail</name></expr></argument>,
							   <argument><expr><literal type="string">"LIMIT and LIMIT OFFSET are not supported in queries defining "</literal>
							   <literal type="string">"continuous aggregates."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>hint</name></expr></argument>,
							   <argument><expr><literal type="string">"Use LIMIT and LIMIT OFFSET in SELECTS from the continuous "</literal>
							   <literal type="string">"aggregate view instead."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>sortClause</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>finalized</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>detail</name></expr></argument>,
							   <argument><expr><literal type="string">"ORDER BY is not supported in queries defining continuous "</literal>
							   <literal type="string">"aggregates."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>hint</name></expr></argument>,
							   <argument><expr><literal type="string">"Use ORDER BY clauses in SELECTS from the continuous aggregate view "</literal>
							   <literal type="string">"instead."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>hasRecursive</name></name> <operator>||</operator> <name><name>query</name><operator>-&gt;</operator><name>hasSubLinks</name></name> <operator>||</operator> <name><name>query</name><operator>-&gt;</operator><name>hasTargetSRFs</name></name> <operator>||</operator> <name><name>query</name><operator>-&gt;</operator><name>cteList</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>detail</name></expr></argument>,
							   <argument><expr><literal type="string">"CTEs, subqueries and set-returning functions are not supported by "</literal>
							   <literal type="string">"continuous aggregates."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>hasForUpdate</name></name> <operator>||</operator> <name><name>query</name><operator>-&gt;</operator><name>hasModifyingCTE</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>detail</name></expr></argument>,
							   <argument><expr><literal type="string">"Data modification is not allowed in continuous aggregate view "</literal>
							   <literal type="string">"definitions."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>hasRowSecurity</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>detail</name></expr></argument>,
							   <argument><expr><literal type="string">"Row level security is not supported by continuous aggregate "</literal>
							   <literal type="string">"views."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>groupingSets</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>detail</name></expr></argument>,
							   <argument><expr><literal type="string">"GROUP BY GROUPING SETS, ROLLUP and CUBE are not supported by "</literal>
							   <literal type="string">"continuous aggregates"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>hint</name></expr></argument>,
							   <argument><expr><literal type="string">"Define multiple continuous aggregates with different grouping "</literal>
							   <literal type="string">"levels."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>setOperations</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>detail</name></expr></argument>,
							   <argument><expr><literal type="string">"UNION, EXCEPT &amp; INTERSECT are not supported by continuous "</literal>
							   <literal type="string">"aggregates"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>query</name><operator>-&gt;</operator><name>groupClause</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*query can have aggregate without group by , so look
		 * for groupClause*/</comment>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>hint</name></expr></argument>,
							   <argument><expr><literal type="string">"Include at least one aggregate function"</literal>
							   <literal type="string">" and a GROUP BY clause with time bucket."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return> <comment type="block">/* Query was OK and is supported */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>CAggTimebucketInfo</name></type>
<name>cagg_validate_query</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>finalized</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cagg_schema</name></decl></parameter>,
					<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cagg_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CAggTimebucketInfo</name></type> <name>bucket_info</name></decl>, <decl><type ref="prev"/><name>bucket_info_parent</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cache</name> <modifier>*</modifier></type><name>hcache</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>rtref</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>fromList</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>hint</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>detail</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>is_nested</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>prev_query</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ContinuousAgg</name> <modifier>*</modifier></type><name>cagg_parent</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>cagg_query_supported</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>hint</name></expr></argument>, <argument><expr><name>detail</name></expr></argument>, <argument><expr><name>finalized</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid continuous aggregate query"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <ternary><condition><expr><name><name>hint</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>hint</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>,</operator>
				 <ternary><condition><expr><name><name>detail</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>detail</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* finalized cagg doesn't have those restrictions anymore */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>finalized</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* validate aggregates allowed */</comment>
		<expr_stmt><expr><call><name>cagg_agg_validate</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>cagg_agg_validate</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>fromList</name> <operator>=</operator> <name><name>query</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>fromlist</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>fromList</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>fromList</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"only one hypertable allowed in continuous aggregate view"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* check if we have a hypertable in the FROM clause */</comment>
	<expr_stmt><expr><name>rtref</name> <operator>=</operator> <call><name>linitial_node</name><argument_list>(<argument><expr><name>RangeTblRef</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>fromlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>, <argument><expr><name><name>rtref</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* FROM only &lt;tablename&gt; sets rte-&gt;inh to false */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator> <name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_VIEW</name><operator>)</operator> <operator>||</operator> <name><name>rte</name><operator>-&gt;</operator><name>tablesample</name></name> <operator>||</operator>
		<name><name>rte</name><operator>-&gt;</operator><name>inh</name></name> <operator>==</operator> <name>false</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid continuous aggregate view"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator> <name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_VIEW</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type><name>part_dimension</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type> <name>parent_mat_hypertable_id</name> <init>= <expr><name>INVALID_HYPERTABLE_ID</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>ht</name> <operator>=</operator> <call><name>ts_hypertable_cache_get_cache_and_entry</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>CACHE_FLAG_NONE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>cagg_parent</name> <operator>=</operator> <call><name>ts_continuous_agg_find_by_relid</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cagg_parent</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid continuous aggregate query"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"continuous aggregate needs to query hypertable or another "</literal>
								 <literal type="string">"continuous aggregate"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ContinuousAggIsFinalized</name><argument_list>(<argument><expr><name>cagg_parent</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"old format of continuous aggregate is not supported"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Run \"CALL cagg_migrate('%s.%s');\" to migrate to the new "</literal>
								 <literal type="string">"format."</literal></expr></argument>,
								 <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>cagg_parent</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>user_view_schema</name></name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>cagg_parent</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>user_view_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>parent_mat_hypertable_id</name> <operator>=</operator> <name><name>cagg_parent</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>mat_hypertable_id</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>hcache</name> <operator>=</operator> <call><name>ts_hypertable_cache_pin</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ht</name> <operator>=</operator> <call><name>ts_hypertable_cache_get_entry_by_id</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>, <argument><expr><name><name>cagg_parent</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>mat_hypertable_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* get the querydef for the source cagg */</comment>
			<expr_stmt><expr><name>is_nested</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>prev_query</name> <operator>=</operator> <call><name>ts_continuous_agg_get_query</name><argument_list>(<argument><expr><name>cagg_parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>TS_HYPERTABLE_IS_INTERNAL_COMPRESSION_TABLE</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"hypertable is an internal compressed hypertable"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ContinuousAggHypertableStatus</name></type> <name>status</name> <init>= <expr><call><name>ts_continuous_agg_hypertable_status</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* prevent create a CAGG over an existing materialization hypertable */</comment>
			<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>HypertableIsMaterialization</name> <operator>||</operator>
				<name>status</name> <operator>==</operator> <name>HypertableIsMaterializationAndRaw</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><specifier>const</specifier> <name>ContinuousAgg</name> <modifier>*</modifier></type><name>cagg</name> <init>= <expr><call><name>ts_continuous_agg_find_by_mat_hypertable_id</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cagg</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"hypertable is a continuous aggregate materialization table"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Materialization hypertable \"%s.%s\"."</literal></expr></argument>,
								   <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>schema_name</name></name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Do you want to use continuous aggregate \"%s.%s\" instead?"</literal></expr></argument>,
								 <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>user_view_schema</name></name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>user_view_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* get primary partitioning column information */</comment>
		<expr_stmt><expr><name>part_dimension</name> <operator>=</operator> <call><name>hyperspace_get_open_dimension</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>space</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* NOTE: if we ever allow custom partitioning functions we'll need to
		 *       change part_dimension-&gt;fd.column_type to partitioning_type
		 *       below, along with any other fallout
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>part_dimension</name><operator>-&gt;</operator><name>partitioning</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"custom partitioning functions not supported"</literal>
							<literal type="string">" with continuous aggregates"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IS_INTEGER_TYPE</name><argument_list>(<argument><expr><call><name>ts_dimension_get_partition_type</name><argument_list>(<argument><expr><name>part_dimension</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>funcschema</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>part_dimension</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>integer_now_func_schema</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>funcname</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>part_dimension</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>integer_now_func</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>funcschema</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"custom time function required on hypertable \"%s\""</literal></expr></argument>,
								<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"An integer-based hypertable requires a custom time"</literal>
								   <literal type="string">" function to support continuous aggregates."</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Set a custom time function on the hypertable."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>caggtimebucketinfo_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bucket_info</name></expr></argument>,
								<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>,
								<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>,
								<argument><expr><name><name>part_dimension</name><operator>-&gt;</operator><name>column_attno</name></name></expr></argument>,
								<argument><expr><name><name>part_dimension</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>column_type</name></name></expr></argument>,
								<argument><expr><name><name>part_dimension</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>interval_length</name></name></expr></argument>,
								<argument><expr><name>parent_mat_hypertable_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>is_nested</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>caggtimebucketinfo_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bucket_info_parent</name></expr></argument>,
									<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>,
									<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>,
									<argument><expr><name><name>part_dimension</name><operator>-&gt;</operator><name>column_attno</name></name></expr></argument>,
									<argument><expr><name><name>part_dimension</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>column_type</name></name></expr></argument>,
									<argument><expr><name><name>part_dimension</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>interval_length</name></name></expr></argument>,
									<argument><expr><name><name>cagg_parent</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>parent_mat_hypertable_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* check row security settings for the table */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>ts_has_row_security</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot create continuous aggregate on hypertable with row security"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We need a GROUP By clause with time_bucket on the partitioning
	 * column of the hypertable
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>caggtimebucket_validate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bucket_info</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* nested cagg validations */</comment>
	<if_stmt><if>if <condition>(<expr><name>is_nested</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int64</name></type> <name>bucket_width</name></decl>, <decl><type ref="prev"/><name>bucket_width_parent</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>is_greater_than_parent</name></decl>, <decl><type ref="prev"/><name>is_multiple_of_parent</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>prev_query</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>caggtimebucket_validate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bucket_info_parent</name></expr></argument>,
								<argument><expr><name><name>prev_query</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
								<argument><expr><name><name>prev_query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* cannot create cagg with fixed bucket on top of variable bucket */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>bucket_info_parent</name><operator>.</operator><name>bucket_width</name></name> <operator>==</operator> <name>BUCKET_WIDTH_VARIABLE</name> <operator>&amp;&amp;</operator>
			 <name><name>bucket_info</name><operator>.</operator><name>bucket_width</name></name> <operator>!=</operator> <name>BUCKET_WIDTH_VARIABLE</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot create continuous aggregate with fixed-width bucket on top of "</literal>
							<literal type="string">"one using variable-width bucket"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Continuous aggregate with a fixed time bucket width (e.g. 61 days) "</literal>
							   <literal type="string">"cannot be created on top of one using variable time bucket width "</literal>
							   <literal type="string">"(e.g. 1 month).\n"</literal>
							   <literal type="string">"The variance can lead to the fixed width one not being a multiple "</literal>
							   <literal type="string">"of the variable width one."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* if variable bucket size then get the month part for the arithmetic */</comment>
		<expr_stmt><expr><name>bucket_width</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>bucket_info</name><operator>.</operator><name>bucket_width</name></name> <operator>==</operator> <name>BUCKET_WIDTH_VARIABLE</name><operator>)</operator></expr> ?</condition><then>
						   <expr><name><name>bucket_info</name><operator>.</operator><name>interval</name><operator>-&gt;</operator><name>month</name></name></expr> </then><else>:
						   <expr><name><name>bucket_info</name><operator>.</operator><name>bucket_width</name></name></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name>bucket_width_parent</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>bucket_info_parent</name><operator>.</operator><name>bucket_width</name></name> <operator>==</operator> <name>BUCKET_WIDTH_VARIABLE</name><operator>)</operator></expr> ?</condition><then>
								  <expr><name><name>bucket_info_parent</name><operator>.</operator><name>interval</name><operator>-&gt;</operator><name>month</name></name></expr> </then><else>:
								  <expr><name><name>bucket_info_parent</name><operator>.</operator><name>bucket_width</name></name></expr></else></ternary></expr>;</expr_stmt>

		<comment type="block">/* check if the current bucket is greater than the parent */</comment>
		<expr_stmt><expr><name>is_greater_than_parent</name> <operator>=</operator> <operator>(</operator><name>bucket_width</name> <operator>&lt;=</operator> <name>bucket_width_parent</name><operator>)</operator></expr>;</expr_stmt>
		<comment type="block">/* check if buckets are multiple */</comment>
		<expr_stmt><expr><name>is_multiple_of_parent</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>bucket_width</name> <operator>%</operator> <name>bucket_width_parent</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

		<comment type="block">/* proceed with validation errors */</comment>
		<if_stmt><if>if <condition>(<expr><name>is_greater_than_parent</name> <operator>||</operator> <name>is_multiple_of_parent</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type> <name>width</name></decl>, <decl><type ref="prev"/><name>width_parent</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type> <name>outfuncid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type> <name>isvarlena</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type> <name>width_type</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>bucket_info</name><operator>.</operator><name>bucket_func</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>width_out</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>width_out_parent</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>message</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name>width_type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>outfuncid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isvarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>width</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>bucket_info</name><operator>.</operator><name>bucket_width</name></name> <operator>==</operator> <name>BUCKET_WIDTH_VARIABLE</name><operator>)</operator></expr> ?</condition><then>
						<expr><call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><name><name>bucket_info</name><operator>.</operator><name>interval</name></name></expr></argument>)</argument_list></call></expr> </then><else>:
						<expr><call><name>ts_internal_to_interval_value</name><argument_list>(<argument><expr><name>bucket_width</name></expr></argument>, <argument><expr><name>width_type</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

			<expr_stmt><expr><name>width_out</name> <operator>=</operator> <call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>OidFunctionCall1</name><argument_list>(<argument><expr><name>outfuncid</name></expr></argument>, <argument><expr><name>width</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>width_parent</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>bucket_info_parent</name><operator>.</operator><name>bucket_width</name></name> <operator>==</operator> <name>BUCKET_WIDTH_VARIABLE</name><operator>)</operator></expr> ?</condition><then>
							   <expr><call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><name><name>bucket_info_parent</name><operator>.</operator><name>interval</name></name></expr></argument>)</argument_list></call></expr> </then><else>:
							   <expr><call><name>ts_internal_to_interval_value</name><argument_list>(<argument><expr><name>bucket_width_parent</name></expr></argument>, <argument><expr><name>width_type</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

			<expr_stmt><expr><name>width_out_parent</name> <operator>=</operator> <call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>OidFunctionCall1</name><argument_list>(<argument><expr><name>outfuncid</name></expr></argument>, <argument><expr><name>width_parent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* new bucket should be greater than the parent */</comment>
			<if_stmt><if>if <condition>(<expr><name>is_greater_than_parent</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>message</name> <operator>=</operator> <literal type="string">"greater than"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* new bucket should be multiple of the parent */</comment>
			<if_stmt><if>if <condition>(<expr><name>is_multiple_of_parent</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>message</name> <operator>=</operator> <literal type="string">"multiple of"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot create continuous aggregate with incompatible bucket width"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Time bucket width of \"%s.%s\" [%s] should be %s the time "</literal>
							   <literal type="string">"bucket width of \"%s.%s\" [%s]."</literal></expr></argument>,
							   <argument><expr><name>cagg_schema</name></expr></argument>,
							   <argument><expr><name>cagg_name</name></expr></argument>,
							   <argument><expr><name>width_out</name></expr></argument>,
							   <argument><expr><name>message</name></expr></argument>,
							   <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>cagg_parent</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>user_view_schema</name></name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>cagg_parent</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>user_view_name</name></name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><name>width_out_parent</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>bucket_info</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* add ts_internal_cagg_final to bytea column.
 * bytea column is the internal state for an agg. Pass info for the agg as "inp".
 * inpcol = bytea column.
 * This function returns an aggref
 * ts_internal_cagg_final( Oid, Oid, bytea, NULL::output_typeid)
 * the arguments are a list of targetentry
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>get_finalizefnoid</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>finalfnoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name><name>finalfnargtypes</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>TEXTOID</name></expr>,	<expr><name>NAMEOID</name></expr>,	  <expr><name>NAMEOID</name></expr>, <expr><call><name>get_array_type</name><argument_list>(<argument><expr><name>NAMEOID</name></expr></argument>)</argument_list></call></expr>,
							  <expr><name>BYTEAOID</name></expr>, <expr><name>ANYELEMENTOID</name></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>funcname</name> <init>= <expr><call><name>list_make2</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>INTERNAL_SCHEMA_NAME</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>FINALFN</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nargs</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>finalfnargtypes</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>finalfnargtypes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>finalfnoid</name> <operator>=</operator> <call><name>LookupFuncName</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>, <argument><expr><name>finalfnargtypes</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>finalfnoid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Build a [N][2] array where N is number of arguments and the inner array is of [schema_name,
 * type_name] */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>get_input_types_array_datum</name><parameter_list>(<parameter><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>original_aggregate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>builder_context</name> <init>=
		<expr><call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>, <argument><expr><literal type="string">"input types builder"</literal></expr></argument>, <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>name_array_type_oid</name> <init>= <expr><call><name>get_array_type</name><argument_list>(<argument><expr><name>NAMEOID</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayBuildStateArr</name> <modifier>*</modifier></type><name>outer_builder</name> <init>=
		<expr><call><name>initArrayResultArr</name><argument_list>(<argument><expr><name>name_array_type_oid</name></expr></argument>, <argument><expr><name>NAMEOID</name></expr></argument>, <argument><expr><name>builder_context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>result</name></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>original_aggregate-&gt;args</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>type_oid</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ArrayBuildState</name> <modifier>*</modifier></type><name>schema_name_builder</name> <init>= <expr><call><name>initArrayResult</name><argument_list>(<argument><expr><name>NAMEOID</name></expr></argument>, <argument><expr><name>builder_context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typtup</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>schema_name</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Name</name></type> <name>type_name</name> <init>= <expr><operator>(</operator><name>Name</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type> <name>schema_datum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type> <name>type_name_datum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type> <name>inner_array_datum</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>type_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for type %u"</literal></expr></argument>, <argument><expr><name>type_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>typtup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><name>type_name</name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>typtup</name><operator>-&gt;</operator><name>typname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>schema_name</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>typtup</name><operator>-&gt;</operator><name>typnamespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>type_name_datum</name> <operator>=</operator> <call><name>NameGetDatum</name><argument_list>(<argument><expr><name>type_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* using name in because creating from a char * (that may be null or too long) */</comment>
		<expr_stmt><expr><name>schema_datum</name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>namein</name></expr></argument>, <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>schema_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>accumArrayResult</name><argument_list>(<argument><expr><name>schema_name_builder</name></expr></argument>, <argument><expr><name>schema_datum</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NAMEOID</name></expr></argument>, <argument><expr><name>builder_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>accumArrayResult</name><argument_list>(<argument><expr><name>schema_name_builder</name></expr></argument>, <argument><expr><name>type_name_datum</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NAMEOID</name></expr></argument>, <argument><expr><name>builder_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>inner_array_datum</name> <operator>=</operator> <call><name>makeArrayResult</name><argument_list>(<argument><expr><name>schema_name_builder</name></expr></argument>, <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>accumArrayResultArr</name><argument_list>(<argument><expr><name>outer_builder</name></expr></argument>,
							<argument><expr><name>inner_array_datum</name></expr></argument>,
							<argument><expr><name>false</name></expr></argument>,
							<argument><expr><name>name_array_type_oid</name></expr></argument>,
							<argument><expr><name>builder_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makeArrayResultArr</name><argument_list>(<argument><expr><name>outer_builder</name></expr></argument>, <argument><expr><name>CurrentMemoryContext</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>builder_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* creates an aggref of the form:
 * finalize-agg(
 *                "sum(int)" TEXT,
 *                collation_schema_name NAME, collation_name NAME,
 *                input_types_array NAME[N][2],
 *                &lt;partial-column-name&gt; BYTEA,
 *                null::&lt;return-type of sum(int)&gt;
 *             )
 * here sum(int) is the input aggregate "inp" in the parameter-list
 */</comment>
<function><type><specifier>static</specifier> <name>Aggref</name> <modifier>*</modifier></type>
<name>get_finalize_aggref</name><parameter_list>(<parameter><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>inp</name></decl></parameter>, <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>partial_state_var</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>aggref</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>aggregate_signature</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>aggregate_signature_const</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>collation_schema_const</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>collation_name_const</name></decl>,
		<decl><type ref="prev"><modifier>*</modifier></type><name>input_types_const</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>return_type_const</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>name_array_type_oid</name> <init>= <expr><call><name>get_array_type</name><argument_list>(<argument><expr><name>NAMEOID</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>partial_bytea_var</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>tlist_attno</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>argtypes</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>collation_name</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>collation_schema_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>collation_name_datum</name> <init>= <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>collation_schema_datum</name> <init>= <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>finalfnoid</name> <init>= <expr><call><name>get_finalizefnoid</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>argtypes</name> <operator>=</operator> <call><name>list_make5_oid</name><argument_list>(<argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><name>NAMEOID</name></expr></argument>, <argument><expr><name>NAMEOID</name></expr></argument>, <argument><expr><name>name_array_type_oid</name></expr></argument>, <argument><expr><name>BYTEAOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>argtypes</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>argtypes</name></expr></argument>, <argument><expr><name><name>inp</name><operator>-&gt;</operator><name>aggtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>aggref</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggfnoid</name></name> <operator>=</operator> <name>finalfnoid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggtype</name></name> <operator>=</operator> <name><name>inp</name><operator>-&gt;</operator><name>aggtype</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggcollid</name></name> <operator>=</operator> <name><name>inp</name><operator>-&gt;</operator><name>aggcollid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aggref</name><operator>-&gt;</operator><name>inputcollid</name></name> <operator>=</operator> <name><name>inp</name><operator>-&gt;</operator><name>inputcollid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggtranstype</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt> <comment type="block">/* will be set by planner */</comment>
	<expr_stmt><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggargtypes</name></name> <operator>=</operator> <name>argtypes</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggdirectargs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> <comment type="block">/*relevant for hypothetical set aggs*/</comment>
	<expr_stmt><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggorder</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggdistinct</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggfilter</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggstar</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggvariadic</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggkind</name></name> <operator>=</operator> <name>AGGKIND_NORMAL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggsplit</name></name> <operator>=</operator> <name>AGGSPLIT_SIMPLE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aggref</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<comment type="block">/* construct the arguments */</comment>
	<expr_stmt><expr><name>aggregate_signature</name> <operator>=</operator> <call><name>format_procedure_qualified</name><argument_list>(<argument><expr><name><name>inp</name><operator>-&gt;</operator><name>aggfnoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>aggregate_signature_const</name> <operator>=</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name>TEXTOID</name></expr></argument>,
										  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
										  <argument><expr><name>DEFAULT_COLLATION_OID</name></expr></argument>,
										  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
										  <argument><expr><call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>aggregate_signature</name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><name>false</name></expr></argument>,
										  <argument><expr><name>false</name></expr></argument> <comment type="block">/* passbyval */</comment>
	)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>aggregate_signature_const</name></expr></argument>, <argument><expr><name>tlist_attno</name><operator>++</operator></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>inp</name><operator>-&gt;</operator><name>inputcollid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* similar to generate_collation_name */</comment>
		<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_collation</name></type> <name>colltup</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>COLLOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>inp</name><operator>-&gt;</operator><name>inputcollid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for collation %u"</literal></expr></argument>, <argument><expr><name><name>inp</name><operator>-&gt;</operator><name>inputcollid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>colltup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_collation</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>collation_name</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>colltup</name><operator>-&gt;</operator><name>collname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>collation_name_datum</name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>namein</name></expr></argument>, <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>collation_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>collation_schema_name</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>colltup</name><operator>-&gt;</operator><name>collnamespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>collation_schema_name</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>collation_schema_datum</name> <operator>=</operator>
				<call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>namein</name></expr></argument>, <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>collation_schema_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>collation_schema_const</name> <operator>=</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name>NAMEOID</name></expr></argument>,
									   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
									   <argument><expr><name>InvalidOid</name></expr></argument>,
									   <argument><expr><name>NAMEDATALEN</name></expr></argument>,
									   <argument><expr><name>collation_schema_datum</name></expr></argument>,
									   <argument><expr><ternary><condition><expr><operator>(</operator><name>collation_schema_name</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr></argument>,
									   <argument><expr><name>false</name></expr></argument> <comment type="block">/* passbyval */</comment>
	)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>collation_schema_const</name></expr></argument>, <argument><expr><name>tlist_attno</name><operator>++</operator></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>collation_name_const</name> <operator>=</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name>NAMEOID</name></expr></argument>,
									 <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
									 <argument><expr><name>InvalidOid</name></expr></argument>,
									 <argument><expr><name>NAMEDATALEN</name></expr></argument>,
									 <argument><expr><name>collation_name_datum</name></expr></argument>,
									 <argument><expr><ternary><condition><expr><operator>(</operator><name>collation_name</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr></argument>,
									 <argument><expr><name>false</name></expr></argument> <comment type="block">/* passbyval */</comment>
	)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>collation_name_const</name></expr></argument>, <argument><expr><name>tlist_attno</name><operator>++</operator></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>input_types_const</name> <operator>=</operator> <call><name>makeConst</name><argument_list>(<argument><expr><call><name>get_array_type</name><argument_list>(<argument><expr><name>NAMEOID</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
								  <argument><expr><name>InvalidOid</name></expr></argument>,
								  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
								  <argument><expr><call><name>get_input_types_array_datum</name><argument_list>(<argument><expr><name>inp</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>false</name></expr></argument>,
								  <argument><expr><name>false</name></expr></argument> <comment type="block">/* passbyval */</comment>
	)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>input_types_const</name></expr></argument>, <argument><expr><name>tlist_attno</name><operator>++</operator></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>partial_bytea_var</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>partial_state_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>partial_bytea_var</name></expr></argument>, <argument><expr><name>tlist_attno</name><operator>++</operator></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>return_type_const</name> <operator>=</operator> <call><name>makeNullConst</name><argument_list>(<argument><expr><name><name>inp</name><operator>-&gt;</operator><name>aggtype</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>inp</name><operator>-&gt;</operator><name>aggcollid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>return_type_const</name></expr></argument>, <argument><expr><name>tlist_attno</name><operator>++</operator></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tlist_attno</name> <operator>==</operator> <literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aggref</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>
	<return>return <expr><name>aggref</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* creates a partialize expr for the passed in agg:
 * partialize_agg( agg)
 */</comment>
<function><type><specifier>static</specifier> <name>FuncExpr</name> <modifier>*</modifier></type>
<name>get_partialize_funcexpr</name><parameter_list>(<parameter><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>agg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>partialize_fnexpr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>partfnoid</name></decl>, <decl><type ref="prev"/><name>partargtype</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>partargtype</name> <operator>=</operator> <name>ANYELEMENTOID</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>partfnoid</name> <operator>=</operator> <call><name>LookupFuncName</name><argument_list>(<argument><expr><call><name>list_make2</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>INTERNAL_SCHEMA_NAME</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>PARTIALFN</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><literal type="number">1</literal></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>partargtype</name></expr></argument>,
							   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>partialize_fnexpr</name> <operator>=</operator> <call><name>makeFuncExpr</name><argument_list>(<argument><expr><name>partfnoid</name></expr></argument>,
									 <argument><expr><name>BYTEAOID</name></expr></argument>,
									 <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>agg</name></expr></argument>)</argument_list></call></expr></argument>, <comment type="block">/*args*/</comment>
									 <argument><expr><name>InvalidOid</name></expr></argument>,
									 <argument><expr><name>InvalidOid</name></expr></argument>,
									 <argument><expr><name>COERCE_EXPLICIT_CALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>partialize_fnexpr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check if the supplied OID belongs to a valid bucket function
 * for continuous aggregates.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>function_allowed_in_cagg_definition</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>funcid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FuncInfo</name> <modifier>*</modifier></type><name>finfo</name> <init>= <expr><call><name>ts_func_cache_get_bucketing_func</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>finfo</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name><name>finfo</name><operator>-&gt;</operator><name>allowed_in_cagg_definition</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize MatTableColumnInfo
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>mattablecolumninfo_init</name><parameter_list>(<parameter><decl><type><name>MatTableColumnInfo</name> <modifier>*</modifier></type><name>matcolinfo</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>grouplist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>matcolinfo</name><operator>-&gt;</operator><name>matcollist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>matcolinfo</name><operator>-&gt;</operator><name>partial_seltlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>matcolinfo</name><operator>-&gt;</operator><name>partial_grouplist</name></name> <operator>=</operator> <name>grouplist</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>matcolinfo</name><operator>-&gt;</operator><name>mat_groupcolname_list</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>matcolinfo</name><operator>-&gt;</operator><name>matpartcolno</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>matcolinfo</name><operator>-&gt;</operator><name>matpartcolname</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Add Information required to create and populate the materialization table columns
 * a) create a columndef for the materialization table
 * b) create the corresponding expr to populate the column of the materialization table (e..g for a
 *    column that is an aggref, we create a partialize_agg expr to populate the column Returns: the
 *    Var corresponding to the newly created column of the materialization table
 *
 * Notes: make sure the materialization table columns do not save
 *        values computed by mutable function.
 *
 * Notes on TargetEntry fields:
 * - (resname != NULL) means it's projected in our case
 * - (ressortgroupref &gt; 0) means part of GROUP BY, which can be projected or not, depending of the
 *                         value of the resjunk
 * - (resjunk == true) applies for GROUP BY columns that are not projected
 *
 */</comment>
<function><type><specifier>static</specifier> <name>Var</name> <modifier>*</modifier></type>
<name>mattablecolumninfo_addentry</name><parameter_list>(<parameter><decl><type><name>MatTableColumnInfo</name> <modifier>*</modifier></type><name>out</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>input</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>original_query_resno</name></decl></parameter>,
							<parameter><decl><type><name>bool</name></type> <name>finalized</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>skip_adding</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>matcolno</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>out</name><operator>-&gt;</operator><name>matcollist</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>colbuf</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>colname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>part_te</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ColumnDef</name> <modifier>*</modifier></type><name>col</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>coltype</name></decl>, <decl><type ref="prev"/><name>colcollation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>coltypmod</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>skip_adding</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>contain_mutable_functions</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"only immutable functions supported in continuous aggregate view"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Make sure all functions in the continuous aggregate definition"</literal>
						 <literal type="string">" have IMMUTABLE volatility. Note that functions or expressions"</literal>
						 <literal type="string">" may be IMMUTABLE for one data type, but STABLE or VOLATILE for"</literal>
						 <literal type="string">" another."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_Aggref</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>fexpr</name> <init>= <expr><call><name>get_partialize_funcexpr</name><argument_list>(<argument><expr><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <name>input</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>PRINT_MATCOLNAME</name><argument_list>(<argument><expr><name>colbuf</name></expr></argument>, <argument><expr><literal type="string">"agg"</literal></expr></argument>, <argument><expr><name>original_query_resno</name></expr></argument>, <argument><expr><name>matcolno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>colname</name> <operator>=</operator> <name>colbuf</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>coltype</name> <operator>=</operator> <name>BYTEAOID</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>coltypmod</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>colcollation</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>col</name> <operator>=</operator> <call><name>makeColumnDef</name><argument_list>(<argument><expr><name>colname</name></expr></argument>, <argument><expr><name>coltype</name></expr></argument>, <argument><expr><name>coltypmod</name></expr></argument>, <argument><expr><name>colcollation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>part_te</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>fexpr</name></expr></argument>, <argument><expr><name>matcolno</name></expr></argument>, <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<break>break;</break>

		<case>case <expr><name>T_TargetEntry</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <name>input</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type> <name>timebkt_chk</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>timebkt_chk</name> <operator>=</operator> <call><name>function_allowed_in_cagg_definition</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name><operator>)</operator><operator>-&gt;</operator><name>funcid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resname</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>colname</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>resname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>timebkt_chk</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>colname</name> <operator>=</operator> <name>DEFAULT_MATPARTCOLUMN_NAME</name></expr>;</expr_stmt></block_content></block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>PRINT_MATCOLNAME</name><argument_list>(<argument><expr><name>colbuf</name></expr></argument>, <argument><expr><literal type="string">"grp"</literal></expr></argument>, <argument><expr><name>original_query_resno</name></expr></argument>, <argument><expr><name>matcolno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>colname</name> <operator>=</operator> <name>colbuf</name></expr>;</expr_stmt>

					<comment type="block">/* for finalized form we skip adding extra group by columns */</comment>
					<expr_stmt><expr><operator>*</operator><name>skip_adding</name> <operator>=</operator> <name>finalized</name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>timebkt_chk</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>resname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>matpartcolno</name></name> <operator>=</operator> <name>matcolno</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>matpartcolname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * Add indexes only for columns that are part of the GROUP BY clause
				 * and for finals form we skip adding it because we'll not add the
				 * extra group by columns to the materialization hypertable anymore
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>skip_adding</name> <operator>&amp;&amp;</operator> <name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>mat_groupcolname_list</name></name> <operator>=</operator>
						<call><name>lappend</name><argument_list>(<argument><expr><name><name>out</name><operator>-&gt;</operator><name>mat_groupcolname_list</name></name></expr></argument>, <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><name>coltype</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>coltypmod</name> <operator>=</operator> <call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>colcollation</name> <operator>=</operator> <call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>col</name> <operator>=</operator> <call><name>makeColumnDef</name><argument_list>(<argument><expr><name>colname</name></expr></argument>, <argument><expr><name>coltype</name></expr></argument>, <argument><expr><name>coltypmod</name></expr></argument>, <argument><expr><name>colcollation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>part_te</name> <operator>=</operator> <operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* keep original resjunk if finalized or not time bucket */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>finalized</name> <operator>||</operator> <name>timebkt_chk</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Need to project all the partial entries so that
				 * materialization table is filled
				 */</comment>
				<expr_stmt><expr><name><name>part_te</name><operator>-&gt;</operator><name>resjunk</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name><name>part_te</name><operator>-&gt;</operator><name>resno</name></name> <operator>=</operator> <name>matcolno</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>timebkt_chk</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>col</name><operator>-&gt;</operator><name>is_not_null</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>part_te</name><operator>-&gt;</operator><name>resname</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>part_te</name><operator>-&gt;</operator><name>resname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
		<break>break;</break>

		<case>case <expr><name>T_Var</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PRINT_MATCOLNAME</name><argument_list>(<argument><expr><name>colbuf</name></expr></argument>, <argument><expr><literal type="string">"var"</literal></expr></argument>, <argument><expr><name>original_query_resno</name></expr></argument>, <argument><expr><name>matcolno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>colname</name> <operator>=</operator> <name>colbuf</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>coltype</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>coltypmod</name> <operator>=</operator> <call><name>exprTypmod</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>colcollation</name> <operator>=</operator> <call><name>exprCollation</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>col</name> <operator>=</operator> <call><name>makeColumnDef</name><argument_list>(<argument><expr><name>colname</name></expr></argument>, <argument><expr><name>coltype</name></expr></argument>, <argument><expr><name>coltypmod</name></expr></argument>, <argument><expr><name>colcollation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>part_te</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>input</name></expr></argument>, <argument><expr><name>matcolno</name></expr></argument>, <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* need to project all the partial entries so that materialization table is filled */</comment>
			<expr_stmt><expr><name><name>part_te</name><operator>-&gt;</operator><name>resjunk</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>part_te</name><operator>-&gt;</operator><name>resno</name></name> <operator>=</operator> <name>matcolno</name></expr>;</expr_stmt>
		</block_content>}</block>
		<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid node type %d"</literal></expr></argument>, <argument><expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><operator>!</operator><name>finalized</name> <operator>&amp;&amp;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>out</name><operator>-&gt;</operator><name>matcollist</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>out</name><operator>-&gt;</operator><name>partial_seltlist</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
		   <operator>(</operator><name>finalized</name> <operator>&amp;&amp;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>out</name><operator>-&gt;</operator><name>matcollist</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>out</name><operator>-&gt;</operator><name>partial_seltlist</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>col</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>part_te</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>skip_adding</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>matcollist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>out</name><operator>-&gt;</operator><name>matcollist</name></name></expr></argument>, <argument><expr><name>col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>partial_seltlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>out</name><operator>-&gt;</operator><name>partial_seltlist</name></name></expr></argument>, <argument><expr><name>part_te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>makeVar</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>matcolno</name></expr></argument>, <argument><expr><name>coltype</name></expr></argument>, <argument><expr><name>coltypmod</name></expr></argument>, <argument><expr><name>colcollation</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>var</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* add internal columns for the materialization table */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>mattablecolumninfo_addinternal</name><parameter_list>(<parameter><decl><type><name>MatTableColumnInfo</name> <modifier>*</modifier></type><name>matcolinfo</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>usertbl_rte</name></decl></parameter>,
							   <parameter><decl><type><name>int32</name></type> <name>usertbl_htid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Index</name></type> <name>maxRef</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>colno</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>matcolinfo</name><operator>-&gt;</operator><name>partial_seltlist</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ColumnDef</name> <modifier>*</modifier></type><name>col</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>chunkfn_arg1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>chunk_fnexpr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>chunkfnoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name><name>argtype</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>OIDOID</name></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>rettype</name> <init>= <expr><name>INT4OID</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>chunk_te</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>sortop</name></decl>, <decl><type ref="prev"/><name>eqop</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>hashable</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>grpcl</name></decl>;</decl_stmt>

	<comment type="block">/* add a chunk_id column for materialization table */</comment>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>vexpr</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeVar</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>colno</name></expr></argument>, <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>col</name> <operator>=</operator> <call><name>makeColumnDef</name><argument_list>(<argument><expr><name>CONTINUOUS_AGG_CHUNK_ID_COL_NAME</name></expr></argument>,
						<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>vexpr</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>exprTypmod</name><argument_list>(<argument><expr><name>vexpr</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>exprCollation</name><argument_list>(<argument><expr><name>vexpr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>matcolinfo</name><operator>-&gt;</operator><name>matcollist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>matcolinfo</name><operator>-&gt;</operator><name>matcollist</name></name></expr></argument>, <argument><expr><name>col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* need to add an entry to the target list for computing chunk_id column
	: chunk_for_tuple( htid, table.*)
	*/</comment>
	<expr_stmt><expr><name>chunkfnoid</name> <operator>=</operator>
		<call><name>LookupFuncName</name><argument_list>(<argument><expr><call><name>list_make2</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>INTERNAL_SCHEMA_NAME</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>CHUNKIDFROMRELID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>argtype</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>argtype</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>,
					   <argument><expr><name>argtype</name></expr></argument>,
					   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>chunkfn_arg1</name> <operator>=</operator> <call><name>makeVar</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>TableOidAttributeNumber</name></expr></argument>, <argument><expr><name>OIDOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>chunk_fnexpr</name> <operator>=</operator> <call><name>makeFuncExpr</name><argument_list>(<argument><expr><name>chunkfnoid</name></expr></argument>,
								<argument><expr><name>rettype</name></expr></argument>,
								<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>chunkfn_arg1</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><name>InvalidOid</name></expr></argument>,
								<argument><expr><name>InvalidOid</name></expr></argument>,
								<argument><expr><name>COERCE_EXPLICIT_CALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>chunk_te</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>chunk_fnexpr</name></expr></argument>,
							   <argument><expr><name>colno</name></expr></argument>,
							   <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>CONTINUOUS_AGG_CHUNK_ID_COL_NAME</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>matcolinfo</name><operator>-&gt;</operator><name>partial_seltlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>matcolinfo</name><operator>-&gt;</operator><name>partial_seltlist</name></name></expr></argument>, <argument><expr><name>chunk_te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*any internal column needs to be added to the group-by clause as well */</comment>
	<expr_stmt><expr><name>maxRef</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>matcolinfo-&gt;partial_seltlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Index</name></type> <name>ref</name> <init>= <expr><operator>(</operator><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>ressortgroupref</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>ref</name> <operator>&gt;</operator> <name>maxRef</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>maxRef</name> <operator>=</operator> <name>ref</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><name><name>chunk_te</name><operator>-&gt;</operator><name>ressortgroupref</name></name> <operator>=</operator>
		<name>maxRef</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* used by sortgroupclause to identify the targetentry */</comment>
	<expr_stmt><expr><name>grpcl</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>SortGroupClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>get_sort_group_operators</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>chunk_te</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name>false</name></expr></argument>,
							 <argument><expr><name>true</name></expr></argument>,
							 <argument><expr><name>false</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>sortop</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>eqop</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>hashable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>grpcl</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name> <operator>=</operator> <name><name>chunk_te</name><operator>-&gt;</operator><name>ressortgroupref</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>grpcl</name><operator>-&gt;</operator><name>eqop</name></name> <operator>=</operator> <name>eqop</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>grpcl</name><operator>-&gt;</operator><name>sortop</name></name> <operator>=</operator> <name>sortop</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>grpcl</name><operator>-&gt;</operator><name>nulls_first</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>grpcl</name><operator>-&gt;</operator><name>hashable</name></name> <operator>=</operator> <name>hashable</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>matcolinfo</name><operator>-&gt;</operator><name>partial_grouplist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>matcolinfo</name><operator>-&gt;</operator><name>partial_grouplist</name></name></expr></argument>, <argument><expr><name>grpcl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Aggref</name> <modifier>*</modifier></type>
<name>add_partialize_column</name><parameter_list>(<parameter><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>agg_to_partialize</name></decl></parameter>, <parameter><decl><type><name>AggPartCxt</name> <modifier>*</modifier></type><name>cxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>newagg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>skip_adding</name></decl>;</decl_stmt>

	<comment type="block">/* step 1: create partialize( aggref) column
	 * for materialization table */</comment>
	<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>mattablecolumninfo_addentry</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>mattblinfo</name></name></expr></argument>,
									  <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>agg_to_partialize</name></expr></argument>,
									  <argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>original_query_resno</name></name></expr></argument>,
									  <argument><expr><name>false</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>skip_adding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>added_aggref_col</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<comment type="block">/* step 2: create finalize_agg expr using var
	 * for the column added to the materialization table
	 */</comment>
	<comment type="block">/* This is a var for the column we created */</comment>
	<expr_stmt><expr><name>newagg</name> <operator>=</operator> <call><name>get_finalize_aggref</name><argument_list>(<argument><expr><name>agg_to_partialize</name></expr></argument>, <argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>newagg</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_var_mapping</name><parameter_list>(<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>orig_var</name></decl></parameter>, <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>mapped_var</name></decl></parameter>, <parameter><decl><type><name>AggPartCxt</name> <modifier>*</modifier></type><name>cxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>orig_vars</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>orig_vars</name></name></expr></argument>, <argument><expr><name>orig_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>mapped_vars</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>mapped_vars</name></name></expr></argument>, <argument><expr><name>mapped_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Checks whether var has already been mapped and returns the corresponding column of the
 * materialization table */</comment>
<function><type><specifier>static</specifier> <name>Var</name> <modifier>*</modifier></type>
<name>var_already_mapped</name><parameter_list>(<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><name>AggPartCxt</name> <modifier>*</modifier></type><name>cxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc_old</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>lc_new</name></decl>;</decl_stmt>

	<macro><name>forboth</name> <argument_list>(<argument>lc_old</argument>, <argument>cxt-&gt;orig_vars</argument>, <argument>lc_new</argument>, <argument>cxt-&gt;mapped_vars</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>orig_var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>lfirst_node</name><argument_list>(<argument><expr><name>Var</name></expr></argument>, <argument><expr><name>lc_old</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>mapped_var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>lfirst_node</name><argument_list>(<argument><expr><name>Var</name></expr></argument>, <argument><expr><name>lc_new</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* there should be no subqueries so varlevelsup should not be a problem here */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name><name>orig_var</name><operator>-&gt;</operator><name>varno</name></name> <operator>&amp;&amp;</operator> <name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <name><name>orig_var</name><operator>-&gt;</operator><name>varattno</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>mapped_var</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>add_var_mutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>AggPartCxt</name> <modifier>*</modifier></type><name>cxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>node</name></expr>;</return> <comment type="block">/*don't process this further */</comment>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>orig_var</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>mapped_var</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>skip_adding</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>mapped_var</name> <operator>=</operator> <call><name>var_already_mapped</name><argument_list>(<argument><expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Avoid duplicating columns in the materialization table */</comment>
		<if_stmt><if>if <condition>(<expr><name>mapped_var</name></expr>)</condition><block type="pseudo"><block_content>
			<comment type="block">/* there should be no subquery so mapped_var-&gt;varlevelsup should not be a problem here
			 */</comment>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>mapped_var</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>orig_var</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>mapped_var</name> <operator>=</operator> <call><name>mattablecolumninfo_addentry</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>mattblinfo</name></name></expr></argument>,
												 <argument><expr><name>node</name></expr></argument>,
												 <argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>original_query_resno</name></name></expr></argument>,
												 <argument><expr><name>false</name></expr></argument>,
												 <argument><expr><operator>&amp;</operator><name>skip_adding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>set_var_mapping</name><argument_list>(<argument><expr><name>orig_var</name></expr></argument>, <argument><expr><name>mapped_var</name></expr></argument>, <argument><expr><name>cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>mapped_var</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>expression_tree_mutator</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>add_var_mutator</name></expr></argument>, <argument><expr><name>cxt</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>add_aggregate_partialize_mutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>AggPartCxt</name> <modifier>*</modifier></type><name>cxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<comment type="block">/* modify the aggref and create a partialize(aggref) expr
	 * for the materialization.
	 * Add a corresponding  columndef for the mat table.
	 * Replace the aggref with the ts_internal_cagg_final fn.
	 * using a Var for the corresponding column in the mat table.
	 * All new Vars have varno = 1 (for RTE 1)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>cxt</name><operator>-&gt;</operator><name>ignore_aggoid</name></name> <operator>==</operator> <operator>(</operator><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>aggfnoid</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>node</name></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/*don't process this further */</comment>

		<decl_stmt><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>newagg</name> <init>= <expr><call><name>add_partialize_column</name><argument_list>(<argument><expr><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>cxt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newagg</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>var_outside_of_aggref</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>expression_tree_mutator</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>add_aggregate_partialize_mutator</name></expr></argument>, <argument><expr><name>cxt</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <name>Cagg_havingcxt</name>
<block>{
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>origq_tlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>finalizeq_tlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AggPartCxt</name></type> <name>agg_cxt</name></decl>;</decl_stmt>
}</block></struct></type> <name>cagg_havingcxt</name>;</typedef>

<comment type="block">/* This function modifies the passed in havingQual by mapping exprs to
 * columns in materialization table or finalized aggregate form.
 * Note that HAVING clause can contain only exprs from group-by or aggregates
 * and GROUP BY clauses cannot be aggregates.
 * (By the time we process havingQuals, all the group by exprs have been
 * processed and have associated columns in the materialization hypertable).
 * Example, if  the original query has
 * GROUP BY  colA + colB, colC
 *   HAVING colA + colB + sum(colD) &gt; 10 OR count(colE) = 10
 *
 * The transformed havingqual would be
 * HAVING   matCol3 + finalize_agg( sum(matCol4) &gt; 10
 *       OR finalize_agg( count(matCol5)) = 10
 *
 *
 * Note: GROUP BY exprs always appear in the query's targetlist.
 * Some of the aggregates from the havingQual  might also already appear in the targetlist.
 * We replace all existing entries with their corresponding entry from the modified targetlist.
 * If an aggregate (in the havingqual) does not exist in the TL, we create a
 *  materialization table column for it and use the finalize(column) form in the
 * transformed havingQual.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>create_replace_having_qual_mutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>cagg_havingcxt</name> <modifier>*</modifier></type><name>cxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<comment type="block">/* See if we already have a column in materialization hypertable for this
	 * expr. We do this by checking the existing targetlist
	 * entries for the query.
	 */</comment>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>origtlist</name> <init>= <expr><name><name>cxt</name><operator>-&gt;</operator><name>origq_tlist</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>modtlist</name> <init>= <expr><name><name>cxt</name><operator>-&gt;</operator><name>finalizeq_tlist</name></name></expr></init></decl>;</decl_stmt>
	<macro><name>forboth</name> <argument_list>(<argument>lc</argument>, <argument>origtlist</argument>, <argument>lc2</argument>, <argument>modtlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>modte</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>modte</name><operator>-&gt;</operator><name>expr</name></name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<comment type="block">/* didn't find a match in targetlist. If it is an aggregate, create a partialize column for
	 * it in materialization hypertable and return corresponding finalize
	 * expr.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AggPartCxt</name> <modifier>*</modifier></type><name>agg_cxt</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>cxt</name><operator>-&gt;</operator><name>agg_cxt</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>agg_cxt</name><operator>-&gt;</operator><name>added_aggref_col</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>newagg</name> <init>= <expr><call><name>add_partialize_column</name><argument_list>(<argument><expr><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>agg_cxt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>agg_cxt</name><operator>-&gt;</operator><name>added_aggref_col</name></name> <operator>==</operator> <name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newagg</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>expression_tree_mutator</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>create_replace_having_qual_mutator</name></expr></argument>, <argument><expr><name>cxt</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>finalizequery_create_havingqual</name><parameter_list>(<parameter><decl><type><name>FinalizeQueryInfo</name> <modifier>*</modifier></type><name>inp</name></decl></parameter>, <parameter><decl><type><name>MatTableColumnInfo</name> <modifier>*</modifier></type><name>mattblinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>orig_query</name> <init>= <expr><name><name>inp</name><operator>-&gt;</operator><name>final_userquery</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>orig_query</name><operator>-&gt;</operator><name>havingQual</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>havingQual</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>orig_query</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>inp</name><operator>-&gt;</operator><name>final_seltlist</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>cagg_havingcxt</name></type> <name>hcxt</name> <init>= <expr><block>{ <expr><operator>.</operator><name>origq_tlist</name> <operator>=</operator> <name><name>orig_query</name><operator>-&gt;</operator><name>targetList</name></name></expr>,
							<expr><operator>.</operator><name>finalizeq_tlist</name> <operator>=</operator> <name><name>inp</name><operator>-&gt;</operator><name>final_seltlist</name></name></expr>,
							<expr><operator>.</operator><name><name>agg_cxt</name><operator>.</operator><name>mattblinfo</name></name> <operator>=</operator> <name>mattblinfo</name></expr>,
							<expr><operator>.</operator><name><name>agg_cxt</name><operator>.</operator><name>original_query_resno</name></name> <operator>=</operator> <literal type="number">0</literal></expr>,
							<expr><operator>.</operator><name><name>agg_cxt</name><operator>.</operator><name>ignore_aggoid</name></name> <operator>=</operator> <call><name>get_finalizefnoid</name><argument_list>()</argument_list></call></expr>,
							<expr><operator>.</operator><name><name>agg_cxt</name><operator>.</operator><name>added_aggref_col</name></name> <operator>=</operator> <name>false</name></expr>,
							<expr><operator>.</operator><name><name>agg_cxt</name><operator>.</operator><name>var_outside_of_aggref</name></name> <operator>=</operator> <name>false</name></expr>,
							<expr><operator>.</operator><name><name>agg_cxt</name><operator>.</operator><name>orig_vars</name></name> <operator>=</operator> <name>NIL</name></expr>,
							<expr><operator>.</operator><name><name>agg_cxt</name><operator>.</operator><name>mapped_vars</name></name> <operator>=</operator> <name>NIL</name></expr> }</block></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>create_replace_having_qual_mutator</name><argument_list>(<argument><expr><name>havingQual</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hcxt</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
Init the finalize query data structure.
Parameters:
orig_query - the original query from user view that is being used as template for the finalize query
tlist_aliases - aliases for the view select list
materialization table columns are created . This will be returned in  the mattblinfo

DO NOT modify orig_query. Make a copy if needed.
SIDE_EFFECT: the data structure in mattblinfo is modified as a side effect by adding new materialize
table columns and partialize exprs.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>finalizequery_init</name><parameter_list>(<parameter><decl><type><name>FinalizeQueryInfo</name> <modifier>*</modifier></type><name>inp</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>orig_query</name></decl></parameter>, <parameter><decl><type><name>MatTableColumnInfo</name> <modifier>*</modifier></type><name>mattblinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AggPartCxt</name></type> <name>cxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>resno</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>inp</name><operator>-&gt;</operator><name>final_userquery</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>orig_query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>inp</name><operator>-&gt;</operator><name>final_seltlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>inp</name><operator>-&gt;</operator><name>final_havingqual</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* Set up the final_seltlist and final_havingqual entries */</comment>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>mattblinfo</name></name> <operator>=</operator> <name>mattblinfo</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>ignore_aggoid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>

	<comment type="block">/* Set up the left over variable mapping lists */</comment>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>orig_vars</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>mapped_vars</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<comment type="block">/* We want all the entries in the targetlist (resjunk or not)
	 * in the materialization  table definition so we include group-by/having clause etc.
	 * We have to do 3 things here: 1) create a column for mat table , 2) partialize_expr to
	 * populate it and 3) modify the target entry to be a finalize_expr that selects from the
	 * materialization table
	 */</comment>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>orig_query-&gt;targetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>modte</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>added_aggref_col</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>var_outside_of_aggref</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>original_query_resno</name></name> <operator>=</operator> <name>resno</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>inp</name><operator>-&gt;</operator><name>finalized</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If tle has aggrefs, get the corresponding
			 * finalize_agg expression and save it in modte
			 * also add correspong materialization table column info
			 * for the aggrefs in tle.
			 */</comment>
			<expr_stmt><expr><name>modte</name> <operator>=</operator> <operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>expression_tree_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>modte</name></expr></argument>,
															<argument><expr><name>add_aggregate_partialize_mutator</name></expr></argument>,
															<argument><expr><operator>&amp;</operator><name>cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* We need columns for non-aggregate targets
		 * if it is not a resjunk OR appears in the grouping clause
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>cxt</name><operator>.</operator><name>added_aggref_col</name></name> <operator>==</operator> <name>false</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name> <operator>==</operator> <name>false</name> <operator>||</operator> <name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type> <name>skip_adding</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>mattablecolumninfo_addentry</name><argument_list>(<argument><expr><name><name>cxt</name><operator>.</operator><name>mattblinfo</name></name></expr></argument>,
											  <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>tle</name></expr></argument>,
											  <argument><expr><name><name>cxt</name><operator>.</operator><name>original_query_resno</name></name></expr></argument>,
											  <argument><expr><name><name>inp</name><operator>-&gt;</operator><name>finalized</name></name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name>skip_adding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* skipp adding this column for finalized form */</comment>
			<if_stmt><if>if <condition>(<expr><name>skip_adding</name></expr>)</condition>
			<block>{<block_content>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* fix the expression for the target entry */</comment>
			<expr_stmt><expr><name><name>modte</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>var</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Check for left over variables (Var) of targets that contain Aggref */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>cxt</name><operator>.</operator><name>added_aggref_col</name></name> <operator>&amp;&amp;</operator> <name><name>cxt</name><operator>.</operator><name>var_outside_of_aggref</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>inp</name><operator>-&gt;</operator><name>finalized</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>modte</name> <operator>=</operator> <operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>expression_tree_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>modte</name></expr></argument>, <argument><expr><name>add_var_mutator</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Construct the targetlist for the query on the
		 * materialization table. The TL maps 1-1 with the original
		 * query:
		 * e.g select a, min(b)+max(d) from foo group by a,timebucket(a);
		 * becomes
		 * select &lt;a-col&gt;,
		 * ts_internal_cagg_final(..b-col ) + ts_internal_cagg_final(..d-col)
		 * from mattbl
		 * group by a-col, timebucket(a-col)
		 */</comment>
		<comment type="block">/*we copy the modte target entries , resnos should be the same for final_selquery and
		 * origquery . so tleSortGroupReffor the targetentry can be reused, only table info needs to
		 * be modified
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><operator>!</operator><name><name>inp</name><operator>-&gt;</operator><name>finalized</name></name> <operator>&amp;&amp;</operator> <name><name>modte</name><operator>-&gt;</operator><name>resno</name></name> <operator>==</operator> <name>resno</name><operator>)</operator> <operator>||</operator>
			   <operator>(</operator><name><name>inp</name><operator>-&gt;</operator><name>finalized</name></name> <operator>&amp;&amp;</operator> <name><name>modte</name><operator>-&gt;</operator><name>resno</name></name> <operator>&gt;=</operator> <name>resno</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>resno</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>modte</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>modte</name><operator>-&gt;</operator><name>resorigcol</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>modte</name><operator>-&gt;</operator><name>expr</name></name><operator>)</operator><operator>-&gt;</operator><name>varattno</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>inp</name><operator>-&gt;</operator><name>final_seltlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>inp</name><operator>-&gt;</operator><name>final_seltlist</name></name></expr></argument>, <argument><expr><name>modte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<comment type="block">/* all grouping clause elements are in targetlist already.
	   so let's check the having clause */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>inp</name><operator>-&gt;</operator><name>finalized</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>inp</name><operator>-&gt;</operator><name>final_havingqual</name></name> <operator>=</operator> <call><name>finalizequery_create_havingqual</name><argument_list>(<argument><expr><name>inp</name></expr></argument>, <argument><expr><name>mattblinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Create select query with the finalize aggregates
 * for the materialization table
 * matcollist - column list for mat table
 * mattbladdress - materialization table ObjectAddress
 */</comment>
<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type>
<name>finalizequery_get_select_query</name><parameter_list>(<parameter><decl><type><name>FinalizeQueryInfo</name> <modifier>*</modifier></type><name>inp</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>matcollist</name></decl></parameter>,
							   <parameter><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>mattbladdress</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>final_selquery</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<comment type="block">/*
	 * for initial cagg creation rtable will have only 1 entry,
	 * for alter table rtable will have multiple entries with our
	 * RangeTblEntry as last member.
	 */</comment>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>llast_node</name><argument_list>(<argument><expr><name>RangeTblEntry</name></expr></argument>, <argument><expr><name><name>inp</name><operator>-&gt;</operator><name>final_userquery</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FromExpr</name> <modifier>*</modifier></type><name>fromexpr</name></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <name><name>mattbladdress</name><operator>-&gt;</operator><name>objectId</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>=</operator> <name>RTE_RELATION</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>=</operator> <name>RELKIND_RELATION</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>tablesample</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>colnames</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>selectedCols</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<comment type="block">/* aliases for column names for the materialization table*/</comment>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>matcollist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ColumnDef</name> <modifier>*</modifier></type><name>cdef</name> <init>= <expr><operator>(</operator><name>ColumnDef</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>colnames</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name><name>cdef</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>selectedCols</name></name> <operator>=</operator>
			<call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>selectedCols</name></name></expr></argument>,
						   <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>requiredPerms</name></name> <operator>|=</operator> <name>ACL_SELECT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>insertedCols</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>updatedCols</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* 2. Fixup targetlist with the correct rel information */</comment>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>inp-&gt;final_seltlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>resorigtbl</name></name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>resorigcol</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name><operator>)</operator><operator>-&gt;</operator><name>varattno</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>CAGG_MAKEQUERY</name><argument_list>(<argument><expr><name>final_selquery</name></expr></argument>, <argument><expr><name><name>inp</name><operator>-&gt;</operator><name>final_userquery</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>final_selquery</name><operator>-&gt;</operator><name>hasAggs</name></name> <operator>=</operator> <operator>!</operator><name><name>inp</name><operator>-&gt;</operator><name>finalized</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>final_selquery</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <name><name>inp</name><operator>-&gt;</operator><name>final_userquery</name><operator>-&gt;</operator><name>rtable</name></name></expr>;</expr_stmt> <comment type="block">/* fixed up above */</comment>
	<comment type="block">/* fixup from list. No quals on original table should be
	 * present here - they should be on the query that populates the mattable (partial_selquery)
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>inp</name><operator>-&gt;</operator><name>final_userquery</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>fromlist</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>fromexpr</name> <operator>=</operator> <name><name>inp</name><operator>-&gt;</operator><name>final_userquery</name><operator>-&gt;</operator><name>jointree</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fromexpr</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>final_selquery</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <name>fromexpr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>final_selquery</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <name><name>inp</name><operator>-&gt;</operator><name>final_seltlist</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>final_selquery</name><operator>-&gt;</operator><name>sortClause</name></name> <operator>=</operator> <name><name>inp</name><operator>-&gt;</operator><name>final_userquery</name><operator>-&gt;</operator><name>sortClause</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>inp</name><operator>-&gt;</operator><name>finalized</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>final_selquery</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>=</operator> <name><name>inp</name><operator>-&gt;</operator><name>final_userquery</name><operator>-&gt;</operator><name>groupClause</name></name></expr>;</expr_stmt>
		<comment type="block">/* copy the having clause too */</comment>
		<expr_stmt><expr><name><name>final_selquery</name><operator>-&gt;</operator><name>havingQual</name></name> <operator>=</operator> <name><name>inp</name><operator>-&gt;</operator><name>final_havingqual</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>final_selquery</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Assign aliases to the targetlist in the query according to the column_names provided
 * in the CREATE VIEW statement.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>fixup_userview_query_tlist</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>userquery</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist_aliases</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>tlist_aliases</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>alist_item</name> <init>= <expr><call><name>list_head</name><argument_list>(<argument><expr><name>tlist_aliases</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>userquery-&gt;targetList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* junk columns don't get aliases */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>resname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>alist_item</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>alist_item</name> <operator>=</operator> <call><name>lnext_compat</name><argument_list>(<argument><expr><name>tlist_aliases</name></expr></argument>, <argument><expr><name>alist_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>alist_item</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt> <comment type="block">/* done assigning aliases */</comment>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><name>alist_item</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"too many column names specified"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Modifies the passed in ViewStmt to do the following
 * a) Create a hypertable for the continuous agg materialization.
 * b) create a view that references the underlying
 * materialization table instead of the original table used in
 * the CREATE VIEW stmt.
 * Example:
 * CREATE VIEW mcagg ...
 * AS  select a, min(b)+max(d) from foo group by a,timebucket(a);
 *
 * Step 1. create a materialiation table which stores the partials for the
 * aggregates and the grouping columns + internal columns.
 * So we have a table like _materialization_hypertable
 * with columns:
 *( a, col1, col2, col3, internal-columns)
 * where col1 =  partialize(min(b)), col2= partialize(max(d)),
 * col3= timebucket(a))
 *
 * Step 2: Create a view with modified select query
 * CREATE VIEW mcagg
 * as
 * select a, finalize( col1) + finalize(col2))
 * from _materialization_hypertable
 * group by a, col3
 *
 * Step 3: Create a view to populate the materialization table
 * create view ts_internal_mcagg_view
 * as
 * select a, partialize(min(b)), partialize(max(d)), timebucket(a), &lt;internal-columns&gt;
 * from foo
 * group by &lt;internal-columns&gt; , a , timebucket(a);
 *
 * Notes: ViewStmt-&gt;query is the raw parse tree
 * panquery is the output of running parse_anlayze( ViewStmt-&gt;query)
 *               so don't recreate invalidation trigger.

 * Since 1.7, we support real time aggregation.
 * If real time aggregation is off i.e. materialized only, the mcagg vew is as described in Step 2.
 * If it is turned on
 * we build a union query that selects from the internal mat view and the raw hypertable
 *     (see build_union_query for details)
 * CREATE VIEW mcagg
 * as
 * SELECT * from
 *        ( SELECT a, finalize(col1) + finalize(col2) from ts_internal_mcagg_view
 *                 ---&gt; query from Step 2 with additional where clause
 *          WHERE timecol &lt; materialization threshold
 *          group by &lt;internal-columns&gt; , a , timebucket(a);
 *          UNION ALL
 *          SELECT a, min(b)+max(d) from foo ---&gt; original view stmt
 *                              ----&gt; with additional where clause
 *          WHERE timecol &gt;= materialization threshold
 *          GROUP BY a, time_bucket(a)
 *        )
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>cagg_create</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CreateTableAsStmt</name> <modifier>*</modifier></type><name>create_stmt</name></decl></parameter>, <parameter><decl><type><name>ViewStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>panquery</name></decl></parameter>,
			<parameter><decl><type><name>CAggTimebucketInfo</name> <modifier>*</modifier></type><name>origquery_ht</name></decl></parameter>, <parameter><decl><type><name>WithClauseResult</name> <modifier>*</modifier></type><name>with_clause_options</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>mataddress</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>relnamebuf</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MatTableColumnInfo</name></type> <name>mattblinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FinalizeQueryInfo</name></type> <name>finalqinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CatalogSecurityContext</name></type> <name>sec_ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>is_create_mattbl_index</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>final_selquery</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>partial_selquery</name></decl>;</decl_stmt>	<comment type="block">/* query to populate the mattable*/</comment>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>orig_userview_query</name></decl>;</decl_stmt> <comment type="block">/* copy of the original user query for dummy view */</comment>
	<decl_stmt><decl><type><name>Oid</name></type> <name>nspid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>part_rel</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>mat_rel</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>dum_rel</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>materialize_hypertable_id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>materialized_only</name> <init>=
		<expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><name><name>with_clause_options</name><index>[<expr><name>ContinuousViewOptionMaterializedOnly</name></expr>]</index></name><operator>.</operator><name>parsed</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>finalized</name> <init>= <expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><name><name>with_clause_options</name><index>[<expr><name>ContinuousViewOptionFinalized</name></expr>]</index></name><operator>.</operator><name>parsed</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>finalqinfo</name><operator>.</operator><name>finalized</name></name> <operator>=</operator> <name>finalized</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Assign the column_name aliases in CREATE VIEW to the query. No other modifications to
	 * panquery
	 */</comment>
	<expr_stmt><expr><call><name>fixup_userview_query_tlist</name><argument_list>(<argument><expr><name>panquery</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>aliases</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>mattablecolumninfo_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mattblinfo</name></expr></argument>, <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>panquery</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>finalizequery_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>finalqinfo</name></expr></argument>, <argument><expr><name>panquery</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mattblinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Invalidate all options on the stmt before using it
	 * The options are valid only for internal use (ts_continuous)
	 */</comment>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Step 0: add any internal columns needed for materialization based
	 *         on the user query's table
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>finalized</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>usertbl_rte</name> <init>= <expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>panquery</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>mattablecolumninfo_addinternal</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mattblinfo</name></expr></argument>, <argument><expr><name>usertbl_rte</name></expr></argument>, <argument><expr><name><name>origquery_ht</name><operator>-&gt;</operator><name>htid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Step 1: create the materialization table */</comment>
	<expr_stmt><expr><call><name>ts_catalog_database_info_become_owner</name><argument_list>(<argument><expr><call><name>ts_catalog_database_info_get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>materialize_hypertable_id</name> <operator>=</operator> <call><name>ts_catalog_table_next_seq_id</name><argument_list>(<argument><expr><call><name>ts_catalog_get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>HYPERTABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_catalog_restore_user</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PRINT_MATINTERNAL_NAME</name><argument_list>(<argument><expr><name>relnamebuf</name></expr></argument>, <argument><expr><literal type="string">"_materialized_hypertable_%d"</literal></expr></argument>, <argument><expr><name>materialize_hypertable_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>mat_rel</name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>INTERNAL_SCHEMA_NAME</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>relnamebuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>is_create_mattbl_index</name> <operator>=</operator>
		<call><name>DatumGetBool</name><argument_list>(<argument><expr><name><name>with_clause_options</name><index>[<expr><name>ContinuousViewOptionCreateGroupIndex</name></expr>]</index></name><operator>.</operator><name>parsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>mattablecolumninfo_create_materialization_table</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mattblinfo</name></expr></argument>,
													<argument><expr><name>materialize_hypertable_id</name></expr></argument>,
													<argument><expr><name>mat_rel</name></expr></argument>,
													<argument><expr><name>origquery_ht</name></expr></argument>,
													<argument><expr><name>is_create_mattbl_index</name></expr></argument>,
													<argument><expr><name><name>create_stmt</name><operator>-&gt;</operator><name>into</name><operator>-&gt;</operator><name>tableSpaceName</name></name></expr></argument>,
													<argument><expr><name><name>create_stmt</name><operator>-&gt;</operator><name>into</name><operator>-&gt;</operator><name>accessMethod</name></name></expr></argument>,
													<argument><expr><operator>&amp;</operator><name>mataddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Step 2: create view with select finalize from materialization
	 * table
	 */</comment>
	<expr_stmt><expr><name>final_selquery</name> <operator>=</operator>
		<call><name>finalizequery_get_select_query</name><argument_list>(<argument><expr><operator>&amp;</operator><name>finalqinfo</name></expr></argument>, <argument><expr><name><name>mattblinfo</name><operator>.</operator><name>matcollist</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mataddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>materialized_only</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>final_selquery</name> <operator>=</operator> <call><name>build_union_query</name><argument_list>(<argument><expr><name>origquery_ht</name></expr></argument>,
										   <argument><expr><name><name>mattblinfo</name><operator>.</operator><name>matpartcolno</name></name></expr></argument>,
										   <argument><expr><name>final_selquery</name></expr></argument>,
										   <argument><expr><name>panquery</name></expr></argument>,
										   <argument><expr><name>materialize_hypertable_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* copy view acl to materialization hypertable */</comment>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>view_address</name> <init>= <expr><call><name>create_view_for_query</name><argument_list>(<argument><expr><name>final_selquery</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>view</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ts_copy_relation_acl</name><argument_list>(<argument><expr><name><name>view_address</name><operator>.</operator><name>objectId</name></name></expr></argument>, <argument><expr><name><name>mataddress</name><operator>.</operator><name>objectId</name></name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Step 3: create the internal view with select partialize(..)
	 */</comment>
	<expr_stmt><expr><name>partial_selquery</name> <operator>=</operator>
		<call><name>mattablecolumninfo_get_partial_select_query</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mattblinfo</name></expr></argument>, <argument><expr><name>panquery</name></expr></argument>, <argument><expr><name><name>finalqinfo</name><operator>.</operator><name>finalized</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PRINT_MATINTERNAL_NAME</name><argument_list>(<argument><expr><name>relnamebuf</name></expr></argument>, <argument><expr><literal type="string">"_partial_view_%d"</literal></expr></argument>, <argument><expr><name>materialize_hypertable_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>part_rel</name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>INTERNAL_SCHEMA_NAME</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>relnamebuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>create_view_for_query</name><argument_list>(<argument><expr><name>partial_selquery</name></expr></argument>, <argument><expr><name>part_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Additional miscellaneous steps */</comment>
	<comment type="block">/* create a dummy view to store the user supplied view query. This is to get PG
	 * to display the view correctly without having to replicate the PG source code for make_viewdef
	 */</comment>
	<expr_stmt><expr><name>orig_userview_query</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>panquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PRINT_MATINTERNAL_NAME</name><argument_list>(<argument><expr><name>relnamebuf</name></expr></argument>, <argument><expr><literal type="string">"_direct_view_%d"</literal></expr></argument>, <argument><expr><name>materialize_hypertable_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dum_rel</name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>INTERNAL_SCHEMA_NAME</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>relnamebuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>create_view_for_query</name><argument_list>(<argument><expr><name>orig_userview_query</name></expr></argument>, <argument><expr><name>dum_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Step 4 add catalog table entry for the objects we just created */</comment>
	<expr_stmt><expr><name>nspid</name> <operator>=</operator> <call><name>RangeVarGetCreationNamespace</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>view</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>create_cagg_catalog_entry</name><argument_list>(<argument><expr><name>materialize_hypertable_id</name></expr></argument>,
							  <argument><expr><name><name>origquery_ht</name><operator>-&gt;</operator><name>htid</name></name></expr></argument>,
							  <argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>nspid</name></expr></argument>)</argument_list></call></expr></argument>, <comment type="block">/*schema name for user view */</comment>
							  <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>view</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>,
							  <argument><expr><name><name>part_rel</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>,
							  <argument><expr><name><name>part_rel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>,
							  <argument><expr><name><name>origquery_ht</name><operator>-&gt;</operator><name>bucket_width</name></name></expr></argument>,
							  <argument><expr><name>materialized_only</name></expr></argument>,
							  <argument><expr><name><name>dum_rel</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>,
							  <argument><expr><name><name>dum_rel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>,
							  <argument><expr><name>finalized</name></expr></argument>,
							  <argument><expr><name><name>origquery_ht</name><operator>-&gt;</operator><name>parent_mat_hypertable_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>origquery_ht</name><operator>-&gt;</operator><name>bucket_width</name></name> <operator>==</operator> <name>BUCKET_WIDTH_VARIABLE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>bucket_width</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>origin</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Variable-sized buckets work only with intervals.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>origquery_ht</name><operator>-&gt;</operator><name>interval</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bucket_width</name> <operator>=</operator> <call><name>DatumGetCString</name><argument_list>(
			<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>interval_out</name></expr></argument>, <argument><expr><call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><name><name>origquery_ht</name><operator>-&gt;</operator><name>interval</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TIMESTAMP_NOT_FINITE</name><argument_list>(<argument><expr><name><name>origquery_ht</name><operator>-&gt;</operator><name>origin</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>origin</name> <operator>=</operator> <call><name>DatumGetCString</name><argument_list>(
				<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>timestamp_out</name></expr></argument>, <argument><expr><call><name>TimestampGetDatum</name><argument_list>(<argument><expr><name><name>origquery_ht</name><operator>-&gt;</operator><name>origin</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * These values are not used for
		 * anything except Assert's yet for the same reasons. Once the design
		 * of variable-sized buckets is finalized we will have a better idea
		 * of what schema is needed exactly. Until then the choice was made
		 * in favor of the most generic schema that can be optimized later.
		 */</comment>
		<expr_stmt><expr><call><name>create_bucket_function_catalog_entry</name><argument_list>(<argument><expr><name>materialize_hypertable_id</name></expr></argument>,
											 <argument><expr><call><name>get_func_namespace</name><argument_list>(
												 <argument><expr><name><name>origquery_ht</name><operator>-&gt;</operator><name>bucket_func</name><operator>-&gt;</operator><name>funcid</name></name></expr></argument>)</argument_list></call> <operator>!=</operator>
												 <name>PG_PUBLIC_NAMESPACE</name></expr></argument>,
											 <argument><expr><call><name>get_func_name</name><argument_list>(<argument><expr><name><name>origquery_ht</name><operator>-&gt;</operator><name>bucket_func</name><operator>-&gt;</operator><name>funcid</name></name></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><name>bucket_width</name></expr></argument>,
											 <argument><expr><name>origin</name></expr></argument>,
											 <argument><expr><name><name>origquery_ht</name><operator>-&gt;</operator><name>timezone</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Step 5 create trigger on raw hypertable -specified in the user view query*/</comment>
	<expr_stmt><expr><call><name>cagg_add_trigger_hypertable</name><argument_list>(<argument><expr><name><name>origquery_ht</name><operator>-&gt;</operator><name>htoid</name></name></expr></argument>, <argument><expr><name><name>origquery_ht</name><operator>-&gt;</operator><name>htid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>DDLResult</name></type>
<name>tsl_process_continuous_agg_viewstmt</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query_string</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pstmt</name></decl></parameter>,
									<parameter><decl><type><name>WithClauseResult</name> <modifier>*</modifier></type><name>with_clause_options</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>CreateTableAsStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>CreateTableAsStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CAggTimebucketInfo</name></type> <name>timebucket_exprinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>nspid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>finalized</name> <init>= <expr><name><name>with_clause_options</name><index>[<expr><name>ContinuousViewOptionFinalized</name></expr>]</index></name><operator>.</operator><name>parsed</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ViewStmt</name></type> <name>viewstmt</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>T_ViewStmt</name></expr>,
		<expr><operator>.</operator><name>view</name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>into</name><operator>-&gt;</operator><name>rel</name></name></expr>,
		<expr><operator>.</operator><name>query</name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>into</name><operator>-&gt;</operator><name>viewQuery</name></name></expr>,
		<expr><operator>.</operator><name>options</name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>into</name><operator>-&gt;</operator><name>options</name></name></expr>,
		<expr><operator>.</operator><name>aliases</name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>into</name><operator>-&gt;</operator><name>colNames</name></name></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>nspid</name> <operator>=</operator> <call><name>RangeVarGetCreationNamespace</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>into</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>get_relname_relid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>into</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>, <argument><expr><name>nspid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>if_not_exists</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"continuous aggregate \"%s\" already exists, skipping"</literal></expr></argument>,
							<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>into</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>DDL_DONE</name></expr>;</return>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"continuous aggregate \"%s\" already exists"</literal></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>into</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Drop or rename the existing continuous aggregate"</literal>
							 <literal type="string">" first or use another name."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>with_clause_options</name><index>[<expr><name>ContinuousViewOptionCompress</name></expr>]</index></name><operator>.</operator><name>is_default</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot enable compression while creating a continuous aggregate"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use ALTER MATERIALIZED VIEW to enable compression."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>timebucket_exprinfo</name> <operator>=</operator> <call><name>cagg_validate_query</name><argument_list>(<argument><expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>into</name><operator>-&gt;</operator><name>viewQuery</name></name></expr></argument>,
											  <argument><expr><name>finalized</name></expr></argument>,
											  <argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>nspid</name></expr></argument>)</argument_list></call></expr></argument>,
											  <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>into</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>cagg_create</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>viewstmt</name></expr></argument>, <argument><expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>query</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>timebucket_exprinfo</name></expr></argument>, <argument><expr><name>with_clause_options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>into</name><operator>-&gt;</operator><name>skipData</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>relid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ContinuousAgg</name> <modifier>*</modifier></type><name>cagg</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>InternalTimeRange</name></type> <name>refresh_window</name> <init>= <expr><block>{
			<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>InvalidOid</name></expr>,
		}</block></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* We are creating a refresh window here in a similar way to how it's
		 * done in continuous_agg_refresh. We do not call the PG function
		 * directly since we want to be able to suppress the output in that
		 * function and adding a 'verbose' parameter to is not useful for a
		 * user. */</comment>
		<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>get_relname_relid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>into</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>, <argument><expr><name>nspid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cagg</name> <operator>=</operator> <call><name>ts_continuous_agg_find_by_relid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cagg</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>refresh_window</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name><name>cagg</name><operator>-&gt;</operator><name>partition_type</name></name></expr>;</expr_stmt>
		<comment type="block">/*
		 * To determine inscribed/circumscribed refresh window for variable-sized
		 * buckets we should be able to calculate time_bucket(window.begin) and
		 * time_bucket(window.end). This, however, is not possible in general case.
		 * As an example, the minimum date is 4714-11-24 BC, which is before any
		 * reasonable default `origin` value. Thus for variable-sized buckets
		 * instead of minimum date we use -infinity since time_bucket(-infinity)
		 * is well-defined as -infinity.
		 *
		 * For more details see:
		 * - ts_compute_inscribed_bucketed_refresh_window_variable()
		 * - ts_compute_circumscribed_bucketed_refresh_window_variable()
		 */</comment>
		<expr_stmt><expr><name><name>refresh_window</name><operator>.</operator><name>start</name></name> <operator>=</operator> <ternary><condition><expr><call><name>ts_continuous_agg_bucket_width_variable</name><argument_list>(<argument><expr><name>cagg</name></expr></argument>)</argument_list></call></expr> ?</condition><then>
								   <expr><call><name>ts_time_get_nobegin</name><argument_list>(<argument><expr><name><name>refresh_window</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr> </then><else>:
								   <expr><call><name>ts_time_get_min</name><argument_list>(<argument><expr><name><name>refresh_window</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>refresh_window</name><operator>.</operator><name>end</name></name> <operator>=</operator> <call><name>ts_time_get_noend_or_max</name><argument_list>(<argument><expr><name><name>refresh_window</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>continuous_agg_refresh_internal</name><argument_list>(<argument><expr><name>cagg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>refresh_window</name></expr></argument>, <argument><expr><name>CAGG_REFRESH_CREATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>DDL_DONE</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* When a view is created (StoreViewQuery), 2 dummy rtable entries corresponding to "old" and
 * "new" are prepended to the rtable list. We remove these and adjust the varnos to recreate
 * the user or direct view query.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>remove_old_and_new_rte_from_query</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>rtable</name> <init>= <expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>rtable</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rtable</name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name>rtable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name>rtable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>OffsetVarNodes</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>query</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Test the view definition of an existing continuous aggregate for errors and attempt to rebuild
 * it if required.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>cagg_rebuild_view_definition</name><parameter_list>(<parameter><decl><type><name>ContinuousAgg</name> <modifier>*</modifier></type><name>agg</name></decl></parameter>, <parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>mat_ht</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>test_failed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relname</name> <init>= <expr><name><name>agg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>user_view_name</name><operator>.</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>schema</name> <init>= <expr><name><name>agg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>user_view_schema</name><operator>.</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>sec_ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>uid</name></decl>, <decl><type ref="prev"/><name>saved_uid</name></decl>;</decl_stmt>
	<comment type="block">/* cagg view created by the user */</comment>
	<decl_stmt><decl><type><name>Oid</name></type> <name>user_view_oid</name> <init>= <expr><call><name>relation_oid</name><argument_list>(<argument><expr><name><name>agg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>user_view_schema</name></name></expr></argument>, <argument><expr><name><name>agg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>user_view_name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>user_view_rel</name> <init>= <expr><call><name>relation_open</name><argument_list>(<argument><expr><name>user_view_oid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>user_query</name> <init>= <expr><call><name>get_view_query</name><argument_list>(<argument><expr><name>user_view_rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>finalized</name> <init>= <expr><call><name>ContinuousAggIsFinalized</name><argument_list>(<argument><expr><name>agg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Extract final query from user view query. */</comment>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>final_query</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>user_query</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>remove_old_and_new_rte_from_query</name><argument_list>(<argument><expr><name>final_query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>agg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>materialized_only</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>final_query</name> <operator>=</operator> <call><name>destroy_union_query</name><argument_list>(<argument><expr><name>final_query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>finalized</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* This continuous aggregate does not have partials, do not check for defects. */</comment>
		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>user_view_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>FinalizeQueryInfo</name></type> <name>fqi</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MatTableColumnInfo</name></type> <name>mattblinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>mataddress</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>classId</name> <operator>=</operator> <name>RelationRelationId</name></expr>,
		<expr><operator>.</operator><name>objectId</name> <operator>=</operator> <name><name>mat_ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>direct_view_oid</name> <init>= <expr><call><name>relation_oid</name><argument_list>(<argument><expr><name><name>agg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>direct_view_schema</name></name></expr></argument>, <argument><expr><name><name>agg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>direct_view_name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>direct_view_rel</name> <init>= <expr><call><name>relation_open</name><argument_list>(<argument><expr><name>direct_view_oid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>direct_query</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><call><name>get_view_query</name><argument_list>(<argument><expr><name>direct_view_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>remove_old_and_new_rte_from_query</name><argument_list>(<argument><expr><name>direct_query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>CAggTimebucketInfo</name></type> <name>timebucket_exprinfo</name> <init>=
		<expr><call><name>cagg_validate_query</name><argument_list>(<argument><expr><name>direct_query</name></expr></argument>,
							<argument><expr><name>finalized</name></expr></argument>,
							<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>agg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>user_view_schema</name></name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>agg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>user_view_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>mattablecolumninfo_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mattblinfo</name></expr></argument>, <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>direct_query</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fqi</name><operator>.</operator><name>finalized</name></name> <operator>=</operator> <name>finalized</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>finalizequery_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fqi</name></expr></argument>, <argument><expr><name>direct_query</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mattblinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>usertbl_rte</name> <init>= <expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>direct_query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>mattablecolumninfo_addinternal</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mattblinfo</name></expr></argument>, <argument><expr><name>usertbl_rte</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>view_query</name> <init>= <expr><call><name>finalizequery_get_select_query</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fqi</name></expr></argument>, <argument><expr><name><name>mattblinfo</name><operator>.</operator><name>matcollist</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mataddress</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>agg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>materialized_only</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>view_query</name> <operator>=</operator> <call><name>build_union_query</name><argument_list>(<argument><expr><operator>&amp;</operator><name>timebucket_exprinfo</name></expr></argument>,
									   <argument><expr><name><name>mattblinfo</name><operator>.</operator><name>matpartcolno</name></name></expr></argument>,
									   <argument><expr><name>view_query</name></expr></argument>,
									   <argument><expr><name>direct_query</name></expr></argument>,
									   <argument><expr><name><name>mat_ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>mattblinfo</name><operator>.</operator><name>matcollist</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>ts_get_relnatts</name><argument_list>(<argument><expr><name><name>mat_ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/* There is a mismatch of columns between the current version's finalization view building
		   logic and the existing schema of the materialization table. As of version 2.7.0 this
		   only happens due to buggy view generation in previous versions. Do not rebuild those
		   views since the materialization table can not be queried correctly. */</comment>
		<expr_stmt><expr><name>test_failed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * When calling StoreViewQuery the target list names of the query have to
	 * match the view's tuple descriptor attribute names. But if a column of the continuous
	 * aggregate has been renamed, the query tree will not have the correct
	 * names in the target list, which will error out when calling
	 * StoreViewQuery. For that reason, we fetch the name from the user view
	 * relation and update the resource name in the query target list to match
	 * the name in the user view.
	 */</comment>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>desc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>user_view_rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<macro><name>forboth</name> <argument_list>(<argument>lc1</argument>, <argument>view_query-&gt;targetList</argument>, <argument>lc2</argument>, <argument>user_query-&gt;targetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>view_tle</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>user_tle</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>FormData_pg_attribute</name> <modifier>*</modifier></type><name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>view_tle</name> <operator>=</operator> <call><name>lfirst_node</name><argument_list>(<argument><expr><name>TargetEntry</name></expr></argument>, <argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>user_tle</name> <operator>=</operator> <call><name>lfirst_node</name><argument_list>(<argument><expr><name>TargetEntry</name></expr></argument>, <argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>view_tle</name><operator>-&gt;</operator><name>resjunk</name></name> <operator>&amp;&amp;</operator> <name><name>user_tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>view_tle</name><operator>-&gt;</operator><name>resjunk</name></name> <operator>||</operator> <name><name>user_tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* This should never happen but if it ever does it's safer to
			 * error here instead of creating broken view definitions. */</comment>
			<expr_stmt><expr><name>test_failed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>view_tle</name><operator>-&gt;</operator><name>resname</name></name> <operator>=</operator> <name><name>user_tle</name><operator>-&gt;</operator><name>resname</name></name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>++</operator><name>i</name></expr>;</expr_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>test_failed</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Inconsistent view definitions for continuous aggregate view "</literal>
						<literal type="string">"\"%s.%s\""</literal></expr></argument>,
						<argument><expr><name>schema</name></expr></argument>,
						<argument><expr><name>relname</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Continuous aggregate data possibly corrupted.\n"</literal>
						   <literal type="string">"You may need to recreate the continuous aggregate with"</literal>
						   <literal type="string">"CREATE MATERIALIZED VIEW."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>SWITCH_TO_TS_USER</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>agg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>user_view_schema</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>uid</name></expr></argument>, <argument><expr><name>saved_uid</name></expr></argument>, <argument><expr><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>StoreViewQuery</name><argument_list>(<argument><expr><name>user_view_oid</name></expr></argument>, <argument><expr><name>view_query</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>RESTORE_USER</name><argument_list>(<argument><expr><name>uid</name></expr></argument>, <argument><expr><name>saved_uid</name></expr></argument>, <argument><expr><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<comment type="block">/* Keep locks until end of transaction and do not close the relation
	 * before the call to StoreViewQuery since it can otherwise release the
	 * memory for attr-&gt;attname, causing a segfault. */</comment>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>direct_view_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>user_view_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>tsl_cagg_try_repair</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relid</name> <init>= <expr><ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>InvalidOid</name></expr> </then><else>: <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name>relkind</name> <init>= <expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ContinuousAgg</name> <modifier>*</modifier></type><name>cagg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>RELKIND_VIEW</name> <operator>==</operator> <name>relkind</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>cagg</name> <operator>=</operator> <call><name>ts_continuous_agg_find_by_relid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>RELKIND_VIEW</name> <operator>!=</operator> <name>relkind</name> <operator>||</operator> <operator>!</operator><name>cagg</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid OID \"%u\" for continuous aggregate view"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Check for database corruption."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Cache</name> <modifier>*</modifier></type><name>hcache</name> <init>= <expr><call><name>ts_hypertable_cache_pin</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>mat_ht</name> <init>= <expr><call><name>ts_hypertable_cache_get_entry_by_id</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>, <argument><expr><name><name>cagg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>mat_hypertable_id</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>mat_ht</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>cagg_rebuild_view_definition</name><argument_list>(<argument><expr><name>cagg</name></expr></argument>, <argument><expr><name>mat_ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Flip the view definition of an existing continuous aggregate from real-time to materialized-only
 * or vice versa depending on the current state.
 */</comment>
<function><type><name>void</name></type>
<name>cagg_flip_realtime_view_definition</name><parameter_list>(<parameter><decl><type><name>ContinuousAgg</name> <modifier>*</modifier></type><name>agg</name></decl></parameter>, <parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>mat_ht</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>sec_ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>uid</name></decl>, <decl><type ref="prev"/><name>saved_uid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>result_view_query</name></decl>;</decl_stmt>

	<comment type="block">/* user view query of the user defined CAGG */</comment>
	<decl_stmt><decl><type><name>Oid</name></type> <name>user_view_oid</name> <init>= <expr><call><name>relation_oid</name><argument_list>(<argument><expr><name><name>agg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>user_view_schema</name></name></expr></argument>, <argument><expr><name><name>agg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>user_view_name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>user_view_rel</name> <init>= <expr><call><name>relation_open</name><argument_list>(<argument><expr><name>user_view_oid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>user_query</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><call><name>get_view_query</name><argument_list>(<argument><expr><name>user_view_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="block">/* keep lock until end of transaction */</comment>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>user_view_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>remove_old_and_new_rte_from_query</name><argument_list>(<argument><expr><name>user_query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* direct view query of the original user view definition at CAGG creation */</comment>
	<decl_stmt><decl><type><name>Oid</name></type> <name>direct_view_oid</name> <init>= <expr><call><name>relation_oid</name><argument_list>(<argument><expr><name><name>agg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>direct_view_schema</name></name></expr></argument>, <argument><expr><name><name>agg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>direct_view_name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>direct_view_rel</name> <init>= <expr><call><name>relation_open</name><argument_list>(<argument><expr><name>direct_view_oid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>direct_query</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><call><name>get_view_query</name><argument_list>(<argument><expr><name>direct_view_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="block">/* keep lock until end of transaction */</comment>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>direct_view_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>remove_old_and_new_rte_from_query</name><argument_list>(<argument><expr><name>direct_query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>CAggTimebucketInfo</name></type> <name>timebucket_exprinfo</name> <init>=
		<expr><call><name>cagg_validate_query</name><argument_list>(<argument><expr><name>direct_query</name></expr></argument>,
							<argument><expr><name><name>agg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>finalized</name></name></expr></argument>,
							<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>agg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>user_view_schema</name></name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>agg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>user_view_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* flip */</comment>
	<expr_stmt><expr><name><name>agg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>materialized_only</name></name> <operator>=</operator> <operator>!</operator><name><name>agg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>materialized_only</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>agg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>materialized_only</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result_view_query</name> <operator>=</operator> <call><name>destroy_union_query</name><argument_list>(<argument><expr><name>user_query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* get primary partitioning column information of time bucketing */</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type><name>mat_part_dimension</name> <init>= <expr><call><name>hyperspace_get_open_dimension</name><argument_list>(<argument><expr><name><name>mat_ht</name><operator>-&gt;</operator><name>space</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>result_view_query</name> <operator>=</operator> <call><name>build_union_query</name><argument_list>(<argument><expr><operator>&amp;</operator><name>timebucket_exprinfo</name></expr></argument>,
											  <argument><expr><name><name>mat_part_dimension</name><operator>-&gt;</operator><name>column_attno</name></name></expr></argument>,
											  <argument><expr><name>user_query</name></expr></argument>,
											  <argument><expr><name>direct_query</name></expr></argument>,
											  <argument><expr><name><name>mat_ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>SWITCH_TO_TS_USER</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>agg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>user_view_schema</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>uid</name></expr></argument>, <argument><expr><name>saved_uid</name></expr></argument>, <argument><expr><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>StoreViewQuery</name><argument_list>(<argument><expr><name>user_view_oid</name></expr></argument>, <argument><expr><name>result_view_query</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RESTORE_USER</name><argument_list>(<argument><expr><name>uid</name></expr></argument>, <argument><expr><name>saved_uid</name></expr></argument>, <argument><expr><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>cagg_rename_view_columns</name><parameter_list>(<parameter><decl><type><name>ContinuousAgg</name> <modifier>*</modifier></type><name>agg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>sec_ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>uid</name></decl>, <decl><type ref="prev"/><name>saved_uid</name></decl>;</decl_stmt>

	<comment type="block">/* user view query of the user defined CAGG */</comment>
	<decl_stmt><decl><type><name>Oid</name></type> <name>user_view_oid</name> <init>= <expr><call><name>relation_oid</name><argument_list>(<argument><expr><name><name>agg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>user_view_schema</name></name></expr></argument>, <argument><expr><name><name>agg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>user_view_name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>user_view_rel</name> <init>= <expr><call><name>relation_open</name><argument_list>(<argument><expr><name>user_view_oid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>user_query</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><call><name>get_view_query</name><argument_list>(<argument><expr><name>user_view_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>remove_old_and_new_rte_from_query</name><argument_list>(<argument><expr><name>user_query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * When calling StoreViewQuery the target list names of the query have to
	 * match the view's tuple descriptor attribute names. But if a column of the continuous
	 * aggregate has been renamed, the query tree will not have the correct
	 * names in the target list, which will error out when calling
	 * StoreViewQuery. For that reason, we fetch the name from the user view
	 * relation and update the resource name in the query target list to match
	 * the name in the user view.
	 */</comment>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>desc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>user_view_rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>user_query-&gt;targetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>user_tle</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>FormData_pg_attribute</name> <modifier>*</modifier></type><name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>user_tle</name> <operator>=</operator> <call><name>lfirst_node</name><argument_list>(<argument><expr><name>TargetEntry</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>user_tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>user_tle</name><operator>-&gt;</operator><name>resname</name></name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>++</operator><name>i</name></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>SWITCH_TO_TS_USER</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>agg</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>user_view_schema</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>uid</name></expr></argument>, <argument><expr><name>saved_uid</name></expr></argument>, <argument><expr><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>StoreViewQuery</name><argument_list>(<argument><expr><name>user_view_oid</name></expr></argument>, <argument><expr><name>user_query</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RESTORE_USER</name><argument_list>(<argument><expr><name>uid</name></expr></argument>, <argument><expr><name>saved_uid</name></expr></argument>, <argument><expr><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Keep locks until end of transaction and do not close the relation
	 * before the call to StoreViewQuery since it can otherwise release the
	 * memory for attr-&gt;attname, causing a segfault. */</comment>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>user_view_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * create Const of proper type for lower bound of watermark when
 * watermark has not been set yet
 */</comment>
<function><type><specifier>static</specifier> <name>Const</name> <modifier>*</modifier></type>
<name>cagg_boundary_make_lower_bound</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type> <name>value</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type> <name>typlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>typbyval</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>get_typlenbyval</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typbyval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>ts_time_datum_get_nobegin_or_min</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>makeConst</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>typlen</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>typbyval</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get oid of function to convert from our internal representation to postgres representation
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>cagg_get_boundary_converter_funcoid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typoid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>function_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name><name>argtyp</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>INT8OID</name></expr> }</block></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>typoid</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>DATEOID</name></expr>:</case>
			<expr_stmt><expr><name>function_name</name> <operator>=</operator> <name>INTERNAL_TO_DATE_FUNCTION</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>TIMESTAMPOID</name></expr>:</case>
			<expr_stmt><expr><name>function_name</name> <operator>=</operator> <name>INTERNAL_TO_TS_FUNCTION</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>TIMESTAMPTZOID</name></expr>:</case>
			<expr_stmt><expr><name>function_name</name> <operator>=</operator> <name>INTERNAL_TO_TSTZ_FUNCTION</name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<comment type="block">/*
			 * this should never be reached and unsupported datatypes
			 * should be caught at much earlier stages
			 */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TS_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no converter function defined for datatype: %s"</literal></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>typoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pg_unreachable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>func_name</name> <init>= <expr><call><name>list_make2</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>INTERNAL_SCHEMA_NAME</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>function_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>converter_oid</name> <init>= <expr><call><name>LookupFuncName</name><argument_list>(<argument><expr><name>func_name</name></expr></argument>, <argument><expr><call><name>lengthof</name><argument_list>(<argument><expr><name>argtyp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>argtyp</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>converter_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>converter_oid</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>FuncExpr</name> <modifier>*</modifier></type>
<name>build_conversion_call</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>boundary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * if the partitioning column type is not integer we need to convert to proper representation
	 */</comment>
	<switch>switch <condition>(<expr><name>type</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>INT2OID</name></expr>:</case>
		<case>case <expr><name>INT4OID</name></expr>:</case>
		<block>{<block_content>
			<comment type="block">/* since the boundary function returns int8 we need to cast to proper type here */</comment>
			<decl_stmt><decl><type><name>Oid</name></type> <name>cast_oid</name> <init>= <expr><call><name>ts_get_cast_func</name><argument_list>(<argument><expr><name>INT8OID</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<return>return <expr><call><name>makeFuncExpr</name><argument_list>(<argument><expr><name>cast_oid</name></expr></argument>,
								<argument><expr><name>type</name></expr></argument>,
								<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>boundary</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><name>InvalidOid</name></expr></argument>,
								<argument><expr><name>InvalidOid</name></expr></argument>,
								<argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block>
		<case>case <expr><name>INT8OID</name></expr>:</case>
			<comment type="block">/* nothing to do for int8 */</comment>
			<return>return <expr><name>boundary</name></expr>;</return>
		<case>case <expr><name>DATEOID</name></expr>:</case>
		<case>case <expr><name>TIMESTAMPOID</name></expr>:</case>
		<case>case <expr><name>TIMESTAMPTZOID</name></expr>:</case>
		<block>{<block_content>
			<comment type="block">/* date/timestamp/timestamptz need to be converted since we store them differently from
			 * postgres format */</comment>
			<decl_stmt><decl><type><name>Oid</name></type> <name>converter_oid</name> <init>= <expr><call><name>cagg_get_boundary_converter_funcoid</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<return>return <expr><call><name>makeFuncExpr</name><argument_list>(<argument><expr><name>converter_oid</name></expr></argument>,
								<argument><expr><name>type</name></expr></argument>,
								<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>boundary</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><name>InvalidOid</name></expr></argument>,
								<argument><expr><name>InvalidOid</name></expr></argument>,
								<argument><expr><name>COERCE_EXPLICIT_CALL</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block>

		<default>default:</default>
			<comment type="block">/* all valid types should be handled above, this should never be reached and error
			 * handling at earlier stages should catch this */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TS_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unsupported datatype for continuous aggregates: %s"</literal></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pg_unreachable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * build function call that returns boundary for a hypertable
 * wrapped in type conversion calls when required
 */</comment>
<function><type><specifier>static</specifier> <name>FuncExpr</name> <modifier>*</modifier></type>
<name>build_boundary_call</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>ht_id</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name><name>argtyp</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>INT4OID</name></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>boundary</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>boundary_func_oid</name> <init>=
		<expr><call><name>LookupFuncName</name><argument_list>(<argument><expr><call><name>list_make2</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>INTERNAL_SCHEMA_NAME</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>BOUNDARY_FUNCTION</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><call><name>lengthof</name><argument_list>(<argument><expr><name>argtyp</name></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><name>argtyp</name></expr></argument>,
					   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>func_args</name> <init>=
		<expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeConst</name><argument_list>(<argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>ht_id</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>boundary</name> <operator>=</operator> <call><name>makeFuncExpr</name><argument_list>(<argument><expr><name>boundary_func_oid</name></expr></argument>,
							<argument><expr><name>INT8OID</name></expr></argument>,
							<argument><expr><name>func_args</name></expr></argument>,
							<argument><expr><name>InvalidOid</name></expr></argument>,
							<argument><expr><name>InvalidOid</name></expr></argument>,
							<argument><expr><name>COERCE_EXPLICIT_CALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>build_conversion_call</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>boundary</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>build_union_query_quals</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>ht_id</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>partcoltype</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>opno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>varno</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>attno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><call><name>makeVar</name><argument_list>(<argument><expr><name>varno</name></expr></argument>, <argument><expr><name>attno</name></expr></argument>, <argument><expr><name>partcoltype</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>boundary</name> <init>= <expr><call><name>build_boundary_call</name><argument_list>(<argument><expr><name>ht_id</name></expr></argument>, <argument><expr><name>partcoltype</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>CoalesceExpr</name> <modifier>*</modifier></type><name>coalesce</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CoalesceExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>coalesce</name><operator>-&gt;</operator><name>coalescetype</name></name> <operator>=</operator> <name>partcoltype</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>coalesce</name><operator>-&gt;</operator><name>coalescecollid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>coalesce</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><name>boundary</name></expr></argument>, <argument><expr><call><name>cagg_boundary_make_lower_bound</name><argument_list>(<argument><expr><name>partcoltype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>make_opclause</name><argument_list>(<argument><expr><name>opno</name></expr></argument>,
								  <argument><expr><name>BOOLOID</name></expr></argument>,
								  <argument><expr><name>false</name></expr></argument>,
								  <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></argument>,
								  <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>coalesce</name></expr></argument>,
								  <argument><expr><name>InvalidOid</name></expr></argument>,
								  <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>RangeTblEntry</name> <modifier>*</modifier></type>
<name>make_subquery_rte</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>subquery</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aliasname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblEntry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>=</operator> <name>RTE_SUBQUERY</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name> <operator>=</operator> <name>subquery</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>alias</name></name> <operator>=</operator> <call><name>makeAlias</name><argument_list>(<argument><expr><name>aliasname</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>alias</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>subquery-&gt;targetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>TargetEntry</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>colnames</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>resname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>lateral</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>inh</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <comment type="block">/* never true for subqueries */</comment>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>inFromCl</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<return>return <expr><name>rte</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * build union query combining the materialized data with data from the raw data hypertable
 *
 * q1 is the query on the materialization hypertable with the finalize call
 * q2 is the query on the raw hypertable which was supplied in the inital CREATE VIEW statement
 * returns a query as
 * SELECT * from (  SELECT * from q1 where &lt;coale_qual&gt;
 *                  UNION ALL
 *                  SELECT * from q2 where existing_qual and &lt;coale_qual&gt;
 * where coale_qual is: time &lt; ----&gt; (or &gt;= )
 * COALESCE(_timescaledb_internal.to_timestamp(_timescaledb_internal.cagg_watermark( &lt;htid&gt;)),
 * '-infinity'::timestamp with time zone)
 * see build_union_quals for COALESCE clause
 */</comment>
<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type>
<name>build_union_query</name><parameter_list>(<parameter><decl><type><name>CAggTimebucketInfo</name> <modifier>*</modifier></type><name>tbinfo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>matpartcolno</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>q1</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>q2</name></decl></parameter>,
				  <parameter><decl><type><name>int</name></type> <name>materialize_htid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>col_types</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>col_typmods</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>col_collations</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>sortClause</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>varno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>q2_quals</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>q1</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>q2</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>q1</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>q1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>q2</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>q2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>q1</name><operator>-&gt;</operator><name>sortClause</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>sortClause</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>q1</name><operator>-&gt;</operator><name>sortClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>tce</name> <init>= <expr><call><name>lookup_type_cache</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>htpartcoltype</name></name></expr></argument>, <argument><expr><name>TYPECACHE_LT_OPR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>varno</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>q1</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>q1</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <call><name>build_union_query_quals</name><argument_list>(<argument><expr><name>materialize_htid</name></expr></argument>,
												  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>htpartcoltype</name></name></expr></argument>,
												  <argument><expr><name><name>tce</name><operator>-&gt;</operator><name>lt_opr</name></name></expr></argument>,
												  <argument><expr><name>varno</name></expr></argument>,
												  <argument><expr><name>matpartcolno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>varno</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>q2</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>q2_quals</name> <operator>=</operator> <call><name>build_union_query_quals</name><argument_list>(<argument><expr><name>materialize_htid</name></expr></argument>,
									   <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>htpartcoltype</name></name></expr></argument>,
									   <argument><expr><call><name>get_negator</name><argument_list>(<argument><expr><name><name>tce</name><operator>-&gt;</operator><name>lt_opr</name></name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><name>varno</name></expr></argument>,
									   <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>htpartcolno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>q2</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <call><name>make_and_qual</name><argument_list>(<argument><expr><name><name>q2</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>, <argument><expr><name>q2_quals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SetOperationStmt</name> <modifier>*</modifier></type><name>setop</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>SetOperationStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte_q1</name> <init>= <expr><call><name>make_subquery_rte</name><argument_list>(<argument><expr><name>q1</name></expr></argument>, <argument><expr><literal type="string">"*SELECT* 1"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte_q2</name> <init>= <expr><call><name>make_subquery_rte</name><argument_list>(<argument><expr><name>q2</name></expr></argument>, <argument><expr><literal type="string">"*SELECT* 2"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>ref_q1</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>ref_q2</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_SELECT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><name>rte_q1</name></expr></argument>, <argument><expr><name>rte_q2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>setOperations</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>setop</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>setop</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>SETOP_UNION</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>setop</name><operator>-&gt;</operator><name>all</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ref_q1</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ref_q2</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>setop</name><operator>-&gt;</operator><name>larg</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>ref_q1</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>setop</name><operator>-&gt;</operator><name>rarg</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>ref_q2</name></expr>;</expr_stmt>

	<macro><name>forboth</name> <argument_list>(<argument>lc1</argument>, <argument>q1-&gt;targetList</argument>, <argument>lc2</argument>, <argument>q2-&gt;targetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>TargetEntry</name></expr></argument>, <argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle2</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>TargetEntry</name></expr></argument>, <argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle_union</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>col_types</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>col_types</name></expr></argument>, <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>col_typmods</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>col_typmods</name></expr></argument>, <argument><expr><call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>col_collations</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>col_collations</name></expr></argument>, <argument><expr><call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>makeVarFromTargetEntry</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/*
			 * we need to use resname from q2 because that is the query from the
			 * initial CREATE VIEW statement so the VIEW can be updated in place
			 */</comment>
			<expr_stmt><expr><name>tle_union</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
										<argument><expr><name><name>tle2</name><operator>-&gt;</operator><name>resname</name></name></expr></argument>,
										<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tle_union</name><operator>-&gt;</operator><name>resorigtbl</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>varno</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tle_union</name><operator>-&gt;</operator><name>resorigcol</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>varattno</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tle_union</name><operator>-&gt;</operator><name>ressortgroupref</name></name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>tle_union</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>sortClause</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>sortClause</name></name> <operator>=</operator> <name>sortClause</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <call><name>makeFromExpr</name><argument_list>(<argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>setop</name><operator>-&gt;</operator><name>colTypes</name></name> <operator>=</operator> <name>col_types</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>setop</name><operator>-&gt;</operator><name>colTypmods</name></name> <operator>=</operator> <name>col_typmods</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>setop</name><operator>-&gt;</operator><name>colCollations</name></name> <operator>=</operator> <name>col_collations</name></expr>;</expr_stmt>

	<return>return <expr><name>query</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Extract the final view from the UNION ALL query
 *
 * q1 is the query on the materialization hypertable with the finalize call
 * q2 is the query on the raw hypertable which was supplied in the inital CREATE VIEW statement
 * returns q1 from:
 * SELECT * from (  SELECT * from q1 where &lt;coale_qual&gt;
 *                  UNION ALL
 *                  SELECT * from q2 where existing_qual and &lt;coale_qual&gt;
 * where coale_qual is: time &lt; ----&gt; (or &gt;= )
 * COALESCE(_timescaledb_internal.to_timestamp(_timescaledb_internal.cagg_watermark( &lt;htid&gt;)),
 * '-infinity'::timestamp with time zone)
 * The WHERE clause of the final view is removed.
 */</comment>
<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type>
<name>destroy_union_query</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>q</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>q</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name> <operator>&amp;&amp;</operator>
		   <operator>(</operator><operator>(</operator><name>SetOperationStmt</name> <operator>*</operator><operator>)</operator> <name><name>q</name><operator>-&gt;</operator><name>setOperations</name></name><operator>)</operator><operator>-&gt;</operator><name>op</name> <operator>==</operator> <name>SETOP_UNION</name> <operator>&amp;&amp;</operator>
		   <operator>(</operator><operator>(</operator><name>SetOperationStmt</name> <operator>*</operator><operator>)</operator> <name><name>q</name><operator>-&gt;</operator><name>setOperations</name></name><operator>)</operator><operator>-&gt;</operator><name>all</name> <operator>==</operator> <name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get RTE of the left-hand side of UNION ALL */</comment>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>q</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Delete the WHERE clause from the final view */</comment>
	<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<return>return <expr><name>query</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * return Oid for a schema-qualified relation
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>relation_oid</name><parameter_list>(<parameter><decl><type><name>NameData</name></type> <name>schema</name></decl></parameter>, <parameter><decl><type><name>NameData</name></type> <name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>get_relname_relid</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>get_namespace_oid</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name>schema</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
