<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/timescaledb/tsl/src/continuous_aggs/invalidation.c"><comment type="block">/*
 * This file and its contents are licensed under the Timescale License.
 * Please see the included NOTICE for copyright information and
 * LICENSE-TIMESCALE for a copy of the license.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postgres.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/builtins.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/memutils.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/palloc.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/snapmgr.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/tuplestore.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/makefuncs.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/memnodes.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;storage/lockdefs.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/htup_details.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/htup.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/xact.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;miscadmin.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;extension.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fmgr.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;funcapi.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;parser/parse_func.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;scanner.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;scan_iterator.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time_utils.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time_bucket.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;hypertable_cache.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compat/compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"remote/dist_commands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ts_catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ts_catalog/continuous_agg.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"continuous_aggs/materialize.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"data_node.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"deparse.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"invalidation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"refresh.h"</cpp:file></cpp:include>

<comment type="block">/*
 * Invalidation processing for continuous aggregates.
 *
 * Invalidations track the regions/intervals [start, end] of a continuous
 * aggregate that are out-of-date relative to the source hypertable on top of
 * which the aggregate is defined. When a continuous aggregate is out-of-date
 * across one or more regions, it can be refreshed with a window covering
 * those regions in order to bring it up-to-date with the source data again.
 *
 * Invalidations are generated by mutations on the source hypertable (INSERT,
 * DELETE, UPDATE, TRUNCATE, drop_chunks, etc.) and are initially written to a
 * hypertable invalidation log [hypertable_id, start, end].
 *
 * When a continuous aggregate is refreshed, invalidations are moved from the
 * hypertable invalidation log to a continuous aggregate invalidation log,
 * where each original entry creates one new entry per continuous aggregate
 * [cagg_id, start, end]. Thus, if one continuous aggregate is refreshed but
 * not others, then only the invalidations for the refreshed aggregate are
 * processed.
 *
 * Simplified, invalidations move through the following stages:
 *
 * insert_trigger =&gt; hypertable_inval_log =&gt; cagg_inval_log =&gt; refreshing
 *
 * Thus, invalidations are generated by mutations and are processed and used
 * as input for refreshing the a continuous aggregate.
 *
 * Invalidations can overlap or be duplicates. Therefore, invalidations are
 * merged during processing to reduce the number of entries in the logs. This
 * typically happens during a refresh of a continuous aggregate, which also
 * cuts invalidations along the refresh window. The cutting will leave some
 * parts of entries in the invalidation log while the entries that fall
 * within the refresh window are stored in an invalidation store and used for
 * refreshing:
 *
 *       |-------------|    refresh window
 *
 *   |-----|  |---| |----|  invalidations
 *
 *             =&gt;
 *
 *   |---|             |--| invalidations that remain in the log
 *
 *       |-|  |---| |--|    invalidations that are used for refreshing
 *
 * The invalidation store will spill to disk in case of many invalidations so
 * it won't blow up memory usage. If there are no invalidations in the store
 * after processing, then the continuous aggregate is up-to-date in the region
 * defined by the refresh window.
 */</comment>

<typedef>typedef <type><struct>struct <name>CaggInvalidationState</name>
<block>{
	<decl_stmt><decl><type><name>int32</name></type> <name>mat_hypertable_id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>raw_hypertable_id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>dimtype</name></decl>;</decl_stmt> <comment type="block">/* The type of the underlying hypertable's time dimension
				  * that is bucketed */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>per_tuple_mctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>cagg_log_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>invalidations</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>CaggsInfo</name> <modifier>*</modifier></type><name>all_caggs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>bucket_width</name></decl>;</decl_stmt>
	<comment type="block">/* bucket_function is NULL unless bucket_width == BUCKET_WIDTH_VARIABLE */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ContinuousAggsBucketFunction</name> <modifier>*</modifier></type><name>bucket_function</name></decl>;</decl_stmt>
}</block></struct></type> <name>CaggInvalidationState</name>;</typedef>

<typedef>typedef <type><enum>enum <name>LogType</name>
<block>{
	<decl><name>LOG_HYPER</name></decl>,
	<decl><name>LOG_CAGG</name></decl>,
}</block></enum></type> <name>LogType</name>;</typedef>

<function><type><specifier>static</specifier> <name>Relation</name></type>
<name>open_invalidation_log</name><parameter_list>(<parameter><decl><type><name>LogType</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>CatalogTable</name></type> <name><name>logmappings</name><index>[]</index></name> <init>= <expr><block>{
		<expr><index>[<expr><name>LOG_HYPER</name></expr>]</index> <operator>=</operator> <name>CONTINUOUS_AGGS_HYPERTABLE_INVALIDATION_LOG</name></expr>,
		<expr><index>[<expr><name>LOG_CAGG</name></expr>]</index> <operator>=</operator> <name>CONTINUOUS_AGGS_MATERIALIZATION_INVALIDATION_LOG</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Catalog</name> <modifier>*</modifier></type><name>catalog</name> <init>= <expr><call><name>ts_catalog_get</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relid</name> <init>= <expr><call><name>catalog_get_table_id</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name><name>logmappings</name><index>[<expr><name>type</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>table_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>hypertable_invalidation_scan_init</name><parameter_list>(<parameter><decl><type><name>ScanIterator</name> <modifier>*</modifier></type><name>iterator</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>hyper_id</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>*</operator><name>iterator</name> <operator>=</operator> <call><name>ts_scan_iterator_create</name><argument_list>(<argument><expr><name>CONTINUOUS_AGGS_HYPERTABLE_INVALIDATION_LOG</name></expr></argument>,
										<argument><expr><name>lockmode</name></expr></argument>,
										<argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>ctx</name><operator>.</operator><name>index</name></name> <operator>=</operator> <call><name>catalog_get_index</name><argument_list>(<argument><expr><call><name>ts_catalog_get</name><argument_list>()</argument_list></call></expr></argument>,
											<argument><expr><name>CONTINUOUS_AGGS_HYPERTABLE_INVALIDATION_LOG</name></expr></argument>,
											<argument><expr><name>CONTINUOUS_AGGS_HYPERTABLE_INVALIDATION_LOG_IDX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_scan_iterator_scan_key_init</name><argument_list>(
		<argument><expr><name>iterator</name></expr></argument>,
		<argument><expr><name>Anum_continuous_aggs_hypertable_invalidation_log_idx_hypertable_id</name></expr></argument>,
		<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
		<argument><expr><name>F_INT4EQ</name></expr></argument>,
		<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>hyper_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>HeapTuple</name></type>
<name>create_invalidation_tup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>cagg_hyper_id</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>end</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type> <name><name>values</name><index>[<expr><name>Natts_continuous_aggs_materialization_invalidation_log</name></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name><name>isnull</name><index>[<expr><name>Natts_continuous_aggs_materialization_invalidation_log</name></expr>]</index></name> <init>= <expr><block>{ <expr><name>false</name></expr> }</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(
		<argument><expr><name>Anum_continuous_aggs_materialization_invalidation_log_materialization_id</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
		<call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>cagg_hyper_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(
		<argument><expr><name>Anum_continuous_aggs_materialization_invalidation_log_lowest_modified_value</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
		<call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(
		<argument><expr><name>Anum_continuous_aggs_materialization_invalidation_log_greatest_modified_value</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
		<call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Add an entry to the continuous aggregate invalidation log.
 */</comment>
<function><type><name>void</name></type>
<name>invalidation_cagg_log_add_entry</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>cagg_hyper_id</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>end</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name> <init>= <expr><call><name>open_invalidation_log</name><argument_list>(<argument><expr><name>LOG_CAGG</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CatalogSecurityContext</name></type> <name>sec_ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>start</name> <operator>&lt;=</operator> <name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>create_invalidation_tup</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cagg_hyper_id</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_catalog_database_info_become_owner</name><argument_list>(<argument><expr><call><name>ts_catalog_database_info_get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_catalog_insert_only</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_catalog_restore_user</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Adds a materialization invalidation log entry to the local data node.
 *
 * @param mat_hypertable_id The hypertable ID of the CAGG materialized hypertable in the Access
 *                          Node.
 * @param start_time The starting time of the materialization invalidation log entry.
 * @param end_time The ending time of the materialization invalidation log entry.
 */</comment>
<function><type><name>Datum</name></type>
<name>tsl_invalidation_cagg_log_add_entry</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type> <name>mat_hypertable_id</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>start_time</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>end_time</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>end_time</name> <operator>&lt;</operator> <name>start_time</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot invalidate cagg, end time should be greater than start time"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>invalidation_cagg_log_add_entry</name><argument_list>(<argument><expr><name>mat_hypertable_id</name></expr></argument>, <argument><expr><name>start_time</name></expr></argument>, <argument><expr><name>end_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Adds a hypertable invalidation log entry to the local data node.
 *
 * @param raw_hypertable_id The hypertable ID of the original distributed hypertable in the Access
 *                          Node.
 * @param start_time The starting time of the materialization invalidation log entry.
 * @param end_time The ending time of the materialization invalidation log entry.
 */</comment>
<function><type><name>Datum</name></type>
<name>tsl_invalidation_hyper_log_add_entry</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type> <name>raw_hypertable_id</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>start_time</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>end_time</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>end_time</name> <operator>&lt;</operator> <name>start_time</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot invalidate hypertable, end time should be greater than start time"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>invalidation_hyper_log_add_entry</name><argument_list>(<argument><expr><name>raw_hypertable_id</name></expr></argument>, <argument><expr><name>start_time</name></expr></argument>, <argument><expr><name>end_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INVALIDATION_CAGG_ADD_ENTRY_NARGS</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INVALIDATION_CAGG_LOG_ADD_ENTRY_FUNCNAME</name></cpp:macro> <cpp:value>"invalidation_cagg_log_add_entry"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INVALIDATION_HYPER_LOG_ADD_ENTRY_FUNCNAME</name></cpp:macro> <cpp:value>"invalidation_hyper_log_add_entry"</cpp:value></cpp:define>

<function><type><name>void</name></type>
<name>remote_invalidation_log_add_entry</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Hypertable</name> <modifier>*</modifier></type><name>raw_ht</name></decl></parameter>,
								  <parameter><decl><type><name>ContinuousAggHypertableStatus</name></type> <name>caggstatus</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>entry_id</name></decl></parameter>,
								  <parameter><decl><type><name>int64</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>end</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>func_oid</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>LOCAL_FCINFO</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>INVALIDATION_CAGG_ADD_ENTRY_NARGS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name></type> <name>flinfo</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>HypertableIsMaterialization</name> <operator>==</operator> <name>caggstatus</name> <operator>||</operator> <name>HypertableIsRawTable</name> <operator>==</operator> <name>caggstatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>Oid</name></type> <name><name>type_id</name><index>[<expr><name>INVALIDATION_CAGG_ADD_ENTRY_NARGS</name></expr>]</index></name> <init>= <expr><block>{ <expr><name>INT4OID</name></expr>, <expr><name>INT8OID</name></expr>, <expr><name>INT8OID</name></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier><specifier>const</specifier></type> <name>fqn</name> <init>= <expr><call><name>list_make2</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>INTERNAL_SCHEMA_NAME</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><ternary><condition><expr><operator>(</operator><name>caggstatus</name> <operator>==</operator> <name>HypertableIsMaterialization</name><operator>)</operator></expr> ?</condition><then>
												<expr><name>INVALIDATION_CAGG_LOG_ADD_ENTRY_FUNCNAME</name></expr> </then><else>:
												<expr><name>INVALIDATION_HYPER_LOG_ADD_ENTRY_FUNCNAME</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hypertable_is_distributed</name><argument_list>(<argument><expr><name>raw_ht</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"function was not provided with a valid distributed hypertable"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>func_oid</name> <operator>=</operator> <call><name>LookupFuncName</name><argument_list>(<argument><expr><name>fqn</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument> <comment type="block">/* lengthof(type_id) */</comment>, <argument><expr><name>type_id</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>func_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>func_oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><operator>*</operator><name>fcinfo</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>flinfo</name></expr></argument>,
							 <argument><expr><name>INVALIDATION_CAGG_ADD_ENTRY_NARGS</name></expr></argument>,
							 <argument><expr><name>InvalidOid</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FC_NULL</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FC_ARG</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>entry_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FC_NULL</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FC_ARG</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FC_NULL</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FC_ARG</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Check for null result, since caller is clearly not expecting one */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"function %u returned NULL"</literal></expr></argument>, <argument><expr><name><name>flinfo</name><operator>.</operator><name>fn_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>DistCmdResult</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>data_node_list</name> <init>= <expr><call><name>ts_hypertable_get_data_node_name_list</name><argument_list>(<argument><expr><name>raw_ht</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ts_dist_cmd_invoke_func_call_on_data_nodes</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>data_node_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ts_dist_cmd_close_response</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>invalidation_hyper_log_add_entry</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>hyper_id</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>end</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name> <init>= <expr><call><name>open_invalidation_log</name><argument_list>(<argument><expr><name>LOG_HYPER</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CatalogSecurityContext</name></type> <name>sec_ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name><name>values</name><index>[<expr><name>Natts_continuous_aggs_hypertable_invalidation_log</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name><name>nulls</name><index>[<expr><name>Natts_continuous_aggs_hypertable_invalidation_log</name></expr>]</index></name> <init>= <expr><block>{ <expr><name>false</name></expr> }</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>start</name> <operator>&lt;=</operator> <name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(
		<argument><expr><name>Anum_continuous_aggs_hypertable_invalidation_log_hypertable_id</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>hyper_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(
		<argument><expr><name>Anum_continuous_aggs_hypertable_invalidation_log_lowest_modified_value</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
		<call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(
		<argument><expr><name>Anum_continuous_aggs_hypertable_invalidation_log_greatest_modified_value</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
		<call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ts_catalog_database_info_become_owner</name><argument_list>(<argument><expr><call><name>ts_catalog_database_info_get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_catalog_insert_values</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_catalog_restore_user</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
		 <argument><expr><literal type="string">"hypertable log for hypertable %d added entry ["</literal> <name>INT64_FORMAT</name> <literal type="string">", "</literal> <name>INT64_FORMAT</name> <literal type="string">"]"</literal></expr></argument>,
		 <argument><expr><name>hyper_id</name></expr></argument>,
		 <argument><expr><name>start</name></expr></argument>,
		 <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Invalidate one or more continuous aggregates.
 *
 * Add an invalidation in the given range. The invalidation is added either to
 * the hypertable invalidation log or the continuous aggregate invalidation
 * log depending on the type of the given hypertable. If the hypertable is a
 * "raw" hypertable (i.e., one that has one or more continous aggregates), the
 * entry is added to the hypertable invalidation log and will invalidate all
 * the associated continuous aggregates. If the hypertable is instead an
 * materialized hypertable, the entry is added to the cagg invalidation log
 * and only invalidates the continuous aggregate owning that materialized
 * hypertable.
 */</comment>
<function><type><name>void</name></type>
<name>continuous_agg_invalidate_raw_ht</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Hypertable</name> <modifier>*</modifier></type><name>raw_ht</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>end</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>raw_ht</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>hypertable_is_distributed</name><argument_list>(<argument><expr><name>raw_ht</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>remote_invalidation_log_add_entry</name><argument_list>(<argument><expr><name>raw_ht</name></expr></argument>, <argument><expr><name>HypertableIsRawTable</name></expr></argument>, <argument><expr><name><name>raw_ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>invalidation_hyper_log_add_entry</name><argument_list>(<argument><expr><name><name>raw_ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>continuous_agg_invalidate_mat_ht</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Hypertable</name> <modifier>*</modifier></type><name>raw_ht</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Hypertable</name> <modifier>*</modifier></type><name>mat_ht</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>start</name></decl></parameter>,
								 <parameter><decl><type><name>int64</name></type> <name>end</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>raw_ht</name> <operator>!=</operator> <name>NULL</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>mat_ht</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>hypertable_is_distributed</name><argument_list>(<argument><expr><name>raw_ht</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>remote_invalidation_log_add_entry</name><argument_list>(<argument><expr><name>raw_ht</name></expr></argument>,
										  <argument><expr><name>HypertableIsMaterialization</name></expr></argument>,
										  <argument><expr><name><name>mat_ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>,
										  <argument><expr><name>start</name></expr></argument>,
										  <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>invalidation_cagg_log_add_entry</name><argument_list>(<argument><expr><name><name>mat_ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<typedef>typedef <type><enum>enum <name>InvalidationResult</name>
<block>{
	<decl><name>INVAL_NOMATCH</name></decl>,
	<decl><name>INVAL_DELETE</name></decl>,
	<decl><name>INVAL_CUT</name></decl>,
}</block></enum></type> <name>InvalidationResult</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_VALID_INVALIDATION</name><parameter_list>(<parameter><type><name>entry</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((entry)-&gt;hyper_id &gt; 0)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>save_invalidation_for_refresh</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CaggInvalidationState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Invalidation</name> <modifier>*</modifier></type><name>invalidation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type> <name>cagg_hyper_id</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>mat_hypertable_id</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupdesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>cagg_log_rel</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>refresh_tup</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_VALID_INVALIDATION</name><argument_list>(<argument><expr><name>invalidation</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>refresh_tup</name> <operator>=</operator> <call><name>create_invalidation_tup</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>,
										  <argument><expr><name>cagg_hyper_id</name></expr></argument>,
										  <argument><expr><name><name>invalidation</name><operator>-&gt;</operator><name>lowest_modified_value</name></name></expr></argument>,
										  <argument><expr><name><name>invalidation</name><operator>-&gt;</operator><name>greatest_modified_value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>tuplestore_puttuple</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>invalidations</name></name></expr></argument>, <argument><expr><name>refresh_tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>refresh_tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_remainder_after_cut</name><parameter_list>(<parameter><decl><type><name>Invalidation</name> <modifier>*</modifier></type><name>remainder</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>hyper_id</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>lowest_modified_value</name></decl></parameter>,
						<parameter><decl><type><name>int64</name></type> <name>greatest_modified_value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>remainder</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>remainder</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>remainder</name><operator>-&gt;</operator><name>hyper_id</name></name> <operator>=</operator> <name>hyper_id</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>remainder</name><operator>-&gt;</operator><name>lowest_modified_value</name></name> <operator>=</operator> <name>lowest_modified_value</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>remainder</name><operator>-&gt;</operator><name>greatest_modified_value</name></name> <operator>=</operator> <name>greatest_modified_value</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Try to cut an invalidation against the refresh window.
 *
 * If an invalidation entry overlaps with the refresh window, it needs
 * additional processing: it is either cut, deleted, or left unmodified.
 *
 * The part(s) of the invalidation that are outside the refresh window after
 * the cut will remain in the log. The part of the invalidation that fits
 * within the window is returned as the "remainder".
 *
 * Note that the refresh window is exclusive in the end while invalidations
 * are inclusive.
 */</comment>
<function><type><specifier>static</specifier> <name>InvalidationResult</name></type>
<name>cut_invalidation_along_refresh_window</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CaggInvalidationState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
									  <parameter><decl><type><specifier>const</specifier> <name>Invalidation</name> <modifier>*</modifier></type><name>invalidation</name></decl></parameter>,
									  <parameter><decl><type><specifier>const</specifier> <name>InternalTimeRange</name> <modifier>*</modifier></type><name>refresh_window</name></decl></parameter>,
									  <parameter><decl><type><name>Invalidation</name> <modifier>*</modifier></type><name>remainder</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type> <name>cagg_hyper_id</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>mat_hypertable_id</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupdesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>cagg_log_rel</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>InvalidationResult</name></type> <name>result</name> <init>= <expr><name>INVAL_NOMATCH</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>lower</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>upper</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>remainder</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Entry is completely enclosed by the refresh window */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>invalidation</name><operator>-&gt;</operator><name>lowest_modified_value</name></name> <operator>&gt;=</operator> <name><name>refresh_window</name><operator>-&gt;</operator><name>start</name></name> <operator>&amp;&amp;</operator>
		<name><name>invalidation</name><operator>-&gt;</operator><name>greatest_modified_value</name></name> <operator>&lt;</operator> <name><name>refresh_window</name><operator>-&gt;</operator><name>end</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Entry completely enclosed so can be deleted:
		 *
		 * [---------------)
		 *     [+++++]
		 */</comment>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>INVAL_DELETE</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>set_remainder_after_cut</name><argument_list>(<argument><expr><name>remainder</name></expr></argument>,
								<argument><expr><name>cagg_hyper_id</name></expr></argument>,
								<argument><expr><name><name>invalidation</name><operator>-&gt;</operator><name>lowest_modified_value</name></name></expr></argument>,
								<argument><expr><name><name>invalidation</name><operator>-&gt;</operator><name>greatest_modified_value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>invalidation</name><operator>-&gt;</operator><name>lowest_modified_value</name></name> <operator>&lt;</operator> <name><name>refresh_window</name><operator>-&gt;</operator><name>start</name></name> <operator>&amp;&amp;</operator>
			<name><name>invalidation</name><operator>-&gt;</operator><name>greatest_modified_value</name></name> <operator>&gt;=</operator> <name><name>refresh_window</name><operator>-&gt;</operator><name>start</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Need to cut in right end:
			 *
			 *     [------)
			 * [++++++]
			 *
			 * [++]
			 */</comment>
			<expr_stmt><expr><name>lower</name> <operator>=</operator> <call><name>create_invalidation_tup</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>,
											<argument><expr><name>cagg_hyper_id</name></expr></argument>,
											<argument><expr><name><name>invalidation</name><operator>-&gt;</operator><name>lowest_modified_value</name></name></expr></argument>,
											<argument><expr><name><name>refresh_window</name><operator>-&gt;</operator><name>start</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>set_remainder_after_cut</name><argument_list>(<argument><expr><name>remainder</name></expr></argument>,
									<argument><expr><name>cagg_hyper_id</name></expr></argument>,
									<argument><expr><name><name>refresh_window</name><operator>-&gt;</operator><name>start</name></name></expr></argument>,
									<comment type="block">/* Refresh window not exclusive at end */</comment>
									<argument><expr><call><name>MIN</name><argument_list>(<argument><expr><name><name>refresh_window</name><operator>-&gt;</operator><name>end</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>,
										<argument><expr><name><name>invalidation</name><operator>-&gt;</operator><name>greatest_modified_value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>INVAL_CUT</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>invalidation</name><operator>-&gt;</operator><name>lowest_modified_value</name></name> <operator>&lt;</operator> <name><name>refresh_window</name><operator>-&gt;</operator><name>end</name></name> <operator>&amp;&amp;</operator>
			<name><name>invalidation</name><operator>-&gt;</operator><name>greatest_modified_value</name></name> <operator>&gt;=</operator> <name><name>refresh_window</name><operator>-&gt;</operator><name>end</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If the invalidation is already cut on the left above, the reminder is set and
			 * will be reset here. The assert prevents from losing information from the reminder.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>result</name> <operator>==</operator> <name>INVAL_CUT</name> <operator>&amp;&amp;</operator>
					<name><name>remainder</name><operator>-&gt;</operator><name>lowest_modified_value</name></name> <operator>==</operator> <name><name>refresh_window</name><operator>-&gt;</operator><name>start</name></name><operator>)</operator> <operator>||</operator>
				   <name>result</name> <operator>==</operator> <name>INVAL_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Need to cut in left end:
			 *
			 * [------)
			 *    [++++++++]
			 *
			 *        [++++]
			 */</comment>
			<expr_stmt><expr><name>upper</name> <operator>=</operator> <call><name>create_invalidation_tup</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>,
											<argument><expr><name>cagg_hyper_id</name></expr></argument>,
											<argument><expr><name><name>refresh_window</name><operator>-&gt;</operator><name>end</name></name></expr></argument>,
											<argument><expr><name><name>invalidation</name><operator>-&gt;</operator><name>greatest_modified_value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>set_remainder_after_cut</name><argument_list>(<argument><expr><name>remainder</name></expr></argument>,
									<argument><expr><name>cagg_hyper_id</name></expr></argument>,
									<argument><expr><call><name>MAX</name><argument_list>(<argument><expr><name><name>invalidation</name><operator>-&gt;</operator><name>lowest_modified_value</name></name></expr></argument>, <argument><expr><name><name>refresh_window</name><operator>-&gt;</operator><name>start</name></name></expr></argument>)</argument_list></call></expr></argument>,
									<comment type="block">/* Refresh window exclusive at end */</comment>
									<argument><expr><name><name>refresh_window</name><operator>-&gt;</operator><name>end</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>INVAL_CUT</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Insert any modifications into the cagg invalidation log */</comment>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>INVAL_CUT</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CatalogSecurityContext</name></type> <name>sec_ctx</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type> <name>other_range</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ts_catalog_database_info_become_owner</name><argument_list>(<argument><expr><call><name>ts_catalog_database_info_get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* We'd like to do one update (unless the TID is not set), and
		 * optionally one insert. We pick one of the tuples for an update, and
		 * the other one will be an insert. */</comment>
		<if_stmt><if>if <condition>(<expr><name>lower</name> <operator>||</operator> <name>upper</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tup</name> <init>= <expr><ternary><condition><expr><name>lower</name></expr> ?</condition><then> <expr><name>lower</name></expr> </then><else>: <expr><name>upper</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>other_range</name> <operator>=</operator> <ternary><condition><expr><name>lower</name></expr> ?</condition><then> <expr><name>upper</name></expr> </then><else>: <expr><name>lower</name></expr></else></ternary></expr>;</expr_stmt>

			<comment type="block">/* If the TID is set, we are updating an existing tuple, i.e., we
			 * are processing and entry in the cagg log itself. Otherwise, we
			 * are processing the hypertable invalidation log and need to
			 * insert a new entry. */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>ItemPointerIsValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>invalidation</name><operator>-&gt;</operator><name>tid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ItemPointerData</name></type> <name>tid</name> <init>= <expr><name><name>invalidation</name><operator>-&gt;</operator><name>tid</name></name></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>ts_catalog_update_tid_only</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>cagg_log_rel</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tid</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ts_catalog_insert_only</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>cagg_log_rel</name></name></expr></argument>, <argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>other_range</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ts_catalog_insert_only</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>cagg_log_rel</name></name></expr></argument>, <argument><expr><name>other_range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>other_range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ts_catalog_restore_user</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>invalidation_entry_reset</name><parameter_list>(<parameter><decl><type><name>Invalidation</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Invalidation</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Expand an invalidation to bucket boundaries.
 *
 * Since a refresh always materializes full buckets, we can safely expand an
 * invalidation to bucket boundaries and in the process merge a lot more
 * invalidations.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>invalidation_expand_to_bucket_boundaries</name><parameter_list>(<parameter><decl><type><name>Invalidation</name> <modifier>*</modifier></type><name>inv</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>time_type_oid</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>bucket_width</name></decl></parameter>,
										 <parameter><decl><type><specifier>const</specifier> <name>ContinuousAggsBucketFunction</name> <modifier>*</modifier></type><name>bucket_function</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int64</name></type> <name>time_dimension_min</name> <init>= <expr><call><name>ts_time_get_min</name><argument_list>(<argument><expr><name>time_type_oid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int64</name></type> <name>time_dimension_max</name> <init>= <expr><call><name>ts_time_get_max</name><argument_list>(<argument><expr><name>time_type_oid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>min_bucket_start</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>max_bucket_end</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>bucket_width</name> <operator>==</operator> <name>BUCKET_WIDTH_VARIABLE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ts_compute_circumscribed_bucketed_refresh_window_variable</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>inv</name><operator>-&gt;</operator><name>lowest_modified_value</name></name></expr></argument>,
																  <argument><expr><operator>&amp;</operator><name><name>inv</name><operator>-&gt;</operator><name>greatest_modified_value</name></name></expr></argument>,
																  <argument><expr><name>bucket_function</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>bucket_width</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Compute the start of the "first" bucket for the type. The min value
	 * must be at the start of the "first" bucket or somewhere in the
	 * bucket. If the min value falls on the exact start of the bucket we are
	 * good. Otherwise, we need to move to the next full bucket. */</comment>
	<expr_stmt><expr><name>min_bucket_start</name> <operator>=</operator> <call><name>ts_time_saturating_add</name><argument_list>(<argument><expr><name>time_dimension_min</name></expr></argument>, <argument><expr><name>bucket_width</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>time_type_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>min_bucket_start</name> <operator>=</operator> <call><name>ts_time_bucket_by_type</name><argument_list>(<argument><expr><name>bucket_width</name></expr></argument>, <argument><expr><name>min_bucket_start</name></expr></argument>, <argument><expr><name>time_type_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Compute the end of the "last" bucket for the time type. Remember that
	 * invalidations are inclusive, so the "greatest" value should be the last
	 * value of the last full bucket. Either the max value is already the last
	 * value of the last bucket, or we need to return the last value of the
	 * previous full bucket.  */</comment>
	<expr_stmt><expr><name>max_bucket_end</name> <operator>=</operator> <call><name>ts_time_bucket_by_type</name><argument_list>(<argument><expr><name>bucket_width</name></expr></argument>, <argument><expr><name>time_dimension_max</name></expr></argument>, <argument><expr><name>time_type_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check if the max value was already the last value of the last bucket */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>ts_time_saturating_add</name><argument_list>(<argument><expr><name>max_bucket_end</name></expr></argument>, <argument><expr><name>bucket_width</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>time_type_oid</name></expr></argument>)</argument_list></call> <operator>==</operator>
		<name>time_dimension_max</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>max_bucket_end</name> <operator>=</operator> <name>time_dimension_max</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* The last bucket was partial. To get the end of previous bucket, we
		 * need to move one step down from the partial last bucket. */</comment>
		<expr_stmt><expr><name>max_bucket_end</name> <operator>=</operator> <call><name>ts_time_saturating_sub</name><argument_list>(<argument><expr><name>max_bucket_end</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>time_type_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>inv</name><operator>-&gt;</operator><name>lowest_modified_value</name></name> <operator>&lt;</operator> <name>min_bucket_start</name></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/* Below the min bucket, so treat as invalid to -infinity. */</comment>
		<expr_stmt><expr><name><name>inv</name><operator>-&gt;</operator><name>lowest_modified_value</name></name> <operator>=</operator> <name>INVAL_NEG_INFINITY</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>inv</name><operator>-&gt;</operator><name>lowest_modified_value</name></name> <operator>&gt;</operator> <name>max_bucket_end</name></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/* Above the max bucket, so treat as invalid to +infinity. */</comment>
		<expr_stmt><expr><name><name>inv</name><operator>-&gt;</operator><name>lowest_modified_value</name></name> <operator>=</operator> <name>INVAL_POS_INFINITY</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>inv</name><operator>-&gt;</operator><name>lowest_modified_value</name></name> <operator>=</operator>
			<call><name>ts_time_bucket_by_type</name><argument_list>(<argument><expr><name>bucket_width</name></expr></argument>, <argument><expr><name><name>inv</name><operator>-&gt;</operator><name>lowest_modified_value</name></name></expr></argument>, <argument><expr><name>time_type_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>inv</name><operator>-&gt;</operator><name>greatest_modified_value</name></name> <operator>&lt;</operator> <name>min_bucket_start</name></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/* Below the min bucket, so treat as invalid to -infinity. */</comment>
		<expr_stmt><expr><name><name>inv</name><operator>-&gt;</operator><name>greatest_modified_value</name></name> <operator>=</operator> <name>INVAL_NEG_INFINITY</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>inv</name><operator>-&gt;</operator><name>greatest_modified_value</name></name> <operator>&gt;</operator> <name>max_bucket_end</name></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/* Above the max bucket, so treat as invalid to +infinity. */</comment>
		<expr_stmt><expr><name><name>inv</name><operator>-&gt;</operator><name>greatest_modified_value</name></name> <operator>=</operator> <name>INVAL_POS_INFINITY</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>inv</name><operator>-&gt;</operator><name>greatest_modified_value</name></name> <operator>=</operator>
			<call><name>ts_time_bucket_by_type</name><argument_list>(<argument><expr><name>bucket_width</name></expr></argument>, <argument><expr><name><name>inv</name><operator>-&gt;</operator><name>greatest_modified_value</name></name></expr></argument>, <argument><expr><name>time_type_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>inv</name><operator>-&gt;</operator><name>greatest_modified_value</name></name> <operator>=</operator>
			<call><name>ts_time_saturating_add</name><argument_list>(<argument><expr><name><name>inv</name><operator>-&gt;</operator><name>greatest_modified_value</name></name></expr></argument>, <argument><expr><name>bucket_width</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>time_type_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Macro to set an Invalidation from a tuple. The tuple can either have the
 * format of the hypertable invalidation log or the continuous aggregate
 * invalidation log (as determined by the type parameter).
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INVALIDATION_ENTRY_SET</name><parameter_list>(<parameter><type><name>entry</name></type></parameter>, <parameter><type><name>ti</name></type></parameter>, <parameter><type><name>hypertable_id</name></type></parameter>, <parameter><type><name>type</name></type></parameter>)</parameter_list></cpp:macro>                                     \
	<cpp:value>do                                                                                             \
	{                                                                                              \
		bool should_free;                                                                          \
		HeapTuple tuple = ts_scanner_fetch_heap_tuple(ti, false, &amp;should_free);                    \
		type form;                                                                                 \
		form = (type) GETSTRUCT(tuple);                                                            \
		(entry)-&gt;hyper_id = form-&gt;hypertable_id;                                                   \
		(entry)-&gt;lowest_modified_value = form-&gt;lowest_modified_value;                              \
		(entry)-&gt;greatest_modified_value = form-&gt;greatest_modified_value;                          \
		(entry)-&gt;is_modified = false;                                                              \
		ItemPointerCopy(&amp;tuple-&gt;t_self, &amp;(entry)-&gt;tid);                                            \
                                                                                                   \
		if (should_free)                                                                           \
			heap_freetuple(tuple);                                                                 \
	} while (0);</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>invalidation_entry_set_from_hyper_invalidation</name><parameter_list>(<parameter><decl><type><name>Invalidation</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name></decl></parameter>,
											   <parameter><decl><type><name>int32</name></type> <name>hyper_id</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>dimtype</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>bucket_width</name></decl></parameter>,
											   <parameter><decl><type><specifier>const</specifier> <name>ContinuousAggsBucketFunction</name> <modifier>*</modifier></type><name>bucket_function</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>INVALIDATION_ENTRY_SET</name><argument_list>(<argument><expr><name>entry</name></expr></argument>,
						   <argument><expr><name>ti</name></expr></argument>,
						   <argument><expr><name>hypertable_id</name></expr></argument>,
						   <argument><expr><name>Form_continuous_aggs_hypertable_invalidation_log</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Since hypertable invalidations are moved to the continuous aggregate
	 * invalidation log, a different hypertable ID must be set (the ID of the
	 * materialized hypertable). */</comment>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>hyper_id</name></name> <operator>=</operator> <name>hyper_id</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>invalidation_expand_to_bucket_boundaries</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>dimtype</name></expr></argument>, <argument><expr><name>bucket_width</name></expr></argument>, <argument><expr><name>bucket_function</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>invalidation_entry_set_from_cagg_invalidation</name><parameter_list>(<parameter><decl><type><name>Invalidation</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>dimtype</name></decl></parameter>,
											  <parameter><decl><type><name>int64</name></type> <name>bucket_width</name></decl></parameter>,
											  <parameter><decl><type><specifier>const</specifier> <name>ContinuousAggsBucketFunction</name> <modifier>*</modifier></type><name>bucket_function</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>INVALIDATION_ENTRY_SET</name><argument_list>(<argument><expr><name>entry</name></expr></argument>,
						   <argument><expr><name>ti</name></expr></argument>,
						   <argument><expr><name>materialization_id</name></expr></argument>,
						   <argument><expr><name>Form_continuous_aggs_materialization_invalidation_log</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* It isn't strictly necessary to expand the invalidation to bucket
	 * boundaries here since all invalidations were already expanded when
	 * copied from the hypertable invalidation log. However, since
	 * invalidation expansion wasn't implemented in early 2.0.x versions of
	 * the extension, there might be unexpanded entries in the cagg
	 * invalidation log for some users. Therefore we try to expand
	 * invalidation entries also here, although in most cases it would do
	 * nothing. */</comment>
	<expr_stmt><expr><call><name>invalidation_expand_to_bucket_boundaries</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>dimtype</name></expr></argument>, <argument><expr><name>bucket_width</name></expr></argument>, <argument><expr><name>bucket_function</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Check if two invalidations can be merged into one.
 *
 * Since invalidations are inclusive in both ends, two adjacent invalidations
 * can be merged.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>invalidations_can_be_merged</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Invalidation</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Invalidation</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* To account for adjacency, expand one window 1 step in each
	 * direction. This makes adjacent invalidations overlapping. */</comment>
	<decl_stmt><decl><type><name>int64</name></type> <name>a_start</name> <init>= <expr><call><name>int64_saturating_sub</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>lowest_modified_value</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>a_end</name> <init>= <expr><call><name>int64_saturating_add</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>greatest_modified_value</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>a_end</name> <operator>&gt;=</operator> <name><name>b</name><operator>-&gt;</operator><name>lowest_modified_value</name></name> <operator>&amp;&amp;</operator> <name>a_start</name> <operator>&lt;=</operator> <name><name>b</name><operator>-&gt;</operator><name>greatest_modified_value</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Try to merge two invalidations into one.
 *
 * Returns true if the invalidations were merged, otherwise false.
 *
 * Given that we scan ordered on lowest_modified_value, the previous and
 * current invalidation can overlap in two ways (generalized):
 *
 * |------|
 *    |++++++++|
 *
 * |-------------|
 *    |++++++++|
 *
 * The closest non-overlapping case is (note that adjacent invalidations can
 * be merged since they are inclusive in both ends):
 *
 * |--|
 *     |++++++++|
 *
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>invalidation_entry_try_merge</name><parameter_list>(<parameter><decl><type><name>Invalidation</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Invalidation</name> <modifier>*</modifier></type><name>newentry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_VALID_INVALIDATION</name><argument_list>(<argument><expr><name>newentry</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Quick exit if no overlap */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>invalidations_can_be_merged</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>newentry</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Check if the new entry expands beyond the old one (first case above) */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>greatest_modified_value</name></name> <operator>&lt;</operator> <name><name>newentry</name><operator>-&gt;</operator><name>greatest_modified_value</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>greatest_modified_value</name></name> <operator>=</operator> <name><name>newentry</name><operator>-&gt;</operator><name>greatest_modified_value</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>is_modified</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>cut_and_insert_new_cagg_invalidation</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CaggInvalidationState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Invalidation</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>,
									 <parameter><decl><type><name>int32</name></type> <name>cagg_hyper_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CatalogSecurityContext</name></type> <name>sec_ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupdesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>cagg_log_rel</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>newtup</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>newtup</name> <operator>=</operator> <call><name>create_invalidation_tup</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>,
									 <argument><expr><name>cagg_hyper_id</name></expr></argument>,
									 <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>lowest_modified_value</name></name></expr></argument>,
									 <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>greatest_modified_value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ts_catalog_database_info_become_owner</name><argument_list>(<argument><expr><call><name>ts_catalog_database_info_get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_catalog_insert_only</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>cagg_log_rel</name></name></expr></argument>, <argument><expr><name>newtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_catalog_restore_user</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Process invalidations in the hypertable invalidation log.
 *
 * Copy and delete all entries from the hypertable invalidation log.
 *
 * Note that each entry gets one copy per continuous aggregate in the cagg
 * invalidation log (unless it was merged or matched the refresh
 * window). These copied entries are later used to track invalidations across
 * refreshes on a per-cagg basis.
 *
 * After this function has run, there are no entries left in the hypertable
 * invalidation log.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>move_invalidations_from_hyper_to_cagg_log</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CaggInvalidationState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>CaggsInfo</name> <modifier>*</modifier></type><name>all_caggs</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>all_caggs</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>hyper_id</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>raw_hypertable_id</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>last_cagg_hyper_id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>lc2</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>lc3</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>last_cagg_hyper_id</name> <operator>=</operator> <call><name>llast_int</name><argument_list>(<argument><expr><name><name>all_caggs</name><operator>-&gt;</operator><name>mat_hypertable_ids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We use a per-tuple memory context in the scan loop since we could be
	 * processing a lot of invalidations (basically an unbounded
	 * amount). Initialize it here by resetting it. */</comment>
	<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>per_tuple_mctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Looping over all continuous aggregates in the outer loop ensures all
	 * tuples for a specific continuous aggregate is inserted consecutively in
	 * the cagg invalidation log. This creates better locality for scanning
	 * the invalidations later.
	 */</comment>
	<macro><name>forthree</name> <argument_list>(<argument>lc1</argument>,
			  <argument>all_caggs-&gt;mat_hypertable_ids</argument>,
			  <argument>lc2</argument>,
			  <argument>all_caggs-&gt;bucket_widths</argument>,
			  <argument>lc3</argument>,
			  <argument>all_caggs-&gt;bucket_functions</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int32</name></type> <name>cagg_hyper_id</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int64</name></type> <name>bucket_width</name> <init>= <expr><call><name>DatumGetInt64</name><argument_list>(<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>ContinuousAggsBucketFunction</name> <modifier>*</modifier></type><name>bucket_function</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc3</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Invalidation</name></type> <name>mergedentry</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ScanIterator</name></type> <name>iterator</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>invalidation_entry_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mergedentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>hypertable_invalidation_scan_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>, <argument><expr><name>hyper_id</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>iterator</name><operator>.</operator><name>ctx</name><operator>.</operator><name>snapshot</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>snapshot</name></name></expr>;</expr_stmt>

		<comment type="block">/* Scan all invalidations */</comment>
		<macro><name>ts_scanner_foreach</name><argument_list>(<argument>&amp;iterator</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldmctx</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Invalidation</name></type> <name>logentry</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>oldmctx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>per_tuple_mctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ti</name> <operator>=</operator> <call><name>ts_scan_iterator_tuple_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>invalidation_entry_set_from_hyper_invalidation</name><argument_list>(<argument><expr><operator>&amp;</operator><name>logentry</name></expr></argument>,
														   <argument><expr><name>ti</name></expr></argument>,
														   <argument><expr><name>cagg_hyper_id</name></expr></argument>,
														   <argument><expr><name><name>state</name><operator>-&gt;</operator><name>dimtype</name></name></expr></argument>,
														   <argument><expr><name>bucket_width</name></expr></argument>,
														   <argument><expr><name>bucket_function</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_VALID_INVALIDATION</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mergedentry</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>mergedentry</name> <operator>=</operator> <name>logentry</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>mergedentry</name><operator>.</operator><name>hyper_id</name></name> <operator>=</operator> <name>cagg_hyper_id</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>invalidation_entry_try_merge</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mergedentry</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>logentry</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>cut_and_insert_new_cagg_invalidation</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mergedentry</name></expr></argument>, <argument><expr><name>cagg_hyper_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>mergedentry</name> <operator>=</operator> <name>logentry</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>cagg_hyper_id</name> <operator>==</operator> <name>last_cagg_hyper_id</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CatalogSecurityContext</name></type> <name>sec_ctx</name></decl>;</decl_stmt>

				<comment type="block">/* The invalidation has been processed for all caggs, so the
				 * only thing left is to delete it from the source hypertable
				 * invalidation log. */</comment>
				<expr_stmt><expr><call><name>ts_catalog_database_info_become_owner</name><argument_list>(<argument><expr><call><name>ts_catalog_database_info_get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ts_catalog_delete_tid_only</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>scanrel</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>logentry</name><operator>.</operator><name>tid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ts_catalog_restore_user</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldmctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>per_tuple_mctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><call><name>ts_scan_iterator_close</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Handle the last merged invalidation */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IS_VALID_INVALIDATION</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mergedentry</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>cut_and_insert_new_cagg_invalidation</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mergedentry</name></expr></argument>, <argument><expr><name>cagg_hyper_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>cagg_invalidations_scan_by_hypertable_init</name><parameter_list>(<parameter><decl><type><name>ScanIterator</name> <modifier>*</modifier></type><name>iterator</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>cagg_hyper_id</name></decl></parameter>,
										   <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>*</operator><name>iterator</name> <operator>=</operator> <call><name>ts_scan_iterator_create</name><argument_list>(<argument><expr><name>CONTINUOUS_AGGS_MATERIALIZATION_INVALIDATION_LOG</name></expr></argument>,
										<argument><expr><name>lockmode</name></expr></argument>,
										<argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>ctx</name><operator>.</operator><name>index</name></name> <operator>=</operator> <call><name>catalog_get_index</name><argument_list>(<argument><expr><call><name>ts_catalog_get</name><argument_list>()</argument_list></call></expr></argument>,
											<argument><expr><name>CONTINUOUS_AGGS_MATERIALIZATION_INVALIDATION_LOG</name></expr></argument>,
											<argument><expr><name>CONTINUOUS_AGGS_MATERIALIZATION_INVALIDATION_LOG_IDX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_scan_iterator_scan_key_init</name><argument_list>(
		<argument><expr><name>iterator</name></expr></argument>,
		<argument><expr><name>Anum_continuous_aggs_materialization_invalidation_log_idx_materialization_id</name></expr></argument>,
		<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
		<argument><expr><name>F_INT4EQ</name></expr></argument>,
		<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>cagg_hyper_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Cut an invalidation and return the part, if any, that remains within the
 * refresh window.
 */</comment>
<function><type><specifier>static</specifier> <name>Invalidation</name></type>
<name>cut_cagg_invalidation</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CaggInvalidationState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>InternalTimeRange</name> <modifier>*</modifier></type><name>refresh_window</name></decl></parameter>,
					  <parameter><decl><type><specifier>const</specifier> <name>Invalidation</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>InvalidationResult</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Invalidation</name></type> <name>remainder</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemPointerData</name></type> <name>tid</name> <init>= <expr><name><name>entry</name><operator>-&gt;</operator><name>tid</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>invalidation_entry_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>remainder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>cut_invalidation_along_refresh_window</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>refresh_window</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>remainder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name>result</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>INVAL_NOMATCH</name></expr>:</case>
			<comment type="block">/* If no cutting was done (i.e., the invalidation was outside the
			 * refresh window), but the invalidation was previously merged
			 * (expanded) with another invalidation, then we still need to
			 * update it. */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>is_modified</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name> <init>= <expr><call><name>create_invalidation_tup</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>cagg_log_rel</name></name></expr></argument>)</argument_list></call></expr></argument>,
														  <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>hyper_id</name></name></expr></argument>,
														  <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>lowest_modified_value</name></name></expr></argument>,
														  <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>greatest_modified_value</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>ts_catalog_update_tid_only</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>cagg_log_rel</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tid</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>INVAL_DELETE</name></expr>:</case>
			<expr_stmt><expr><call><name>ts_catalog_delete_tid_only</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>cagg_log_rel</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>INVAL_CUT</name></expr>:</case>
			<comment type="block">/* Nothing to do */</comment>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>remainder</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Invalidation</name></type>
<name>cut_cagg_invalidation_and_compute_remainder</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CaggInvalidationState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
											<parameter><decl><type><specifier>const</specifier> <name>InternalTimeRange</name> <modifier>*</modifier></type><name>refresh_window</name></decl></parameter>,
											<parameter><decl><type><specifier>const</specifier> <name>Invalidation</name> <modifier>*</modifier></type><name>mergedentry</name></decl></parameter>,
											<parameter><decl><type><specifier>const</specifier> <name>Invalidation</name> <modifier>*</modifier></type><name>current_remainder</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Invalidation</name></type> <name>new_remainder</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Invalidation</name></type> <name>remainder</name> <init>= <expr><operator>*</operator><name>current_remainder</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* The previous and current invalidation could not be merged. We
	 * need to cut the prev invalidation against the refresh window */</comment>
	<expr_stmt><expr><name>new_remainder</name> <operator>=</operator> <call><name>cut_cagg_invalidation</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>refresh_window</name></expr></argument>, <argument><expr><name>mergedentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_VALID_INVALIDATION</name><argument_list>(<argument><expr><operator>&amp;</operator><name>remainder</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>remainder</name> <operator>=</operator> <name>new_remainder</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>invalidation_entry_try_merge</name><argument_list>(<argument><expr><operator>&amp;</operator><name>remainder</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_remainder</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>save_invalidation_for_refresh</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>remainder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>remainder</name> <operator>=</operator> <name>new_remainder</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>remainder</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Clear all cagg invalidations that match a refresh window.
 *
 * This function clears all invalidations in the cagg invalidation log that
 * matches a window, and adds the invalidation segments covered by the window
 * to the invalidation store (tuple store) in the state argument. The
 * remaining segments that are added to the invalidation store are regions
 * that require materialization.
 *
 * An invalidation entry that gets processed is either completely enclosed
 * (covered) by the refresh window, or it partially overlaps. In the former
 * case, the invalidation entry is removed and for the latter case it is
 * cut. Thus, an entry can either disappear, reduce in size, or be cut in two.
 *
 * Note that the refresh window is inclusive at the start and exclusive at the
 * end. This function also assumes that invalidations are scanned in order of
 * lowest_modified_value.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>clear_cagg_invalidations_for_refresh</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CaggInvalidationState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
									 <parameter><decl><type><specifier>const</specifier> <name>InternalTimeRange</name> <modifier>*</modifier></type><name>refresh_window</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScanIterator</name></type> <name>iterator</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>cagg_hyper_id</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>mat_hypertable_id</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Invalidation</name></type> <name>mergedentry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Invalidation</name></type> <name>remainder</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>invalidation_entry_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mergedentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>invalidation_entry_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>remainder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>cagg_invalidations_scan_by_hypertable_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>, <argument><expr><name>cagg_hyper_id</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>iterator</name><operator>.</operator><name>ctx</name><operator>.</operator><name>snapshot</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>snapshot</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>per_tuple_mctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Process all invalidations for the continuous aggregate */</comment>
	<macro><name>ts_scanner_foreach</name><argument_list>(<argument>&amp;iterator</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name> <init>= <expr><call><name>ts_scan_iterator_tuple_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldmctx</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Invalidation</name></type> <name>logentry</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int64</name></type> <name>bucket_width</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>bucket_width</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>ContinuousAggsBucketFunction</name> <modifier>*</modifier></type><name>bucket_function</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>bucket_function</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>oldmctx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>per_tuple_mctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>invalidation_entry_set_from_cagg_invalidation</name><argument_list>(<argument><expr><operator>&amp;</operator><name>logentry</name></expr></argument>,
													  <argument><expr><name>ti</name></expr></argument>,
													  <argument><expr><name><name>state</name><operator>-&gt;</operator><name>dimtype</name></name></expr></argument>,
													  <argument><expr><name>bucket_width</name></expr></argument>,
													  <argument><expr><name>bucket_function</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_VALID_INVALIDATION</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mergedentry</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>mergedentry</name> <operator>=</operator> <name>logentry</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>invalidation_entry_try_merge</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mergedentry</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>logentry</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * The previous and current invalidation were merged into
			 * one entry (i.e., they overlapped or were adjacent).
			 */</comment>
			<expr_stmt><expr><call><name>ts_catalog_delete_tid_only</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>cagg_log_rel</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>logentry</name><operator>.</operator><name>tid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>remainder</name> <operator>=</operator> <call><name>cut_cagg_invalidation_and_compute_remainder</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
																	<argument><expr><name>refresh_window</name></expr></argument>,
																	<argument><expr><operator>&amp;</operator><name>mergedentry</name></expr></argument>,
																	<argument><expr><operator>&amp;</operator><name>remainder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>mergedentry</name> <operator>=</operator> <name>logentry</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldmctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>per_tuple_mctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>ts_scan_iterator_close</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Handle the last (merged) invalidation */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IS_VALID_INVALIDATION</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mergedentry</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>remainder</name> <operator>=</operator> <call><name>cut_cagg_invalidation_and_compute_remainder</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
																<argument><expr><name>refresh_window</name></expr></argument>,
																<argument><expr><operator>&amp;</operator><name>mergedentry</name></expr></argument>,
																<argument><expr><operator>&amp;</operator><name>remainder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Handle the last (merged) remainder */</comment>
	<expr_stmt><expr><call><name>save_invalidation_for_refresh</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>remainder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>invalidation_state_init</name><parameter_list>(<parameter><decl><type><name>CaggInvalidationState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>mat_hypertable_id</name></decl></parameter>,
						<parameter><decl><type><name>int32</name></type> <name>raw_hypertable_id</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>dimtype</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CaggsInfo</name> <modifier>*</modifier></type><name>all_caggs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>lc2</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>lc3</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name> <name>PG_USED_FOR_ASSERTS_ONLY</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mat_hypertable_id</name></name> <operator>=</operator> <name>mat_hypertable_id</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>raw_hypertable_id</name></name> <operator>=</operator> <name>raw_hypertable_id</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>dimtype</name></name> <operator>=</operator> <name>dimtype</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>all_caggs</name></name> <operator>=</operator> <name>all_caggs</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>cagg_log_rel</name></name> <operator>=</operator> <call><name>open_invalidation_log</name><argument_list>(<argument><expr><name>LOG_CAGG</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>per_tuple_mctx</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
												  <argument><expr><literal type="string">"Continuous aggregate invalidations"</literal></expr></argument>,
												  <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>snapshot</name></name> <operator>=</operator> <call><name>RegisterSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>forthree</name> <argument_list>(<argument>lc1</argument>,
			  <argument>all_caggs-&gt;mat_hypertable_ids</argument>,
			  <argument>lc2</argument>,
			  <argument>all_caggs-&gt;bucket_widths</argument>,
			  <argument>lc3</argument>,
			  <argument>all_caggs-&gt;bucket_functions</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int32</name></type> <name>cagg_hyper_id</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>cagg_hyper_id</name> <operator>==</operator> <name>mat_hypertable_id</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>bucket_width</name></name> <operator>=</operator> <call><name>DatumGetInt64</name><argument_list>(<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>bucket_function</name></name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>invalidation_state_cleanup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CaggInvalidationState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>cagg_log_rel</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UnregisterSnapshot</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>per_tuple_mctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>invalidation_process_hypertable_log</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>mat_hypertable_id</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>raw_hypertable_id</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>dimtype</name></decl></parameter>,
									<parameter><decl><type><specifier>const</specifier> <name>CaggsInfo</name> <modifier>*</modifier></type><name>all_caggs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CaggInvalidationState</name></type> <name>state</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>invalidation_state_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>mat_hypertable_id</name></expr></argument>, <argument><expr><name>raw_hypertable_id</name></expr></argument>, <argument><expr><name>dimtype</name></expr></argument>, <argument><expr><name>all_caggs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>move_invalidations_from_hyper_to_cagg_log</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>invalidation_state_cleanup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Generates the default bucket_functions[] argument for the following functions:
 *
 * - _timescaledb_internal.invalidation_process_hypertable_log()
 * - _timescaledb_internal.invalidation_process_cagg_log()
 *
 * Users are expected to have the same or higher version of TimescaleDB on the
 * data nodes. When the access node runs the older version that knows nothing
 * about the bucket_functions[] argument, the data nodes that runs newer version
 * will receive less arguments that they expect. When this happens data nodes
 * generate the default argument, and execute the rest of the logic as usual.
 */</comment>
<function><type><specifier>static</specifier> <name>ArrayType</name> <modifier>*</modifier></type>
<name>bucket_functions_default_argument</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>ndim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>bucketfunctions</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>ndim</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndim</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>bucketfunctions</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<return>return <expr><call><name>construct_array</name><argument_list>(<argument><expr><name>bucketfunctions</name></expr></argument>, <argument><expr><name>ndim</name></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>TYPALIGN_INT</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Processes the hypertable invalidation log in a data node for all the CAGGs that belong to the
 * distributed hypertable with hypertable ID 'raw_hypertable_id' in the Access Node. The
 * invalidations are cut, merged and moved to the materialization invalidation log.
 *
 * @param mat_hypertable_id The hypertable ID of the CAGG materialized hypertable in the Access
 *                          Node that is currently being refreshed.
 * @param raw_hypertable_id The hypertable ID of the original distributed hypertable in the Access
 *                          Node.
 * @param dimtype The OID of the type of the time dimension for this CAGG.
 * @param mat_hypertable_ids The array of hypertable IDs for all CAGG materialized hypertables in
 *                           the Access Node that belong to 'raw_hypertable_id'.
 * @param bucket_widths The array of time bucket widths for all the CAGGs that belong to
 *                      'raw_hypertable_id'.
 * @param max_bucket_widths (Deprecated) This argument is ignored and is present only for backward
 *                          compatibility.
 * @param bucket_functions (Optional) The array of serialized information about bucket functions.
 */</comment>
<function><type><name>Datum</name></type>
<name>tsl_invalidation_process_hypertable_log</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type> <name>mat_hypertable_id</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>raw_hypertable_id</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>dimtype</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>mat_hypertable_ids</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>bucket_widths</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>bucket_functions</name> <init>= <expr><ternary><condition><expr><call><name>PG_NARGS</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">6</literal></expr> ?</condition><then>
									  <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr> </then><else>:
									  <expr><call><name>bucket_functions_default_argument</name><argument_list>(<argument><expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>bucket_widths</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CaggsInfo</name></type> <name>all_caggs_info</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ts_populate_caggs_info_from_arrays</name><argument_list>(<argument><expr><name>mat_hypertable_ids</name></expr></argument>,
									   <argument><expr><name>bucket_widths</name></expr></argument>,
									   <argument><expr><name>bucket_functions</name></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name>all_caggs_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>invalidation_process_hypertable_log</name><argument_list>(<argument><expr><name>mat_hypertable_id</name></expr></argument>,
										<argument><expr><name>raw_hypertable_id</name></expr></argument>,
										<argument><expr><name>dimtype</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>all_caggs_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INVALIDATION_PROCESS_HYPERTABLE_LOG_NARGS</name></cpp:macro> <cpp:value>7</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INVALIDATION_PROCESS_HYPERTABLE_LOG_FUNCNAME</name></cpp:macro> <cpp:value>"invalidation_process_hypertable_log"</cpp:value></cpp:define>

<function><type><name>void</name></type>
<name>remote_invalidation_process_hypertable_log</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>mat_hypertable_id</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>raw_hypertable_id</name></decl></parameter>,
										   <parameter><decl><type><name>Oid</name></type> <name>dimtype</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CaggsInfo</name> <modifier>*</modifier></type><name>all_caggs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>func_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>mat_hypertable_ids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>bucket_widths</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>bucket_functions</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>LOCAL_FCINFO</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>INVALIDATION_PROCESS_HYPERTABLE_LOG_NARGS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name></type> <name>flinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ts_create_arrays_from_caggs_info</name><argument_list>(<argument><expr><name>all_caggs</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>mat_hypertable_ids</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>bucket_widths</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>bucket_functions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>Oid</name></type> <name><name>type_id</name><index>[<expr><name>INVALIDATION_PROCESS_HYPERTABLE_LOG_NARGS</name></expr>]</index></name> <init>= <expr><block>{
		<expr><name>INT4OID</name></expr>, <expr><name>INT4OID</name></expr>, <expr><name>REGTYPEOID</name></expr>, <expr><name>INT4ARRAYOID</name></expr>, <expr><name>INT8ARRAYOID</name></expr>, <expr><name>INT8ARRAYOID</name></expr>, <expr><name>TEXTARRAYOID</name></expr>
	}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier><specifier>const</specifier></type> <name>fqn</name> <init>= <expr><call><name>list_make2</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>INTERNAL_SCHEMA_NAME</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>INVALIDATION_PROCESS_HYPERTABLE_LOG_FUNCNAME</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Note that we have to explicitly specify the amount of arguments in this
	 * case, because there are several overloaded versions of invalidation_process_hypertable_log().
	 */</comment>
	<expr_stmt><expr><name>func_oid</name> <operator>=</operator> <call><name>LookupFuncName</name><argument_list>(<argument><expr><name>fqn</name></expr></argument>, <argument><expr><call><name>lengthof</name><argument_list>(<argument><expr><name>type_id</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>type_id</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>func_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>func_oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><operator>*</operator><name>fcinfo</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>flinfo</name></expr></argument>,
							 <argument><expr><name>INVALIDATION_PROCESS_HYPERTABLE_LOG_NARGS</name></expr></argument>,
							 <argument><expr><name>InvalidOid</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>INVALIDATION_PROCESS_HYPERTABLE_LOG_NARGS</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>FC_NULL</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>FC_ARG</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>mat_hypertable_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FC_ARG</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>raw_hypertable_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FC_ARG</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>dimtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FC_ARG</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>mat_hypertable_ids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FC_ARG</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>bucket_widths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FC_ARG</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>construct_empty_array</name><argument_list>(<argument><expr><name>INT8OID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FC_ARG</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>bucket_functions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Check for null result, since caller is clearly not expecting one */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"function %u returned NULL"</literal></expr></argument>, <argument><expr><name><name>flinfo</name><operator>.</operator><name>fn_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name> <init>= <expr><call><name>ts_hypertable_get_by_id</name><argument_list>(<argument><expr><name>raw_hypertable_id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ht</name> <operator>||</operator> <operator>!</operator><call><name>hypertable_is_distributed</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"function was not provided with a valid distributed hypertable id"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>DistCmdResult</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>data_node_list</name> <init>= <expr><call><name>ts_hypertable_get_data_node_name_list</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ts_dist_cmd_invoke_func_call_on_data_nodes</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>data_node_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ts_dist_cmd_close_response</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>InvalidationStore</name> <modifier>*</modifier></type>
<name>invalidation_process_cagg_log</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>mat_hypertable_id</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>raw_hypertable_id</name></decl></parameter>,
							  <parameter><decl><type><specifier>const</specifier> <name>InternalTimeRange</name> <modifier>*</modifier></type><name>refresh_window</name></decl></parameter>,
							  <parameter><decl><type><specifier>const</specifier> <name>CaggsInfo</name> <modifier>*</modifier></type><name>all_caggs_info</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>long</name></type> <name>max_materializations</name></decl></parameter>,
							  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>do_merged_refresh</name></decl></parameter>, <parameter><decl><type><name>InternalTimeRange</name> <modifier>*</modifier></type><name>ret_merged_refresh_window</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CaggInvalidationState</name></type> <name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>InvalidationStore</name> <modifier>*</modifier></type><name>store</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type> <name>count</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>do_merged_refresh</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>invalidation_state_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>,
							<argument><expr><name>mat_hypertable_id</name></expr></argument>,
							<argument><expr><name>raw_hypertable_id</name></expr></argument>,
							<argument><expr><name><name>refresh_window</name><operator>-&gt;</operator><name>type</name></name></expr></argument>,
							<argument><expr><name>all_caggs_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>.</operator><name>invalidations</name></name> <operator>=</operator> <call><name>tuplestore_begin_heap</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>work_mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>clear_cagg_invalidations_for_refresh</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>refresh_window</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>count</name> <operator>=</operator> <call><name>tuplestore_tuple_count</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>invalidations</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>tuplestore_end</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>invalidations</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>store</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>InvalidationStore</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>store</name><operator>-&gt;</operator><name>tupstore</name></name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>invalidations</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>store</name><operator>-&gt;</operator><name>tupdesc</name></name> <operator>=</operator> <call><name>CreateTupleDescCopy</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>cagg_log_rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>invalidation_state_cleanup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If there are many individual invalidation ranges to refresh, then
	 * revert to a merged refresh across the range decided by lowest and
	 * highest invalidated value.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>count</name> <operator>&amp;&amp;</operator> <call><name>tuplestore_tuple_count</name><argument_list>(<argument><expr><name><name>store</name><operator>-&gt;</operator><name>tupstore</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>max_materializations</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>InternalTimeRange</name></type> <name>merged_refresh_window</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>continuous_agg_calculate_merged_refresh_window</name><argument_list>(<argument><expr><name>refresh_window</name></expr></argument>,
													   <argument><expr><name>store</name></expr></argument>,
													   <argument><expr><name><name>state</name><operator>.</operator><name>bucket_width</name></name></expr></argument>,
													   <argument><expr><name><name>state</name><operator>.</operator><name>bucket_function</name></name></expr></argument>,
													   <argument><expr><operator>&amp;</operator><name>merged_refresh_window</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>do_merged_refresh</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>ret_merged_refresh_window</name> <operator>=</operator> <name>merged_refresh_window</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>invalidation_store_free</name><argument_list>(<argument><expr><name>store</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>store</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>store</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Processes the materialization invalidation log in a data node for the CAGG being refreshed that
 * belongs to the distributed hypertable with hypertable ID 'raw_hypertable_id' in the Access Node.
 * The invalidations are cut, merged and returned as a single refresh window.
 *
 * @param mat_hypertable_id The hypertable ID of the CAGG materialized hypertable in the Access
 *                          Node that is currently being refreshed.
 * @param raw_hypertable_id The hypertable ID of the original distributed hypertable in the Access
 *                          Node.
 * @param dimtype The OID of the type of the time dimension for this CAGG.
 * @param window_start The starting time of the CAGG refresh window.
 * @param window_end The ending time of the CAGG refresh window.
 * @param mat_hypertable_ids The array of hypertable IDs for all CAGG materialized hypertables in
 *                           the Access Node that belong to 'raw_hypertable_id'.
 * @param bucket_widths The array of time bucket widths for all the CAGGs that belong to
 *                      'raw_hypertable_id'.
 * @param max_bucket_widths (Deprecated) This argument is ignored and is present only for backward
 *                          compatibility.
 * @param bucket_functions (Optional) The array of serialized information about bucket functions.
 * @return a tuple of:
 *         ret_window_start - The merged refresh window starting time
 *         ret_window_end - The merged refresh window ending time
 */</comment>
<function><type><name>Datum</name></type>
<name>tsl_invalidation_process_cagg_log</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>do_merged_refresh</name></decl>;</decl_stmt>
	<function_decl><type><name>InvalidationStore</name> <modifier>*</modifier><name>invalidations</name></type> <name>pg_attribute_unused</name><parameter_list>()</parameter_list> <init>= <expr><name>NULL</name></expr></init>;</function_decl>

	<decl_stmt><decl><type><name>int32</name></type> <name>mat_hypertable_id</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>raw_hypertable_id</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>InternalTimeRange</name></type> <name>refresh_window</name> <init>= <expr><block>{ <expr><operator>.</operator><name>type</name> <operator>=</operator> <call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>,
										 <expr><operator>.</operator><name>start</name> <operator>=</operator> <call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>,
										 <expr><operator>.</operator><name>end</name> <operator>=</operator> <macro><name>PG_GETARG_INT64</name><argument_list>(<argument><literal type="number">4</literal></argument>)</argument_list></macro></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>mat_hypertable_ids</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>bucket_widths</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>bucket_functions</name> <init>= <expr><ternary><condition><expr><call><name>PG_NARGS</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">8</literal></expr> ?</condition><then>
									  <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr> </then><else>:
									  <expr><call><name>bucket_functions_default_argument</name><argument_list>(<argument><expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>bucket_widths</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CaggsInfo</name></type> <name>all_caggs_info</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>InternalTimeRange</name></type> <name>ret_merged_refresh_window</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ts_populate_caggs_info_from_arrays</name><argument_list>(<argument><expr><name>mat_hypertable_ids</name></expr></argument>,
									   <argument><expr><name>bucket_widths</name></expr></argument>,
									   <argument><expr><name>bucket_functions</name></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name>all_caggs_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Force to always merge the refresh ranges since it is running in the data node
	 * by setting (max_materializations = 0) */</comment>
	<expr_stmt><expr><name>invalidations</name> <operator>=</operator> <call><name>invalidation_process_cagg_log</name><argument_list>(<argument><expr><name>mat_hypertable_id</name></expr></argument>,
												  <argument><expr><name>raw_hypertable_id</name></expr></argument>,
												  <argument><expr><operator>&amp;</operator><name>refresh_window</name></expr></argument>,
												  <argument><expr><operator>&amp;</operator><name>all_caggs_info</name></expr></argument>,
												  <argument><expr><literal type="number">0</literal></expr></argument> <comment type="block">/* max_materializations */</comment>,
												  <argument><expr><operator>&amp;</operator><name>do_merged_refresh</name></expr></argument>,
												  <argument><expr><operator>&amp;</operator><name>ret_merged_refresh_window</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name><name>nulls</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{ <expr><name>false</name></expr>, <expr><name>false</name></expr> }</block></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>get_call_result_type</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupdesc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TYPEFUNC_COMPOSITE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"function returning record called in context that cannot accept type record"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>BlessTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>do_merged_refresh</name></expr>)</condition>
	<block>{<block_content> <comment type="block">/* No invalidations found whatsoever */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>invalidations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><name><name>ret_merged_refresh_window</name><operator>.</operator><name>start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><name><name>ret_merged_refresh_window</name><operator>.</operator><name>end</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INVALIDATION_PROCESS_CAGG_LOG_NARGS</name></cpp:macro> <cpp:value>9</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INVALIDATION_PROCESS_CAGG_LOG_FUNCNAME</name></cpp:macro> <cpp:value>"invalidation_process_cagg_log"</cpp:value></cpp:define>

<function><type><name>void</name></type>
<name>remote_invalidation_process_cagg_log</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>mat_hypertable_id</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>raw_hypertable_id</name></decl></parameter>,
									 <parameter><decl><type><specifier>const</specifier> <name>InternalTimeRange</name> <modifier>*</modifier></type><name>refresh_window</name></decl></parameter>,
									 <parameter><decl><type><specifier>const</specifier> <name>CaggsInfo</name> <modifier>*</modifier></type><name>all_caggs</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>do_merged_refresh</name></decl></parameter>,
									 <parameter><decl><type><name>InternalTimeRange</name> <modifier>*</modifier></type><name>ret_merged_refresh_window</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>func_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>mat_hypertable_ids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>bucket_widths</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>bucket_functions</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>LOCAL_FCINFO</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>INVALIDATION_PROCESS_CAGG_LOG_NARGS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name></type> <name>flinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>do_merged_refresh</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ts_create_arrays_from_caggs_info</name><argument_list>(<argument><expr><name>all_caggs</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>mat_hypertable_ids</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>bucket_widths</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>bucket_functions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>Oid</name></type> <name><name>type_id</name><index>[<expr><name>INVALIDATION_PROCESS_CAGG_LOG_NARGS</name></expr>]</index></name> <init>= <expr><block>{
		<expr><name>INT4OID</name></expr>,	  <expr><name>INT4OID</name></expr>,		<expr><name>REGTYPEOID</name></expr>,	  <expr><name>INT8OID</name></expr>,		<expr><name>INT8OID</name></expr>,
		<expr><name>INT4ARRAYOID</name></expr>, <expr><name>INT8ARRAYOID</name></expr>, <expr><name>INT8ARRAYOID</name></expr>, <expr><name>TEXTARRAYOID</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier><specifier>const</specifier></type> <name>fqn</name> <init>= <expr><call><name>list_make2</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>INTERNAL_SCHEMA_NAME</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>INVALIDATION_PROCESS_CAGG_LOG_FUNCNAME</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Note that we have to explicitly specify the amount of arguments in this
	 * case, because there are several overloaded versions of invalidation_process_cagg_log().
	 */</comment>
	<expr_stmt><expr><name>func_oid</name> <operator>=</operator> <call><name>LookupFuncName</name><argument_list>(<argument><expr><name>fqn</name></expr></argument>, <argument><expr><call><name>lengthof</name><argument_list>(<argument><expr><name>type_id</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>type_id</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>func_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>func_oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><operator>*</operator><name>fcinfo</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>flinfo</name></expr></argument>,
							 <argument><expr><name>INVALIDATION_PROCESS_CAGG_LOG_NARGS</name></expr></argument>,
							 <argument><expr><name>InvalidOid</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>INVALIDATION_PROCESS_CAGG_LOG_NARGS</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>FC_NULL</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>FC_ARG</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>mat_hypertable_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FC_ARG</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>raw_hypertable_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FC_ARG</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>refresh_window</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FC_ARG</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><name><name>refresh_window</name><operator>-&gt;</operator><name>start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FC_ARG</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><name><name>refresh_window</name><operator>-&gt;</operator><name>end</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FC_ARG</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>mat_hypertable_ids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FC_ARG</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>bucket_widths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FC_ARG</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>construct_empty_array</name><argument_list>(<argument><expr><name>INT8OID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FC_ARG</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>bucket_functions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Check for null result, since caller is clearly not expecting one */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"function %u returned NULL"</literal></expr></argument>, <argument><expr><name><name>flinfo</name><operator>.</operator><name>fn_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name> <init>= <expr><call><name>ts_hypertable_get_by_id</name><argument_list>(<argument><expr><name>raw_hypertable_id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ht</name> <operator>||</operator> <operator>!</operator><call><name>hypertable_is_distributed</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"function was not provided with a valid distributed hypertable id"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>DistCmdResult</name> <modifier>*</modifier></type><name>dist_res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>data_node_list</name> <init>= <expr><call><name>ts_hypertable_get_data_node_name_list</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>dist_res</name> <operator>=</operator> <call><name>ts_dist_cmd_invoke_func_call_on_data_nodes</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>data_node_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>dist_res</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>unsigned</name></type> <name>num_dist_res</name> <init>= <expr><call><name>ts_dist_cmd_response_count</name><argument_list>(<argument><expr><name>dist_res</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int64</name></type> <name>start_time</name></decl>, <decl><type ref="prev"/><name>end_time</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>InternalTimeRange</name></type> <name>merged_window</name> <init>= <expr><block>{
			<expr><operator>.</operator><name>type</name> <operator>=</operator> <name><name>refresh_window</name><operator>-&gt;</operator><name>type</name></name></expr>,
			<expr><operator>.</operator><name>start</name> <operator>=</operator> <name>TS_TIME_NOEND</name></expr>, <comment type="block">/* initial state invalid */</comment>
			<expr><operator>.</operator><name>end</name> <operator>=</operator> <name>TS_TIME_NOBEGIN</name></expr>	<comment type="block">/* initial state invalid */</comment>
		}</block></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_dist_res</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>node_name</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>ts_dist_cmd_get_result_by_index</name><argument_list>(<argument><expr><name>dist_res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>node_name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_TUPLES_OK</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_EXCEPTION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>PQresultErrorMessage</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>PQnfields</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content> <comment type="block">/* No invalidations in this data node */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>start_time</name> <operator>=</operator> <call><name>pg_strtoint64</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>end_time</name> <operator>=</operator> <call><name>pg_strtoint64</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
				 <argument><expr><literal type="string">"merged invalidations for refresh on ["</literal> <name>INT64_FORMAT</name> <literal type="string">", "</literal> <name>INT64_FORMAT</name> <literal type="string">"] from %s"</literal></expr></argument>,
				 <argument><expr><name>start_time</name></expr></argument>,
				 <argument><expr><name>end_time</name></expr></argument>,
				 <argument><expr><name>node_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* merge refresh windows from the data nodes */</comment>
			<if_stmt><if>if <condition>(<expr><name>start_time</name> <operator>&lt;</operator> <name><name>merged_window</name><operator>.</operator><name>start</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>merged_window</name><operator>.</operator><name>start</name></name> <operator>=</operator> <name>start_time</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>end_time</name> <operator>&gt;</operator> <name><name>merged_window</name><operator>.</operator><name>end</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>merged_window</name><operator>.</operator><name>end</name></name> <operator>=</operator> <name>end_time</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>ts_dist_cmd_close_response</name><argument_list>(<argument><expr><name>dist_res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>merged_window</name><operator>.</operator><name>start</name></name> <operator>&lt;=</operator> <name><name>merged_window</name><operator>.</operator><name>end</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>ret_merged_refresh_window</name> <operator>=</operator> <name>merged_window</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>do_merged_refresh</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INVALIDATION_LOG_DELETE_NARGS</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HYPERTABLE_INVALIDATION_LOG_DELETE_FUNCNAME</name></cpp:macro> <cpp:value>"hypertable_invalidation_log_delete"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MATERIALIZATION_INVALIDATION_LOG_DELETE_FUNCNAME</name></cpp:macro> <cpp:value>"materialization_invalidation_log_delete"</cpp:value></cpp:define>

<function><type><name>void</name></type>
<name>remote_invalidation_log_delete</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>raw_hypertable_id</name></decl></parameter>, <parameter><decl><type><name>ContinuousAggHypertableStatus</name></type> <name>caggstatus</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Execute on all data nodes if there are any */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>data_nodes</name> <init>= <expr><call><name>data_node_get_node_name_list</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>NIL</name> <operator>==</operator> <name>data_nodes</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>func_oid</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>LOCAL_FCINFO</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>INVALIDATION_LOG_DELETE_NARGS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name></type> <name>flinfo</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>HypertableIsMaterialization</name> <operator>==</operator> <name>caggstatus</name> <operator>||</operator> <name>HypertableIsRawTable</name> <operator>==</operator> <name>caggstatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>Oid</name></type> <name><name>type_id</name><index>[<expr><name>INVALIDATION_LOG_DELETE_NARGS</name></expr>]</index></name> <init>= <expr><block>{ <expr><name>INT4OID</name></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier><specifier>const</specifier></type> <name>fqn</name> <init>= <expr><call><name>list_make2</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>INTERNAL_SCHEMA_NAME</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><ternary><condition><expr><operator>(</operator><name>caggstatus</name> <operator>==</operator> <name>HypertableIsMaterialization</name><operator>)</operator></expr> ?</condition><then>
												<expr><name>MATERIALIZATION_INVALIDATION_LOG_DELETE_FUNCNAME</name></expr> </then><else>:
												<expr><name>HYPERTABLE_INVALIDATION_LOG_DELETE_FUNCNAME</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>func_oid</name> <operator>=</operator> <call><name>LookupFuncName</name><argument_list>(<argument><expr><name>fqn</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument> <comment type="block">/* lengthof(type_id) */</comment>, <argument><expr><name>type_id</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>func_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>func_oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><operator>*</operator><name>fcinfo</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>flinfo</name></expr></argument>,
							 <argument><expr><name>INVALIDATION_LOG_DELETE_NARGS</name></expr></argument>,
							 <argument><expr><name>InvalidOid</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FC_NULL</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FC_ARG</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>raw_hypertable_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Check for null result, since caller is clearly not expecting one */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"function %u returned NULL"</literal></expr></argument>, <argument><expr><name><name>flinfo</name><operator>.</operator><name>fn_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>DistCmdResult</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ts_dist_cmd_invoke_func_call_on_data_nodes</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>data_nodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ts_dist_cmd_close_response</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Delete invalidation trigger for distributed hypertable member with hypertable ID
 * 'raw_hypertable_id' in the Data Node.
 *
 * @param raw_hypertable_id - The hypertable ID of the distributed hypertable member in the
 *                            Data Node.
 */</comment>
<function><type><name>Datum</name></type>
<name>tsl_drop_dist_ht_invalidation_trigger</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cache</name> <modifier>*</modifier></type><name>hcache</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>raw_hypertable_id</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>hcache</name> <operator>=</operator> <call><name>ts_hypertable_cache_pin</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ht</name> <operator>=</operator> <call><name>ts_hypertable_cache_get_entry_by_id</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>, <argument><expr><name>raw_hypertable_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ht</name> <operator>||</operator> <operator>!</operator><call><name>hypertable_is_distributed_member</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"function was not provided with a valid distributed hypertable id"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ts_materialization_invalidation_log_delete_inner</name><argument_list>(<argument><expr><name>raw_hypertable_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_hypertable_drop_trigger</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>, <argument><expr><name>CAGGINVAL_TRIGGER_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DROP_DIST_HT_INVALIDATION_TRIGGER_NARGS</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DROP_DIST_HT_INVALIDATION_TRIGGER_FUNCNAME</name></cpp:macro> <cpp:value>"drop_dist_ht_invalidation_trigger"</cpp:value></cpp:define>

<function><type><name>void</name></type>
<name>remote_drop_dist_ht_invalidation_trigger</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>raw_hypertable_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cache</name> <modifier>*</modifier></type><name>hcache</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>hcache</name> <operator>=</operator> <call><name>ts_hypertable_cache_pin</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ht</name> <operator>=</operator> <call><name>ts_hypertable_cache_get_entry_by_id</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>, <argument><expr><name>raw_hypertable_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hypertable_is_distributed</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>data_node_list</name> <init>= <expr><call><name>ts_hypertable_get_data_node_name_list</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DistCmdResult</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>func_oid</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>Oid</name></type> <name><name>type_id</name><index>[<expr><name>DROP_DIST_HT_INVALIDATION_TRIGGER_NARGS</name></expr>]</index></name> <init>= <expr><block>{ <expr><name>INT4OID</name></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier><specifier>const</specifier></type> <name>fqn</name> <init>= <expr><call><name>list_make2</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>INTERNAL_SCHEMA_NAME</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>DROP_DIST_HT_INVALIDATION_TRIGGER_FUNCNAME</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>func_oid</name> <operator>=</operator> <call><name>LookupFuncName</name><argument_list>(<argument><expr><name>fqn</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument> <comment type="block">/* lengthof(type_id) */</comment>, <argument><expr><name>type_id</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>func_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name> <init>=
		<expr><call><name>palloc</name><argument_list>(<argument><expr><call><name>SizeForFunctionCallInfo</name><argument_list>(<argument><expr><name>DROP_DIST_HT_INVALIDATION_TRIGGER_NARGS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name></type> <name>flinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>cmd_descriptors</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt> <comment type="block">/* same order as ht-&gt;data_nodes */</comment>
	<decl_stmt><decl><type><name>DistCmdDescr</name> <modifier>*</modifier></type><name>cmd_descr_data</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>data_node_list</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>cmd_descr_data</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>cell</argument>, <argument>ht-&gt;data_nodes</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HypertableDataNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>func_oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><operator>*</operator><name>fcinfo</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>flinfo</name></expr></argument>,
								 <argument><expr><name>DROP_DIST_HT_INVALIDATION_TRIGGER_NARGS</name></expr></argument>,
								 <argument><expr><name>InvalidOid</name></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>FC_NULL</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<comment type="block">/* distributed member hypertable ID */</comment>
		<expr_stmt><expr><call><name>FC_ARG</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>node_hypertable_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Check for null result, since caller is clearly not expecting one */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"function %u returned NULL"</literal></expr></argument>, <argument><expr><name><name>flinfo</name><operator>.</operator><name>fn_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>cmd_descr_data</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sql</name> <operator>=</operator> <call><name>deparse_func_call</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cmd_descr_data</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>params</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>cmd_descriptors</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>cmd_descriptors</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cmd_descr_data</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ts_dist_multi_cmds_params_invoke_on_data_nodes</name><argument_list>(<argument><expr><name>cmd_descriptors</name></expr></argument>, <argument><expr><name>data_node_list</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ts_dist_cmd_close_response</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>invalidation_store_free</name><parameter_list>(<parameter><decl><type><name>InvalidationStore</name> <modifier>*</modifier></type><name>store</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>FreeTupleDesc</name><argument_list>(<argument><expr><name><name>store</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>tuplestore_end</name><argument_list>(<argument><expr><name><name>store</name><operator>-&gt;</operator><name>tupstore</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>store</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
