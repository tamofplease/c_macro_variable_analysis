<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/psycopg2/psycopg/pqpath.c"><comment type="block">/* pqpath.c - single path into libpq
 *
 * Copyright (C) 2003-2019 Federico Di Gregorio &lt;fog@debian.org&gt;
 * Copyright (C) 2020-2021 The Psycopg Team
 *
 * This file is part of psycopg.
 *
 * psycopg2 is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition, as a special exception, the copyright holders give
 * permission to link this program with the OpenSSL library (or with
 * modified versions of OpenSSL that use the same license as OpenSSL),
 * and distribute linked combinations including the two.
 *
 * You must obey the GNU Lesser General Public License in all respects for
 * all of the code used other than OpenSSL.
 *
 * psycopg2 is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
 * License for more details.
 */</comment>

<comment type="block">/* IMPORTANT NOTE: no function in this file do its own connection locking
   except for pg_execute and pq_fetch (that are somehow high-level). This means
   that all the other functions should be called while holding a lock to the
   connection.
*/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PSYCOPG_MODULE</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"psycopg/psycopg.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"psycopg/pqpath.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"psycopg/connection.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"psycopg/cursor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"psycopg/replication_cursor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"psycopg/replication_message.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"psycopg/green.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"psycopg/typecast.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"psycopg/pgtypes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"psycopg/error.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"psycopg/column.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"psycopg/libpq_support.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-fe.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
<comment type="block">/* select() */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;winsock2.h&gt;</cpp:file></cpp:include>
<comment type="block">/* gettimeofday() */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"win32_support.h"</cpp:file></cpp:include>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__sun</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__SVR4</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"solaris_support.h"</cpp:file></cpp:include>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_AIX</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"aix_support.h"</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>extern</specifier> <name>HIDDEN</name> <name>PyObject</name> <modifier>*</modifier></type><name>psyco_DescriptionType</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>HIDDEN</name> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>srv_isolevels</name><index>[]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>HIDDEN</name> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>srv_readonly</name><index>[]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>HIDDEN</name> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>srv_deferrable</name><index>[]</index></name></decl>;</decl_stmt>

<comment type="block">/* Strip off the severity from a Postgres error message. */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>strip_severity</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>msg</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">8</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><literal type="string">"ERROR:  "</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call> <operator>||</operator>
                            <operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><literal type="string">"FATAL:  "</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call> <operator>||</operator>
                            <operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><literal type="string">"PANIC:  "</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>&amp;</operator><name><name>msg</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr>;</return></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><name>msg</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/* pq_raise - raise a python exception of the right kind

   This function should be called while holding the GIL.

   The function passes the ownership of the pgres to the returned exception,
   where the pgres was the explicit argument or taken from the cursor.
   So, after calling it curs-&gt;pgres will be set to null */</comment>

<function><type><name>RAISES</name> <specifier>static</specifier> <name>void</name></type>
<name>pq_raise</name><parameter_list>(<parameter><decl><type><name>connectionObject</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>cursorObject</name> <modifier>*</modifier></type><name>curs</name></decl></parameter>, <parameter><decl><type><name>PGresult</name> <modifier>*</modifier><modifier>*</modifier></type><name>pgres</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>exc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>err</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>err2</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>code</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>pyerr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>pgerror</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pgcode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>conn</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>DatabaseError</name></expr></argument>,
            <argument><expr><literal type="string">"psycopg went psychotic and raised a null error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* if the connection has somehow been broken, we mark the connection
       object as closed but requiring cleanup */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>pgconn</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>PQstatus</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CONNECTION_BAD</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>closed</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>exc</name> <operator>=</operator> <name>OperationalError</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>pgres</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>curs</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>pgres</name> <operator>=</operator> <operator>&amp;</operator><name><name>curs</name><operator>-&gt;</operator><name>pgres</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>pgres</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>pgres</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>PQresultErrorMessage</name><argument_list>(<argument><expr><operator>*</operator><name>pgres</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>err</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"pq_raise: PQresultErrorMessage: err=%s"</literal></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>PQresultErrorField</name><argument_list>(<argument><expr><operator>*</operator><name>pgres</name></expr></argument>, <argument><expr><name>PG_DIAG_SQLSTATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>err</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"pq_raise: PQerrorMessage: err=%s"</literal></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* if the is no error message we probably called pq_raise without reason:
       we need to set an exception anyway because the caller will probably
       raise and a meaningful message is better than an empty one.
       Note: it can happen without it being our error: see ticket #82 */</comment>
    <if_stmt><if>if <condition>(<expr><name>err</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>err</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>DatabaseError</name></expr></argument>,
            <argument><expr><literal type="string">"error with status %s and no message from the libpq"</literal></expr></argument>,
            <argument><expr><call><name>PQresStatus</name><argument_list>(<argument><expr><ternary><condition><expr><name>pgres</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then>
                <expr><call><name>PQstatus</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><operator>*</operator><name>pgres</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Analyze the message and try to deduce the right exception kind
       (only if we got the SQLSTATE from the pgres, obviously) */</comment>
    <if_stmt><if>if <condition>(<expr><name>code</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>exc</name> <operator>=</operator> <call><name>exception_from_sqlstate</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>exc</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Fallback if there is no exception code (unless we already
           determined that the connection was closed). */</comment>
        <expr_stmt><expr><name>exc</name> <operator>=</operator> <name>DatabaseError</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* try to remove the initial "ERROR: " part from the postgresql error */</comment>
    <expr_stmt><expr><name>err2</name> <operator>=</operator> <call><name>strip_severity</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"pq_raise: err2=%s"</literal></expr></argument>, <argument><expr><name>err2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* decode now the details of the error, because after psyco_set_error
     * decoding will fail.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>pgerror</name> <operator>=</operator> <call><name>conn_text_from_chars</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
        <comment type="block">/* we can't really handle an exception while handling this error
         * so just print it. */</comment>
        <expr_stmt><expr><call><name>PyErr_Print</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>pgcode</name> <operator>=</operator> <call><name>conn_text_from_chars</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>code</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>PyErr_Print</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>pyerr</name> <operator>=</operator> <call><name>psyco_set_error</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>curs</name></expr></argument>, <argument><expr><name>err2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>pyerr</name> <operator>&amp;&amp;</operator> <call><name>PyObject_TypeCheck</name><argument_list>(<argument><expr><name>pyerr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>errorType</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>errorObject</name> <modifier>*</modifier></type><name>perr</name> <init>= <expr><operator>(</operator><name>errorObject</name> <operator>*</operator><operator>)</operator><name>pyerr</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>perr</name><operator>-&gt;</operator><name>pydecoder</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pydecoder</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>perr</name><operator>-&gt;</operator><name>pydecoder</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>pydecoder</name></name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>perr</name><operator>-&gt;</operator><name>pgerror</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>perr</name><operator>-&gt;</operator><name>pgerror</name></name> <operator>=</operator> <name>pgerror</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pgerror</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>perr</name><operator>-&gt;</operator><name>pgcode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>perr</name><operator>-&gt;</operator><name>pgcode</name></name> <operator>=</operator> <name>pgcode</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pgcode</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>CLEARPGRES</name><argument_list>(<argument><expr><name><name>perr</name><operator>-&gt;</operator><name>pgres</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>pgres</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>pgres</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>perr</name><operator>-&gt;</operator><name>pgres</name></name> <operator>=</operator> <operator>*</operator><name>pgres</name></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>pgres</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>pgerror</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>pgcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* pq_clear_async - clear the effects of a previous async query

   note that this function does block because it needs to wait for the full
   result sets of the previous query to clear them.

   this function does not call any Py_*_ALLOW_THREADS macros */</comment>

<function><type><name>void</name></type>
<name>pq_clear_async</name><parameter_list>(<parameter><decl><type><name>connectionObject</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>pgres</name></decl>;</decl_stmt>

    <comment type="block">/* this will get all pending results (if the submitted query consisted of
       many parts, i.e. "select 1; select 2", there will be many) and also
       finalize asynchronous processing so the connection will be ready to
       accept another query */</comment>

    <while>while <condition>(<expr><operator>(</operator><name>pgres</name> <operator>=</operator> <call><name>PQgetResult</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"pq_clear_async: clearing PGresult at %p"</literal></expr></argument>, <argument><expr><name>pgres</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>pgres</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>async_cursor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* pq_set_non_blocking - set the nonblocking status on a connection.

   Accepted arg values are 1 (nonblocking) and 0 (blocking).

   Return 0 if everything ok, else &lt; 0 and set an exception.
 */</comment>
<function><type><name>RAISES_NEG</name> <name>int</name></type>
<name>pq_set_non_blocking</name><parameter_list>(<parameter><decl><type><name>connectionObject</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>PQsetnonblocking</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>!=</operator> <name>ret</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"PQsetnonblocking(%d) FAILED"</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>OperationalError</name></expr></argument>, <argument><expr><literal type="string">"PQsetnonblocking() failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* pg_execute_command_locked - execute a no-result query on a locked connection.

   This function should only be called on a locked connection without
   holding the global interpreter lock.

   On error, -1 is returned, and the conn-&gt;pgres will hold the
   relevant result structure.

   The tstate parameter should be the pointer of the _save variable created by
   Py_BEGIN_ALLOW_THREADS: this enables the function to acquire and release
   again the GIL if needed, i.e. if a Python wait callback must be invoked.
 */</comment>
<function><type><name>int</name></type>
<name>pq_execute_command_locked</name><parameter_list>(
    <parameter><decl><type><name>connectionObject</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>PyThreadState</name> <modifier>*</modifier><modifier>*</modifier></type><name>tstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>pgstatus</name></decl>, <decl><type ref="prev"/><name>retvalue</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"pq_execute_command_locked: pgconn = %p, query = %s"</literal></expr></argument>,
            <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>psyco_green</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>conn_set_result</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><call><name>PQexec</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>PyEval_RestoreThread</name><argument_list>(<argument><expr><operator>*</operator><name>tstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>conn_set_result</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><call><name>psyco_exec_green</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>tstate</name> <operator>=</operator> <call><name>PyEval_SaveThread</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>pgres</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"pq_execute_command_locked: PQexec returned NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PyEval_RestoreThread</name><argument_list>(<argument><expr><operator>*</operator><name>tstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>conn_set_error</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><operator>*</operator><name>tstate</name> <operator>=</operator> <call><name>PyEval_SaveThread</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>cleanup</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>pgstatus</name> <operator>=</operator> <call><name>PQresultStatus</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgres</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>pgstatus</name> <operator>!=</operator> <name>PGRES_COMMAND_OK</name></expr> )</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"pq_execute_command_locked: result was not COMMAND_OK (%d)"</literal></expr></argument>,
                <argument><expr><name>pgstatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>cleanup</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>retvalue</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CLEARPGRES</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgres</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>cleanup</name>:</label>
    <return>return <expr><name>retvalue</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* pq_complete_error: handle an error from pq_execute_command_locked()

   If pq_execute_command_locked() returns -1, this function should be
   called to convert the result to a Python exception.

   This function should be called while holding the global interpreter
   lock.
 */</comment>
<function><type><name>RAISES</name> <name>void</name></type>
<name>pq_complete_error</name><parameter_list>(<parameter><decl><type><name>connectionObject</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"pq_complete_error: pgconn = %p, error = %s"</literal></expr></argument>,
            <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>error</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>pgres</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>pq_raise</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>pgres</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* now conn-&gt;pgres is null */</comment>
    </block_content>}</block></if>
    <else>else <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>error</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>OperationalError</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>error</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <comment type="block">/* There was a Python error (e.g. in the callback). Don't clobber
             * it with an unknown exception. (see #410) */</comment>
            <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"pq_complete_error: forwarding Python exception"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>OperationalError</name></expr></argument>, <argument><expr><literal type="string">"unknown error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <comment type="block">/* Trivia: with a broken socket connection PQexec returns NULL, so we
         * end up here. With a TCP connection we get a pgres with an error
         * instead, and the connection gets closed in the pq_raise call above
         * (see ticket #196)
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>CONNECTION_BAD</name> <operator>==</operator> <call><name>PQstatus</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>closed</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>conn_set_error</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* pq_begin_locked - begin a transaction, if necessary

   This function should only be called on a locked connection without
   holding the global interpreter lock.

   On error, -1 is returned, and the conn-&gt;pgres argument will hold the
   relevant result structure.
 */</comment>
<function><type><name>int</name></type>
<name>pq_begin_locked</name><parameter_list>(<parameter><decl><type><name>connectionObject</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>PyThreadState</name> <modifier>*</modifier><modifier>*</modifier></type><name>tstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>bufsize</name> <init>= <expr><literal type="number">256</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>  <comment type="block">/* buf size must be same as bufsize */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"pq_begin_locked: pgconn = %p, %d, status = %d"</literal></expr></argument>,
            <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>autocommit</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <name>CONN_STATUS_READY</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"pq_begin_locked: transaction in progress"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>autocommit</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>entered</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"pq_begin_locked: autocommit and no with block"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>isolevel</name></name> <operator>==</operator> <name>ISOLATION_LEVEL_DEFAULT</name>
            <operator>&amp;&amp;</operator> <name><name>conn</name><operator>-&gt;</operator><name>readonly</name></name> <operator>==</operator> <name>STATE_DEFAULT</name>
            <operator>&amp;&amp;</operator> <name><name>conn</name><operator>-&gt;</operator><name>deferrable</name></name> <operator>==</operator> <name>STATE_DEFAULT</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"BEGIN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>,
            <argument><expr><ternary><condition><expr><name><name>conn</name><operator>-&gt;</operator><name>server_version</name></name> <operator>&gt;=</operator> <literal type="number">80000</literal></expr> ?</condition><then>
                <expr><literal type="string">"BEGIN%s%s%s%s"</literal></expr> </then><else>: <expr><literal type="string">"BEGIN;SET TRANSACTION%s%s%s%s"</literal></expr></else></ternary></expr></argument>,
            <argument><expr><ternary><condition><expr><operator>(</operator><name><name>conn</name><operator>-&gt;</operator><name>isolevel</name></name> <operator>&gt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>conn</name><operator>-&gt;</operator><name>isolevel</name></name> <operator>&lt;=</operator> <literal type="number">4</literal><operator>)</operator></expr>
                ?</condition><then> <expr><literal type="string">" ISOLATION LEVEL "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
            <argument><expr><ternary><condition><expr><operator>(</operator><name><name>conn</name><operator>-&gt;</operator><name>isolevel</name></name> <operator>&gt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>conn</name><operator>-&gt;</operator><name>isolevel</name></name> <operator>&lt;=</operator> <literal type="number">4</literal><operator>)</operator></expr>
                ?</condition><then> <expr><name><name>srv_isolevels</name><index>[<expr><name><name>conn</name><operator>-&gt;</operator><name>isolevel</name></name></expr>]</index></name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
            <argument><expr><name><name>srv_readonly</name><index>[<expr><name><name>conn</name><operator>-&gt;</operator><name>readonly</name></name></expr>]</index></name></expr></argument>,
            <argument><expr><name><name>srv_deferrable</name><index>[<expr><name><name>conn</name><operator>-&gt;</operator><name>deferrable</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pq_execute_command_locked</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>tstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONN_STATUS_BEGIN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* pq_commit - send an END, if necessary

   This function should be called while holding the global interpreter
   lock.
*/</comment>

<function><type><name>int</name></type>
<name>pq_commit</name><parameter_list>(<parameter><decl><type><name>connectionObject</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>retvalue</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>Py_BEGIN_ALLOW_THREADS</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"pq_commit: pgconn = %p, status = %d"</literal></expr></argument>,
            <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <name>CONN_STATUS_BEGIN</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"pq_commit: no transaction to commit"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>retvalue</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else <block>{<block_content>
        <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>mark</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>retvalue</name> <operator>=</operator> <call><name>pq_execute_command_locked</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"COMMIT"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>_save</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name>Py_BLOCK_THREADS</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>conn_notice_process</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>Py_UNBLOCK_THREADS</name></expr>;</expr_stmt>

    <comment type="block">/* Even if an error occurred, the connection will be rolled back,
       so we unconditionally set the connection status here. */</comment>
    <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONN_STATUS_READY</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>Py_END_ALLOW_THREADS</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>retvalue</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pq_complete_error</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>retvalue</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>RAISES_NEG</name> <name>int</name></type>
<name>pq_abort_locked</name><parameter_list>(<parameter><decl><type><name>connectionObject</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>PyThreadState</name> <modifier>*</modifier><modifier>*</modifier></type><name>tstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>retvalue</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"pq_abort_locked: pgconn = %p, status = %d"</literal></expr></argument>,
            <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <name>CONN_STATUS_BEGIN</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"pq_abort_locked: no transaction to abort"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>mark</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>retvalue</name> <operator>=</operator> <call><name>pq_execute_command_locked</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"ROLLBACK"</literal></expr></argument>, <argument><expr><name>tstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>retvalue</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONN_STATUS_READY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>retvalue</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* pq_abort - send an ABORT, if necessary

   This function should be called while holding the global interpreter
   lock. */</comment>

<function><type><name>RAISES_NEG</name> <name>int</name></type>
<name>pq_abort</name><parameter_list>(<parameter><decl><type><name>connectionObject</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>retvalue</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"pq_abort: pgconn = %p, autocommit = %d, status = %d"</literal></expr></argument>,
            <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>autocommit</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>Py_BEGIN_ALLOW_THREADS</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>retvalue</name> <operator>=</operator> <call><name>pq_abort_locked</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>_save</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>Py_BLOCK_THREADS</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>conn_notice_process</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>Py_UNBLOCK_THREADS</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>Py_END_ALLOW_THREADS</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>retvalue</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pq_complete_error</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>retvalue</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* pq_reset - reset the connection

   This function should be called while holding the global interpreter
   lock.

   The _locked version of this function should be called on a locked
   connection without holding the global interpreter lock.
*/</comment>

<function><type><name>RAISES_NEG</name> <name>int</name></type>
<name>pq_reset_locked</name><parameter_list>(<parameter><decl><type><name>connectionObject</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>PyThreadState</name> <modifier>*</modifier><modifier>*</modifier></type><name>tstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>retvalue</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"pq_reset_locked: pgconn = %p, status = %d"</literal></expr></argument>,
            <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>mark</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>CONN_STATUS_BEGIN</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>retvalue</name> <operator>=</operator> <call><name>pq_execute_command_locked</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"ABORT"</literal></expr></argument>, <argument><expr><name>tstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>retvalue</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>retvalue</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>server_version</name></name> <operator>&gt;=</operator> <literal type="number">80300</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>retvalue</name> <operator>=</operator> <call><name>pq_execute_command_locked</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"DISCARD ALL"</literal></expr></argument>, <argument><expr><name>tstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>retvalue</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>retvalue</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <else>else <block>{<block_content>
        <expr_stmt><expr><name>retvalue</name> <operator>=</operator> <call><name>pq_execute_command_locked</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"RESET ALL"</literal></expr></argument>, <argument><expr><name>tstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>retvalue</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>retvalue</name></expr>;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>retvalue</name> <operator>=</operator> <call><name>pq_execute_command_locked</name><argument_list>(<argument><expr><name>conn</name></expr></argument>,
            <argument><expr><literal type="string">"SET SESSION AUTHORIZATION DEFAULT"</literal></expr></argument>, <argument><expr><name>tstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>retvalue</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>retvalue</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* should set the tpc xid to null: postponed until we get the GIL again */</comment>
    <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONN_STATUS_READY</name></expr>;</expr_stmt>

    <return>return <expr><name>retvalue</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pq_reset</name><parameter_list>(<parameter><decl><type><name>connectionObject</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>retvalue</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"pq_reset: pgconn = %p, autocommit = %d, status = %d"</literal></expr></argument>,
            <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>autocommit</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>Py_BEGIN_ALLOW_THREADS</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>retvalue</name> <operator>=</operator> <call><name>pq_reset_locked</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>_save</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>Py_BLOCK_THREADS</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>conn_notice_process</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>Py_UNBLOCK_THREADS</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>Py_END_ALLOW_THREADS</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>retvalue</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>pq_complete_error</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>tpc_xid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><name>retvalue</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Get a session parameter.
 *
 * The function should be called on a locked connection without
 * holding the GIL.
 *
 * The result is a new string allocated with malloc.
 */</comment>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>pq_get_guc_locked</name><parameter_list>(<parameter><decl><type><name>connectionObject</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>param</name></decl></parameter>, <parameter><decl><type><name>PyThreadState</name> <modifier>*</modifier><modifier>*</modifier></type><name>tstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>query</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>rv</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"pq_get_guc_locked: reading %s"</literal></expr></argument>, <argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"SHOW %s"</literal></expr></argument>, <argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>size</name> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>conn_set_error</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"SHOW: query too large"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>cleanup</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"pq_get_guc_locked: pgconn = %p, query = %s"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>psyco_green</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>conn_set_result</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><call><name>PQexec</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>PyEval_RestoreThread</name><argument_list>(<argument><expr><operator>*</operator><name>tstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>conn_set_result</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><call><name>psyco_exec_green</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>tstate</name> <operator>=</operator> <call><name>PyEval_SaveThread</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>pgres</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"pq_get_guc_locked: PQexec returned NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PyEval_RestoreThread</name><argument_list>(<argument><expr><operator>*</operator><name>tstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>conn_set_error</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><operator>*</operator><name>tstate</name> <operator>=</operator> <call><name>PyEval_SaveThread</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>cleanup</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgres</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_TUPLES_OK</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"pq_get_guc_locked: result was not TUPLES_OK (%s)"</literal></expr></argument>,
                <argument><expr><call><name>PQresStatus</name><argument_list>(<argument><expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgres</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>cleanup</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgres</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CLEARPGRES</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgres</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>cleanup</name>:</label>
    <return>return <expr><name>rv</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Set a session parameter.
 *
 * The function should be called on a locked connection without
 * holding the GIL
 */</comment>

<function><type><name>int</name></type>
<name>pq_set_guc_locked</name><parameter_list>(
    <parameter><decl><type><name>connectionObject</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>param</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>,
    <parameter><decl><type><name>PyThreadState</name> <modifier>*</modifier><modifier>*</modifier></type><name>tstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>query</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rv</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"pq_set_guc_locked: setting %s to %s"</literal></expr></argument>, <argument><expr><name>param</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="string">"default"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></sizeof></expr></argument>,
            <argument><expr><literal type="string">"SET %s TO DEFAULT"</literal></expr></argument>, <argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else <block>{<block_content>
        <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></sizeof></expr></argument>,
            <argument><expr><literal type="string">"SET %s TO '%s'"</literal></expr></argument>, <argument><expr><name>param</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>size</name> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>conn_set_error</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"SET: query too large"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>exit</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>pq_execute_command_locked</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>tstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>exit</name>:</label>
    <return>return <expr><name>rv</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Call one of the PostgreSQL tpc-related commands.
 *
 * This function should only be called on a locked connection without
 * holding the global interpreter lock. */</comment>

<function><type><name>int</name></type>
<name>pq_tpc_command_locked</name><parameter_list>(
    <parameter><decl><type><name>connectionObject</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tid</name></decl></parameter>,
    <parameter><decl><type><name>PyThreadState</name> <modifier>*</modifier><modifier>*</modifier></type><name>tstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rv</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>etid</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>buf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>buflen</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"_pq_tpc_command: pgconn = %p, command = %s"</literal></expr></argument>,
            <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>mark</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PyEval_RestoreThread</name><argument_list>(<argument><expr><operator>*</operator><name>tstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* convert the xid into the postgres transaction_id and quote it. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>etid</name> <operator>=</operator> <call><name>psyco_escape_string</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
    <block>{<block_content> <goto>goto <name>exit</name>;</goto> </block_content>}</block></if></if_stmt>

    <comment type="block">/* prepare the command to the server */</comment>
    <expr_stmt><expr><name>buflen</name> <operator>=</operator> <literal type="number">2</literal> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>etid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* add space, zero */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>buf</name> <operator>=</operator> <call><name>PyMem_Malloc</name><argument_list>(<argument><expr><name>buflen</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>exit</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&gt;</operator> <call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>, <argument><expr><literal type="string">"%s %s"</literal></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>etid</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> <goto>goto <name>exit</name>;</goto> </block_content>}</block></if></if_stmt>

    <comment type="block">/* run the command and let it handle the error cases */</comment>
    <expr_stmt><expr><operator>*</operator><name>tstate</name> <operator>=</operator> <call><name>PyEval_SaveThread</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>pq_execute_command_locked</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>tstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PyEval_RestoreThread</name><argument_list>(<argument><expr><operator>*</operator><name>tstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>exit</name>:</label>
    <expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>etid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><operator>*</operator><name>tstate</name> <operator>=</operator> <call><name>PyEval_SaveThread</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>rv</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* pq_get_result_async - read an available result without blocking.
 *
 * Return 0 if the result is ready, 1 if it will block, -1 on error.
 * The last result will be returned in conn-&gt;pgres.
 *
 * The function should be called with the lock and holding the GIL.
 */</comment>

<function><type><name>RAISES_NEG</name> <name>int</name></type>
<name>pq_get_result_async</name><parameter_list>(<parameter><decl><type><name>connectionObject</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rv</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"pq_get_result_async: calling PQconsumeInput()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>PQconsumeInput</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"pq_get_result_async: PQconsumeInput() failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* if the libpq says pgconn is lost, close the py conn */</comment>
        <if_stmt><if>if <condition>(<expr><name>CONNECTION_BAD</name> <operator>==</operator> <call><name>PQstatus</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>closed</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>OperationalError</name></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>exit</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>conn_notifies_process</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>conn_notice_process</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>busy</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ExecStatusType</name></type> <name>status</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"pq_get_result_async: calling PQisBusy()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>busy</name> <operator>=</operator> <call><name>PQisBusy</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>busy</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* try later */</comment>
            <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"pq_get_result_async: PQisBusy() = 1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>rv</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <goto>goto <name>exit</name>;</goto>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>res</name> <operator>=</operator> <call><name>PQgetResult</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"pq_get_result_async: got no result"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* the result is ready: it was the previously read one */</comment>
            <expr_stmt><expr><name>rv</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <goto>goto <name>exit</name>;</goto>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"pq_get_result_async: got result %s"</literal></expr></argument>, <argument><expr><call><name>PQresStatus</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Store the result outside because we want to return the last non-null
         * one and we may have to do it across poll calls. However if there is
         * an error in the stream of results we want to handle the *first*
         * error. So don't clobber it with the following ones. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>pgres</name></name> <operator>&amp;&amp;</operator> <call><name>PQresultStatus</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgres</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PGRES_FATAL_ERROR</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"previous pgres is error: discarding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>conn_set_result</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <switch>switch <condition>(<expr><name>status</name></expr>)</condition> <block>{<block_content>
            <case>case <expr><name>PGRES_COPY_OUT</name></expr>:</case>
            <case>case <expr><name>PGRES_COPY_IN</name></expr>:</case>
            <case>case <expr><name>PGRES_COPY_BOTH</name></expr>:</case>
                <comment type="block">/* After entering copy mode, libpq will make a phony
                 * PGresult for us every time we query for it, so we need to
                 * break out of this endless loop. */</comment>
                <expr_stmt><expr><name>rv</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <goto>goto <name>exit</name>;</goto>

            <default>default:</default>
                <comment type="block">/* keep on reading to check if there are other results or
                 * we have finished. */</comment>
                <continue>continue;</continue>
        </block_content>}</block></switch>
    </block_content>}</block></for>

<label><name>exit</name>:</label>
    <return>return <expr><name>rv</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* pq_flush - flush output and return connection status

   a status of 1 means that a some data is still pending to be flushed, while a
   status of 0 means that there is no data waiting to be sent. -1 means an
   error and an exception will be set accordingly.

   this function locks the connection object
   this function call Py_*_ALLOW_THREADS macros */</comment>

<function><type><name>int</name></type>
<name>pq_flush</name><parameter_list>(<parameter><decl><type><name>connectionObject</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"pq_flush: flushing output"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>Py_BEGIN_ALLOW_THREADS</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>conn</name><operator>-&gt;</operator><name>lock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQflush</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>conn</name><operator>-&gt;</operator><name>lock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>Py_END_ALLOW_THREADS</name></expr>;</expr_stmt>

    <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* pq_execute - execute a query, possibly asynchronously
 *
 * With no_result an eventual query result is discarded.
 * Currently only used to implement cursor.executemany().
 *
 * This function locks the connection object
 * This function call Py_*_ALLOW_THREADS macros
*/</comment>

<function><type><name>RAISES_NEG</name> <name>int</name></type>
<name>_pq_execute_sync</name><parameter_list>(<parameter><decl><type><name>cursorObject</name> <modifier>*</modifier></type><name>curs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>no_result</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>no_begin</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>connectionObject</name> <modifier>*</modifier></type><name>conn</name> <init>= <expr><name><name>curs</name><operator>-&gt;</operator><name>conn</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>CLEARPGRES</name><argument_list>(<argument><expr><name><name>curs</name><operator>-&gt;</operator><name>pgres</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>Py_BEGIN_ALLOW_THREADS</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>conn</name><operator>-&gt;</operator><name>lock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>no_begin</name> <operator>&amp;&amp;</operator> <call><name>pq_begin_locked</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>_save</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>conn</name><operator>-&gt;</operator><name>lock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>Py_BLOCK_THREADS</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pq_complete_error</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"pq_execute: executing SYNC query: pgconn = %p"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"    %-.200s"</literal></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>psyco_green</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>conn_set_result</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><call><name>PQexec</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else <block>{<block_content>
        <expr_stmt><expr><name>Py_BLOCK_THREADS</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>conn_set_result</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><call><name>psyco_exec_green</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>Py_UNBLOCK_THREADS</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* don't let pgres = NULL go to pq_fetch() */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>pgres</name></name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>CONNECTION_BAD</name> <operator>==</operator> <call><name>PQstatus</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>closed</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>conn</name><operator>-&gt;</operator><name>lock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>Py_BLOCK_THREADS</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>OperationalError</name></expr></argument>,
                            <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>Py_BLOCK_THREADS</name></expr>;</expr_stmt>

    <comment type="block">/* assign the result back to the cursor now that we have the GIL */</comment>
    <expr_stmt><expr><call><name>curs_set_result</name><argument_list>(<argument><expr><name>curs</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgres</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>pgres</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/* Process notifies here instead of when fetching the tuple as we are
     * into the same critical section that received the data. Without this
     * care, reading notifies may disrupt other thread communications.
     * (as in ticket #55). */</comment>
    <expr_stmt><expr><call><name>conn_notifies_process</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>conn_notice_process</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>Py_UNBLOCK_THREADS</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>conn</name><operator>-&gt;</operator><name>lock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>Py_END_ALLOW_THREADS</name></expr>;</expr_stmt>

    <comment type="block">/* if the execute was sync, we call pq_fetch() immediately,
       to respect the old DBAPI-2.0 compatible behaviour */</comment>
    <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"pq_execute: entering synchronous DBAPI compatibility mode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>pq_fetch</name><argument_list>(<argument><expr><name>curs</name></expr></argument>, <argument><expr><name>no_result</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>RAISES_NEG</name> <name>int</name></type>
<name>_pq_execute_async</name><parameter_list>(<parameter><decl><type><name>cursorObject</name> <modifier>*</modifier></type><name>curs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>no_result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>async_status</name> <init>= <expr><name>ASYNC_WRITE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>connectionObject</name> <modifier>*</modifier></type><name>conn</name> <init>= <expr><name><name>curs</name><operator>-&gt;</operator><name>conn</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>CLEARPGRES</name><argument_list>(<argument><expr><name><name>curs</name><operator>-&gt;</operator><name>pgres</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>Py_BEGIN_ALLOW_THREADS</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>conn</name><operator>-&gt;</operator><name>lock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"pq_execute: executing ASYNC query: pgconn = %p"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"    %-.200s"</literal></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>PQsendQuery</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>CONNECTION_BAD</name> <operator>==</operator> <call><name>PQstatus</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>closed</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>conn</name><operator>-&gt;</operator><name>lock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>Py_BLOCK_THREADS</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>OperationalError</name></expr></argument>,
                        <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"pq_execute: async query sent to backend"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>PQflush</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* the query got fully sent to the server */</comment>
        <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"pq_execute: query got flushed immediately"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* the async status will be ASYNC_READ */</comment>
        <expr_stmt><expr><name>async_status</name> <operator>=</operator> <name>ASYNC_READ</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>ret</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* not all of the query got sent to the server */</comment>
        <expr_stmt><expr><name>async_status</name> <operator>=</operator> <name>ASYNC_WRITE</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else <block>{<block_content>
        <comment type="block">/* there was an error */</comment>
        <expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>conn</name><operator>-&gt;</operator><name>lock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>Py_BLOCK_THREADS</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>OperationalError</name></expr></argument>,
                        <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>conn</name><operator>-&gt;</operator><name>lock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>Py_END_ALLOW_THREADS</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>async_status</name></name> <operator>=</operator> <name>async_status</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>conn</name><operator>-&gt;</operator><name>async_cursor</name></name>
            <operator>=</operator> <call><name>PyWeakref_NewRef</name><argument_list>(<argument><expr><operator>(</operator><name>PyObject</name> <operator>*</operator><operator>)</operator><name>curs</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>RAISES_NEG</name> <name>int</name></type>
<name>pq_execute</name><parameter_list>(<parameter><decl><type><name>cursorObject</name> <modifier>*</modifier></type><name>curs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>async</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>no_result</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>no_begin</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* check status of connection, raise error if not OK */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PQstatus</name><argument_list>(<argument><expr><name><name>curs</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CONNECTION_OK</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"pq_execute: connection NOT OK"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>OperationalError</name></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>curs</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"pq_execute: pg connection at %p OK"</literal></expr></argument>, <argument><expr><name><name>curs</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>async</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name>_pq_execute_sync</name><argument_list>(<argument><expr><name>curs</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>no_result</name></expr></argument>, <argument><expr><name>no_begin</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <return>return <expr><call><name>_pq_execute_async</name><argument_list>(<argument><expr><name>curs</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>no_result</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/* send an async query to the backend.
 *
 * Return 1 if command succeeded, else 0.
 *
 * The function should be called helding the connection lock and the GIL.
 */</comment>
<function><type><name>int</name></type>
<name>pq_send_query</name><parameter_list>(<parameter><decl><type><name>connectionObject</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"pq_send_query: sending ASYNC query:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"    %-.200s"</literal></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>CLEARPGRES</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgres</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <operator>(</operator><name>rv</name> <operator>=</operator> <call><name>PQsendQuery</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"pq_send_query: error: %s"</literal></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>rv</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* pq_fetch - fetch data after a query

   this function locks the connection object
   this function call Py_*_ALLOW_THREADS macros

   return value:
     -1 - some error occurred while calling libpq
      0 - no result from the backend but no libpq errors
      1 - result from backend (possibly data is ready)
*/</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> <modifier>*</modifier></type>
<name>_get_cast</name><parameter_list>(<parameter><decl><type><name>cursorObject</name> <modifier>*</modifier></type><name>curs</name></decl></parameter>, <parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>pgres</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* fill the right cast function by accessing three different dictionaries:
       - the per-cursor dictionary, if available (can be NULL or None)
       - the per-connection dictionary (always exists but can be null)
       - the global dictionary (at module level)
       if we get no defined cast use the default one */</comment>
    <decl_stmt><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>type</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>cast</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>rv</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>Oid</name></type> <name>ftype</name> <init>= <expr><call><name>PQftype</name><argument_list>(<argument><expr><name>pgres</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>type</name> <operator>=</operator> <call><name>PyLong_FromOid</name><argument_list>(<argument><expr><name>ftype</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content> <goto>goto <name>exit</name>;</goto> </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"_pq_fetch_tuples: looking for cast %u:"</literal></expr></argument>, <argument><expr><name>ftype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>cast</name> <operator>=</operator> <call><name>curs_get_cast</name><argument_list>(<argument><expr><name>curs</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content> <goto>goto <name>exit</name>;</goto> </block_content>}</block></if></if_stmt>

    <comment type="block">/* else if we got binary tuples and if we got a field that
       is binary use the default cast
       FIXME: what the hell am I trying to do here? This just can't work..
    */</comment>
    <if_stmt><if>if <condition>(<expr><name>cast</name> <operator>==</operator> <name>psyco_default_binary_cast</name> <operator>&amp;&amp;</operator> <call><name>PQbinaryTuples</name><argument_list>(<argument><expr><name>pgres</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"_pq_fetch_tuples: Binary cursor and "</literal>
                <literal type="string">"binary field: %u using default cast"</literal></expr></argument>, <argument><expr><name>ftype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>cast</name> <operator>=</operator> <name>psyco_default_cast</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"_pq_fetch_tuples: using cast at %p for type %u"</literal></expr></argument>, <argument><expr><name>cast</name></expr></argument>, <argument><expr><name>ftype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* success */</comment>
    <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>cast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rv</name> <operator>=</operator> <name>cast</name></expr>;</expr_stmt>

<label><name>exit</name>:</label>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>rv</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> <modifier>*</modifier></type>
<name>_make_column</name><parameter_list>(<parameter><decl><type><name>connectionObject</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>pgres</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type> <name>ftype</name> <init>= <expr><call><name>PQftype</name><argument_list>(<argument><expr><name>pgres</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>fsize</name> <init>= <expr><call><name>PQfsize</name><argument_list>(<argument><expr><name>pgres</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>fmod</name> <init>=  <expr><call><name>PQfmod</name><argument_list>(<argument><expr><name>pgres</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type> <name>ftable</name> <init>= <expr><call><name>PQftable</name><argument_list>(<argument><expr><name>pgres</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ftablecol</name> <init>= <expr><call><name>PQftablecol</name><argument_list>(<argument><expr><name>pgres</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>columnObject</name> <modifier>*</modifier></type><name>column</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>rv</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>column</name> <operator>=</operator> <operator>(</operator><name>columnObject</name> <operator>*</operator><operator>)</operator><call><name>PyObject_CallObject</name><argument_list>(
            <argument><expr><operator>(</operator><name>PyObject</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>columnType</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
        <goto>goto <name>exit</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* fill the type and name fields */</comment>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>tmp</name> <operator>=</operator> <call><name>PyLong_FromOid</name><argument_list>(<argument><expr><name>ftype</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
            <goto>goto <name>exit</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>type_code</name></name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
    </block_content>}</block>

    <block>{<block_content>
        <decl_stmt><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>tmp</name> <operator>=</operator> <call><name>conn_text_from_chars</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><call><name>PQfname</name><argument_list>(<argument><expr><name>pgres</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
            <goto>goto <name>exit</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/* display size is the maximum size of this field result tuples. */</comment>
    <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>display_size</name></name> <operator>=</operator> <name>Py_None</name></expr>;</expr_stmt>

    <comment type="block">/* size on the backend */</comment>
    <if_stmt><if>if <condition>(<expr><name>fmod</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>fmod</name> <operator>=</operator> <name>fmod</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>fsize</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>ftype</name> <operator>==</operator> <name>NUMERICOID</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>tmp</name> <operator>=</operator> <call><name>PyInt_FromLong</name><argument_list>(<argument><expr><operator>(</operator><name>fmod</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content> <goto>goto <name>exit</name>;</goto> </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>internal_size</name></name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else <block>{<block_content> <comment type="block">/* If variable length record, return maximum size */</comment>
            <decl_stmt><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>tmp</name> <operator>=</operator> <call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>fmod</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content> <goto>goto <name>exit</name>;</goto> </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>internal_size</name></name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <else>else <block>{<block_content>
        <decl_stmt><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>tmp</name> <operator>=</operator> <call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>fsize</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content> <goto>goto <name>exit</name>;</goto> </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>internal_size</name></name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* scale and precision */</comment>
    <if_stmt><if>if <condition>(<expr><name>ftype</name> <operator>==</operator> <name>NUMERICOID</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>tmp</name> <operator>=</operator> <call><name>PyInt_FromLong</name><argument_list>(<argument><expr><operator>(</operator><name>fmod</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFFFF</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
            <goto>goto <name>exit</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>precision</name></name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>tmp</name> <operator>=</operator> <call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>fmod</name> <operator>&amp;</operator> <literal type="number">0xFFFF</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
            <goto>goto <name>exit</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>scale</name></name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* table_oid, table_column */</comment>
    <if_stmt><if>if <condition>(<expr><name>ftable</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>tmp</name> <operator>=</operator> <call><name>PyLong_FromOid</name><argument_list>(<argument><expr><name>ftable</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content> <goto>goto <name>exit</name>;</goto> </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>table_oid</name></name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>ftablecol</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>tmp</name> <operator>=</operator> <call><name>PyInt_FromLong</name><argument_list>(<argument><expr><operator>(</operator><name>long</name><operator>)</operator><name>ftablecol</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content> <goto>goto <name>exit</name>;</goto> </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>table_column</name></name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* success */</comment>
    <expr_stmt><expr><name>rv</name> <operator>=</operator> <operator>(</operator><name>PyObject</name> <operator>*</operator><operator>)</operator><name>column</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>column</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<label><name>exit</name>:</label>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>rv</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>RAISES_NEG</name> <specifier>static</specifier> <name>int</name></type>
<name>_pq_fetch_tuples</name><parameter_list>(<parameter><decl><type><name>cursorObject</name> <modifier>*</modifier></type><name>curs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>pgnfields</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rv</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>description</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>casts</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>Py_BEGIN_ALLOW_THREADS</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>curs</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>lock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>Py_END_ALLOW_THREADS</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>pgnfields</name> <operator>=</operator> <call><name>PQnfields</name><argument_list>(<argument><expr><name><name>curs</name><operator>-&gt;</operator><name>pgres</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>curs</name><operator>-&gt;</operator><name>notuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/* create the tuple for description and typecasting */</comment>
    <expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>curs</name><operator>-&gt;</operator><name>description</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>curs</name><operator>-&gt;</operator><name>casts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>description</name> <operator>=</operator> <call><name>PyTuple_New</name><argument_list>(<argument><expr><name>pgnfields</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content> <goto>goto <name>exit</name>;</goto> </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>casts</name> <operator>=</operator> <call><name>PyTuple_New</name><argument_list>(<argument><expr><name>pgnfields</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content> <goto>goto <name>exit</name>;</goto> </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>curs</name><operator>-&gt;</operator><name>columns</name></name> <operator>=</operator> <name>pgnfields</name></expr>;</expr_stmt>

    <comment type="block">/* calculate each field's parameters and typecasters */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>pgnfields</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>column</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>cast</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>column</name> <operator>=</operator> <call><name>_make_column</name><argument_list>(<argument><expr><name><name>curs</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><name><name>curs</name><operator>-&gt;</operator><name>pgres</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
            <goto>goto <name>exit</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>description</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>(</operator><name>PyObject</name> <operator>*</operator><operator>)</operator><name>column</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>cast</name> <operator>=</operator> <call><name>_get_cast</name><argument_list>(<argument><expr><name>curs</name></expr></argument>, <argument><expr><name><name>curs</name><operator>-&gt;</operator><name>pgres</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
            <goto>goto <name>exit</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>casts</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>cast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name><name>curs</name><operator>-&gt;</operator><name>description</name></name> <operator>=</operator> <name>description</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>description</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>curs</name><operator>-&gt;</operator><name>casts</name></name> <operator>=</operator> <name>casts</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>casts</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>rv</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<label><name>exit</name>:</label>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>description</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>casts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>Py_BEGIN_ALLOW_THREADS</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>curs</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>lock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>Py_END_ALLOW_THREADS</name></expr>;</expr_stmt>

    <return>return <expr><name>rv</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>_read_rowcount</name><parameter_list>(<parameter><decl><type><name>cursorObject</name> <modifier>*</modifier></type><name>curs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>rowcount</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>rowcount</name> <operator>=</operator> <call><name>PQcmdTuples</name><argument_list>(<argument><expr><name><name>curs</name><operator>-&gt;</operator><name>pgres</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"_read_rowcount: PQcmdTuples = %s"</literal></expr></argument>, <argument><expr><name>rowcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>rowcount</name> <operator>||</operator> <operator>!</operator><name><name>rowcount</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>curs</name><operator>-&gt;</operator><name>rowcount</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name><name>curs</name><operator>-&gt;</operator><name>rowcount</name></name> <operator>=</operator> <call><name>atol</name><argument_list>(<argument><expr><name>rowcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>_pq_copy_in_v3</name><parameter_list>(<parameter><decl><type><name>cursorObject</name> <modifier>*</modifier></type><name>curs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* COPY FROM implementation when protocol 3 is available: this function
       uses the new PQputCopyData() and can detect errors and set the correct
       exception */</comment>
    <decl_stmt><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>o</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>func</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>size</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>length</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>, <decl><type ref="prev"/><name>error</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>curs</name><operator>-&gt;</operator><name>copyfile</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>ProgrammingError</name></expr></argument>,
            <argument><expr><literal type="string">"can't execute COPY FROM: use the copy_from() method instead"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>error</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <goto>goto <name>exit</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>func</name> <operator>=</operator> <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name><name>curs</name><operator>-&gt;</operator><name>copyfile</name></name></expr></argument>, <argument><expr><literal type="string">"read"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"_pq_copy_in_v3: can't get o.read"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>error</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <goto>goto <name>exit</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>size</name> <operator>=</operator> <call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name><name>curs</name><operator>-&gt;</operator><name>copysize</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"_pq_copy_in_v3: can't get int from copysize"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>error</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <goto>goto <name>exit</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>o</name> <operator>=</operator> <call><name>PyObject_CallFunctionObjArgs</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"_pq_copy_in_v3: read() failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>error</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* a file may return unicode if implements io.TextIOBase */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>tmp</name> <operator>=</operator> <call><name>conn_encode</name><argument_list>(<argument><expr><name><name>curs</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"_pq_copy_in_v3: encoding() failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>error</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>o</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>Bytes_Check</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"_pq_copy_in_v3: got %s instead of bytes"</literal></expr></argument>,
                <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>error</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <operator>(</operator><name>length</name> <operator>=</operator> <call><name>Bytes_GET_SIZE</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>length</name> <operator>&gt;</operator> <name>INT_MAX</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"_pq_copy_in_v3: bad length: "</literal> <name>FORMAT_CODE_PY_SSIZE_T</name></expr></argument>,
                <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>error</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>Py_BEGIN_ALLOW_THREADS</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQputCopyData</name><argument_list>(<argument><expr><name><name>curs</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>, <argument><expr><call><name>Bytes_AS_STRING</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>,
            <comment type="block">/* Py_ssize_t-&gt;int cast was validated above */</comment>
            <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"_pq_copy_in_v3: sent "</literal> <name>FORMAT_CODE_PY_SSIZE_T</name> <literal type="string">" bytes of data; res = %d"</literal></expr></argument>,
            <argument><expr><name>length</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <comment type="block">/* FIXME: in theory this should not happen but adding a check
               here would be a nice idea */</comment>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>res</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"_pq_copy_in_v3: PQerrorMessage = %s"</literal></expr></argument>,
                <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>curs</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>error</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>Py_END_ALLOW_THREADS</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>error</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"_pq_copy_in_v3: error = %d"</literal></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* 0 means that the copy went well, 2 that there was an error on the
       backend: in both cases we'll get the error message from the PQresult */</comment>
    <if_stmt><if>if <condition>(<expr><name>error</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQputCopyEnd</name><argument_list>(<argument><expr><name><name>curs</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name>error</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQputCopyEnd</name><argument_list>(<argument><expr><name><name>curs</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>, <argument><expr><literal type="string">"error in PQputCopyData() call"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"error in .read() call"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>t</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ex</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tb</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>PyErr_Fetch</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ex</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>ex</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>
                <expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>PyObject_Str</name><argument_list>(<argument><expr><name>ex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>psyco_ensure_bytes</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>str</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                        <argument><expr><literal type="string">"error in .read() call: %s %s"</literal></expr></argument>,
                        <argument><expr><operator>(</operator><operator>(</operator><name>PyTypeObject</name> <operator>*</operator><operator>)</operator><name>t</name><operator>)</operator><operator>-&gt;</operator><name>tp_name</name></expr></argument>, <argument><expr><call><name>Bytes_AsString</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <comment type="block">/* Clear the Py exception: it will be re-raised from the libpq */</comment>
            <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>ex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>tb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQputCopyEnd</name><argument_list>(<argument><expr><name><name>curs</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>CLEARPGRES</name><argument_list>(<argument><expr><name><name>curs</name><operator>-&gt;</operator><name>pgres</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"_pq_copy_in_v3: copy ended; res = %d"</literal></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* if the result is -1 we should not even try to get a result from the
       because that will lock the current thread forever */</comment>
    <if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>pq_raise</name><argument_list>(<argument><expr><name><name>curs</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><name>curs</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* FIXME: pq_raise check the connection but for some reason even
           if the error message says "server closed the connection unexpectedly"
           the status returned by PQstatus is CONNECTION_OK! */</comment>
        <expr_stmt><expr><name><name>curs</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>closed</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else <block>{<block_content>
        <comment type="block">/* and finally we grab the operation result from the backend */</comment>
        <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
            <expr_stmt><expr><name>Py_BEGIN_ALLOW_THREADS</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>curs_set_result</name><argument_list>(<argument><expr><name>curs</name></expr></argument>, <argument><expr><call><name>PQgetResult</name><argument_list>(<argument><expr><name><name>curs</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>Py_END_ALLOW_THREADS</name></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>curs</name><operator>-&gt;</operator><name>pgres</name></name></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>_read_rowcount</name><argument_list>(<argument><expr><name>curs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name><name>curs</name><operator>-&gt;</operator><name>pgres</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PGRES_FATAL_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>pq_raise</name><argument_list>(<argument><expr><name><name>curs</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><name>curs</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>CLEARPGRES</name><argument_list>(<argument><expr><name><name>curs</name><operator>-&gt;</operator><name>pgres</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></else></if_stmt>

<label><name>exit</name>:</label>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>(</operator><ternary><condition><expr><name>error</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>_pq_copy_out_v3</name><parameter_list>(<parameter><decl><type><name>cursorObject</name> <modifier>*</modifier></type><name>curs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>func</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>obj</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>is_text</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>curs</name><operator>-&gt;</operator><name>copyfile</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>ProgrammingError</name></expr></argument>,
            <argument><expr><literal type="string">"can't execute COPY TO: use the copy_to() method instead"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>exit</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>func</name> <operator>=</operator> <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name><name>curs</name><operator>-&gt;</operator><name>copyfile</name></name></expr></argument>, <argument><expr><literal type="string">"write"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"_pq_copy_out_v3: can't get o.write"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>exit</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* if the file is text we must pass it unicode. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>-</operator><literal type="number">1</literal> <operator>==</operator> <operator>(</operator><name>is_text</name> <operator>=</operator> <call><name>psyco_is_text_file</name><argument_list>(<argument><expr><name><name>curs</name><operator>-&gt;</operator><name>copyfile</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
        <goto>goto <name>exit</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>Py_BEGIN_ALLOW_THREADS</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>PQgetCopyData</name><argument_list>(<argument><expr><name><name>curs</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>Py_END_ALLOW_THREADS</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>buffer</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>is_text</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>obj</name> <operator>=</operator> <call><name>conn_decode</name><argument_list>(<argument><expr><name><name>curs</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><name>obj</name> <operator>=</operator> <call><name>Bytes_FromStringAndSize</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <expr_stmt><expr><call><name>PQfreemem</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>obj</name></expr>)</condition> <block>{<block_content> <goto>goto <name>exit</name>;</goto> </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>PyObject_CallFunctionObjArgs</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>tmp</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                <goto>goto <name>exit</name>;</goto>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <comment type="block">/* we break on len == 0 but note that that should *not* happen,
           because we are not doing an async call (if it happens blame
           postgresql authors :/) */</comment>
        <if type="elseif">else if <condition>(<expr><name>len</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></while>

    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <operator>-</operator><literal type="number">2</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>pq_raise</name><argument_list>(<argument><expr><name><name>curs</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><name>curs</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>exit</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* and finally we grab the operation result from the backend */</comment>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
        <expr_stmt><expr><name>Py_BEGIN_ALLOW_THREADS</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>curs_set_result</name><argument_list>(<argument><expr><name>curs</name></expr></argument>, <argument><expr><call><name>PQgetResult</name><argument_list>(<argument><expr><name><name>curs</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>Py_END_ALLOW_THREADS</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>curs</name><operator>-&gt;</operator><name>pgres</name></name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>_read_rowcount</name><argument_list>(<argument><expr><name>curs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name><name>curs</name><operator>-&gt;</operator><name>pgres</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PGRES_FATAL_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>pq_raise</name><argument_list>(<argument><expr><name><name>curs</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><name>curs</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>CLEARPGRES</name><argument_list>(<argument><expr><name><name>curs</name><operator>-&gt;</operator><name>pgres</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<label><name>exit</name>:</label>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Tries to read the next message from the replication stream, without
   blocking, in both sync and async connection modes.  If no message
   is ready in the CopyData buffer, tries to read from the server,
   again without blocking.  If that doesn't help, returns Py_None.
   The caller is then supposed to block on the socket(s) and call this
   function again.

   Any keepalive messages from the server are silently consumed and
   are never returned to the caller.
 */</comment>
<function><type><name>int</name></type>
<name>pq_read_replication_message</name><parameter_list>(<parameter><decl><type><name>replicationCursorObject</name> <modifier>*</modifier></type><name>repl</name></decl></parameter>, <parameter><decl><type><name>replicationMessageObject</name> <modifier>*</modifier><modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>cursorObject</name> <modifier>*</modifier></type><name>curs</name> <init>= <expr><operator>&amp;</operator><name><name>repl</name><operator>-&gt;</operator><name>cur</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>connectionObject</name> <modifier>*</modifier></type><name>conn</name> <init>= <expr><name><name>curs</name><operator>-&gt;</operator><name>conn</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>pgconn</name> <init>= <expr><name><name>conn</name><operator>-&gt;</operator><name>pgconn</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>data_size</name></decl>, <decl><type ref="prev"/><name>consumed</name></decl>, <decl><type ref="prev"/><name>hdr</name></decl>, <decl><type ref="prev"/><name>reply</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>data_start</name></decl>, <decl><type ref="prev"/><name>wal_end</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>send_time</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>curr_time</name></decl>, <decl><type ref="prev"/><name>feedback_time</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"pq_read_replication_message"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><operator>*</operator><name>msg</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>consumed</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/* Is it a time to send the next feedback message? */</comment>
    <expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>curr_time</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>timeradd</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>repl</name><operator>-&gt;</operator><name>last_feedback</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>repl</name><operator>-&gt;</operator><name>status_interval</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>feedback_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>timercmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>curr_time</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>feedback_time</name></expr></argument>, <argument><expr><operator>&gt;=</operator></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>pq_send_replication_feedback</name><argument_list>(<argument><expr><name>repl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <goto>goto <name>exit</name>;</goto>
    </block_content>}</block></if></if_stmt>

<label><name>retry</name>:</label>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>PQgetCopyData</name><argument_list>(<argument><expr><name>pgconn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument> <comment type="block">/* async */</comment>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* If we've tried reading some data, but there was none, bail out. */</comment>
        <if_stmt><if>if <condition>(<expr><name>consumed</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <goto>goto <name>exit</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* We should only try reading more data when there is nothing
           available at the moment.  Otherwise, with a really highly loaded
           server we might be reading a number of messages for every single
           one we process, thus overgrowing the internal buffer until the
           client system runs out of memory. */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQconsumeInput</name><argument_list>(<argument><expr><name>pgconn</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>pq_raise</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>curs</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>exit</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* But PQconsumeInput() doesn't tell us if it has actually read
           anything into the internal buffer and there is no (supported) way
           to ask libpq about this directly.  The way we check is setting the
           flag and re-trying PQgetCopyData(): if that returns 0 again,
           there's no more data available in the buffer, so we return None. */</comment>
        <expr_stmt><expr><name>consumed</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <goto>goto <name>retry</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <operator>-</operator><literal type="number">2</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* serious error */</comment>
        <expr_stmt><expr><call><name>pq_raise</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>curs</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>exit</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* EOF */</comment>
        <expr_stmt><expr><call><name>curs_set_result</name><argument_list>(<argument><expr><name>curs</name></expr></argument>, <argument><expr><call><name>PQgetResult</name><argument_list>(<argument><expr><name>pgconn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>curs</name><operator>-&gt;</operator><name>pgres</name></name> <operator>&amp;&amp;</operator> <call><name>PQresultStatus</name><argument_list>(<argument><expr><name><name>curs</name><operator>-&gt;</operator><name>pgres</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PGRES_FATAL_ERROR</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>pq_raise</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>curs</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>exit</name>;</goto>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>CLEARPGRES</name><argument_list>(<argument><expr><name><name>curs</name><operator>-&gt;</operator><name>pgres</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <goto>goto <name>exit</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* It also makes sense to set this flag here to make us return early in
       case of retry due to keepalive message.  Any pending data on the socket
       will trigger read condition in select() in the calling code anyway. */</comment>
    <expr_stmt><expr><name>consumed</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <comment type="block">/* ok, we did really read something: update the io timestamp */</comment>
    <expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>repl</name><operator>-&gt;</operator><name>last_io</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"pq_read_replication_message: msg=%c, len=%d"</literal></expr></argument>, <argument><expr><name><name>buffer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>buffer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'w'</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* XLogData: msgtype(1), dataStart(8), walEnd(8), sendTime(8) */</comment>
        <expr_stmt><expr><name>hdr</name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <literal type="number">8</literal> <operator>+</operator> <literal type="number">8</literal> <operator>+</operator> <literal type="number">8</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <name>hdr</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>psyco_set_error</name><argument_list>(<argument><expr><name>OperationalError</name></expr></argument>, <argument><expr><name>curs</name></expr></argument>, <argument><expr><literal type="string">"data message header too small"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>exit</name>;</goto>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>data_size</name>  <operator>=</operator> <name>len</name> <operator>-</operator> <name>hdr</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>data_start</name> <operator>=</operator> <call><name>fe_recvint64</name><argument_list>(<argument><expr><name>buffer</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>wal_end</name>    <operator>=</operator> <call><name>fe_recvint64</name><argument_list>(<argument><expr><name>buffer</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>send_time</name>  <operator>=</operator> <call><name>fe_recvint64</name><argument_list>(<argument><expr><name>buffer</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <literal type="number">8</literal> <operator>+</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"pq_read_replication_message: data_start="</literal><name>XLOGFMTSTR</name><literal type="string">", wal_end="</literal><name>XLOGFMTSTR</name></expr></argument>,
                <argument><expr><call><name>XLOGFMTARGS</name><argument_list>(<argument><expr><name>data_start</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>XLOGFMTARGS</name><argument_list>(<argument><expr><name>wal_end</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"pq_read_replication_message: &gt;&gt;%.*s&lt;&lt;"</literal></expr></argument>, <argument><expr><name>data_size</name></expr></argument>, <argument><expr><name>buffer</name> <operator>+</operator> <name>hdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>repl</name><operator>-&gt;</operator><name>decode</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>conn_decode</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>buffer</name> <operator>+</operator> <name>hdr</name></expr></argument>, <argument><expr><name>data_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>Bytes_FromStringAndSize</name><argument_list>(<argument><expr><name>buffer</name> <operator>+</operator> <name>hdr</name></expr></argument>, <argument><expr><name>data_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>str</name></expr>)</condition> <block>{<block_content> <goto>goto <name>exit</name>;</goto> </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PyObject_CallFunctionObjArgs</name><argument_list>(<argument><expr><operator>(</operator><name>PyObject</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>replicationMessageType</name></expr></argument>,
                                              <argument><expr><name>curs</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition> <block>{<block_content> <goto>goto <name>exit</name>;</goto> </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><operator>*</operator><name>msg</name> <operator>=</operator> <operator>(</operator><name>replicationMessageObject</name> <operator>*</operator><operator>)</operator><name>result</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>msg</name><operator>)</operator><operator>-&gt;</operator><name>data_size</name></name>  <operator>=</operator> <name>data_size</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>msg</name><operator>)</operator><operator>-&gt;</operator><name>data_start</name></name> <operator>=</operator> <name>data_start</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>msg</name><operator>)</operator><operator>-&gt;</operator><name>wal_end</name></name>    <operator>=</operator> <name>wal_end</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>msg</name><operator>)</operator><operator>-&gt;</operator><name>send_time</name></name>  <operator>=</operator> <name>send_time</name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>repl</name><operator>-&gt;</operator><name>wal_end</name></name> <operator>=</operator> <name>wal_end</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>repl</name><operator>-&gt;</operator><name>last_msg_data_start</name></name> <operator>=</operator> <name>data_start</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>buffer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'k'</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Primary keepalive message: msgtype(1), walEnd(8), sendTime(8), reply(1) */</comment>
        <expr_stmt><expr><name>hdr</name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <literal type="number">8</literal> <operator>+</operator> <literal type="number">8</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <name>hdr</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>psyco_set_error</name><argument_list>(<argument><expr><name>OperationalError</name></expr></argument>, <argument><expr><name>curs</name></expr></argument>, <argument><expr><literal type="string">"keepalive message header too small"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>exit</name>;</goto>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>wal_end</name> <operator>=</operator> <call><name>fe_recvint64</name><argument_list>(<argument><expr><name>buffer</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"pq_read_replication_message: wal_end="</literal><name>XLOGFMTSTR</name></expr></argument>, <argument><expr><call><name>XLOGFMTARGS</name><argument_list>(<argument><expr><name>wal_end</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>repl</name><operator>-&gt;</operator><name>wal_end</name></name> <operator>=</operator> <name>wal_end</name></expr>;</expr_stmt>

        <comment type="block">/* We can safely forward flush_lsn to the wal_end from the server keepalive message
         * if we know that the client already processed (confirmed) the last XLogData message */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>repl</name><operator>-&gt;</operator><name>explicitly_flushed_lsn</name></name> <operator>&gt;=</operator> <name><name>repl</name><operator>-&gt;</operator><name>last_msg_data_start</name></name>
                <operator>&amp;&amp;</operator> <name>wal_end</name> <operator>&gt;</operator> <name><name>repl</name><operator>-&gt;</operator><name>explicitly_flushed_lsn</name></name>
                <operator>&amp;&amp;</operator> <name>wal_end</name> <operator>&gt;</operator> <name><name>repl</name><operator>-&gt;</operator><name>flush_lsn</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>repl</name><operator>-&gt;</operator><name>flush_lsn</name></name> <operator>=</operator> <name>wal_end</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>reply</name> <operator>=</operator> <name><name>buffer</name><index>[<expr><name>hdr</name></expr>]</index></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>reply</name> <operator>&amp;&amp;</operator> <call><name>pq_send_replication_feedback</name><argument_list>(<argument><expr><name>repl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <goto>goto <name>exit</name>;</goto>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>PQfreemem</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>buffer</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <goto>goto <name>retry</name>;</goto>
    </block_content>}</block></if>
    <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>psyco_set_error</name><argument_list>(<argument><expr><name>OperationalError</name></expr></argument>, <argument><expr><name>curs</name></expr></argument>, <argument><expr><literal type="string">"unrecognized replication message type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>exit</name>;</goto>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<label><name>exit</name>:</label>
    <if_stmt><if>if <condition>(<expr><name>buffer</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>PQfreemem</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pq_send_replication_feedback</name><parameter_list>(<parameter><decl><type><name>replicationCursorObject</name> <modifier>*</modifier></type><name>repl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reply_requested</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>cursorObject</name> <modifier>*</modifier></type><name>curs</name> <init>= <expr><operator>&amp;</operator><name><name>repl</name><operator>-&gt;</operator><name>cur</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>connectionObject</name> <modifier>*</modifier></type><name>conn</name> <init>= <expr><name><name>curs</name><operator>-&gt;</operator><name>conn</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>pgconn</name> <init>= <expr><name><name>conn</name><operator>-&gt;</operator><name>pgconn</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>replybuf</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <literal type="number">8</literal> <operator>+</operator> <literal type="number">8</literal> <operator>+</operator> <literal type="number">8</literal> <operator>+</operator> <literal type="number">8</literal> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"pq_send_replication_feedback: write="</literal><name>XLOGFMTSTR</name><literal type="string">", flush="</literal><name>XLOGFMTSTR</name><literal type="string">", apply="</literal><name>XLOGFMTSTR</name></expr></argument>,
            <argument><expr><call><name>XLOGFMTARGS</name><argument_list>(<argument><expr><name><name>repl</name><operator>-&gt;</operator><name>write_lsn</name></name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><call><name>XLOGFMTARGS</name><argument_list>(<argument><expr><name><name>repl</name><operator>-&gt;</operator><name>flush_lsn</name></name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><call><name>XLOGFMTARGS</name><argument_list>(<argument><expr><name><name>repl</name><operator>-&gt;</operator><name>apply_lsn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>replybuf</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'r'</literal></expr>;</expr_stmt> <expr_stmt><expr><name>len</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fe_sendint64</name><argument_list>(<argument><expr><name><name>repl</name><operator>-&gt;</operator><name>write_lsn</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>replybuf</name><index>[<expr><name>len</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>len</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fe_sendint64</name><argument_list>(<argument><expr><name><name>repl</name><operator>-&gt;</operator><name>flush_lsn</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>replybuf</name><index>[<expr><name>len</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>len</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fe_sendint64</name><argument_list>(<argument><expr><name><name>repl</name><operator>-&gt;</operator><name>apply_lsn</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>replybuf</name><index>[<expr><name>len</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>len</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fe_sendint64</name><argument_list>(<argument><expr><call><name>feGetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>replybuf</name><index>[<expr><name>len</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>len</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>replybuf</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>reply_requested</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt> <expr_stmt><expr><name>len</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>PQputCopyData</name><argument_list>(<argument><expr><name>pgconn</name></expr></argument>, <argument><expr><name>replybuf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>PQflush</name><argument_list>(<argument><expr><name>pgconn</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>pq_raise</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>curs</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>repl</name><operator>-&gt;</operator><name>last_feedback</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>repl</name><operator>-&gt;</operator><name>last_io</name></name> <operator>=</operator> <name><name>repl</name><operator>-&gt;</operator><name>last_feedback</name></name></expr>;</expr_stmt>

    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Calls pq_read_replication_message in an endless loop, until
   stop_replication is called or a fatal error occurs.  The messages
   are passed to the consumer object.

   When no message is available, blocks on the connection socket, but
   manages to send keepalive messages to the server as needed.
*/</comment>
<function><type><name>int</name></type>
<name>pq_copy_both</name><parameter_list>(<parameter><decl><type><name>replicationCursorObject</name> <modifier>*</modifier></type><name>repl</name></decl></parameter>, <parameter><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>consume</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>cursorObject</name> <modifier>*</modifier></type><name>curs</name> <init>= <expr><operator>&amp;</operator><name><name>repl</name><operator>-&gt;</operator><name>cur</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>connectionObject</name> <modifier>*</modifier></type><name>conn</name> <init>= <expr><name><name>curs</name><operator>-&gt;</operator><name>conn</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>pgconn</name> <init>= <expr><name><name>conn</name><operator>-&gt;</operator><name>pgconn</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>replicationMessageObject</name> <modifier>*</modifier></type><name>msg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>, <decl><type ref="prev"/><name>sel</name></decl>, <decl><type ref="prev"/><name>ret</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>fd_set</name></type> <name>fds</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>curr_time</name></decl>, <decl><type ref="prev"/><name>feedback_time</name></decl>, <decl><type ref="prev"/><name>timeout</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PyCallable_Check</name><argument_list>(<argument><expr><name>consume</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"pq_copy_both: expected callable consume object"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>exit</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>CLEARPGRES</name><argument_list>(<argument><expr><name><name>curs</name><operator>-&gt;</operator><name>pgres</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>pq_read_replication_message</name><argument_list>(<argument><expr><name>repl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <goto>goto <name>exit</name>;</goto>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>msg</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>PQsocket</name><argument_list>(<argument><expr><name>pgconn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>pq_raise</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>curs</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>exit</name>;</goto>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>FD_ZERO</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>FD_SET</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* how long can we wait before we need to send a feedback? */</comment>
            <expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>curr_time</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>timeradd</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>repl</name><operator>-&gt;</operator><name>last_feedback</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>repl</name><operator>-&gt;</operator><name>status_interval</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>feedback_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>timersub</name><argument_list>(<argument><expr><operator>&amp;</operator><name>feedback_time</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>curr_time</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>timeout</name><operator>.</operator><name>tv_sec</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>Py_BEGIN_ALLOW_THREADS</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>sel</name> <operator>=</operator> <call><name>select</name><argument_list>(<argument><expr><name>fd</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>fds</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>Py_END_ALLOW_THREADS</name></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>sel</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>EINTR</name></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>PyExc_OSError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <goto>goto <name>exit</name>;</goto>
                    </block_content>}</block></if></if_stmt>
                    <if_stmt><if>if <condition>(<expr><call><name>PyErr_CheckSignals</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                        <goto>goto <name>exit</name>;</goto>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <else>else <block>{<block_content>
            <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>PyObject_CallFunctionObjArgs</name><argument_list>(<argument><expr><name>consume</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>tmp</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"pq_copy_both: consume returned NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>exit</name>;</goto>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<label><name>exit</name>:</label>
    <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pq_fetch</name><parameter_list>(<parameter><decl><type><name>cursorObject</name> <modifier>*</modifier></type><name>curs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>no_result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>pgstatus</name></decl>, <decl><type ref="prev"/><name>ex</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* even if we fail, we remove any information about the previous query */</comment>
    <expr_stmt><expr><call><name>curs_reset</name><argument_list>(<argument><expr><name>curs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>curs</name><operator>-&gt;</operator><name>pgres</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>pgstatus</name> <operator>=</operator> <call><name>PQresultStatus</name><argument_list>(<argument><expr><name><name>curs</name><operator>-&gt;</operator><name>pgres</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"pq_fetch: pgstatus = %s"</literal></expr></argument>, <argument><expr><call><name>PQresStatus</name><argument_list>(<argument><expr><name>pgstatus</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* backend status message */</comment>
    <expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>curs</name><operator>-&gt;</operator><name>pgstatus</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>curs</name><operator>-&gt;</operator><name>pgstatus</name></name> <operator>=</operator> <call><name>conn_text_from_chars</name><argument_list>(
            <argument><expr><name><name>curs</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><call><name>PQcmdStatus</name><argument_list>(<argument><expr><name><name>curs</name><operator>-&gt;</operator><name>pgres</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>ex</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <return>return <expr><name>ex</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <switch>switch<condition>(<expr><name>pgstatus</name></expr>)</condition> <block>{<block_content>

    <case>case <expr><name>PGRES_COMMAND_OK</name></expr>:</case>
        <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"pq_fetch: command returned OK (no tuples)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>_read_rowcount</name><argument_list>(<argument><expr><name>curs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>curs</name><operator>-&gt;</operator><name>lastoid</name></name> <operator>=</operator> <call><name>PQoidValue</name><argument_list>(<argument><expr><name><name>curs</name><operator>-&gt;</operator><name>pgres</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CLEARPGRES</name><argument_list>(<argument><expr><name><name>curs</name><operator>-&gt;</operator><name>pgres</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>ex</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <break>break;</break>

    <case>case <expr><name>PGRES_COPY_OUT</name></expr>:</case>
        <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"pq_fetch: data from a COPY TO (no tuples)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>curs</name><operator>-&gt;</operator><name>rowcount</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>ex</name> <operator>=</operator> <call><name>_pq_copy_out_v3</name><argument_list>(<argument><expr><name>curs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* error caught by out glorious notice handler */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ex</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>CLEARPGRES</name><argument_list>(<argument><expr><name><name>curs</name><operator>-&gt;</operator><name>pgres</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

    <case>case <expr><name>PGRES_COPY_IN</name></expr>:</case>
        <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"pq_fetch: data from a COPY FROM (no tuples)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>curs</name><operator>-&gt;</operator><name>rowcount</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>ex</name> <operator>=</operator> <call><name>_pq_copy_in_v3</name><argument_list>(<argument><expr><name>curs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* error caught by out glorious notice handler */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ex</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>CLEARPGRES</name><argument_list>(<argument><expr><name><name>curs</name><operator>-&gt;</operator><name>pgres</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

    <case>case <expr><name>PGRES_COPY_BOTH</name></expr>:</case>
        <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"pq_fetch: data from a streaming replication slot (no tuples)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>curs</name><operator>-&gt;</operator><name>rowcount</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>ex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <comment type="block">/* Nothing to do here: pq_copy_both will be called separately.

           Also don't clear the result status: it's checked in
           consume_stream. */</comment>
        <comment type="block">/*CLEARPGRES(curs-&gt;pgres);*/</comment>
        <break>break;</break>

    <case>case <expr><name>PGRES_TUPLES_OK</name></expr>:</case>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>no_result</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"pq_fetch: got tuples"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>curs</name><operator>-&gt;</operator><name>rowcount</name></name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name><name>curs</name><operator>-&gt;</operator><name>pgres</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <call><name>_pq_fetch_tuples</name><argument_list>(<argument><expr><name>curs</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>ex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
            <comment type="block">/* don't clear curs-&gt;pgres, because it contains the results! */</comment>
        </block_content>}</block></if>
        <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"pq_fetch: got tuples, discarding them"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* TODO: is there any case in which PQntuples == PQcmdTuples? */</comment>
            <expr_stmt><expr><call><name>_read_rowcount</name><argument_list>(<argument><expr><name>curs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>CLEARPGRES</name><argument_list>(<argument><expr><name><name>curs</name><operator>-&gt;</operator><name>pgres</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>ex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <break>break;</break>

    <case>case <expr><name>PGRES_EMPTY_QUERY</name></expr>:</case>
        <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>ProgrammingError</name></expr></argument>,
            <argument><expr><literal type="string">"can't execute an empty query"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CLEARPGRES</name><argument_list>(<argument><expr><name><name>curs</name><operator>-&gt;</operator><name>pgres</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>ex</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <break>break;</break>

    <case>case <expr><name>PGRES_BAD_RESPONSE</name></expr>:</case>
    <case>case <expr><name>PGRES_NONFATAL_ERROR</name></expr>:</case>
    <case>case <expr><name>PGRES_FATAL_ERROR</name></expr>:</case>
        <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"pq_fetch: uh-oh, something FAILED: status = %d pgconn = %p"</literal></expr></argument>,
            <argument><expr><name>pgstatus</name></expr></argument>, <argument><expr><name><name>curs</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pq_raise</name><argument_list>(<argument><expr><name><name>curs</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><name>curs</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>ex</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <break>break;</break>

    <default>default:</default>
        <comment type="block">/* PGRES_SINGLE_TUPLE, future statuses */</comment>
        <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"pq_fetch: got unsupported result: status = %d pgconn = %p"</literal></expr></argument>,
            <argument><expr><name>pgstatus</name></expr></argument>, <argument><expr><name><name>curs</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>NotSupportedError</name></expr></argument>,
            <argument><expr><literal type="string">"got server response with unsupported status %s"</literal></expr></argument>,
            <argument><expr><call><name>PQresStatus</name><argument_list>(<argument><expr><ternary><condition><expr><name><name>curs</name><operator>-&gt;</operator><name>pgres</name></name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then>
                <expr><call><name>PQstatus</name><argument_list>(<argument><expr><name><name>curs</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name><name>curs</name><operator>-&gt;</operator><name>pgres</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CLEARPGRES</name><argument_list>(<argument><expr><name><name>curs</name><operator>-&gt;</operator><name>pgres</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>ex</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>

    <return>return <expr><name>ex</name></expr>;</return>
</block_content>}</block></function>
</unit>
