<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/psycopg2/psycopg/connection_int.c"><comment type="block">/* connection_int.c - code used by the connection object
 *
 * Copyright (C) 2003-2019 Federico Di Gregorio &lt;fog@debian.org&gt;
 * Copyright (C) 2020-2021 The Psycopg Team
 *
 * This file is part of psycopg.
 *
 * psycopg2 is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition, as a special exception, the copyright holders give
 * permission to link this program with the OpenSSL library (or with
 * modified versions of OpenSSL that use the same license as OpenSSL),
 * and distribute linked combinations including the two.
 *
 * You must obey the GNU Lesser General Public License in all respects for
 * all of the code used other than OpenSSL.
 *
 * psycopg2 is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
 * License for more details.
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PSYCOPG_MODULE</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"psycopg/psycopg.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"psycopg/connection.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"psycopg/cursor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"psycopg/pqpath.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"psycopg/green.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"psycopg/notify.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<comment type="block">/* String indexes match the ISOLATION_LEVEL_* consts */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>srv_isolevels</name><index>[]</index></name> <init>= <expr><block>{
    <expr><name>NULL</name></expr>, <comment type="block">/* autocommit */</comment>
    <expr><literal type="string">"READ COMMITTED"</literal></expr>,
    <expr><literal type="string">"REPEATABLE READ"</literal></expr>,
    <expr><literal type="string">"SERIALIZABLE"</literal></expr>,
    <expr><literal type="string">"READ UNCOMMITTED"</literal></expr>,
    <expr><literal type="string">"default"</literal></expr>       <comment type="block">/* only to set GUC, not for BEGIN */</comment>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Read only false, true */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>srv_readonly</name><index>[]</index></name> <init>= <expr><block>{
    <expr><literal type="string">" READ WRITE"</literal></expr>,
    <expr><literal type="string">" READ ONLY"</literal></expr>,
    <expr><literal type="string">""</literal></expr>      <comment type="block">/* default */</comment>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Deferrable false, true */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>srv_deferrable</name><index>[]</index></name> <init>= <expr><block>{
    <expr><literal type="string">" NOT DEFERRABLE"</literal></expr>,
    <expr><literal type="string">" DEFERRABLE"</literal></expr>,
    <expr><literal type="string">""</literal></expr>      <comment type="block">/* default */</comment>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* On/Off/Default GUC states
 */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>srv_state_guc</name><index>[]</index></name> <init>= <expr><block>{
    <expr><literal type="string">"off"</literal></expr>,
    <expr><literal type="string">"on"</literal></expr>,
    <expr><literal type="string">"default"</literal></expr>
}</block></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>SRV_STATE_UNCHANGED</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>


<comment type="block">/* Return a new "string" from a char* from the database.
 *
 * On Py2 just get a string, on Py3 decode it in the connection codec.
 *
 * Use a fallback if the connection is NULL.
 */</comment>
<function><type><name>PyObject</name> <modifier>*</modifier></type>
<name>conn_text_from_chars</name><parameter_list>(<parameter><decl><type><name>connectionObject</name> <modifier>*</modifier></type><name>self</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>psyco_text_from_chars_safe</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>self</name></expr> ?</condition><then> <expr><name><name>self</name><operator>-&gt;</operator><name>pydecoder</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Encode an unicode object into a bytes object in the connection encoding.
 *
 * If no connection or encoding is available, default to utf8
 */</comment>
<function><type><name>PyObject</name> <modifier>*</modifier></type>
<name>conn_encode</name><parameter_list>(<parameter><decl><type><name>connectionObject</name> <modifier>*</modifier></type><name>self</name></decl></parameter>, <parameter><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>u</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>rv</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>self</name> <operator>&amp;&amp;</operator> <name><name>self</name><operator>-&gt;</operator><name>pyencoder</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>PyUnicode_AsUTF8String</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>exit</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>t</name> <operator>=</operator> <call><name>PyObject_CallFunctionObjArgs</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>pyencoder</name></name></expr></argument>, <argument><expr><name>u</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
        <goto>goto <name>exit</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>rv</name> <operator>=</operator> <call><name>PyTuple_GetItem</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content> <goto>goto <name>exit</name>;</goto> </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>exit</name>:</label>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>rv</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* decode a c string into a Python unicode in the connection encoding
 *
 * len can be &lt; 0: in this case it will be calculated
 *
 * If no connection or encoding is available, default to utf8
 */</comment>
<function><type><name>PyObject</name> <modifier>*</modifier></type>
<name>conn_decode</name><parameter_list>(<parameter><decl><type><name>connectionObject</name> <modifier>*</modifier></type><name>self</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>self</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>self</name><operator>-&gt;</operator><name>cdecoder</name></name></expr>)</condition> <block>{<block_content>
            <return>return <expr><call><name><name>self</name><operator>-&gt;</operator><name>cdecoder</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>self</name><operator>-&gt;</operator><name>pydecoder</name></name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>b</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>rv</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>b</name> <operator>=</operator> <call><name>Bytes_FromStringAndSize</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content> <goto>goto <name>error</name>;</goto> </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>t</name> <operator>=</operator> <call><name>PyObject_CallFunctionObjArgs</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>pydecoder</name></name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
                <goto>goto <name>error</name>;</goto>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>rv</name> <operator>=</operator> <call><name>PyTuple_GetItem</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content> <goto>goto <name>error</name>;</goto> </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>      <comment type="block">/* PyTuple_GetItem gives a borrowes one */</comment>
<label><name>error</name>:</label>
            <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>rv</name></expr>;</return>
        </block_content>}</block></if>
        <else>else <block>{<block_content>
            <return>return <expr><call><name>PyUnicode_FromStringAndSize</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <else>else <block>{<block_content>
        <return>return <expr><call><name>PyUnicode_FromStringAndSize</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* conn_notice_callback - process notices */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>conn_notice_callback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>message</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>connectionObject_notice</name></name> <modifier>*</modifier></type><name>notice</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>connectionObject</name> <modifier>*</modifier></type><name>self</name> <init>= <expr><operator>(</operator><name>connectionObject</name> <operator>*</operator><operator>)</operator><name>args</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"conn_notice_callback: %s"</literal></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* NOTE: if we get here and the connection is unlocked then there is a
       problem but this should happen because the notice callback is only
       called from libpq and when we're inside libpq the connection is usually
       locked.
    */</comment>
    <expr_stmt><expr><name>notice</name> <operator>=</operator> <operator>(</operator>struct <name>connectionObject_notice</name> <operator>*</operator><operator>)</operator>
        <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>connectionObject_notice</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>notice</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Discard the notice in case of failed allocation. */</comment>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>notice</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>notice</name><operator>-&gt;</operator><name>message</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>notice</name><operator>-&gt;</operator><name>message</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>notice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>self</name><operator>-&gt;</operator><name>last_notice</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>notice_pending</name></name> <operator>=</operator> <name><name>self</name><operator>-&gt;</operator><name>last_notice</name></name> <operator>=</operator> <name>notice</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else <block>{<block_content>
        <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>last_notice</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>notice</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>last_notice</name></name> <operator>=</operator> <name>notice</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Expose the notices received as Python objects.
 *
 * The function should be called with the connection lock and the GIL.
 */</comment>
<function><type><name>void</name></type>
<name>conn_notice_process</name><parameter_list>(<parameter><decl><type><name>connectionObject</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>connectionObject_notice</name></name> <modifier>*</modifier></type><name>notice</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>msg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> <modifier>*</modifier></type><name>append</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>self</name><operator>-&gt;</operator><name>notice_pending</name></name></expr>)</condition> <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>append</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>append</name> <operator>=</operator> <call><name>Text_FromUTF8</name><argument_list>(<argument><expr><literal type="string">"append"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
            <goto>goto <name>error</name>;</goto>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>notice</name> <operator>=</operator> <name><name>self</name><operator>-&gt;</operator><name>notice_pending</name></name></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>notice</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"conn_notice_process: %s"</literal></expr></argument>, <argument><expr><name><name>notice</name><operator>-&gt;</operator><name>message</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>msg</name> <operator>=</operator> <call><name>conn_text_from_chars</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name><name>notice</name><operator>-&gt;</operator><name>message</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content> <goto>goto <name>error</name>;</goto> </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>tmp</name> <operator>=</operator> <call><name>PyObject_CallMethodObjArgs</name><argument_list>(
                <argument><expr><name><name>self</name><operator>-&gt;</operator><name>notice_list</name></name></expr></argument>, <argument><expr><name>append</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

            <goto>goto <name>error</name>;</goto>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>tmp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>msg</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>notice</name> <operator>=</operator> <name><name>notice</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/* Remove the oldest item if the queue is getting too long. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PyList_Check</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>notice_list</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>nnotices</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>nnotices</name> <operator>=</operator> <call><name>PyList_GET_SIZE</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>notice_list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>nnotices</name> <operator>&gt;</operator> <name>CONN_NOTICES_LIMIT</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>-</operator><literal type="number">1</literal> <operator>==</operator> <call><name>PySequence_DelSlice</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>notice_list</name></name></expr></argument>,
                    <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nnotices</name> <operator>-</operator> <name>CONN_NOTICES_LIMIT</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>conn_notice_clean</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>

<label><name>error</name>:</label>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>conn_notice_clean</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* TODO: the caller doesn't expects errors from us */</comment>
    <expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>conn_notice_clean</name><parameter_list>(<parameter><decl><type><name>connectionObject</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>connectionObject_notice</name></name> <modifier>*</modifier></type><name>tmp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>notice</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>notice</name> <operator>=</operator> <name><name>self</name><operator>-&gt;</operator><name>notice_pending</name></name></expr>;</expr_stmt>

    <while>while <condition>(<expr><name>notice</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>tmp</name> <operator>=</operator> <name>notice</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>notice</name> <operator>=</operator> <name><name>notice</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>tmp</name><operator>-&gt;</operator><name>message</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>last_notice</name></name> <operator>=</operator> <name><name>self</name><operator>-&gt;</operator><name>notice_pending</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* conn_notifies_process - make received notification available
 *
 * The function should be called with the connection lock and holding the GIL.
 */</comment>

<function><type><name>void</name></type>
<name>conn_notifies_process</name><parameter_list>(<parameter><decl><type><name>connectionObject</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PGnotify</name> <modifier>*</modifier></type><name>pgn</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>notify</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>pid</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>channel</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>payload</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> <modifier>*</modifier></type><name>append</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>append</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>append</name> <operator>=</operator> <call><name>Text_FromUTF8</name><argument_list>(<argument><expr><literal type="string">"append"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
            <goto>goto <name>error</name>;</goto>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <while>while <condition>(<expr><operator>(</operator><name>pgn</name> <operator>=</operator> <call><name>PQnotifies</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

        <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"conn_notifies_process: got NOTIFY from pid %d, msg = %s"</literal></expr></argument>,
                <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>pgn</name><operator>-&gt;</operator><name>be_pid</name></name></expr></argument>, <argument><expr><name><name>pgn</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>pid</name> <operator>=</operator> <call><name>PyInt_FromLong</name><argument_list>(<argument><expr><operator>(</operator><name>long</name><operator>)</operator><name><name>pgn</name><operator>-&gt;</operator><name>be_pid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content> <goto>goto <name>error</name>;</goto> </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>channel</name> <operator>=</operator> <call><name>conn_text_from_chars</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name><name>pgn</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content> <goto>goto <name>error</name>;</goto> </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>payload</name> <operator>=</operator> <call><name>conn_text_from_chars</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name><name>pgn</name><operator>-&gt;</operator><name>extra</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content> <goto>goto <name>error</name>;</goto> </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>notify</name> <operator>=</operator> <call><name>PyObject_CallFunctionObjArgs</name><argument_list>(<argument><expr><operator>(</operator><name>PyObject</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>notifyType</name></expr></argument>,
                <argument><expr><name>pid</name></expr></argument>, <argument><expr><name>channel</name></expr></argument>, <argument><expr><name>payload</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
            <goto>goto <name>error</name>;</goto>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>pid</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>channel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>channel</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>payload</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>payload</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>tmp</name> <operator>=</operator> <call><name>PyObject_CallMethodObjArgs</name><argument_list>(
                <argument><expr><name><name>self</name><operator>-&gt;</operator><name>notifies</name></name></expr></argument>, <argument><expr><name>append</name></expr></argument>, <argument><expr><name>notify</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
            <goto>goto <name>error</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>tmp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>notify</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>notify</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PQfreemem</name><argument_list>(<argument><expr><name>pgn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>pgn</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <return>return;</return>  <comment type="block">/* no error */</comment>

<label><name>error</name>:</label>
    <if_stmt><if>if <condition>(<expr><name>pgn</name></expr>)</condition> <block>{<block_content> <expr_stmt><expr><call><name>PQfreemem</name><argument_list>(<argument><expr><name>pgn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>notify</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>channel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>payload</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* TODO: callers currently don't expect an error from us */</comment>
    <expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>


<comment type="block">/*
 * the conn_get_* family of functions makes it easier to obtain the connection
 * parameters from query results or by interrogating the connection itself
*/</comment>

<function><type><name>int</name></type>
<name>conn_get_standard_conforming_strings</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>pgconn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>equote</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>scs</name></decl>;</decl_stmt>
    <comment type="block">/*
     * The presence of the 'standard_conforming_strings' parameter
     * means that the server _accepts_ the E'' quote.
     *
     * If the parameter is off, the PQescapeByteaConn returns
     * backslash escaped strings (e.g. '\001' -&gt; "\\001"),
     * so the E'' quotes are required to avoid warnings
     * if 'escape_string_warning' is set.
     *
     * If the parameter is on, the PQescapeByteaConn returns
     * not escaped strings (e.g. '\001' -&gt; "\001"), relying on the
     * fact that the '\' will pass untouched the string parser.
     * In this case the E'' quotes are NOT to be used.
     */</comment>
    <expr_stmt><expr><name>scs</name> <operator>=</operator> <call><name>PQparameterStatus</name><argument_list>(<argument><expr><name>pgconn</name></expr></argument>, <argument><expr><literal type="string">"standard_conforming_strings"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"conn_connect: server standard_conforming_strings parameter: %s"</literal></expr></argument>,
        <argument><expr><ternary><condition><expr><name>scs</name></expr> ?</condition><then> <expr><name>scs</name></expr> </then><else>: <expr><literal type="string">"unavailable"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>equote</name> <operator>=</operator> <operator>(</operator><name>scs</name> <operator>&amp;&amp;</operator> <operator>(</operator><literal type="number">0</literal> <operator>==</operator> <call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"off"</literal></expr></argument>, <argument><expr><name>scs</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"conn_connect: server requires E'' quotes: %s"</literal></expr></argument>,
            <argument><expr><ternary><condition><expr><name>equote</name></expr> ?</condition><then> <expr><literal type="string">"YES"</literal></expr> </then><else>: <expr><literal type="string">"NO"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>equote</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Remove irrelevant chars from encoding name and turn it uppercase.
 *
 * Return a buffer allocated on Python heap into 'clean' and return 0 on
 * success, otherwise return -1 and set an exception.
 */</comment>
<function><type><name>RAISES_NEG</name> <specifier>static</specifier> <name>int</name></type>
<name>clear_encoding_name</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>clean</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>i</name> <init>= <expr><name>enc</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>j</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rv</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* convert to upper case and remove '-' and '_' from string */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>j</name> <operator>=</operator> <name>buf</name> <operator>=</operator> <call><name>PyMem_Malloc</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>exit</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <while>while <condition>(<expr><operator>*</operator><name>i</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isalnum</name><argument_list>(<argument><expr><operator>*</operator><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><operator>++</operator><name>i</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>j</name><operator>++</operator> <operator>=</operator> <call><name>toupper</name><argument_list>(<argument><expr><operator>*</operator><name>i</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><operator>*</operator><name>j</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"clear_encoding_name: %s -&gt; %s"</literal></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>clean</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rv</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<label><name>exit</name>:</label>
    <return>return <expr><name>rv</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* set fast access functions according to the currently selected encoding
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>conn_set_fast_codec</name><parameter_list>(<parameter><decl><type><name>connectionObject</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"conn_set_fast_codec: encoding=%s"</literal></expr></argument>, <argument><expr><name><name>self</name><operator>-&gt;</operator><name>encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>encoding</name></name></expr></argument>, <argument><expr><literal type="string">"UTF8"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"conn_set_fast_codec: PyUnicode_DecodeUTF8"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>cdecoder</name></name> <operator>=</operator> <name>PyUnicode_DecodeUTF8</name></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>encoding</name></name></expr></argument>, <argument><expr><literal type="string">"LATIN1"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"conn_set_fast_codec: PyUnicode_DecodeLatin1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>cdecoder</name></name> <operator>=</operator> <name>PyUnicode_DecodeLatin1</name></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"conn_set_fast_codec: no fast codec"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>cdecoder</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* Return the Python encoding from a PostgreSQL encoding.
 *
 * Optionally return the clean version of the postgres encoding too
 */</comment>
<function><type><name>PyObject</name> <modifier>*</modifier></type>
<name>conn_pgenc_to_pyenc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>encoding</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>clean_encoding</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pgenc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>rv</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&gt;</operator> <call><name>clear_encoding_name</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pgenc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> <goto>goto <name>exit</name>;</goto> </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>rv</name> <operator>=</operator> <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>psycoEncodings</name></expr></argument>, <argument><expr><name>pgenc</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>OperationalError</name></expr></argument>,
            <argument><expr><literal type="string">"no Python encoding for PostgreSQL encoding '%s'"</literal></expr></argument>, <argument><expr><name>pgenc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>exit</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>clean_encoding</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>clean_encoding</name> <operator>=</operator> <name>pgenc</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>pgenc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

<label><name>exit</name>:</label>
    <return>return <expr><name>rv</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Convert a Postgres encoding into Python encoding and decoding functions.
 *
 * Set clean_encoding to a clean version of the Postgres encoding name
 * and pyenc and pydec to python codec functions.
 *
 * Return 0 on success, else -1 and set an exception.
 */</comment>
<function><type><name>RAISES_NEG</name> <specifier>static</specifier> <name>int</name></type>
<name>conn_get_python_codec</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>encoding</name></decl></parameter>,
    <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>clean_encoding</name></decl></parameter>, <parameter><decl><type><name>PyObject</name> <modifier>*</modifier><modifier>*</modifier></type><name>pyenc</name></decl></parameter>, <parameter><decl><type><name>PyObject</name> <modifier>*</modifier><modifier>*</modifier></type><name>pydec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rv</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pgenc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>encname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>enc_tmp</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>dec_tmp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* get the Python name of the encoding as a C string */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>encname</name> <operator>=</operator> <call><name>conn_pgenc_to_pyenc</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pgenc</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content> <goto>goto <name>exit</name>;</goto> </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>encname</name> <operator>=</operator> <call><name>psyco_ensure_bytes</name><argument_list>(<argument><expr><name>encname</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content> <goto>goto <name>exit</name>;</goto> </block_content>}</block></if></if_stmt>

    <comment type="block">/* Look up the codec functions */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>enc_tmp</name> <operator>=</operator> <call><name>PyCodec_Encoder</name><argument_list>(<argument><expr><call><name>Bytes_AS_STRING</name><argument_list>(<argument><expr><name>encname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content> <goto>goto <name>exit</name>;</goto> </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>dec_tmp</name> <operator>=</operator> <call><name>PyCodec_Decoder</name><argument_list>(<argument><expr><call><name>Bytes_AS_STRING</name><argument_list>(<argument><expr><name>encname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content> <goto>goto <name>exit</name>;</goto> </block_content>}</block></if></if_stmt>

    <comment type="block">/* success */</comment>
    <expr_stmt><expr><operator>*</operator><name>pyenc</name> <operator>=</operator> <name>enc_tmp</name></expr>;</expr_stmt> <expr_stmt><expr><name>enc_tmp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pydec</name> <operator>=</operator> <name>dec_tmp</name></expr>;</expr_stmt> <expr_stmt><expr><name>dec_tmp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>clean_encoding</name> <operator>=</operator> <name>pgenc</name></expr>;</expr_stmt> <expr_stmt><expr><name>pgenc</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rv</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<label><name>exit</name>:</label>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>enc_tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>dec_tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>encname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>pgenc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>rv</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Store the encoding in the pgconn-&gt;encoding field and set the other related
 * encoding fields in the connection structure.
 *
 * Return 0 on success, else -1 and set an exception.
 */</comment>
<function><type><name>RAISES_NEG</name> <specifier>static</specifier> <name>int</name></type>
<name>conn_store_encoding</name><parameter_list>(<parameter><decl><type><name>connectionObject</name> <modifier>*</modifier></type><name>self</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>encoding</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rv</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pgenc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>enc_tmp</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>dec_tmp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&gt;</operator> <call><name>conn_get_python_codec</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pgenc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>enc_tmp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dec_tmp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <goto>goto <name>exit</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Good, success: store the encoding/codec in the connection. */</comment>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><name><name>self</name><operator>-&gt;</operator><name>encoding</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>encoding</name></name> <operator>=</operator> <name>pgenc</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pgenc</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block>

    <expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>pyencoder</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>pyencoder</name></name> <operator>=</operator> <name>enc_tmp</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>enc_tmp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>pydecoder</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>pydecoder</name></name> <operator>=</operator> <name>dec_tmp</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>dec_tmp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>conn_set_fast_codec</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rv</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<label><name>exit</name>:</label>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>enc_tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>dec_tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>pgenc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>rv</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Read the client encoding from the backend and store it in the connection.
 *
 * Return 0 on success, else -1.
 */</comment>
<function><type><name>RAISES_NEG</name> <specifier>static</specifier> <name>int</name></type>
<name>conn_read_encoding</name><parameter_list>(<parameter><decl><type><name>connectionObject</name> <modifier>*</modifier></type><name>self</name></decl></parameter>, <parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>pgconn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>encoding</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rv</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>encoding</name> <operator>=</operator> <call><name>PQparameterStatus</name><argument_list>(<argument><expr><name>pgconn</name></expr></argument>, <argument><expr><literal type="string">"client_encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"conn_connect: client encoding: %s"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>encoding</name></expr> ?</condition><then> <expr><name>encoding</name></expr> </then><else>: <expr><literal type="string">"(none)"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>encoding</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>OperationalError</name></expr></argument>,
            <argument><expr><literal type="string">"server didn't return client encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>exit</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&gt;</operator> <call><name>conn_store_encoding</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <goto>goto <name>exit</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>rv</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<label><name>exit</name>:</label>
    <return>return <expr><name>rv</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>int</name></type>
<name>conn_get_protocol_version</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>pgconn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>PQprotocolVersion</name><argument_list>(<argument><expr><name>pgconn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"conn_connect: using protocol %d"</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>conn_get_server_version</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>pgconn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>PQserverVersion</name><argument_list>(<argument><expr><name>pgconn</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* set up the cancel key of the connection.
 * On success return 0, else set an exception and return -1
 */</comment>
<function><type><name>RAISES_NEG</name> <specifier>static</specifier> <name>int</name></type>
<name>conn_setup_cancel</name><parameter_list>(<parameter><decl><type><name>connectionObject</name> <modifier>*</modifier></type><name>self</name></decl></parameter>, <parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>pgconn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>self</name><operator>-&gt;</operator><name>cancel</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>PQfreeCancel</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>cancel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>self</name><operator>-&gt;</operator><name>cancel</name></name> <operator>=</operator> <call><name>PQgetCancel</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>OperationalError</name></expr></argument>, <argument><expr><literal type="string">"can't get cancellation key"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return 1 if the "replication" keyword is set in the DSN, 0 otherwise */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>dsn_has_replication</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>pgdsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PQconninfoOption</name> <modifier>*</modifier></type><name>connopts</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>connopts</name> <operator>=</operator> <call><name>PQconninfoParse</name><argument_list>(<argument><expr><name>pgdsn</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for<control>(<init><expr><name>ptr</name> <operator>=</operator> <name>connopts</name></expr>;</init> <condition><expr><name><name>ptr</name><operator>-&gt;</operator><name>keyword</name></name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>ptr</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <if_stmt><if>if<condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>keyword</name></name></expr></argument>, <argument><expr><literal type="string">"replication"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>ptr</name><operator>-&gt;</operator><name>val</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>PQconninfoFree</name><argument_list>(<argument><expr><name>connopts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Return 1 if the server datestyle allows us to work without problems,
   0 if it needs to be set to something better, e.g. ISO. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>conn_is_datestyle_ok</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>pgconn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ds</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>ds</name> <operator>=</operator> <call><name>PQparameterStatus</name><argument_list>(<argument><expr><name>pgconn</name></expr></argument>, <argument><expr><literal type="string">"DateStyle"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"conn_connect: DateStyle %s"</literal></expr></argument>, <argument><expr><name>ds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* pgbouncer does not pass on DateStyle */</comment>
    <if_stmt><if>if <condition>(<expr><name>ds</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Return true if ds starts with "ISO"
     * e.g. "ISO, DMY" is fine, "German" not. */</comment>
    <return>return <expr><operator>(</operator><name><name>ds</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'I'</literal> <operator>&amp;&amp;</operator> <name><name>ds</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'S'</literal> <operator>&amp;&amp;</operator> <name><name>ds</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'O'</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* conn_setup - setup and read basic information about the connection */</comment>

<function><type><name>RAISES_NEG</name> <name>int</name></type>
<name>conn_setup</name><parameter_list>(<parameter><decl><type><name>connectionObject</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rv</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>equote</name></name> <operator>=</operator> <call><name>conn_get_standard_conforming_strings</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>server_version</name></name> <operator>=</operator> <call><name>conn_get_server_version</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>protocol</name></name> <operator>=</operator> <call><name>conn_get_protocol_version</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><literal type="number">3</literal> <operator>!=</operator> <name><name>self</name><operator>-&gt;</operator><name>protocol</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>InterfaceError</name></expr></argument>, <argument><expr><literal type="string">"only protocol 3 supported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>exit</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&gt;</operator> <call><name>conn_read_encoding</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name><name>self</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <goto>goto <name>exit</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&gt;</operator> <call><name>conn_setup_cancel</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name><name>self</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <goto>goto <name>exit</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>Py_BEGIN_ALLOW_THREADS</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>self</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>Py_BLOCK_THREADS</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>dsn_has_replication</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>dsn</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>conn_is_datestyle_ok</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>Py_UNBLOCK_THREADS</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pq_set_guc_locked</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><literal type="string">"datestyle"</literal></expr></argument>, <argument><expr><literal type="string">"ISO"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>_save</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>Py_BLOCK_THREADS</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>res</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>pq_complete_error</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>unlock</name>;</goto>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* for reset */</comment>
    <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>autocommit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>isolevel</name></name> <operator>=</operator> <name>ISOLATION_LEVEL_DEFAULT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>readonly</name></name> <operator>=</operator> <name>STATE_DEFAULT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>deferrable</name></name> <operator>=</operator> <name>STATE_DEFAULT</name></expr>;</expr_stmt>

    <comment type="block">/* success */</comment>
    <expr_stmt><expr><name>rv</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<label><name>unlock</name>:</label>
    <expr_stmt><expr><name>Py_UNBLOCK_THREADS</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>self</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>Py_END_ALLOW_THREADS</name></expr>;</expr_stmt>

<label><name>exit</name>:</label>
    <return>return <expr><name>rv</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* conn_connect - execute a connection to the database */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>_conn_sync_connect</name><parameter_list>(<parameter><decl><type><name>connectionObject</name> <modifier>*</modifier></type><name>self</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>green</name></decl>;</decl_stmt>

    <comment type="block">/* store this value to prevent inconsistencies due to a change
     * in the middle of the function. */</comment>
    <expr_stmt><expr><name>green</name> <operator>=</operator> <call><name>psyco_green</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>green</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>Py_BEGIN_ALLOW_THREADS</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>pgconn</name></name> <operator>=</operator> <call><name>PQconnectdb</name><argument_list>(<argument><expr><name>dsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>Py_END_ALLOW_THREADS</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"conn_connect: new PG connection at %p"</literal></expr></argument>, <argument><expr><name><name>self</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else <block>{<block_content>
        <expr_stmt><expr><name>Py_BEGIN_ALLOW_THREADS</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>pgconn</name></name> <operator>=</operator> <call><name>PQconnectStart</name><argument_list>(<argument><expr><name>dsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>Py_END_ALLOW_THREADS</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"conn_connect: new green PG connection at %p"</literal></expr></argument>, <argument><expr><name><name>self</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>self</name><operator>-&gt;</operator><name>pgconn</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"conn_connect: PQconnectdb(%s) FAILED"</literal></expr></argument>, <argument><expr><name>dsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>OperationalError</name></expr></argument>, <argument><expr><literal type="string">"PQconnectdb() failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>PQstatus</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CONNECTION_BAD</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"conn_connect: PQconnectdb(%s) returned BAD"</literal></expr></argument>, <argument><expr><name>dsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>OperationalError</name></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>PQsetNoticeProcessor</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>, <argument><expr><name>conn_notice_callback</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* if the connection is green, wait to finish connection */</comment>
    <if_stmt><if>if <condition>(<expr><name>green</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&gt;</operator> <call><name>pq_set_non_blocking</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>!=</operator> <call><name>psyco_wait</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* From here the connection is considered ready: with the new status,
     * poll() will use PQisBusy instead of PQconnectPoll.
     */</comment>
    <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONN_STATUS_READY</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>conn_setup</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>_conn_async_connect</name><parameter_list>(<parameter><decl><type><name>connectionObject</name> <modifier>*</modifier></type><name>self</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>pgconn</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>pgconn</name></name> <operator>=</operator> <name>pgconn</name> <operator>=</operator> <call><name>PQconnectStart</name><argument_list>(<argument><expr><name>dsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"conn_connect: new postgresql connection at %p"</literal></expr></argument>, <argument><expr><name>pgconn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>pgconn</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"conn_connect: PQconnectStart(%s) FAILED"</literal></expr></argument>, <argument><expr><name>dsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>OperationalError</name></expr></argument>, <argument><expr><literal type="string">"PQconnectStart() failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>PQstatus</name><argument_list>(<argument><expr><name>pgconn</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CONNECTION_BAD</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"conn_connect: PQconnectdb(%s) returned BAD"</literal></expr></argument>, <argument><expr><name>dsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>OperationalError</name></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>pgconn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>PQsetNoticeProcessor</name><argument_list>(<argument><expr><name>pgconn</name></expr></argument>, <argument><expr><name>conn_notice_callback</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Set the connection to nonblocking now. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>pq_set_non_blocking</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* The connection will be completed banging on poll():
     * First with _conn_poll_connecting() that will finish connection,
     * then with _conn_poll_setup_async() that will do the same job
     * of setup_async(). */</comment>

    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>conn_connect</name><parameter_list>(<parameter><decl><type><name>connectionObject</name> <modifier>*</modifier></type><name>self</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dsn</name></decl></parameter>, <parameter><decl><type><name>long</name> <name>int</name></type> <name>async</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>async</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"con_connect: connecting in ASYNC mode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>_conn_async_connect</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>dsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else <block>{<block_content>
      <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"con_connect: connecting in SYNC mode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>_conn_sync_connect</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>dsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* connection failed, so let's close ourselves */</comment>
        <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>closed</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>rv</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* poll during a connection attempt until the connection has established. */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>_conn_poll_connecting</name><parameter_list>(<parameter><decl><type><name>connectionObject</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><name>PSYCO_POLL_ERROR</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"conn_poll: poll connecting"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <switch>switch <condition>(<expr><call><name>PQconnectPoll</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>PGRES_POLLING_OK</name></expr>:</case>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <name>PSYCO_POLL_OK</name></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>PGRES_POLLING_READING</name></expr>:</case>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <name>PSYCO_POLL_READ</name></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>PGRES_POLLING_WRITING</name></expr>:</case>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <name>PSYCO_POLL_WRITE</name></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>PGRES_POLLING_FAILED</name></expr>:</case>
    <case>case <expr><name>PGRES_POLLING_ACTIVE</name></expr>:</case>
        <expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>msg</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>msg</name><operator>)</operator></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>msg</name> <operator>=</operator> <literal type="string">"asynchronous connection failed"</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>OperationalError</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <name>PSYCO_POLL_ERROR</name></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>

    <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Advance to the next state after an attempt of flushing output */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>_conn_poll_advance_write</name><parameter_list>(<parameter><decl><type><name>connectionObject</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>flush</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"conn_poll: poll writing"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>flush</name> <operator>=</operator> <call><name>PQflush</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"conn_poll: PQflush() = %i"</literal></expr></argument>, <argument><expr><name>flush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <switch>switch <condition>(<expr><name>flush</name></expr>)</condition> <block>{<block_content>
    <case>case  <expr><literal type="number">0</literal></expr>:</case>  <comment type="block">/* success */</comment>
        <comment type="block">/* we've finished pushing the query to the server. Let's start
          reading the results. */</comment>
        <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"conn_poll: async_status -&gt; ASYNC_READ"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>async_status</name></name> <operator>=</operator> <name>ASYNC_READ</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <name>PSYCO_POLL_READ</name></expr>;</expr_stmt>
        <break>break;</break>
    <case>case  <expr><literal type="number">1</literal></expr>:</case>  <comment type="block">/* would block */</comment>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <name>PSYCO_POLL_WRITE</name></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><operator>-</operator><literal type="number">1</literal></expr>:</case>  <comment type="block">/* error */</comment>
        <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>OperationalError</name></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <name>PSYCO_POLL_ERROR</name></expr>;</expr_stmt>
        <break>break;</break>
    <default>default:</default>
        <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"conn_poll: unexpected result from flush: %d"</literal></expr></argument>, <argument><expr><name>flush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <name>PSYCO_POLL_ERROR</name></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>
    <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Advance to the next state after reading results */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>_conn_poll_advance_read</name><parameter_list>(<parameter><decl><type><name>connectionObject</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>busy</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"conn_poll: poll reading"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>busy</name> <operator>=</operator> <call><name>pq_get_result_async</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <switch>switch <condition>(<expr><name>busy</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><literal type="number">0</literal></expr>:</case> <comment type="block">/* result is ready */</comment>
        <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"conn_poll: async_status -&gt; ASYNC_DONE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>async_status</name></name> <operator>=</operator> <name>ASYNC_DONE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <name>PSYCO_POLL_OK</name></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><literal type="number">1</literal></expr>:</case> <comment type="block">/* result not ready: fd would block */</comment>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <name>PSYCO_POLL_READ</name></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><operator>-</operator><literal type="number">1</literal></expr>:</case> <comment type="block">/* ouch, error */</comment>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <name>PSYCO_POLL_ERROR</name></expr>;</expr_stmt>
        <break>break;</break>
    <default>default:</default>
        <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"conn_poll: unexpected result from pq_get_result_async: %d"</literal></expr></argument>,
            <argument><expr><name>busy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <name>PSYCO_POLL_ERROR</name></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>
    <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Poll the connection for the send query/retrieve result phase

  Advance the async_status (usually going WRITE -&gt; READ -&gt; DONE) but don't
  mess with the connection status. */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>_conn_poll_query</name><parameter_list>(<parameter><decl><type><name>connectionObject</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><name>PSYCO_POLL_ERROR</name></expr></init></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name><name>self</name><operator>-&gt;</operator><name>async_status</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>ASYNC_WRITE</name></expr>:</case>
        <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"conn_poll: async_status = ASYNC_WRITE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>_conn_poll_advance_write</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

    <case>case <expr><name>ASYNC_READ</name></expr>:</case>
        <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"conn_poll: async_status = ASYNC_READ"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>_conn_poll_advance_read</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

    <case>case <expr><name>ASYNC_DONE</name></expr>:</case>
        <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"conn_poll: async_status = ASYNC_DONE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* We haven't asked anything: just check for notifications. */</comment>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>_conn_poll_advance_read</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

    <default>default:</default>
        <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"conn_poll: in unexpected async status: %d"</literal></expr></argument>,
                <argument><expr><name><name>self</name><operator>-&gt;</operator><name>async_status</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <name>PSYCO_POLL_ERROR</name></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>

    <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Advance to the next state during an async connection setup
 *
 * If the connection is green, this is performed by the regular
 * sync code so the queries are sent by conn_setup() while in
 * CONN_STATUS_READY state.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>_conn_poll_setup_async</name><parameter_list>(<parameter><decl><type><name>connectionObject</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><name>PSYCO_POLL_ERROR</name></expr></init></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name><name>self</name><operator>-&gt;</operator><name>status</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>CONN_STATUS_CONNECTING</name></expr>:</case>
        <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>equote</name></name> <operator>=</operator> <call><name>conn_get_standard_conforming_strings</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>protocol</name></name> <operator>=</operator> <call><name>conn_get_protocol_version</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>server_version</name></name> <operator>=</operator> <call><name>conn_get_server_version</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><literal type="number">3</literal> <operator>!=</operator> <name><name>self</name><operator>-&gt;</operator><name>protocol</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>InterfaceError</name></expr></argument>, <argument><expr><literal type="string">"only protocol 3 supported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&gt;</operator> <call><name>conn_read_encoding</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name><name>self</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&gt;</operator> <call><name>conn_setup_cancel</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name><name>self</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* asynchronous connections always use isolation level 0, the user is
         * expected to manage the transactions himself, by sending
         * (asynchronously) BEGIN and COMMIT statements.
         */</comment>
        <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>autocommit</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

        <comment type="block">/* If the datestyle is ISO or anything else good,
         * we can skip the CONN_STATUS_DATESTYLE step.
         * Note that we cannot change the datestyle on a replication
         * connection.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>dsn_has_replication</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>dsn</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>conn_is_datestyle_ok</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"conn_poll: status -&gt; CONN_STATUS_DATESTYLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONN_STATUS_DATESTYLE</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <call><name>pq_send_query</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>psyco_datestyle</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>OperationalError</name></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"conn_poll: async_status -&gt; ASYNC_WRITE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>async_status</name></name> <operator>=</operator> <name>ASYNC_WRITE</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>res</name> <operator>=</operator> <name>PSYCO_POLL_WRITE</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"conn_poll: status -&gt; CONN_STATUS_READY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONN_STATUS_READY</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>res</name> <operator>=</operator> <name>PSYCO_POLL_OK</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <break>break;</break>

    <case>case <expr><name>CONN_STATUS_DATESTYLE</name></expr>:</case>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>_conn_poll_query</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>PSYCO_POLL_OK</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>res</name> <operator>=</operator> <name>PSYCO_POLL_ERROR</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>self</name><operator>-&gt;</operator><name>pgres</name></name> <operator>==</operator> <name>NULL</name>
                    <operator>||</operator> <call><name>PQresultStatus</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>pgres</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COMMAND_OK</name></expr> )</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>OperationalError</name></expr></argument>, <argument><expr><literal type="string">"can't set datestyle to ISO"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>CLEARPGRES</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>pgres</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"conn_poll: status -&gt; CONN_STATUS_READY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONN_STATUS_READY</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>res</name> <operator>=</operator> <name>PSYCO_POLL_OK</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <break>break;</break>
    </block_content>}</block></switch>
    <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>cursorObject</name> <modifier>*</modifier></type>
<name>_conn_get_async_cursor</name><parameter_list>(<parameter><decl><type><name>connectionObject</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>py_curs</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>py_curs</name> <operator>=</operator> <call><name>PyWeakref_GetObject</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>async_cursor</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
            <argument><expr><literal type="string">"got null dereferencing cursor weakref"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>error</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>Py_None</name> <operator>==</operator> <name>py_curs</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>InterfaceError</name></expr></argument>,
            <argument><expr><literal type="string">"the asynchronous cursor has disappeared"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>error</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>py_curs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>(</operator><name>cursorObject</name> <operator>*</operator><operator>)</operator><name>py_curs</name></expr>;</return>

<label><name>error</name>:</label>
    <expr_stmt><expr><call><name>pq_clear_async</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* conn_poll - Main polling switch
 *
 * The function is called in all the states and connection types and invokes
 * the right "next step".
 */</comment>

<function><type><name>int</name></type>
<name>conn_poll</name><parameter_list>(<parameter><decl><type><name>connectionObject</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><name>PSYCO_POLL_ERROR</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"conn_poll: status = %d"</literal></expr></argument>, <argument><expr><name><name>self</name><operator>-&gt;</operator><name>status</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <switch>switch <condition>(<expr><name><name>self</name><operator>-&gt;</operator><name>status</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>CONN_STATUS_SETUP</name></expr>:</case>
        <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"conn_poll: status -&gt; CONN_STATUS_SETUP"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONN_STATUS_CONNECTING</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <name>PSYCO_POLL_WRITE</name></expr>;</expr_stmt>
        <break>break;</break>

    <case>case <expr><name>CONN_STATUS_CONNECTING</name></expr>:</case>
        <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"conn_poll: status -&gt; CONN_STATUS_CONNECTING"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>_conn_poll_connecting</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>PSYCO_POLL_OK</name> <operator>&amp;&amp;</operator> <name><name>self</name><operator>-&gt;</operator><name>async</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>_conn_poll_setup_async</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <break>break;</break>

    <case>case <expr><name>CONN_STATUS_DATESTYLE</name></expr>:</case>
        <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"conn_poll: status -&gt; CONN_STATUS_DATESTYLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>_conn_poll_setup_async</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

    <case>case <expr><name>CONN_STATUS_READY</name></expr>:</case>
    <case>case <expr><name>CONN_STATUS_BEGIN</name></expr>:</case>
    <case>case <expr><name>CONN_STATUS_PREPARED</name></expr>:</case>
        <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"conn_poll: status -&gt; CONN_STATUS_*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>_conn_poll_query</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>PSYCO_POLL_OK</name> <operator>&amp;&amp;</operator> <name><name>self</name><operator>-&gt;</operator><name>async</name></name> <operator>&amp;&amp;</operator> <name><name>self</name><operator>-&gt;</operator><name>async_cursor</name></name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>cursorObject</name> <modifier>*</modifier></type><name>curs</name></decl>;</decl_stmt>

            <comment type="block">/* An async query has just finished: parse the tuple in the
             * target cursor. */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>curs</name> <operator>=</operator> <call><name>_conn_get_async_cursor</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>res</name> <operator>=</operator> <name>PSYCO_POLL_ERROR</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>curs_set_result</name><argument_list>(<argument><expr><name>curs</name></expr></argument>, <argument><expr><name><name>self</name><operator>-&gt;</operator><name>pgres</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>pgres</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

            <comment type="block">/* fetch the tuples (if there are any) and build the result. We
             * don't care if pq_fetch return 0 or 1, but if there was an error,
             * we want to signal it to the caller. */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>pq_fetch</name><argument_list>(<argument><expr><name>curs</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
               <expr_stmt><expr><name>res</name> <operator>=</operator> <name>PSYCO_POLL_ERROR</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* We have finished with our async_cursor */</comment>
            <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>curs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>async_cursor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <break>break;</break>

    <default>default:</default>
        <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"conn_poll: in unexpected state"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <name>PSYCO_POLL_ERROR</name></expr>;</expr_stmt>
    </block_content>}</block></switch>

    <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"conn_poll: returning %d"</literal></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* conn_close - do anything needed to shut down the connection */</comment>

<function><type><name>void</name></type>
<name>conn_close</name><parameter_list>(<parameter><decl><type><name>connectionObject</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* a connection with closed == 2 still requires cleanup */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>self</name><operator>-&gt;</operator><name>closed</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* sets this connection as closed even for other threads; */</comment>
    <expr_stmt><expr><name>Py_BEGIN_ALLOW_THREADS</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>self</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>conn_close_locked</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>self</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>Py_END_ALLOW_THREADS</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* Return a copy of the 'dsn' string with the password scrubbed.
 *
 * The string returned is allocated on the Python heap.
 *
 * In case of error return NULL and raise an exception.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>conn_obscure_password</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PQconninfoOption</name> <modifier>*</modifier></type><name>options</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>d</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>v</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pydsn</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>rv</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>dsn</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>InternalError</name></expr></argument>, <argument><expr><literal type="string">"unexpected null string"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>exit</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>options</name> <operator>=</operator> <call><name>PQconninfoParse</name><argument_list>(<argument><expr><name>dsn</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
        <comment type="block">/* unlikely: the dsn was already tested valid */</comment>
        <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>InternalError</name></expr></argument>, <argument><expr><literal type="string">"the connection string is not valid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>exit</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>d</name> <operator>=</operator> <call><name>psyco_dict_from_conninfo_options</name><argument_list>(
            <argument><expr><name>options</name></expr></argument>, <comment type="block">/* include_password = */</comment> <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
        <goto>goto <name>exit</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><literal type="string">"password"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <comment type="block">/* the dsn doesn't have a password */</comment>
        <expr_stmt><expr><call><name>psyco_strdup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rv</name></expr></argument>, <argument><expr><name>dsn</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>exit</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* scrub the password and put back the connection string together */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>v</name> <operator>=</operator> <call><name>Text_FromUTF8</name><argument_list>(<argument><expr><literal type="string">"xxx"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content> <goto>goto <name>exit</name>;</goto> </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&gt;</operator> <call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><literal type="string">"password"</literal></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> <goto>goto <name>exit</name>;</goto> </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>pydsn</name> <operator>=</operator> <call><name>psyco_make_dsn</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content> <goto>goto <name>exit</name>;</goto> </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>pydsn</name> <operator>=</operator> <call><name>psyco_ensure_bytes</name><argument_list>(<argument><expr><name>pydsn</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content> <goto>goto <name>exit</name>;</goto> </block_content>}</block></if></if_stmt>

    <comment type="block">/* Return the connection string with the password replaced */</comment>
    <expr_stmt><expr><call><name>psyco_strdup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rv</name></expr></argument>, <argument><expr><call><name>Bytes_AS_STRING</name><argument_list>(<argument><expr><name>pydsn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>exit</name>:</label>
    <expr_stmt><expr><call><name>PQconninfoFree</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>pydsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>rv</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* conn_close_locked - shut down the connection with the lock already taken */</comment>

<function><type><name>void</name></type> <name>conn_close_locked</name><parameter_list>(<parameter><decl><type><name>connectionObject</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>self</name><operator>-&gt;</operator><name>closed</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* We used to call pq_abort_locked here, but the idea of issuing a
     * rollback on close/GC has been considered inappropriate.
     *
     * Dropping the connection on the server has the same effect as the
     * transaction is automatically rolled back. Some middleware, such as
     * PgBouncer, have problem with connections closed in the middle of the
     * transaction though: to avoid these problems the transaction should be
     * closed only in status CONN_STATUS_READY.
     */</comment>
    <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>closed</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <comment type="block">/* we need to check the value of pgconn, because we get called even when
     * the connection fails! */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>self</name><operator>-&gt;</operator><name>pgconn</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>pgconn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>pgconn</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"conn_close: PQfinish called"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* conn_commit - commit on a connection */</comment>

<function><type><name>RAISES_NEG</name> <name>int</name></type>
<name>conn_commit</name><parameter_list>(<parameter><decl><type><name>connectionObject</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pq_commit</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* conn_rollback - rollback a connection */</comment>

<function><type><name>RAISES_NEG</name> <name>int</name></type>
<name>conn_rollback</name><parameter_list>(<parameter><decl><type><name>connectionObject</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pq_abort</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Change the state of the session */</comment>
<function><type><name>RAISES_NEG</name> <name>int</name></type>
<name>conn_set_session</name><parameter_list>(<parameter><decl><type><name>connectionObject</name> <modifier>*</modifier></type><name>self</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>autocommit</name></decl></parameter>,
        <parameter><decl><type><name>int</name></type> <name>isolevel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>readonly</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>deferrable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rv</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>want_autocommit</name> <init>= <expr><ternary><condition><expr><name>autocommit</name> <operator>==</operator> <name>SRV_STATE_UNCHANGED</name></expr> ?</condition><then>
        <expr><name><name>self</name><operator>-&gt;</operator><name>autocommit</name></name></expr> </then><else>: <expr><name>autocommit</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>deferrable</name> <operator>!=</operator> <name>SRV_STATE_UNCHANGED</name> <operator>&amp;&amp;</operator> <name><name>self</name><operator>-&gt;</operator><name>server_version</name></name> <operator>&lt;</operator> <literal type="number">90100</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>ProgrammingError</name></expr></argument>,
            <argument><expr><literal type="string">"the 'deferrable' setting is only available"</literal>
            <literal type="string">" from PostgreSQL 9.1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>exit</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Promote an isolation level to one of the levels supported by the server */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>self</name><operator>-&gt;</operator><name>server_version</name></name> <operator>&lt;</operator> <literal type="number">80000</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>isolevel</name> <operator>==</operator> <name>ISOLATION_LEVEL_READ_UNCOMMITTED</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>isolevel</name> <operator>=</operator> <name>ISOLATION_LEVEL_READ_COMMITTED</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>isolevel</name> <operator>==</operator> <name>ISOLATION_LEVEL_REPEATABLE_READ</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>isolevel</name> <operator>=</operator> <name>ISOLATION_LEVEL_SERIALIZABLE</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>Py_BEGIN_ALLOW_THREADS</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>self</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>want_autocommit</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* we are or are going in autocommit state, so no BEGIN will be issued:
         * configure the session with the characteristics requested */</comment>
        <if_stmt><if>if <condition>(<expr><name>isolevel</name> <operator>!=</operator> <name>SRV_STATE_UNCHANGED</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&gt;</operator> <call><name>pq_set_guc_locked</name><argument_list>(<argument><expr><name>self</name></expr></argument>,
                    <argument><expr><literal type="string">"default_transaction_isolation"</literal></expr></argument>, <argument><expr><name><name>srv_isolevels</name><index>[<expr><name>isolevel</name></expr>]</index></name></expr></argument>,
                    <argument><expr><operator>&amp;</operator><name>_save</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <goto>goto <name>endlock</name>;</goto>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>readonly</name> <operator>!=</operator> <name>SRV_STATE_UNCHANGED</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&gt;</operator> <call><name>pq_set_guc_locked</name><argument_list>(<argument><expr><name>self</name></expr></argument>,
                    <argument><expr><literal type="string">"default_transaction_read_only"</literal></expr></argument>, <argument><expr><name><name>srv_state_guc</name><index>[<expr><name>readonly</name></expr>]</index></name></expr></argument>,
                    <argument><expr><operator>&amp;</operator><name>_save</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <goto>goto <name>endlock</name>;</goto>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>deferrable</name> <operator>!=</operator> <name>SRV_STATE_UNCHANGED</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&gt;</operator> <call><name>pq_set_guc_locked</name><argument_list>(<argument><expr><name>self</name></expr></argument>,
                    <argument><expr><literal type="string">"default_transaction_deferrable"</literal></expr></argument>, <argument><expr><name><name>srv_state_guc</name><index>[<expr><name>deferrable</name></expr>]</index></name></expr></argument>,
                    <argument><expr><operator>&amp;</operator><name>_save</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <goto>goto <name>endlock</name>;</goto>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>self</name><operator>-&gt;</operator><name>autocommit</name></name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* we are moving from autocommit to not autocommit, so revert the
         * characteristics to defaults to let BEGIN do its work */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>self</name><operator>-&gt;</operator><name>isolevel</name></name> <operator>!=</operator> <name>ISOLATION_LEVEL_DEFAULT</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&gt;</operator> <call><name>pq_set_guc_locked</name><argument_list>(<argument><expr><name>self</name></expr></argument>,
                    <argument><expr><literal type="string">"default_transaction_isolation"</literal></expr></argument>, <argument><expr><literal type="string">"default"</literal></expr></argument>,
                    <argument><expr><operator>&amp;</operator><name>_save</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <goto>goto <name>endlock</name>;</goto>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>self</name><operator>-&gt;</operator><name>readonly</name></name> <operator>!=</operator> <name>STATE_DEFAULT</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&gt;</operator> <call><name>pq_set_guc_locked</name><argument_list>(<argument><expr><name>self</name></expr></argument>,
                    <argument><expr><literal type="string">"default_transaction_read_only"</literal></expr></argument>, <argument><expr><literal type="string">"default"</literal></expr></argument>,
                    <argument><expr><operator>&amp;</operator><name>_save</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <goto>goto <name>endlock</name>;</goto>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>self</name><operator>-&gt;</operator><name>server_version</name></name> <operator>&gt;=</operator> <literal type="number">90100</literal> <operator>&amp;&amp;</operator> <name><name>self</name><operator>-&gt;</operator><name>deferrable</name></name> <operator>!=</operator> <name>STATE_DEFAULT</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&gt;</operator> <call><name>pq_set_guc_locked</name><argument_list>(<argument><expr><name>self</name></expr></argument>,
                    <argument><expr><literal type="string">"default_transaction_deferrable"</literal></expr></argument>, <argument><expr><literal type="string">"default"</literal></expr></argument>,
                    <argument><expr><operator>&amp;</operator><name>_save</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <goto>goto <name>endlock</name>;</goto>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>autocommit</name> <operator>!=</operator> <name>SRV_STATE_UNCHANGED</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>autocommit</name></name> <operator>=</operator> <name>autocommit</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>isolevel</name> <operator>!=</operator> <name>SRV_STATE_UNCHANGED</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>isolevel</name></name> <operator>=</operator> <name>isolevel</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>readonly</name> <operator>!=</operator> <name>SRV_STATE_UNCHANGED</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>readonly</name></name> <operator>=</operator> <name>readonly</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>deferrable</name> <operator>!=</operator> <name>SRV_STATE_UNCHANGED</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>deferrable</name></name> <operator>=</operator> <name>deferrable</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>rv</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<label><name>endlock</name>:</label>
    <expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>self</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>Py_END_ALLOW_THREADS</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>rv</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>pq_complete_error</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>exit</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>Dprintf</name><argument_list>(
        <argument><expr><literal type="string">"conn_set_session: autocommit %d, isolevel %d, readonly %d, deferrable %d"</literal></expr></argument>,
        <argument><expr><name>autocommit</name></expr></argument>, <argument><expr><name>isolevel</name></expr></argument>, <argument><expr><name>readonly</name></expr></argument>, <argument><expr><name>deferrable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<label><name>exit</name>:</label>
    <return>return <expr><name>rv</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* conn_set_client_encoding - switch client encoding on connection */</comment>

<function><type><name>RAISES_NEG</name> <name>int</name></type>
<name>conn_set_client_encoding</name><parameter_list>(<parameter><decl><type><name>connectionObject</name> <modifier>*</modifier></type><name>self</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pgenc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>clean_enc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* We must know what python encoding this encoding is. */</comment>
    <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&gt;</operator> <call><name>clear_encoding_name</name><argument_list>(<argument><expr><name>pgenc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>clean_enc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> <goto>goto <name>exit</name>;</goto> </block_content>}</block></if></if_stmt>

    <comment type="block">/* If the current encoding is equal to the requested one we don't
       issue any query to the backend */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>encoding</name></name></expr></argument>, <argument><expr><name>clean_enc</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <goto>goto <name>exit</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>Py_BEGIN_ALLOW_THREADS</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>self</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* abort the current transaction, to set the encoding ouside of
       transactions */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>pq_abort_locked</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>_save</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
        <goto>goto <name>endlock</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>pq_set_guc_locked</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><literal type="string">"client_encoding"</literal></expr></argument>, <argument><expr><name>clean_enc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>_save</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
        <goto>goto <name>endlock</name>;</goto>
    </block_content>}</block></if></if_stmt>

<label><name>endlock</name>:</label>
    <expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>self</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>Py_END_ALLOW_THREADS</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>res</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>pq_complete_error</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>exit</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>conn_store_encoding</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>pgenc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"conn_set_client_encoding: encoding set to %s"</literal></expr></argument>, <argument><expr><name><name>self</name><operator>-&gt;</operator><name>encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>exit</name>:</label>
    <expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>clean_enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* conn_tpc_begin -- begin a two-phase commit.
 *
 * The state of a connection in the middle of a TPC is exactly the same
 * of a normal transaction, in CONN_STATUS_BEGIN, but with the tpc_xid
 * member set to the xid used. This allows to reuse all the code paths used
 * in regular transactions, as PostgreSQL won't even know we are in a TPC
 * until PREPARE. */</comment>

<function><type><name>RAISES_NEG</name> <name>int</name></type>
<name>conn_tpc_begin</name><parameter_list>(<parameter><decl><type><name>connectionObject</name> <modifier>*</modifier></type><name>self</name></decl></parameter>, <parameter><decl><type><name>xidObject</name> <modifier>*</modifier></type><name>xid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"conn_tpc_begin: starting transaction"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>Py_BEGIN_ALLOW_THREADS</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>self</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>pq_begin_locked</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>_save</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>self</name><operator>-&gt;</operator><name>lock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>Py_BLOCK_THREADS</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pq_complete_error</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>self</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>Py_END_ALLOW_THREADS</name></expr>;</expr_stmt>

    <comment type="block">/* The transaction started ok, let's store this xid. */</comment>
    <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>tpc_xid</name></name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt>

    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* conn_tpc_command -- run one of the TPC-related PostgreSQL commands.
 *
 * The function doesn't change the connection state as it can be used
 * for many commands and for recovered transactions. */</comment>

<function><type><name>RAISES_NEG</name> <name>int</name></type>
<name>conn_tpc_command</name><parameter_list>(<parameter><decl><type><name>connectionObject</name> <modifier>*</modifier></type><name>self</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>xidObject</name> <modifier>*</modifier></type><name>xid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>tid</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ctid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rv</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Dprintf</name><argument_list>(<argument><expr><literal type="string">"conn_tpc_command: %s"</literal></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* convert the xid into PostgreSQL transaction id while keeping the GIL */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>tid</name> <operator>=</operator> <call><name>psyco_ensure_bytes</name><argument_list>(<argument><expr><call><name>xid_get_tid</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content> <goto>goto <name>exit</name>;</goto> </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>ctid</name> <operator>=</operator> <call><name>Bytes_AsString</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content> <goto>goto <name>exit</name>;</goto> </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>Py_BEGIN_ALLOW_THREADS</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>self</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&gt;</operator> <operator>(</operator><name>rv</name> <operator>=</operator> <call><name>pq_tpc_command_locked</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>ctid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>_save</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>self</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>Py_BLOCK_THREADS</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pq_complete_error</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>exit</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>self</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>Py_END_ALLOW_THREADS</name></expr>;</expr_stmt>

<label><name>exit</name>:</label>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>rv</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* conn_tpc_recover -- return a list of pending TPC Xid */</comment>

<function><type><name>PyObject</name> <modifier>*</modifier></type>
<name>conn_tpc_recover</name><parameter_list>(<parameter><decl><type><name>connectionObject</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>xids</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>rv</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>

    <comment type="block">/* store the status to restore it. */</comment>
    <expr_stmt><expr><name>status</name> <operator>=</operator> <name><name>self</name><operator>-&gt;</operator><name>status</name></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>xids</name> <operator>=</operator> <call><name>xid_recover</name><argument_list>(<argument><expr><operator>(</operator><name>PyObject</name> <operator>*</operator><operator>)</operator><name>self</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content> <goto>goto <name>exit</name>;</goto> </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>CONN_STATUS_READY</name> <operator>&amp;&amp;</operator> <name><name>self</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>CONN_STATUS_BEGIN</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* recover began a transaction: let's abort it. */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>tmp</name> <operator>=</operator> <call><name>PyObject_CallMethod</name><argument_list>(<argument><expr><operator>(</operator><name>PyObject</name> <operator>*</operator><operator>)</operator><name>self</name></expr></argument>, <argument><expr><literal type="string">"rollback"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
            <goto>goto <name>exit</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* all fine */</comment>
    <expr_stmt><expr><name>rv</name> <operator>=</operator> <name>xids</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>xids</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<label><name>exit</name>:</label>
    <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>xids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>rv</name></expr>;</return>

</block_content>}</block></function>


<function><type><name>void</name></type>
<name>conn_set_result</name><parameter_list>(<parameter><decl><type><name>connectionObject</name> <modifier>*</modifier></type><name>self</name></decl></parameter>, <parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>pgres</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>pgres</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>pgres</name></name> <operator>=</operator> <name>pgres</name></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>conn_set_error</name><parameter_list>(<parameter><decl><type><name>connectionObject</name> <modifier>*</modifier></type><name>self</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>self</name><operator>-&gt;</operator><name>error</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>error</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>error</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>msg</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>msg</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>error</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
</unit>
