<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="../out/cloned_projects/brotli/c/include/brotli/decode.h"><comment type="block">/* Copyright 2013 Google Inc. All Rights Reserved.

   Distributed under MIT license.
   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT
*/</comment>

<comment type="block" format="doxygen">/**
 * @file
 * API for Brotli decompression.
 */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>BROTLI_DEC_DECODE_H_</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_DEC_DECODE_H_</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;brotli/port.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;brotli/shared_dictionary.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;brotli/types.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>c_plusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
<extern>extern <literal type="string">"C"</literal> <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block" format="doxygen">/**
 * Opaque structure that holds decoder state.
 *
 * Allocated and initialized with ::BrotliDecoderCreateInstance.
 * Cleaned up and deallocated with ::BrotliDecoderDestroyInstance.
 */</comment>
<typedef>typedef <type><name><name>struct</name> <name>BrotliDecoderStateStruct</name></name></type> <name>BrotliDecoderState</name>;</typedef>

<comment type="block" format="doxygen">/**
 * Result type for ::BrotliDecoderDecompress and
 * ::BrotliDecoderDecompressStream functions.
 */</comment>
<typedef>typedef <type><enum>enum <block>{
  <comment type="block" format="doxygen">/** Decoding error, e.g. corrupted input or memory allocation problem. */</comment>
  <decl><name>BROTLI_DECODER_RESULT_ERROR</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
  <comment type="block" format="doxygen">/** Decoding successfully completed. */</comment>
  <decl><name>BROTLI_DECODER_RESULT_SUCCESS</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,
  <comment type="block" format="doxygen">/** Partially done; should be called again with more input. */</comment>
  <decl><name>BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>,
  <comment type="block" format="doxygen">/** Partially done; should be called again with more output. */</comment>
  <decl><name>BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>
}</block></enum></type> <name>BrotliDecoderResult</name>;</typedef>

<comment type="block" format="doxygen">/**
 * Template that evaluates items of ::BrotliDecoderErrorCode.
 *
 * Example: @code {.cpp}
 * // Log Brotli error code.
 * switch (brotliDecoderErrorCode) {
 * #define CASE_(PREFIX, NAME, CODE) \
 *   case BROTLI_DECODER ## PREFIX ## NAME: \
 *     LOG(INFO) &lt;&lt; "error code:" &lt;&lt; #NAME; \
 *     break;
 * #define NEWLINE_
 * BROTLI_DECODER_ERROR_CODES_LIST(CASE_, NEWLINE_)
 * #undef CASE_
 * #undef NEWLINE_
 *   default: LOG(FATAL) &lt;&lt; "unknown brotli error code";
 * }
 * @endcode
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_DECODER_ERROR_CODES_LIST</name><parameter_list>(<parameter><type><name>BROTLI_ERROR_CODE</name></type></parameter>, <parameter><type><name>SEPARATOR</name></type></parameter>)</parameter_list></cpp:macro>      \
  <cpp:value>BROTLI_ERROR_CODE(_, NO_ERROR, 0) SEPARATOR                              \
  <comment type="block">/* Same as BrotliDecoderResult values */</comment>                                 \
  BROTLI_ERROR_CODE(_, SUCCESS, 1) SEPARATOR                               \
  BROTLI_ERROR_CODE(_, NEEDS_MORE_INPUT, 2) SEPARATOR                      \
  BROTLI_ERROR_CODE(_, NEEDS_MORE_OUTPUT, 3) SEPARATOR                     \
                                                                           \
  <comment type="block">/* Errors caused by invalid input */</comment>                                     \
  BROTLI_ERROR_CODE(_ERROR_FORMAT_, EXUBERANT_NIBBLE, -1) SEPARATOR        \
  BROTLI_ERROR_CODE(_ERROR_FORMAT_, RESERVED, -2) SEPARATOR                \
  BROTLI_ERROR_CODE(_ERROR_FORMAT_, EXUBERANT_META_NIBBLE, -3) SEPARATOR   \
  BROTLI_ERROR_CODE(_ERROR_FORMAT_, SIMPLE_HUFFMAN_ALPHABET, -4) SEPARATOR \
  BROTLI_ERROR_CODE(_ERROR_FORMAT_, SIMPLE_HUFFMAN_SAME, -5) SEPARATOR     \
  BROTLI_ERROR_CODE(_ERROR_FORMAT_, CL_SPACE, -6) SEPARATOR                \
  BROTLI_ERROR_CODE(_ERROR_FORMAT_, HUFFMAN_SPACE, -7) SEPARATOR           \
  BROTLI_ERROR_CODE(_ERROR_FORMAT_, CONTEXT_MAP_REPEAT, -8) SEPARATOR      \
  BROTLI_ERROR_CODE(_ERROR_FORMAT_, BLOCK_LENGTH_1, -9) SEPARATOR          \
  BROTLI_ERROR_CODE(_ERROR_FORMAT_, BLOCK_LENGTH_2, -10) SEPARATOR         \
  BROTLI_ERROR_CODE(_ERROR_FORMAT_, TRANSFORM, -11) SEPARATOR              \
  BROTLI_ERROR_CODE(_ERROR_FORMAT_, DICTIONARY, -12) SEPARATOR             \
  BROTLI_ERROR_CODE(_ERROR_FORMAT_, WINDOW_BITS, -13) SEPARATOR            \
  BROTLI_ERROR_CODE(_ERROR_FORMAT_, PADDING_1, -14) SEPARATOR              \
  BROTLI_ERROR_CODE(_ERROR_FORMAT_, PADDING_2, -15) SEPARATOR              \
  BROTLI_ERROR_CODE(_ERROR_FORMAT_, DISTANCE, -16) SEPARATOR               \
                                                                           \
  <comment type="block">/* -17 code is reserved */</comment>                                               \
                                                                           \
  BROTLI_ERROR_CODE(_ERROR_, COMPOUND_DICTIONARY, -18) SEPARATOR           \
  BROTLI_ERROR_CODE(_ERROR_, DICTIONARY_NOT_SET, -19) SEPARATOR            \
  BROTLI_ERROR_CODE(_ERROR_, INVALID_ARGUMENTS, -20) SEPARATOR             \
                                                                           \
  <comment type="block">/* Memory allocation problems */</comment>                                         \
  BROTLI_ERROR_CODE(_ERROR_ALLOC_, CONTEXT_MODES, -21) SEPARATOR           \
  <comment type="block">/* Literal, insert and distance trees together */</comment>                        \
  BROTLI_ERROR_CODE(_ERROR_ALLOC_, TREE_GROUPS, -22) SEPARATOR             \
  <comment type="block">/* -23..-24 codes are reserved for distinct tree groups */</comment>               \
  BROTLI_ERROR_CODE(_ERROR_ALLOC_, CONTEXT_MAP, -25) SEPARATOR             \
  BROTLI_ERROR_CODE(_ERROR_ALLOC_, RING_BUFFER_1, -26) SEPARATOR           \
  BROTLI_ERROR_CODE(_ERROR_ALLOC_, RING_BUFFER_2, -27) SEPARATOR           \
  <comment type="block">/* -28..-29 codes are reserved for dynamic ring-buffer allocation */</comment>     \
  BROTLI_ERROR_CODE(_ERROR_ALLOC_, BLOCK_TYPE_TREES, -30) SEPARATOR        \
                                                                           \
  <comment type="block">/* "Impossible" states */</comment>                                                \
  BROTLI_ERROR_CODE(_ERROR_, UNREACHABLE, -31)</cpp:value></cpp:define>

<comment type="block" format="doxygen">/**
 * Error code for detailed logging / production debugging.
 *
 * See ::BrotliDecoderGetErrorCode and ::BROTLI_LAST_ERROR_CODE.
 */</comment>
<typedef>typedef <type><enum>enum <block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_COMMA_</name></cpp:macro> <cpp:value>,</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_ERROR_CODE_ENUM_ITEM_</name><parameter_list>(<parameter><type><name>PREFIX</name></type></parameter>, <parameter><type><name>NAME</name></type></parameter>, <parameter><type><name>CODE</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>BROTLI_DECODER ## PREFIX ## NAME = CODE</cpp:value></cpp:define>
  <macro><name>BROTLI_DECODER_ERROR_CODES_LIST</name><argument_list>(<argument>BROTLI_ERROR_CODE_ENUM_ITEM_</argument>, <argument>BROTLI_COMMA_</argument>)</argument_list></macro>
}</block></enum></type> <name>BrotliDecoderErrorCode</name>;</typedef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BROTLI_ERROR_CODE_ENUM_ITEM_</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BROTLI_COMMA_</name></cpp:undef>

<comment type="block" format="doxygen">/**
 * The value of the last error code, negative integer.
 *
 * All other error code values are in the range from ::BROTLI_LAST_ERROR_CODE
 * to @c -1. There are also 4 other possible non-error codes @c 0 .. @c 3 in
 * ::BrotliDecoderErrorCode enumeration.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_LAST_ERROR_CODE</name></cpp:macro> <cpp:value>BROTLI_DECODER_ERROR_UNREACHABLE</cpp:value></cpp:define>

<comment type="block" format="doxygen">/** Options to be used with ::BrotliDecoderSetParameter. */</comment>
<typedef>typedef <type><enum>enum <name>BrotliDecoderParameter</name> <block>{
  <comment type="block" format="doxygen">/**
   * Disable "canny" ring buffer allocation strategy.
   *
   * Ring buffer is allocated according to window size, despite the real size of
   * the content.
   */</comment>
  <decl><name>BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
  <comment type="block" format="doxygen">/**
   * Flag that determines if "Large Window Brotli" is used.
   */</comment>
  <decl><name>BROTLI_DECODER_PARAM_LARGE_WINDOW</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>
}</block></enum></type> <name>BrotliDecoderParameter</name>;</typedef>

<comment type="block" format="doxygen">/**
 * Sets the specified parameter to the given decoder instance.
 *
 * @param state decoder instance
 * @param param parameter to set
 * @param value new parameter value
 * @returns ::BROTLI_FALSE if parameter is unrecognized, or value is invalid
 * @returns ::BROTLI_TRUE if value is accepted
 */</comment>
<function_decl><type><name>BROTLI_DEC_API</name> <name>BROTLI_BOOL</name></type> <name>BrotliDecoderSetParameter</name><parameter_list>(
    <parameter><decl><type><name>BrotliDecoderState</name><modifier>*</modifier></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>BrotliDecoderParameter</name></type> <name>param</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>value</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block" format="doxygen">/**
 * Adds LZ77 prefix dictionary, adds or replaces built-in static dictionary and
 * transforms.
 *
 * Attached dictionary ownership is not transferred.
 * Data provided to this method should be kept accessible until
 * decoding is finished and decoder instance is destroyed.
 *
 * @note Dictionaries can NOT be attached after actual decoding is started.
 *
 * @param state decoder instance
 * @param type dictionary data format
 * @param data_size length of memory region pointed by @p data
 * @param data dictionary data in format corresponding to @p type
 * @returns ::BROTLI_FALSE if dictionary is corrupted,
 *          or dictionary count limit is reached
 * @returns ::BROTLI_TRUE if dictionary is accepted / attached
 */</comment>
<function_decl><type><name>BROTLI_DEC_API</name> <name>BROTLI_BOOL</name></type> <name>BrotliDecoderAttachDictionary</name><parameter_list>(
    <parameter><decl><type><name>BrotliDecoderState</name><modifier>*</modifier></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>BrotliSharedDictionaryType</name></type> <name>type</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>data_size</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name></type> <name><name>data</name><index>[<expr><call><name>BROTLI_ARRAY_PARAM</name><argument_list>(<argument><expr><name>data_size</name></expr></argument>)</argument_list></call></expr>]</index></name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block" format="doxygen">/**
 * Creates an instance of ::BrotliDecoderState and initializes it.
 *
 * The instance can be used once for decoding and should then be destroyed with
 * ::BrotliDecoderDestroyInstance, it cannot be reused for a new decoding
 * session.
 *
 * @p alloc_func and @p free_func @b MUST be both zero or both non-zero. In the
 * case they are both zero, default memory allocators are used. @p opaque is
 * passed to @p alloc_func and @p free_func when they are called. @p free_func
 * has to return without doing anything when asked to free a NULL pointer.
 *
 * @param alloc_func custom memory allocation function
 * @param free_func custom memory free function
 * @param opaque custom memory manager handle
 * @returns @c 0 if instance can not be allocated or initialized
 * @returns pointer to initialized ::BrotliDecoderState otherwise
 */</comment>
<function_decl><type><name>BROTLI_DEC_API</name> <name>BrotliDecoderState</name><modifier>*</modifier></type> <name>BrotliDecoderCreateInstance</name><parameter_list>(
    <parameter><decl><type><name>brotli_alloc_func</name></type> <name>alloc_func</name></decl></parameter>, <parameter><decl><type><name>brotli_free_func</name></type> <name>free_func</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>opaque</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block" format="doxygen">/**
 * Deinitializes and frees ::BrotliDecoderState instance.
 *
 * @param state decoder instance to be cleaned up and deallocated
 */</comment>
<function_decl><type><name>BROTLI_DEC_API</name> <name>void</name></type> <name>BrotliDecoderDestroyInstance</name><parameter_list>(<parameter><decl><type><name>BrotliDecoderState</name><modifier>*</modifier></type> <name>state</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block" format="doxygen">/**
 * Performs one-shot memory-to-memory decompression.
 *
 * Decompresses the data in @p encoded_buffer into @p decoded_buffer, and sets
 * @p *decoded_size to the decompressed length.
 *
 * @param encoded_size size of @p encoded_buffer
 * @param encoded_buffer compressed data buffer with at least @p encoded_size
 *        addressable bytes
 * @param[in, out] decoded_size @b in: size of @p decoded_buffer; \n
 *                 @b out: length of decompressed data written to
 *                 @p decoded_buffer
 * @param decoded_buffer decompressed data destination buffer
 * @returns ::BROTLI_DECODER_RESULT_ERROR if input is corrupted, memory
 *          allocation failed, or @p decoded_buffer is not large enough;
 * @returns ::BROTLI_DECODER_RESULT_SUCCESS otherwise
 */</comment>
<function_decl><type><name>BROTLI_DEC_API</name> <name>BrotliDecoderResult</name></type> <name>BrotliDecoderDecompress</name><parameter_list>(
    <parameter><decl><type><name>size_t</name></type> <name>encoded_size</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name></type> <name><name>encoded_buffer</name><index>[<expr><call><name>BROTLI_ARRAY_PARAM</name><argument_list>(<argument><expr><name>encoded_size</name></expr></argument>)</argument_list></call></expr>]</index></name></decl></parameter>,
    <parameter><decl><type><name>size_t</name><modifier>*</modifier></type> <name>decoded_size</name></decl></parameter>,
    <parameter><decl><type><name>uint8_t</name></type> <name><name>decoded_buffer</name><index>[<expr><call><name>BROTLI_ARRAY_PARAM</name><argument_list>(<argument><expr><operator>*</operator><name>decoded_size</name></expr></argument>)</argument_list></call></expr>]</index></name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block" format="doxygen">/**
 * Decompresses the input stream to the output stream.
 *
 * The values @p *available_in and @p *available_out must specify the number of
 * bytes addressable at @p *next_in and @p *next_out respectively.
 * When @p *available_out is @c 0, @p next_out is allowed to be @c NULL.
 *
 * After each call, @p *available_in will be decremented by the amount of input
 * bytes consumed, and the @p *next_in pointer will be incremented by that
 * amount. Similarly, @p *available_out will be decremented by the amount of
 * output bytes written, and the @p *next_out pointer will be incremented by
 * that amount.
 *
 * @p total_out, if it is not a null-pointer, will be set to the number
 * of bytes decompressed since the last @p state initialization.
 *
 * @note Input is never overconsumed, so @p next_in and @p available_in could be
 * passed to the next consumer after decoding is complete.
 *
 * @param state decoder instance
 * @param[in, out] available_in @b in: amount of available input; \n
 *                 @b out: amount of unused input
 * @param[in, out] next_in pointer to the next compressed byte
 * @param[in, out] available_out @b in: length of output buffer; \n
 *                 @b out: remaining size of output buffer
 * @param[in, out] next_out output buffer cursor;
 *                 can be @c NULL if @p available_out is @c 0
 * @param[out] total_out number of bytes decompressed so far; can be @c NULL
 * @returns ::BROTLI_DECODER_RESULT_ERROR if input is corrupted, memory
 *          allocation failed, arguments were invalid, etc.;
 *          use ::BrotliDecoderGetErrorCode to get detailed error code
 * @returns ::BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT decoding is blocked until
 *          more input data is provided
 * @returns ::BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT decoding is blocked until
 *          more output space is provided
 * @returns ::BROTLI_DECODER_RESULT_SUCCESS decoding is finished, no more
 *          input might be consumed and no more output will be produced
 */</comment>
<function_decl><type><name>BROTLI_DEC_API</name> <name>BrotliDecoderResult</name></type> <name>BrotliDecoderDecompressStream</name><parameter_list>(
  <parameter><decl><type><name>BrotliDecoderState</name><modifier>*</modifier></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>size_t</name><modifier>*</modifier></type> <name>available_in</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name><modifier>*</modifier><modifier>*</modifier></type> <name>next_in</name></decl></parameter>,
  <parameter><decl><type><name>size_t</name><modifier>*</modifier></type> <name>available_out</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name><modifier>*</modifier><modifier>*</modifier></type> <name>next_out</name></decl></parameter>, <parameter><decl><type><name>size_t</name><modifier>*</modifier></type> <name>total_out</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block" format="doxygen">/**
 * Checks if decoder has more output.
 *
 * @param state decoder instance
 * @returns ::BROTLI_TRUE, if decoder has some unconsumed output
 * @returns ::BROTLI_FALSE otherwise
 */</comment>
<function_decl><type><name>BROTLI_DEC_API</name> <name>BROTLI_BOOL</name></type> <name>BrotliDecoderHasMoreOutput</name><parameter_list>(
    <parameter><decl><type><specifier>const</specifier> <name>BrotliDecoderState</name><modifier>*</modifier></type> <name>state</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block" format="doxygen">/**
 * Acquires pointer to internal output buffer.
 *
 * This method is used to make language bindings easier and more efficient:
 *  -# push data to ::BrotliDecoderDecompressStream,
 *     until ::BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT is reported
 *  -# use ::BrotliDecoderTakeOutput to peek bytes and copy to language-specific
 *     entity
 *
 * Also this could be useful if there is an output stream that is able to
 * consume all the provided data (e.g. when data is saved to file system).
 *
 * @attention After every call to ::BrotliDecoderTakeOutput @p *size bytes of
 *            output are considered consumed for all consecutive calls to the
 *            instance methods; returned pointer becomes invalidated as well.
 *
 * @note Decoder output is not guaranteed to be contiguous. This means that
 *       after the size-unrestricted call to ::BrotliDecoderTakeOutput,
 *       immediate next call to ::BrotliDecoderTakeOutput may return more data.
 *
 * @param state decoder instance
 * @param[in, out] size @b in: number of bytes caller is ready to take, @c 0 if
 *                 any amount could be handled; \n
 *                 @b out: amount of data pointed by returned pointer and
 *                 considered consumed; \n
 *                 out value is never greater than in value, unless it is @c 0
 * @returns pointer to output data
 */</comment>
<function_decl><type><name>BROTLI_DEC_API</name> <specifier>const</specifier> <name>uint8_t</name><modifier>*</modifier></type> <name>BrotliDecoderTakeOutput</name><parameter_list>(
    <parameter><decl><type><name>BrotliDecoderState</name><modifier>*</modifier></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>size_t</name><modifier>*</modifier></type> <name>size</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block" format="doxygen">/**
 * Checks if instance has already consumed input.
 *
 * Instance that returns ::BROTLI_FALSE is considered "fresh" and could be
 * reused.
 *
 * @param state decoder instance
 * @returns ::BROTLI_TRUE if decoder has already used some input bytes
 * @returns ::BROTLI_FALSE otherwise
 */</comment>
<function_decl><type><name>BROTLI_DEC_API</name> <name>BROTLI_BOOL</name></type> <name>BrotliDecoderIsUsed</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BrotliDecoderState</name><modifier>*</modifier></type> <name>state</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block" format="doxygen">/**
 * Checks if decoder instance reached the final state.
 *
 * @param state decoder instance
 * @returns ::BROTLI_TRUE if decoder is in a state where it reached the end of
 *          the input and produced all of the output
 * @returns ::BROTLI_FALSE otherwise
 */</comment>
<function_decl><type><name>BROTLI_DEC_API</name> <name>BROTLI_BOOL</name></type> <name>BrotliDecoderIsFinished</name><parameter_list>(
    <parameter><decl><type><specifier>const</specifier> <name>BrotliDecoderState</name><modifier>*</modifier></type> <name>state</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block" format="doxygen">/**
 * Acquires a detailed error code.
 *
 * Should be used only after ::BrotliDecoderDecompressStream returns
 * ::BROTLI_DECODER_RESULT_ERROR.
 *
 * See also ::BrotliDecoderErrorString
 *
 * @param state decoder instance
 * @returns last saved error code
 */</comment>
<function_decl><type><name>BROTLI_DEC_API</name> <name>BrotliDecoderErrorCode</name></type> <name>BrotliDecoderGetErrorCode</name><parameter_list>(
    <parameter><decl><type><specifier>const</specifier> <name>BrotliDecoderState</name><modifier>*</modifier></type> <name>state</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block" format="doxygen">/**
 * Converts error code to a c-string.
 */</comment>
<function_decl><type><name>BROTLI_DEC_API</name> <specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>BrotliDecoderErrorString</name><parameter_list>(<parameter><decl><type><name>BrotliDecoderErrorCode</name></type> <name>c</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block" format="doxygen">/**
 * Gets a decoder library version.
 *
 * Look at BROTLI_VERSION for more information.
 */</comment>
<function_decl><type><name>BROTLI_DEC_API</name> <name>uint32_t</name></type> <name>BrotliDecoderVersion</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>c_plusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
</block_content>}</block></extern> <comment type="block">/* extern "C" */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* BROTLI_DEC_DECODE_H_ */</comment>
</unit>
