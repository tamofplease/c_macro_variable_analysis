<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="../out/cloned_projects/brotli/c/include/brotli/encode.h"><comment type="block">/* Copyright 2013 Google Inc. All Rights Reserved.

   Distributed under MIT license.
   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT
*/</comment>

<comment type="block" format="doxygen">/**
 * @file
 * API for Brotli compression.
 */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>BROTLI_ENC_ENCODE_H_</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_ENC_ENCODE_H_</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;brotli/port.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;brotli/shared_dictionary.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;brotli/types.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>c_plusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
<extern>extern <literal type="string">"C"</literal> <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block" format="doxygen">/** Minimal value for ::BROTLI_PARAM_LGWIN parameter. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_MIN_WINDOW_BITS</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>
<comment type="block" format="doxygen">/**
 * Maximal value for ::BROTLI_PARAM_LGWIN parameter.
 *
 * @note equal to @c BROTLI_MAX_DISTANCE_BITS constant.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_MAX_WINDOW_BITS</name></cpp:macro> <cpp:value>24</cpp:value></cpp:define>
<comment type="block" format="doxygen">/**
 * Maximal value for ::BROTLI_PARAM_LGWIN parameter
 * in "Large Window Brotli" (32-bit).
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_LARGE_MAX_WINDOW_BITS</name></cpp:macro> <cpp:value>30</cpp:value></cpp:define>
<comment type="block" format="doxygen">/** Minimal value for ::BROTLI_PARAM_LGBLOCK parameter. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_MIN_INPUT_BLOCK_BITS</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>
<comment type="block" format="doxygen">/** Maximal value for ::BROTLI_PARAM_LGBLOCK parameter. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_MAX_INPUT_BLOCK_BITS</name></cpp:macro> <cpp:value>24</cpp:value></cpp:define>
<comment type="block" format="doxygen">/** Minimal value for ::BROTLI_PARAM_QUALITY parameter. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_MIN_QUALITY</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<comment type="block" format="doxygen">/** Maximal value for ::BROTLI_PARAM_QUALITY parameter. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_MAX_QUALITY</name></cpp:macro> <cpp:value>11</cpp:value></cpp:define>

<comment type="block" format="doxygen">/** Options for ::BROTLI_PARAM_MODE parameter. */</comment>
<typedef>typedef <type><enum>enum <name>BrotliEncoderMode</name> <block>{
  <comment type="block" format="doxygen">/**
   * Default compression mode.
   *
   * In this mode compressor does not know anything in advance about the
   * properties of the input.
   */</comment>
  <decl><name>BROTLI_MODE_GENERIC</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
  <comment type="block" format="doxygen">/** Compression mode for UTF-8 formatted text input. */</comment>
  <decl><name>BROTLI_MODE_TEXT</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,
  <comment type="block" format="doxygen">/** Compression mode used in WOFF 2.0. */</comment>
  <decl><name>BROTLI_MODE_FONT</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>
}</block></enum></type> <name>BrotliEncoderMode</name>;</typedef>

<comment type="block" format="doxygen">/** Default value for ::BROTLI_PARAM_QUALITY parameter. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_DEFAULT_QUALITY</name></cpp:macro> <cpp:value>11</cpp:value></cpp:define>
<comment type="block" format="doxygen">/** Default value for ::BROTLI_PARAM_LGWIN parameter. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_DEFAULT_WINDOW</name></cpp:macro> <cpp:value>22</cpp:value></cpp:define>
<comment type="block" format="doxygen">/** Default value for ::BROTLI_PARAM_MODE parameter. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_DEFAULT_MODE</name></cpp:macro> <cpp:value>BROTLI_MODE_GENERIC</cpp:value></cpp:define>

<comment type="block" format="doxygen">/** Operations that can be performed by streaming encoder. */</comment>
<typedef>typedef <type><enum>enum <name>BrotliEncoderOperation</name> <block>{
  <comment type="block" format="doxygen">/**
   * Process input.
   *
   * Encoder may postpone producing output, until it has processed enough input.
   */</comment>
  <decl><name>BROTLI_OPERATION_PROCESS</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
  <comment type="block" format="doxygen">/**
   * Produce output for all processed input.
   *
   * Actual flush is performed when input stream is depleted and there is enough
   * space in output stream. This means that client should repeat
   * ::BROTLI_OPERATION_FLUSH operation until @p available_in becomes @c 0, and
   * ::BrotliEncoderHasMoreOutput returns ::BROTLI_FALSE. If output is acquired
   * via ::BrotliEncoderTakeOutput, then operation should be repeated after
   * output buffer is drained.
   *
   * @warning Until flush is complete, client @b SHOULD @b NOT swap,
   *          reduce or extend input stream.
   *
   * When flush is complete, output data will be sufficient for decoder to
   * reproduce all the given input.
   */</comment>
  <decl><name>BROTLI_OPERATION_FLUSH</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,
  <comment type="block" format="doxygen">/**
   * Finalize the stream.
   *
   * Actual finalization is performed when input stream is depleted and there is
   * enough space in output stream. This means that client should repeat
   * ::BROTLI_OPERATION_FINISH operation until @p available_in becomes @c 0, and
   * ::BrotliEncoderHasMoreOutput returns ::BROTLI_FALSE. If output is acquired
   * via ::BrotliEncoderTakeOutput, then operation should be repeated after
   * output buffer is drained.
   *
   * @warning Until finalization is complete, client @b SHOULD @b NOT swap,
   *          reduce or extend input stream.
   *
   * Helper function ::BrotliEncoderIsFinished checks if stream is finalized and
   * output fully dumped.
   *
   * Adding more input data to finalized stream is impossible.
   */</comment>
  <decl><name>BROTLI_OPERATION_FINISH</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>,
  <comment type="block" format="doxygen">/**
   * Emit metadata block to stream.
   *
   * Metadata is opaque to Brotli: neither encoder, nor decoder processes this
   * data or relies on it. It may be used to pass some extra information from
   * encoder client to decoder client without interfering with main data stream.
   *
   * @note Encoder may emit empty metadata blocks internally, to pad encoded
   *       stream to byte boundary.
   *
   * @warning Until emitting metadata is complete client @b SHOULD @b NOT swap,
   *          reduce or extend input stream.
   *
   * @warning The whole content of input buffer is considered to be the content
   *          of metadata block. Do @b NOT @e append metadata to input stream,
   *          before it is depleted with other operations.
   *
   * Stream is soft-flushed before metadata block is emitted. Metadata block
   * @b MUST be no longer than than 16MiB.
   */</comment>
  <decl><name>BROTLI_OPERATION_EMIT_METADATA</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>
}</block></enum></type> <name>BrotliEncoderOperation</name>;</typedef>

<comment type="block" format="doxygen">/** Options to be used with ::BrotliEncoderSetParameter. */</comment>
<typedef>typedef <type><enum>enum <name>BrotliEncoderParameter</name> <block>{
  <comment type="block" format="doxygen">/**
   * Tune encoder for specific input.
   *
   * ::BrotliEncoderMode enumerates all available values.
   */</comment>
  <decl><name>BROTLI_PARAM_MODE</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
  <comment type="block" format="doxygen">/**
   * The main compression speed-density lever.
   *
   * The higher the quality, the slower the compression. Range is
   * from ::BROTLI_MIN_QUALITY to ::BROTLI_MAX_QUALITY.
   */</comment>
  <decl><name>BROTLI_PARAM_QUALITY</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,
  <comment type="block" format="doxygen">/**
   * Recommended sliding LZ77 window size.
   *
   * Encoder may reduce this value, e.g. if input is much smaller than
   * window size.
   *
   * Window size is `(1 &lt;&lt; value) - 16`.
   *
   * Range is from ::BROTLI_MIN_WINDOW_BITS to ::BROTLI_MAX_WINDOW_BITS.
   */</comment>
  <decl><name>BROTLI_PARAM_LGWIN</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>,
  <comment type="block" format="doxygen">/**
   * Recommended input block size.
   *
   * Encoder may reduce this value, e.g. if input is much smaller than input
   * block size.
   *
   * Range is from ::BROTLI_MIN_INPUT_BLOCK_BITS to
   * ::BROTLI_MAX_INPUT_BLOCK_BITS.
   *
   * @note Bigger input block size allows better compression, but consumes more
   *       memory. \n The rough formula of memory used for temporary input
   *       storage is `3 &lt;&lt; lgBlock`.
   */</comment>
  <decl><name>BROTLI_PARAM_LGBLOCK</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>,
  <comment type="block" format="doxygen">/**
   * Flag that affects usage of "literal context modeling" format feature.
   *
   * This flag is a "decoding-speed vs compression ratio" trade-off.
   */</comment>
  <decl><name>BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>,
  <comment type="block" format="doxygen">/**
   * Estimated total input size for all ::BrotliEncoderCompressStream calls.
   *
   * The default value is 0, which means that the total input size is unknown.
   */</comment>
  <decl><name>BROTLI_PARAM_SIZE_HINT</name> <init>= <expr><literal type="number">5</literal></expr></init></decl>,
  <comment type="block" format="doxygen">/**
   * Flag that determines if "Large Window Brotli" is used.
   */</comment>
  <decl><name>BROTLI_PARAM_LARGE_WINDOW</name> <init>= <expr><literal type="number">6</literal></expr></init></decl>,
  <comment type="block" format="doxygen">/**
   * Recommended number of postfix bits (NPOSTFIX).
   *
   * Encoder may change this value.
   *
   * Range is from 0 to ::BROTLI_MAX_NPOSTFIX.
   */</comment>
  <decl><name>BROTLI_PARAM_NPOSTFIX</name> <init>= <expr><literal type="number">7</literal></expr></init></decl>,
  <comment type="block" format="doxygen">/**
   * Recommended number of direct distance codes (NDIRECT).
   *
   * Encoder may change this value.
   *
   * Range is from 0 to (15 &lt;&lt; NPOSTFIX) in steps of (1 &lt;&lt; NPOSTFIX).
   */</comment>
  <decl><name>BROTLI_PARAM_NDIRECT</name> <init>= <expr><literal type="number">8</literal></expr></init></decl>,
  <comment type="block" format="doxygen">/**
   * Number of bytes of input stream already processed by a different instance.
   *
   * @note It is important to configure all the encoder instances with same
   *       parameters (except this one) in order to allow all the encoded parts
   *       obey the same restrictions implied by header.
   *
   * If offset is not 0, then stream header is omitted.
   * In any case output start is byte aligned, so for proper streams stitching
   * "predecessor" stream must be flushed.
   *
   * Range is not artificially limited, but all the values greater or equal to
   * maximal window size have the same effect. Values greater than 2**30 are not
   * allowed.
   */</comment>
  <decl><name>BROTLI_PARAM_STREAM_OFFSET</name> <init>= <expr><literal type="number">9</literal></expr></init></decl>
}</block></enum></type> <name>BrotliEncoderParameter</name>;</typedef>

<comment type="block" format="doxygen">/**
 * Opaque structure that holds encoder state.
 *
 * Allocated and initialized with ::BrotliEncoderCreateInstance.
 * Cleaned up and deallocated with ::BrotliEncoderDestroyInstance.
 */</comment>
<typedef>typedef <type><name><name>struct</name> <name>BrotliEncoderStateStruct</name></name></type> <name>BrotliEncoderState</name>;</typedef>

<comment type="block" format="doxygen">/**
 * Sets the specified parameter to the given encoder instance.
 *
 * @param state encoder instance
 * @param param parameter to set
 * @param value new parameter value
 * @returns ::BROTLI_FALSE if parameter is unrecognized, or value is invalid
 * @returns ::BROTLI_FALSE if value of parameter can not be changed at current
 *          encoder state (e.g. when encoding is started, window size might be
 *          already encoded and therefore it is impossible to change it)
 * @returns ::BROTLI_TRUE if value is accepted
 * @warning invalid values might be accepted in case they would not break
 *          encoding process.
 */</comment>
<function_decl><type><name>BROTLI_ENC_API</name> <name>BROTLI_BOOL</name></type> <name>BrotliEncoderSetParameter</name><parameter_list>(
    <parameter><decl><type><name>BrotliEncoderState</name><modifier>*</modifier></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>BrotliEncoderParameter</name></type> <name>param</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>value</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block" format="doxygen">/**
 * Creates an instance of ::BrotliEncoderState and initializes it.
 *
 * @p alloc_func and @p free_func @b MUST be both zero or both non-zero. In the
 * case they are both zero, default memory allocators are used. @p opaque is
 * passed to @p alloc_func and @p free_func when they are called. @p free_func
 * has to return without doing anything when asked to free a NULL pointer.
 *
 * @param alloc_func custom memory allocation function
 * @param free_func custom memory free function
 * @param opaque custom memory manager handle
 * @returns @c 0 if instance can not be allocated or initialized
 * @returns pointer to initialized ::BrotliEncoderState otherwise
 */</comment>
<function_decl><type><name>BROTLI_ENC_API</name> <name>BrotliEncoderState</name><modifier>*</modifier></type> <name>BrotliEncoderCreateInstance</name><parameter_list>(
    <parameter><decl><type><name>brotli_alloc_func</name></type> <name>alloc_func</name></decl></parameter>, <parameter><decl><type><name>brotli_free_func</name></type> <name>free_func</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>opaque</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block" format="doxygen">/**
 * Deinitializes and frees ::BrotliEncoderState instance.
 *
 * @param state decoder instance to be cleaned up and deallocated
 */</comment>
<function_decl><type><name>BROTLI_ENC_API</name> <name>void</name></type> <name>BrotliEncoderDestroyInstance</name><parameter_list>(<parameter><decl><type><name>BrotliEncoderState</name><modifier>*</modifier></type> <name>state</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Opaque type for pointer to different possible internal structures containing
   dictionary prepared for the encoder */</comment>
<typedef>typedef <type><name><name>struct</name> <name>BrotliEncoderPreparedDictionaryStruct</name></name></type>
    <name>BrotliEncoderPreparedDictionary</name>;</typedef>

<comment type="block" format="doxygen">/**
 * Prepares a shared dictionary from the given file format for the encoder.
 *
 * @p alloc_func and @p free_func @b MUST be both zero or both non-zero. In the
 * case they are both zero, default memory allocators are used. @p opaque is
 * passed to @p alloc_func and @p free_func when they are called. @p free_func
 * has to return without doing anything when asked to free a NULL pointer.
 *
 * @param type type of dictionary stored in data
 * @param data_size size of @p data buffer
 * @param data pointer to the dictionary data
 * @param quality the maximum Brotli quality to prepare the dictionary for,
 *        use BROTLI_MAX_QUALITY by default
 * @param alloc_func custom memory allocation function
 * @param free_func custom memory free function
 * @param opaque custom memory manager handle
 */</comment>
<function_decl><type><name>BROTLI_ENC_API</name> <name>BrotliEncoderPreparedDictionary</name><modifier>*</modifier></type>
<name>BrotliEncoderPrepareDictionary</name><parameter_list>(<parameter><decl><type><name>BrotliSharedDictionaryType</name></type> <name>type</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>data_size</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name></type> <name><name>data</name><index>[<expr><call><name>BROTLI_ARRAY_PARAM</name><argument_list>(<argument><expr><name>data_size</name></expr></argument>)</argument_list></call></expr>]</index></name></decl></parameter>,
    <parameter><decl><type><name>int</name></type> <name>quality</name></decl></parameter>,
    <parameter><decl><type><name>brotli_alloc_func</name></type> <name>alloc_func</name></decl></parameter>, <parameter><decl><type><name>brotli_free_func</name></type> <name>free_func</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>opaque</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>BROTLI_ENC_API</name> <name>void</name></type> <name>BrotliEncoderDestroyPreparedDictionary</name><parameter_list>(
    <parameter><decl><type><name>BrotliEncoderPreparedDictionary</name><modifier>*</modifier></type> <name>dictionary</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block" format="doxygen">/**
 * Attaches a prepared dictionary of any type to the encoder. Can be used
 * multiple times to attach multiple dictionaries. The dictionary type was
 * determined by BrotliEncoderPrepareDictionary. Multiple raw prefix
 * dictionaries and/or max 1 serialized dictionary with custom words can be
 * attached.
 *
 * @returns ::BROTLI_FALSE in case of error
 * @returns ::BROTLI_TRUE otherwise
 */</comment>
<function_decl><type><name>BROTLI_ENC_API</name> <name>BROTLI_BOOL</name></type> <name>BrotliEncoderAttachPreparedDictionary</name><parameter_list>(
    <parameter><decl><type><name>BrotliEncoderState</name><modifier>*</modifier></type> <name>state</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>BrotliEncoderPreparedDictionary</name><modifier>*</modifier></type> <name>dictionary</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block" format="doxygen">/**
 * Calculates the output size bound for the given @p input_size.
 *
 * @warning Result is only valid if quality is at least @c 2 and, in
 *          case ::BrotliEncoderCompressStream was used, no flushes
 *          (::BROTLI_OPERATION_FLUSH) were performed.
 *
 * @param input_size size of projected input
 * @returns @c 0 if result does not fit @c size_t
 */</comment>
<function_decl><type><name>BROTLI_ENC_API</name> <name>size_t</name></type> <name>BrotliEncoderMaxCompressedSize</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>input_size</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block" format="doxygen">/**
 * Performs one-shot memory-to-memory compression.
 *
 * Compresses the data in @p input_buffer into @p encoded_buffer, and sets
 * @p *encoded_size to the compressed length.
 *
 * @note If ::BrotliEncoderMaxCompressedSize(@p input_size) returns non-zero
 *       value, then output is guaranteed to be no longer than that.
 *
 * @note If @p lgwin is greater than ::BROTLI_MAX_WINDOW_BITS then resulting
 *       stream might be incompatible with RFC 7932; to decode such streams,
 *       decoder should be configured with
 *       ::BROTLI_DECODER_PARAM_LARGE_WINDOW = @c 1
 *
 * @param quality quality parameter value, e.g. ::BROTLI_DEFAULT_QUALITY
 * @param lgwin lgwin parameter value, e.g. ::BROTLI_DEFAULT_WINDOW
 * @param mode mode parameter value, e.g. ::BROTLI_DEFAULT_MODE
 * @param input_size size of @p input_buffer
 * @param input_buffer input data buffer with at least @p input_size
 *        addressable bytes
 * @param[in, out] encoded_size @b in: size of @p encoded_buffer; \n
 *                 @b out: length of compressed data written to
 *                 @p encoded_buffer, or @c 0 if compression fails
 * @param encoded_buffer compressed data destination buffer
 * @returns ::BROTLI_FALSE in case of compression error
 * @returns ::BROTLI_FALSE if output buffer is too small
 * @returns ::BROTLI_TRUE otherwise
 */</comment>
<function_decl><type><name>BROTLI_ENC_API</name> <name>BROTLI_BOOL</name></type> <name>BrotliEncoderCompress</name><parameter_list>(
    <parameter><decl><type><name>int</name></type> <name>quality</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lgwin</name></decl></parameter>, <parameter><decl><type><name>BrotliEncoderMode</name></type> <name>mode</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>input_size</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name></type> <name><name>input_buffer</name><index>[<expr><call><name>BROTLI_ARRAY_PARAM</name><argument_list>(<argument><expr><name>input_size</name></expr></argument>)</argument_list></call></expr>]</index></name></decl></parameter>,
    <parameter><decl><type><name>size_t</name><modifier>*</modifier></type> <name>encoded_size</name></decl></parameter>,
    <parameter><decl><type><name>uint8_t</name></type> <name><name>encoded_buffer</name><index>[<expr><call><name>BROTLI_ARRAY_PARAM</name><argument_list>(<argument><expr><operator>*</operator><name>encoded_size</name></expr></argument>)</argument_list></call></expr>]</index></name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block" format="doxygen">/**
 * Compresses input stream to output stream.
 *
 * The values @p *available_in and @p *available_out must specify the number of
 * bytes addressable at @p *next_in and @p *next_out respectively.
 * When @p *available_out is @c 0, @p next_out is allowed to be @c NULL.
 *
 * After each call, @p *available_in will be decremented by the amount of input
 * bytes consumed, and the @p *next_in pointer will be incremented by that
 * amount. Similarly, @p *available_out will be decremented by the amount of
 * output bytes written, and the @p *next_out pointer will be incremented by
 * that amount.
 *
 * @p total_out, if it is not a null-pointer, will be set to the number
 * of bytes compressed since the last @p state initialization.
 *
 *
 *
 * Internally workflow consists of 3 tasks:
 *  -# (optionally) copy input data to internal buffer
 *  -# actually compress data and (optionally) store it to internal buffer
 *  -# (optionally) copy compressed bytes from internal buffer to output stream
 *
 * Whenever all 3 tasks can't move forward anymore, or error occurs, this
 * method returns the control flow to caller.
 *
 * @p op is used to perform flush, finish the stream, or inject metadata block.
 * See ::BrotliEncoderOperation for more information.
 *
 * Flushing the stream means forcing encoding of all input passed to encoder and
 * completing the current output block, so it could be fully decoded by stream
 * decoder. To perform flush set @p op to ::BROTLI_OPERATION_FLUSH.
 * Under some circumstances (e.g. lack of output stream capacity) this operation
 * would require several calls to ::BrotliEncoderCompressStream. The method must
 * be called again until both input stream is depleted and encoder has no more
 * output (see ::BrotliEncoderHasMoreOutput) after the method is called.
 *
 * Finishing the stream means encoding of all input passed to encoder and
 * adding specific "final" marks, so stream decoder could determine that stream
 * is complete. To perform finish set @p op to ::BROTLI_OPERATION_FINISH.
 * Under some circumstances (e.g. lack of output stream capacity) this operation
 * would require several calls to ::BrotliEncoderCompressStream. The method must
 * be called again until both input stream is depleted and encoder has no more
 * output (see ::BrotliEncoderHasMoreOutput) after the method is called.
 *
 * @warning When flushing and finishing, @p op should not change until operation
 *          is complete; input stream should not be swapped, reduced or
 *          extended as well.
 *
 * @param state encoder instance
 * @param op requested operation
 * @param[in, out] available_in @b in: amount of available input; \n
 *                 @b out: amount of unused input
 * @param[in, out] next_in pointer to the next input byte
 * @param[in, out] available_out @b in: length of output buffer; \n
 *                 @b out: remaining size of output buffer
 * @param[in, out] next_out compressed output buffer cursor;
 *                 can be @c NULL if @p available_out is @c 0
 * @param[out] total_out number of bytes produced so far; can be @c NULL
 * @returns ::BROTLI_FALSE if there was an error
 * @returns ::BROTLI_TRUE otherwise
 */</comment>
<function_decl><type><name>BROTLI_ENC_API</name> <name>BROTLI_BOOL</name></type> <name>BrotliEncoderCompressStream</name><parameter_list>(
    <parameter><decl><type><name>BrotliEncoderState</name><modifier>*</modifier></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>BrotliEncoderOperation</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>size_t</name><modifier>*</modifier></type> <name>available_in</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name><modifier>*</modifier><modifier>*</modifier></type> <name>next_in</name></decl></parameter>, <parameter><decl><type><name>size_t</name><modifier>*</modifier></type> <name>available_out</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name><modifier>*</modifier><modifier>*</modifier></type> <name>next_out</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name><modifier>*</modifier></type> <name>total_out</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block" format="doxygen">/**
 * Checks if encoder instance reached the final state.
 *
 * @param state encoder instance
 * @returns ::BROTLI_TRUE if encoder is in a state where it reached the end of
 *          the input and produced all of the output
 * @returns ::BROTLI_FALSE otherwise
 */</comment>
<function_decl><type><name>BROTLI_ENC_API</name> <name>BROTLI_BOOL</name></type> <name>BrotliEncoderIsFinished</name><parameter_list>(<parameter><decl><type><name>BrotliEncoderState</name><modifier>*</modifier></type> <name>state</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block" format="doxygen">/**
 * Checks if encoder has more output.
 *
 * @param state encoder instance
 * @returns ::BROTLI_TRUE, if encoder has some unconsumed output
 * @returns ::BROTLI_FALSE otherwise
 */</comment>
<function_decl><type><name>BROTLI_ENC_API</name> <name>BROTLI_BOOL</name></type> <name>BrotliEncoderHasMoreOutput</name><parameter_list>(
    <parameter><decl><type><name>BrotliEncoderState</name><modifier>*</modifier></type> <name>state</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block" format="doxygen">/**
 * Acquires pointer to internal output buffer.
 *
 * This method is used to make language bindings easier and more efficient:
 *  -# push data to ::BrotliEncoderCompressStream,
 *     until ::BrotliEncoderHasMoreOutput returns BROTL_TRUE
 *  -# use ::BrotliEncoderTakeOutput to peek bytes and copy to language-specific
 *     entity
 *
 * Also this could be useful if there is an output stream that is able to
 * consume all the provided data (e.g. when data is saved to file system).
 *
 * @attention After every call to ::BrotliEncoderTakeOutput @p *size bytes of
 *            output are considered consumed for all consecutive calls to the
 *            instance methods; returned pointer becomes invalidated as well.
 *
 * @note Encoder output is not guaranteed to be contiguous. This means that
 *       after the size-unrestricted call to ::BrotliEncoderTakeOutput,
 *       immediate next call to ::BrotliEncoderTakeOutput may return more data.
 *
 * @param state encoder instance
 * @param[in, out] size @b in: number of bytes caller is ready to take, @c 0 if
 *                 any amount could be handled; \n
 *                 @b out: amount of data pointed by returned pointer and
 *                 considered consumed; \n
 *                 out value is never greater than in value, unless it is @c 0
 * @returns pointer to output data
 */</comment>
<function_decl><type><name>BROTLI_ENC_API</name> <specifier>const</specifier> <name>uint8_t</name><modifier>*</modifier></type> <name>BrotliEncoderTakeOutput</name><parameter_list>(
    <parameter><decl><type><name>BrotliEncoderState</name><modifier>*</modifier></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>size_t</name><modifier>*</modifier></type> <name>size</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Returns the estimated peak memory usage (in bytes) of the BrotliCompress()
   function, not counting the memory needed for the input and output. */</comment>
<function_decl><type><name>BROTLI_ENC_EXTRA_API</name> <name>size_t</name></type> <name>BrotliEncoderEstimatePeakMemoryUsage</name><parameter_list>(
    <parameter><decl><type><name>int</name></type> <name>quality</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lgwin</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>input_size</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block">/* Returns 0 if dictionary is not valid; otherwise returns allocation size. */</comment>
<function_decl><type><name>BROTLI_ENC_EXTRA_API</name> <name>size_t</name></type> <name>BrotliEncoderGetPreparedDictionarySize</name><parameter_list>(
    <parameter><decl><type><specifier>const</specifier> <name>BrotliEncoderPreparedDictionary</name><modifier>*</modifier></type> <name>dictionary</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block" format="doxygen">/**
 * Gets an encoder library version.
 *
 * Look at BROTLI_VERSION for more information.
 */</comment>
<function_decl><type><name>BROTLI_ENC_API</name> <name>uint32_t</name></type> <name>BrotliEncoderVersion</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>c_plusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
</block_content>}</block></extern>  <comment type="block">/* extern "C" */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* BROTLI_ENC_ENCODE_H_ */</comment>
</unit>
