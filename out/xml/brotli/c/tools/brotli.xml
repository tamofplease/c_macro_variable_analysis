<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="../out/cloned_projects/brotli/c/tools/brotli.c"><comment type="block">/* Copyright 2014 Google Inc. All Rights Reserved.

   Distributed under MIT license.
   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT
*/</comment>

<comment type="block">/* Command line interface for Brotli library. */</comment>

<comment type="block">/* Mute strerror/strcpy warnings. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_CRT_SECURE_NO_WARNINGS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_CRT_SECURE_NO_WARNINGS</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;brotli/decode.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;brotli/encode.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../common/constants.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../common/version.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utime.h&gt;</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAKE_BINARY</name><parameter_list>(<parameter><type><name>FILENO</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(FILENO)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;io.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;share.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/utime.h&gt;</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAKE_BINARY</name><parameter_list>(<parameter><type><name>FILENO</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(_setmode((FILENO), _O_BINARY), (FILENO))</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__MINGW32__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STDIN_FILENO</name></cpp:macro> <cpp:value>_fileno(stdin)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STDOUT_FILENO</name></cpp:macro> <cpp:value>_fileno(stdout)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S_IRUSR</name></cpp:macro> <cpp:value>S_IREAD</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S_IWUSR</name></cpp:macro> <cpp:value>S_IWRITE</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>fdopen</name></cpp:macro> <cpp:value>_fdopen</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>isatty</name></cpp:macro> <cpp:value>_isatty</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>unlink</name></cpp:macro> <cpp:value>_unlink</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>utimbuf</name></cpp:macro> <cpp:value>_utimbuf</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>utime</name></cpp:macro> <cpp:value>_utime</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>fopen</name></cpp:macro> <cpp:value>ms_fopen</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>open</name></cpp:macro> <cpp:value>ms_open</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>chmod</name><parameter_list>(<parameter><type><name>F</name></type></parameter>, <parameter><type><name>P</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>chown</name><parameter_list>(<parameter><type><name>F</name></type></parameter>, <parameter><type><name>O</name></type></parameter>, <parameter><type><name>G</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(0)</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>_MSC_VER</name> <operator>&gt;=</operator> <literal type="number">1400</literal><operator>)</operator></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>fseek</name></cpp:macro> <cpp:value>_fseeki64</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ftell</name></cpp:macro> <cpp:value>_ftelli64</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>FILE</name><modifier>*</modifier></type> <name>ms_fopen</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>filename</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>mode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>FILE</name><modifier>*</modifier></type> <name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>fopen_s</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>ms_open</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>filename</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>oflag</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pmode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>_sopen_s</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>oflag</name> <operator>|</operator> <name>O_BINARY</name></expr></argument>, <argument><expr><name>_SH_DENYNO</name></expr></argument>, <argument><expr><name>pmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* WIN32 */</comment>

<typedef>typedef <type><enum>enum <block>{
  <decl><name>COMMAND_COMPRESS</name></decl>,
  <decl><name>COMMAND_DECOMPRESS</name></decl>,
  <decl><name>COMMAND_HELP</name></decl>,
  <decl><name>COMMAND_INVALID</name></decl>,
  <decl><name>COMMAND_TEST_INTEGRITY</name></decl>,
  <decl><name>COMMAND_NOOP</name></decl>,
  <decl><name>COMMAND_VERSION</name></decl>
}</block></enum></type> <name>Command</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_LGWIN</name></cpp:macro> <cpp:value>24</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_SUFFIX</name></cpp:macro> <cpp:value>".br"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_OPTIONS</name></cpp:macro> <cpp:value>20</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <block>{
  <comment type="block">/* Parameters */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>quality</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>lgwin</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>verbosity</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BROTLI_BOOL</name></type> <name>force_overwrite</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BROTLI_BOOL</name></type> <name>junk_source</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BROTLI_BOOL</name></type> <name>copy_stat</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BROTLI_BOOL</name></type> <name>write_to_stdout</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BROTLI_BOOL</name></type> <name>test_integrity</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BROTLI_BOOL</name></type> <name>decompress</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BROTLI_BOOL</name></type> <name>large_window</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>output_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>dictionary_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>suffix</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name><name>not_input_indices</name><index>[<expr><name>MAX_OPTIONS</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>longest_path_len</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>input_count</name></decl>;</decl_stmt>

  <comment type="block">/* Inner state */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>argc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name><modifier>*</modifier><modifier>*</modifier></type> <name>argv</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name><modifier>*</modifier></type> <name>dictionary</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>dictionary_size</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BrotliEncoderPreparedDictionary</name><modifier>*</modifier></type> <name>prepared_dictionary</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>modified_path</name></decl>;</decl_stmt>  <comment type="block">/* Storage for path with appended / cut suffix */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iterator</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>ignore</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BROTLI_BOOL</name></type> <name>iterator_error</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name><modifier>*</modifier></type> <name>buffer</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name><modifier>*</modifier></type> <name>input</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name><modifier>*</modifier></type> <name>output</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>current_input_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>current_output_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int64_t</name></type> <name>input_file_length</name></decl>;</decl_stmt>  <comment type="block">/* -1, if impossible to calculate */</comment>
  <decl_stmt><decl><type><name>FILE</name><modifier>*</modifier></type> <name>fin</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FILE</name><modifier>*</modifier></type> <name>fout</name></decl>;</decl_stmt>

  <comment type="block">/* I/O buffers */</comment>
  <decl_stmt><decl><type><name>size_t</name></type> <name>available_in</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name><modifier>*</modifier></type> <name>next_in</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>available_out</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name><modifier>*</modifier></type> <name>next_out</name></decl>;</decl_stmt>

  <comment type="block">/* Reporting */</comment>
  <comment type="block">/* size_t would be large enough,
     until 4GiB+ files are compressed / decompressed on 32-bit CPUs. */</comment>
  <decl_stmt><decl><type><name>size_t</name></type> <name>total_in</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>total_out</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>clock_t</name></type> <name>start_time</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>clock_t</name></type> <name>end_time</name></decl>;</decl_stmt>
}</block></struct></type> <name>Context</name>;</typedef>

<comment type="block">/* Parse up to 5 decimal digits. */</comment>
<function><type><specifier>static</specifier> <name>BROTLI_BOOL</name></type> <name>ParseInt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>low</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>high</name></decl></parameter>, <parameter><decl><type><name>int</name><modifier>*</modifier></type> <name>result</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>value</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">5</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name>c</name> <init>= <expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;</operator> <literal type="char">'0'</literal> <operator>||</operator> <name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <literal type="char">'9'</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>BROTLI_FALSE</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>value</name> <operator>=</operator> <operator>(</operator><literal type="number">10</literal> <operator>*</operator> <name>value</name><operator>)</operator> <operator>+</operator> <operator>(</operator><name>c</name> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>BROTLI_FALSE</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>s</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'0'</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>BROTLI_FALSE</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>BROTLI_FALSE</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>value</name> <argument_list type="generic">&lt; <argument><expr><name>low</name> <operator>||</operator> <name>value</name></expr></argument> &gt;</argument_list></name> <name>high</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>BROTLI_FALSE</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
  <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Returns "base file name" or its tail, if it contains '/' or '\'. */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>FileName</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>path</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>separator_position</name> <init>= <expr><call><name>strrchr</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>separator_position</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>path</name> <operator>=</operator> <name>separator_position</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>separator_position</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="char">'\\'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>separator_position</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>path</name> <operator>=</operator> <name>separator_position</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>path</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Detect if the program name is a special alias that infers a command type. */</comment>
<function><type><specifier>static</specifier> <name>Command</name></type> <name>ParseAlias</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* TODO: cast name to lower case? */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>unbrotli</name> <init>= <expr><literal type="string">"unbrotli"</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>unbrotli_len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>unbrotli</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>FileName</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Partial comparison. On Windows there could be ".exe" suffix. */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>unbrotli</name></expr></argument>, <argument><expr><name>unbrotli_len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name>terminator</name> <init>= <expr><name><name>name</name><index>[<expr><name>unbrotli_len</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>terminator</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>terminator</name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>COMMAND_DECOMPRESS</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>COMMAND_COMPRESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Command</name></type> <name>ParseParams</name><parameter_list>(<parameter><decl><type><name>Context</name><modifier>*</modifier></type> <name>params</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>argc</name> <init>= <expr><name><name>params</name><operator>-&gt;</operator><name>argc</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name><modifier>*</modifier><modifier>*</modifier></type> <name>argv</name> <init>= <expr><name><name>params</name><operator>-&gt;</operator><name>argv</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>next_option_index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>input_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>longest_path_len</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BROTLI_BOOL</name></type> <name>command_set</name> <init>= <expr><name>BROTLI_FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BROTLI_BOOL</name></type> <name>quality_set</name> <init>= <expr><name>BROTLI_FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BROTLI_BOOL</name></type> <name>output_set</name> <init>= <expr><name>BROTLI_FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BROTLI_BOOL</name></type> <name>keep_set</name> <init>= <expr><name>BROTLI_FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BROTLI_BOOL</name></type> <name>lgwin_set</name> <init>= <expr><name>BROTLI_FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BROTLI_BOOL</name></type> <name>suffix_set</name> <init>= <expr><name>BROTLI_FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BROTLI_BOOL</name></type> <name>after_dash_dash</name> <init>= <expr><name>BROTLI_FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Command</name></type> <name>command</name> <init>= <expr><call><name>ParseAlias</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>arg</name> <init>= <expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <comment type="block">/* C99 5.1.2.2.1: "members argv[0] through argv[argc-1] inclusive shall
       contain pointers to strings"; NULL and 0-length are not forbidden. */</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>arg_len</name> <init>= <expr><ternary><condition><expr><name>arg</name></expr> ?</condition><then> <expr><call><name>strlen</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>arg_len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>not_input_indices</name><index>[<expr><name>next_option_index</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Too many options. The expected longest option list is:
       "-q 0 -w 10 -o f -D d -S b -d -f -k -n -v --", i.e. 16 items in total.
       This check is an additional guard that is never triggered, but provides
       a guard for future changes. */</comment>
    <if_stmt><if>if <condition>(<expr><name>next_option_index</name> <operator>&gt;</operator> <operator>(</operator><name>MAX_OPTIONS</name> <operator>-</operator> <literal type="number">2</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"too many options passed\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>COMMAND_INVALID</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Input file entry. */</comment>
    <if_stmt><if>if <condition>(<expr><name>after_dash_dash</name> <operator>||</operator> <name><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'-'</literal> <operator>||</operator> <name>arg_len</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>input_count</name><operator>++</operator></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>longest_path_len</name> <operator>&lt;</operator> <name>arg_len</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>longest_path_len</name> <operator>=</operator> <name>arg_len</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Not a file entry. */</comment>
    <expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>not_input_indices</name><index>[<expr><name>next_option_index</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

    <comment type="block">/* '--' entry stop parsing arguments. */</comment>
    <if_stmt><if>if <condition>(<expr><name>arg_len</name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>arg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>after_dash_dash</name> <operator>=</operator> <name>BROTLI_TRUE</name></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Simple / coalesced options. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>arg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>size_t</name></type> <name>j</name></decl>;</decl_stmt>
      <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>arg_len</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type> <name>c</name> <init>= <expr><name><name>arg</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <literal type="char">'9'</literal></expr>)</condition> <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>quality_set</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"quality already set\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>COMMAND_INVALID</name></expr>;</return>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>quality_set</name> <operator>=</operator> <name>BROTLI_TRUE</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>quality</name></name> <operator>=</operator> <name>c</name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
          <continue>continue;</continue>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'c'</literal></expr>)</condition> <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>output_set</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"write to standard output already set\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>COMMAND_INVALID</name></expr>;</return>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>output_set</name> <operator>=</operator> <name>BROTLI_TRUE</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>write_to_stdout</name></name> <operator>=</operator> <name>BROTLI_TRUE</name></expr>;</expr_stmt>
          <continue>continue;</continue>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'d'</literal></expr>)</condition> <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>command_set</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"command already set when parsing -d\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>COMMAND_INVALID</name></expr>;</return>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>command_set</name> <operator>=</operator> <name>BROTLI_TRUE</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>command</name> <operator>=</operator> <name>COMMAND_DECOMPRESS</name></expr>;</expr_stmt>
          <continue>continue;</continue>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'f'</literal></expr>)</condition> <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>force_overwrite</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"force output overwrite already set\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>COMMAND_INVALID</name></expr>;</return>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>force_overwrite</name></name> <operator>=</operator> <name>BROTLI_TRUE</name></expr>;</expr_stmt>
          <continue>continue;</continue>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'h'</literal></expr>)</condition> <block>{<block_content>
          <comment type="block">/* Don't parse further. */</comment>
          <return>return <expr><name>COMMAND_HELP</name></expr>;</return>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'j'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'k'</literal></expr>)</condition> <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>keep_set</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"argument --rm / -j or --keep / -k already set\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>COMMAND_INVALID</name></expr>;</return>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>keep_set</name> <operator>=</operator> <name>BROTLI_TRUE</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>junk_source</name></name> <operator>=</operator> <call><name>TO_BROTLI_BOOL</name><argument_list>(<argument><expr><name>c</name> <operator>==</operator> <literal type="char">'j'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <continue>continue;</continue>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'n'</literal></expr>)</condition> <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>params</name><operator>-&gt;</operator><name>copy_stat</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"argument --no-copy-stat / -n already set\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>COMMAND_INVALID</name></expr>;</return>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>copy_stat</name></name> <operator>=</operator> <name>BROTLI_FALSE</name></expr>;</expr_stmt>
          <continue>continue;</continue>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'t'</literal></expr>)</condition> <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>command_set</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"command already set when parsing -t\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>COMMAND_INVALID</name></expr>;</return>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>command_set</name> <operator>=</operator> <name>BROTLI_TRUE</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>command</name> <operator>=</operator> <name>COMMAND_TEST_INTEGRITY</name></expr>;</expr_stmt>
          <continue>continue;</continue>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'v'</literal></expr>)</condition> <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>verbosity</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"argument --verbose / -v already set\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>COMMAND_INVALID</name></expr>;</return>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>verbosity</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <continue>continue;</continue>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'V'</literal></expr>)</condition> <block>{<block_content>
          <comment type="block">/* Don't parse further. */</comment>
          <return>return <expr><name>COMMAND_VERSION</name></expr>;</return>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'Z'</literal></expr>)</condition> <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>quality_set</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"quality already set\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>COMMAND_INVALID</name></expr>;</return>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>quality_set</name> <operator>=</operator> <name>BROTLI_TRUE</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>quality</name></name> <operator>=</operator> <literal type="number">11</literal></expr>;</expr_stmt>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* o/q/w/D/S with parameter is expected */</comment>
        <if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <literal type="char">'o'</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <literal type="char">'q'</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <literal type="char">'w'</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <literal type="char">'D'</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <literal type="char">'S'</literal></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"invalid argument -%c\n"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>COMMAND_INVALID</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>j</name> <operator>+</operator> <literal type="number">1</literal> <operator>!=</operator> <name>arg_len</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"expected parameter for argument -%c\n"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>COMMAND_INVALID</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>argc</name> <operator>||</operator> <operator>!</operator><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name> <operator>||</operator> <name><name>argv</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"expected parameter for argument -%c\n"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>COMMAND_INVALID</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>not_input_indices</name><index>[<expr><name>next_option_index</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'o'</literal></expr>)</condition> <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>output_set</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"write to standard output already set (-o)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>COMMAND_INVALID</name></expr>;</return>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>output_path</name></name> <operator>=</operator> <name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'q'</literal></expr>)</condition> <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>quality_set</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"quality already set\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>COMMAND_INVALID</name></expr>;</return>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>quality_set</name> <operator>=</operator> <call><name>ParseInt</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>BROTLI_MIN_QUALITY</name></expr></argument>,
                                 <argument><expr><name>BROTLI_MAX_QUALITY</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>params</name><operator>-&gt;</operator><name>quality</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><operator>!</operator><name>quality_set</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"error parsing quality value [%s]\n"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>COMMAND_INVALID</name></expr>;</return>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'w'</literal></expr>)</condition> <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>lgwin_set</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"lgwin parameter already set\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>COMMAND_INVALID</name></expr>;</return>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>lgwin_set</name> <operator>=</operator> <call><name>ParseInt</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                               <argument><expr><name>BROTLI_MAX_WINDOW_BITS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>params</name><operator>-&gt;</operator><name>lgwin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><operator>!</operator><name>lgwin_set</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"error parsing lgwin value [%s]\n"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>COMMAND_INVALID</name></expr>;</return>
          </block_content>}</block></if></if_stmt>
          <if_stmt><if>if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>lgwin</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>params</name><operator>-&gt;</operator><name>lgwin</name></name> <operator>&lt;</operator> <name>BROTLI_MIN_WINDOW_BITS</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                    <argument><expr><literal type="string">"lgwin parameter (%d) smaller than the minimum (%d)\n"</literal></expr></argument>,
                    <argument><expr><name><name>params</name><operator>-&gt;</operator><name>lgwin</name></name></expr></argument>, <argument><expr><name>BROTLI_MIN_WINDOW_BITS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>COMMAND_INVALID</name></expr>;</return>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'D'</literal></expr>)</condition> <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>dictionary_path</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"dictionary path already set\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>COMMAND_INVALID</name></expr>;</return>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>dictionary_path</name></name> <operator>=</operator> <name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'S'</literal></expr>)</condition> <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>suffix_set</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"suffix already set\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>COMMAND_INVALID</name></expr>;</return>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>suffix_set</name> <operator>=</operator> <name>BROTLI_TRUE</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>suffix</name></name> <operator>=</operator> <name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* Double-dash. */</comment>
      <expr_stmt><expr><name>arg</name> <operator>=</operator> <operator>&amp;</operator><name><name>arg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"best"</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>quality_set</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"quality already set\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>COMMAND_INVALID</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>quality_set</name> <operator>=</operator> <name>BROTLI_TRUE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>quality</name></name> <operator>=</operator> <literal type="number">11</literal></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"decompress"</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>command_set</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"command already set when parsing --decompress\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>COMMAND_INVALID</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>command_set</name> <operator>=</operator> <name>BROTLI_TRUE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>command</name> <operator>=</operator> <name>COMMAND_DECOMPRESS</name></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"force"</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>force_overwrite</name></name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"force output overwrite already set\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>COMMAND_INVALID</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>force_overwrite</name></name> <operator>=</operator> <name>BROTLI_TRUE</name></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"help"</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Don't parse further. */</comment>
        <return>return <expr><name>COMMAND_HELP</name></expr>;</return>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"keep"</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>keep_set</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"argument --rm / -j or --keep / -k already set\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>COMMAND_INVALID</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>keep_set</name> <operator>=</operator> <name>BROTLI_TRUE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>junk_source</name></name> <operator>=</operator> <name>BROTLI_FALSE</name></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"no-copy-stat"</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>params</name><operator>-&gt;</operator><name>copy_stat</name></name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"argument --no-copy-stat / -n already set\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>COMMAND_INVALID</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>copy_stat</name></name> <operator>=</operator> <name>BROTLI_FALSE</name></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"rm"</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>keep_set</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"argument --rm / -j or --keep / -k already set\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>COMMAND_INVALID</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>keep_set</name> <operator>=</operator> <name>BROTLI_TRUE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>junk_source</name></name> <operator>=</operator> <name>BROTLI_TRUE</name></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"stdout"</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>output_set</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"write to standard output already set\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>COMMAND_INVALID</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>output_set</name> <operator>=</operator> <name>BROTLI_TRUE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>write_to_stdout</name></name> <operator>=</operator> <name>BROTLI_TRUE</name></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"test"</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>command_set</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"command already set when parsing --test\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>COMMAND_INVALID</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>command_set</name> <operator>=</operator> <name>BROTLI_TRUE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>command</name> <operator>=</operator> <name>COMMAND_TEST_INTEGRITY</name></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"verbose"</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>verbosity</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"argument --verbose / -v already set\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>COMMAND_INVALID</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>verbosity</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"version"</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Don't parse further. */</comment>
        <return>return <expr><name>COMMAND_VERSION</name></expr>;</return>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="block">/* key=value */</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>value</name> <init>= <expr><call><name>strrchr</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>key_len</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>value</name> <operator>||</operator> <name><name>value</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"must pass the parameter as --%s=value\n"</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>COMMAND_INVALID</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>key_len</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>value</name> <operator>-</operator> <name>arg</name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>value</name><operator>++</operator></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><literal type="string">"dictionary"</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>key_len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>dictionary_path</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"dictionary path already set\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>COMMAND_INVALID</name></expr>;</return>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>dictionary_path</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><literal type="string">"lgwin"</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>key_len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>lgwin_set</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"lgwin parameter already set\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>COMMAND_INVALID</name></expr>;</return>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>lgwin_set</name> <operator>=</operator> <call><name>ParseInt</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                               <argument><expr><name>BROTLI_MAX_WINDOW_BITS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>params</name><operator>-&gt;</operator><name>lgwin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><operator>!</operator><name>lgwin_set</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"error parsing lgwin value [%s]\n"</literal></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>COMMAND_INVALID</name></expr>;</return>
          </block_content>}</block></if></if_stmt>
          <if_stmt><if>if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>lgwin</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>params</name><operator>-&gt;</operator><name>lgwin</name></name> <operator>&lt;</operator> <name>BROTLI_MIN_WINDOW_BITS</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                    <argument><expr><literal type="string">"lgwin parameter (%d) smaller than the minimum (%d)\n"</literal></expr></argument>,
                    <argument><expr><name><name>params</name><operator>-&gt;</operator><name>lgwin</name></name></expr></argument>, <argument><expr><name>BROTLI_MIN_WINDOW_BITS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>COMMAND_INVALID</name></expr>;</return>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><literal type="string">"large_window"</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>key_len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
          <comment type="block">/* This option is intentionally not mentioned in help. */</comment>
          <if_stmt><if>if <condition>(<expr><name>lgwin_set</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"lgwin parameter already set\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>COMMAND_INVALID</name></expr>;</return>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>lgwin_set</name> <operator>=</operator> <call><name>ParseInt</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                               <argument><expr><name>BROTLI_LARGE_MAX_WINDOW_BITS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>params</name><operator>-&gt;</operator><name>lgwin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><operator>!</operator><name>lgwin_set</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"error parsing lgwin value [%s]\n"</literal></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>COMMAND_INVALID</name></expr>;</return>
          </block_content>}</block></if></if_stmt>
          <if_stmt><if>if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>lgwin</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>params</name><operator>-&gt;</operator><name>lgwin</name></name> <operator>&lt;</operator> <name>BROTLI_MIN_WINDOW_BITS</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                    <argument><expr><literal type="string">"lgwin parameter (%d) smaller than the minimum (%d)\n"</literal></expr></argument>,
                    <argument><expr><name><name>params</name><operator>-&gt;</operator><name>lgwin</name></name></expr></argument>, <argument><expr><name>BROTLI_MIN_WINDOW_BITS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>COMMAND_INVALID</name></expr>;</return>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><literal type="string">"output"</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>key_len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>output_set</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                    <argument><expr><literal type="string">"write to standard output already set (--output)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>COMMAND_INVALID</name></expr>;</return>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>output_path</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><literal type="string">"quality"</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>key_len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>quality_set</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"quality already set\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>COMMAND_INVALID</name></expr>;</return>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>quality_set</name> <operator>=</operator> <call><name>ParseInt</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>BROTLI_MIN_QUALITY</name></expr></argument>,
                                 <argument><expr><name>BROTLI_MAX_QUALITY</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>params</name><operator>-&gt;</operator><name>quality</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><operator>!</operator><name>quality_set</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"error parsing quality value [%s]\n"</literal></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>COMMAND_INVALID</name></expr>;</return>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><literal type="string">"suffix"</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>key_len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>suffix_set</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"suffix already set\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>COMMAND_INVALID</name></expr>;</return>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>suffix_set</name> <operator>=</operator> <name>BROTLI_TRUE</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>suffix</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"invalid parameter: [%s]\n"</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>COMMAND_INVALID</name></expr>;</return>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>input_count</name></name> <operator>=</operator> <name>input_count</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>longest_path_len</name></name> <operator>=</operator> <name>longest_path_len</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>decompress</name></name> <operator>=</operator> <operator>(</operator><name>command</name> <operator>==</operator> <name>COMMAND_DECOMPRESS</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>test_integrity</name></name> <operator>=</operator> <operator>(</operator><name>command</name> <operator>==</operator> <name>COMMAND_TEST_INTEGRITY</name><operator>)</operator></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>input_count</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>output_set</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>COMMAND_INVALID</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>test_integrity</name></name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>output_path</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>COMMAND_INVALID</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>write_to_stdout</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>COMMAND_INVALID</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>strchr</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>, <argument><expr><literal type="char">'\\'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>COMMAND_INVALID</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>command</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>PrintVersion</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>major</name> <init>= <expr><name>BROTLI_VERSION</name> <operator>&gt;&gt;</operator> <literal type="number">24</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>minor</name> <init>= <expr><operator>(</operator><name>BROTLI_VERSION</name> <operator>&gt;&gt;</operator> <literal type="number">12</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFFF</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>patch</name> <init>= <expr><name>BROTLI_VERSION</name> <operator>&amp;</operator> <literal type="number">0xFFF</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><literal type="string">"brotli %d.%d.%d\n"</literal></expr></argument>, <argument><expr><name>major</name></expr></argument>, <argument><expr><name>minor</name></expr></argument>, <argument><expr><name>patch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>PrintHelp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>name</name></decl></parameter>, <parameter><decl><type><name>BROTLI_BOOL</name></type> <name>error</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>FILE</name><modifier>*</modifier></type> <name>media</name> <init>= <expr><ternary><condition><expr><name>error</name></expr> ?</condition><then> <expr><name>stderr</name></expr> </then><else>: <expr><name>stdout</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <comment type="block">/* String is cut to pieces with length less than 509, to conform C90 spec. */</comment>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>media</name></expr></argument>,
<argument><expr><literal type="string">"Usage: %s [OPTION]... [FILE]...\n"</literal></expr></argument>,
          <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>media</name></expr></argument>,
<argument><expr><literal type="string">"Options:\n"</literal>
<literal type="string">"  -#                          compression level (0-9)\n"</literal>
<literal type="string">"  -c, --stdout                write on standard output\n"</literal>
<literal type="string">"  -d, --decompress            decompress\n"</literal>
<literal type="string">"  -f, --force                 force output file overwrite\n"</literal>
<literal type="string">"  -h, --help                  display this help and exit\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>media</name></expr></argument>,
<argument><expr><literal type="string">"  -j, --rm                    remove source file(s)\n"</literal>
<literal type="string">"  -k, --keep                  keep source file(s) (default)\n"</literal>
<literal type="string">"  -n, --no-copy-stat          do not copy source file(s) attributes\n"</literal>
<literal type="string">"  -o FILE, --output=FILE      output file (only if 1 input file)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>media</name></expr></argument>,
<argument><expr><literal type="string">"  -q NUM, --quality=NUM       compression level (%d-%d)\n"</literal></expr></argument>,
          <argument><expr><name>BROTLI_MIN_QUALITY</name></expr></argument>, <argument><expr><name>BROTLI_MAX_QUALITY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>media</name></expr></argument>,
<argument><expr><literal type="string">"  -t, --test                  test compressed file integrity\n"</literal>
<literal type="string">"  -v, --verbose               verbose mode\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>media</name></expr></argument>,
<argument><expr><literal type="string">"  -w NUM, --lgwin=NUM         set LZ77 window size (0, %d-%d)\n"</literal>
<literal type="string">"                              window size = 2**NUM - 16\n"</literal>
<literal type="string">"                              0 lets compressor choose the optimal value\n"</literal></expr></argument>,
          <argument><expr><name>BROTLI_MIN_WINDOW_BITS</name></expr></argument>, <argument><expr><name>BROTLI_MAX_WINDOW_BITS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>media</name></expr></argument>,
<argument><expr><literal type="string">"  --large_window=NUM          use incompatible large-window brotli\n"</literal>
<literal type="string">"                              bitstream with window size (0, %d-%d)\n"</literal>
<literal type="string">"                              WARNING: this format is not compatible\n"</literal>
<literal type="string">"                              with brotli RFC 7932 and may not be\n"</literal>
<literal type="string">"                              decodable with regular brotli decoders\n"</literal></expr></argument>,
          <argument><expr><name>BROTLI_MIN_WINDOW_BITS</name></expr></argument>, <argument><expr><name>BROTLI_LARGE_MAX_WINDOW_BITS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>media</name></expr></argument>,
<argument><expr><literal type="string">"  -D FILE, --dictionary=FILE  use FILE as raw (LZ77) dictionary\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>media</name></expr></argument>,
<argument><expr><literal type="string">"  -S SUF, --suffix=SUF        output file suffix (default:'%s')\n"</literal></expr></argument>,
          <argument><expr><name>DEFAULT_SUFFIX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>media</name></expr></argument>,
<argument><expr><literal type="string">"  -V, --version               display version and exit\n"</literal>
<literal type="string">"  -Z, --best                  use best compression level (11) (default)\n"</literal>
<literal type="string">"Simple options could be coalesced, i.e. '-9kf' is equivalent to '-9 -k -f'.\n"</literal>
<literal type="string">"With no FILE, or when FILE is -, read standard input.\n"</literal>
<literal type="string">"All arguments after '--' are treated as files.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>PrintablePath</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>path</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><ternary><condition><expr><name>path</name></expr> ?</condition><then> <expr><name>path</name></expr> </then><else>: <expr><literal type="string">"con"</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BROTLI_BOOL</name></type> <name>OpenInputFile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>input_path</name></decl></parameter>, <parameter><decl><type><name>FILE</name><modifier>*</modifier><modifier>*</modifier></type> <name>f</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><operator>*</operator><name>f</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>input_path</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>f</name> <operator>=</operator> <call><name>fdopen</name><argument_list>(<argument><expr><call><name>MAKE_BINARY</name><argument_list>(<argument><expr><name>STDIN_FILENO</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"rb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>f</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>input_path</name></expr></argument>, <argument><expr><literal type="string">"rb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>f</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"failed to open input file [%s]: %s\n"</literal></expr></argument>,
            <argument><expr><call><name>PrintablePath</name><argument_list>(<argument><expr><name>input_path</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>BROTLI_FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BROTLI_BOOL</name></type> <name>OpenOutputFile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>output_path</name></decl></parameter>, <parameter><decl><type><name>FILE</name><modifier>*</modifier><modifier>*</modifier></type> <name>f</name></decl></parameter>,
                                  <parameter><decl><type><name>BROTLI_BOOL</name></type> <name>force</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
  <expr_stmt><expr><operator>*</operator><name>f</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>output_path</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>f</name> <operator>=</operator> <call><name>fdopen</name><argument_list>(<argument><expr><call><name>MAKE_BINARY</name><argument_list>(<argument><expr><name>STDOUT_FILENO</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"wb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>output_path</name></expr></argument>, <argument><expr><name>O_CREAT</name> <operator>|</operator> <operator>(</operator><ternary><condition><expr><name>force</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>O_EXCL</name></expr></else></ternary><operator>)</operator> <operator>|</operator> <name>O_WRONLY</name> <operator>|</operator> <name>O_TRUNC</name></expr></argument>,
            <argument><expr><name>S_IRUSR</name> <operator>|</operator> <name>S_IWUSR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"failed to open output file [%s]: %s\n"</literal></expr></argument>,
            <argument><expr><call><name>PrintablePath</name><argument_list>(<argument><expr><name>output_path</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>BROTLI_FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>f</name> <operator>=</operator> <call><name>fdopen</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="string">"wb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>f</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"failed to open output file [%s]: %s\n"</literal></expr></argument>,
            <argument><expr><call><name>PrintablePath</name><argument_list>(<argument><expr><name>output_path</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>BROTLI_FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int64_t</name></type> <name>FileSize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>path</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>FILE</name><modifier>*</modifier></type> <name>f</name> <init>= <expr><call><name>fopen</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">"rb"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int64_t</name></type> <name>retval</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>f</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>fseek</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="number">0L</literal></expr></argument>, <argument><expr><name>SEEK_END</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>ftell</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Copy file times and permissions.
   TODO(eustas): this is a "best effort" implementation; honest cross-platform
   fully featured implementation is way too hacky; add more hacks by request. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>CopyStat</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>input_path</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>output_path</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>statbuf</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>utimbuf</name></name></type> <name>times</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>input_path</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>output_path</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>input_path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>times</name><operator>.</operator><name>actime</name></name> <operator>=</operator> <name><name>statbuf</name><operator>.</operator><name>st_atime</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>times</name><operator>.</operator><name>modtime</name></name> <operator>=</operator> <name><name>statbuf</name><operator>.</operator><name>st_mtime</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>utime</name><argument_list>(<argument><expr><name>output_path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>times</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>chmod</name><argument_list>(<argument><expr><name>output_path</name></expr></argument>, <argument><expr><name><name>statbuf</name><operator>.</operator><name>st_mode</name></name> <operator>&amp;</operator> <operator>(</operator><name>S_IRWXU</name> <operator>|</operator> <name>S_IRWXG</name> <operator>|</operator> <name>S_IRWXO</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>res</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"setting access bits failed for [%s]: %s\n"</literal></expr></argument>,
            <argument><expr><call><name>PrintablePath</name><argument_list>(<argument><expr><name>output_path</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>chown</name><argument_list>(<argument><expr><name>output_path</name></expr></argument>, <argument><expr><operator>(</operator><name>uid_t</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>statbuf</name><operator>.</operator><name>st_gid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>res</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"setting group failed for [%s]: %s\n"</literal></expr></argument>,
            <argument><expr><call><name>PrintablePath</name><argument_list>(<argument><expr><name>output_path</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>chown</name><argument_list>(<argument><expr><name>output_path</name></expr></argument>, <argument><expr><name><name>statbuf</name><operator>.</operator><name>st_uid</name></name></expr></argument>, <argument><expr><operator>(</operator><name>gid_t</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>res</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"setting user failed for [%s]: %s\n"</literal></expr></argument>,
            <argument><expr><call><name>PrintablePath</name><argument_list>(<argument><expr><name>output_path</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Result ownership is passed to caller.
   |*dictionary_size| is set to resulting buffer size. */</comment>
<function><type><specifier>static</specifier> <name>BROTLI_BOOL</name></type> <name>ReadDictionary</name><parameter_list>(<parameter><decl><type><name>Context</name><modifier>*</modifier></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>Command</name></type> <name>command</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>kMaxDictionarySize</name> <init>=
      <expr><name>BROTLI_MAX_DISTANCE</name> <operator>-</operator> <call><name>BROTLI_MAX_BACKWARD_LIMIT</name><argument_list>(<argument><expr><literal type="number">24</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FILE</name><modifier>*</modifier></type> <name>f</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int64_t</name></type> <name>file_size_64</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name><modifier>*</modifier></type> <name>buffer</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>bytes_read</name></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>dictionary_path</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>BROTLI_TRUE</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>dictionary_path</name></name></expr></argument>, <argument><expr><literal type="string">"rb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>f</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"failed to open dictionary file [%s]: %s\n"</literal></expr></argument>,
            <argument><expr><call><name>PrintablePath</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>dictionary_path</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>BROTLI_FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>file_size_64</name> <operator>=</operator> <call><name>FileSize</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>dictionary_path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>file_size_64</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"could not get size of dictionary file [%s]"</literal></expr></argument>,
            <argument><expr><call><name>PrintablePath</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>dictionary_path</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>BROTLI_FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>file_size_64</name> <operator>&gt;</operator> <name>kMaxDictionarySize</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"dictionary [%s] is larger than maximum allowed: %d\n"</literal></expr></argument>,
            <argument><expr><call><name>PrintablePath</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>dictionary_path</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>kMaxDictionarySize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>BROTLI_FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>dictionary_size</name></name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>file_size_64</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>buffer</name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>dictionary_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>buffer</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"could not read dictionary: out of memory\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>BROTLI_FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>bytes_read</name> <operator>=</operator> <call><name>fread</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint8_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>dictionary_size</name></name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>bytes_read</name> <operator>!=</operator> <name><name>context</name><operator>-&gt;</operator><name>dictionary_size</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"failed to read dictionary [%s]: %s\n"</literal></expr></argument>,
            <argument><expr><call><name>PrintablePath</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>dictionary_path</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>BROTLI_FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>dictionary</name></name> <operator>=</operator> <name>buffer</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>command</name> <operator>==</operator> <name>COMMAND_COMPRESS</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>prepared_dictionary</name></name> <operator>=</operator> <call><name>BrotliEncoderPrepareDictionary</name><argument_list>(
        <argument><expr><name>BROTLI_SHARED_DICTIONARY_RAW</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>dictionary_size</name></name></expr></argument>,
        <argument><expr><name><name>context</name><operator>-&gt;</operator><name>dictionary</name></name></expr></argument>, <argument><expr><name>BROTLI_MAX_QUALITY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>prepared_dictionary</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"failed to prepare dictionary [%s]\n"</literal></expr></argument>,
              <argument><expr><call><name>PrintablePath</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>dictionary_path</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>BROTLI_FALSE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BROTLI_BOOL</name></type> <name>NextFile</name><parameter_list>(<parameter><decl><type><name>Context</name><modifier>*</modifier></type> <name>context</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>arg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>arg_len</name></decl>;</decl_stmt>

  <comment type="block">/* Iterator points to last used arg; increment to search for the next one. */</comment>
  <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>iterator</name></name><operator>++</operator></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>input_file_length</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

  <comment type="block">/* No input path; read from console. */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>input_count</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>iterator</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>BROTLI_FALSE</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>current_input_path</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <comment type="block">/* Either write to the specified path, or to console. */</comment>
    <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>current_output_path</name></name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>output_path</name></name></expr>;</expr_stmt>
    <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Skip option arguments. */</comment>
  <while>while <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>iterator</name></name> <operator>==</operator> <name><name>context</name><operator>-&gt;</operator><name>not_input_indices</name><index>[<expr><name><name>context</name><operator>-&gt;</operator><name>ignore</name></name></expr>]</index></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>iterator</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>ignore</name></name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></while>

  <comment type="block">/* All args are scanned already. */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>iterator</name></name> <operator>&gt;=</operator> <name><name>context</name><operator>-&gt;</operator><name>argc</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>BROTLI_FALSE</name></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* Iterator now points to the input file name. */</comment>
  <expr_stmt><expr><name>arg</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name><name>context</name><operator>-&gt;</operator><name>iterator</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>arg_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Read from console. */</comment>
  <if_stmt><if>if <condition>(<expr><name>arg_len</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>current_input_path</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>current_output_path</name></name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>output_path</name></name></expr>;</expr_stmt>
    <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>current_input_path</name></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>input_file_length</name></name> <operator>=</operator> <call><name>FileSize</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>current_output_path</name></name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>output_path</name></name></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>output_path</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>BROTLI_TRUE</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>write_to_stdout</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>BROTLI_TRUE</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>modified_path</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>current_output_path</name></name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>modified_path</name></name></expr>;</expr_stmt>
  <comment type="block">/* If output is not specified, input path suffix should match. */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>decompress</name></name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>suffix_len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>name</name> <init>= <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>FileName</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>modified_path</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>name_suffix</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>name_len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>name_len</name> <operator>&lt;</operator> <name>suffix_len</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"empty output file name for [%s] input file\n"</literal></expr></argument>,
              <argument><expr><call><name>PrintablePath</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>iterator_error</name></name> <operator>=</operator> <name>BROTLI_TRUE</name></expr>;</expr_stmt>
      <return>return <expr><name>BROTLI_FALSE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>name_suffix</name> <operator>=</operator> <name>name</name> <operator>+</operator> <name>name_len</name> <operator>-</operator> <name>suffix_len</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>, <argument><expr><name>name_suffix</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"input file [%s] suffix mismatch\n"</literal></expr></argument>,
              <argument><expr><call><name>PrintablePath</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>iterator_error</name></name> <operator>=</operator> <name>BROTLI_TRUE</name></expr>;</expr_stmt>
      <return>return <expr><name>BROTLI_FALSE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>name_suffix</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>modified_path</name></name> <operator>+</operator> <name>arg_len</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BROTLI_BOOL</name></type> <name>OpenFiles</name><parameter_list>(<parameter><decl><type><name>Context</name><modifier>*</modifier></type> <name>context</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>BROTLI_BOOL</name></type> <name>is_ok</name> <init>= <expr><call><name>OpenInputFile</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>current_input_path</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>fin</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>context</name><operator>-&gt;</operator><name>test_integrity</name></name> <operator>&amp;&amp;</operator> <name>is_ok</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>is_ok</name> <operator>=</operator> <call><name>OpenOutputFile</name><argument_list>(
        <argument><expr><name><name>context</name><operator>-&gt;</operator><name>current_output_path</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>fout</name></name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>force_overwrite</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>is_ok</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BROTLI_BOOL</name></type> <name>CloseFiles</name><parameter_list>(<parameter><decl><type><name>Context</name><modifier>*</modifier></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>BROTLI_BOOL</name></type> <name>success</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>BROTLI_BOOL</name></type> <name>is_ok</name> <init>= <expr><name>BROTLI_TRUE</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>context</name><operator>-&gt;</operator><name>test_integrity</name></name> <operator>&amp;&amp;</operator> <name><name>context</name><operator>-&gt;</operator><name>fout</name></name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name> <operator>&amp;&amp;</operator> <name><name>context</name><operator>-&gt;</operator><name>current_output_path</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>current_output_path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>fclose</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>fout</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>success</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"fclose failed [%s]: %s\n"</literal></expr></argument>,
                <argument><expr><call><name>PrintablePath</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>current_output_path</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>is_ok</name> <operator>=</operator> <name>BROTLI_FALSE</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* TOCTOU violation, but otherwise it is impossible to set file times. */</comment>
    <if_stmt><if>if <condition>(<expr><name>success</name> <operator>&amp;&amp;</operator> <name>is_ok</name> <operator>&amp;&amp;</operator> <name><name>context</name><operator>-&gt;</operator><name>copy_stat</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>CopyStat</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>current_input_path</name></name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>current_output_path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>fin</name></name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>fclose</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>fin</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>is_ok</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"fclose failed [%s]: %s\n"</literal></expr></argument>,
                <argument><expr><call><name>PrintablePath</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>current_input_path</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>is_ok</name> <operator>=</operator> <name>BROTLI_FALSE</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>success</name> <operator>&amp;&amp;</operator> <name><name>context</name><operator>-&gt;</operator><name>junk_source</name></name> <operator>&amp;&amp;</operator> <name><name>context</name><operator>-&gt;</operator><name>current_input_path</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>current_input_path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>fin</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>fout</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

  <return>return <expr><name>is_ok</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>size_t</name></type> <name>kFileBufferSize</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">19</literal></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type> <name>InitializeBuffers</name><parameter_list>(<parameter><decl><type><name>Context</name><modifier>*</modifier></type> <name>context</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>available_in</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>next_in</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>available_out</name></name> <operator>=</operator> <name>kFileBufferSize</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>next_out</name></name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>output</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>total_in</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>total_out</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>verbosity</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>start_time</name></name> <operator>=</operator> <call><name>clock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* This method might give the false-negative result.
   However, after an empty / incomplete read it should tell the truth. */</comment>
<function><type><specifier>static</specifier> <name>BROTLI_BOOL</name></type> <name>HasMoreInput</name><parameter_list>(<parameter><decl><type><name>Context</name><modifier>*</modifier></type> <name>context</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><ternary><condition><expr><call><name>feof</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>fin</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>BROTLI_FALSE</name></expr> </then><else>: <expr><name>BROTLI_TRUE</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BROTLI_BOOL</name></type> <name>ProvideInput</name><parameter_list>(<parameter><decl><type><name>Context</name><modifier>*</modifier></type> <name>context</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>available_in</name></name> <operator>=</operator>
      <call><name>fread</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>input</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>kFileBufferSize</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>fin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>total_in</name></name> <operator>+=</operator> <name><name>context</name><operator>-&gt;</operator><name>available_in</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>next_in</name></name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>input</name></name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>ferror</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>fin</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"failed to read input [%s]: %s\n"</literal></expr></argument>,
            <argument><expr><call><name>PrintablePath</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>current_input_path</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>BROTLI_FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Internal: should be used only in Provide-/Flush-Output. */</comment>
<function><type><specifier>static</specifier> <name>BROTLI_BOOL</name></type> <name>WriteOutput</name><parameter_list>(<parameter><decl><type><name>Context</name><modifier>*</modifier></type> <name>context</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>size_t</name></type> <name>out_size</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name><name>context</name><operator>-&gt;</operator><name>next_out</name></name> <operator>-</operator> <name><name>context</name><operator>-&gt;</operator><name>output</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>total_out</name></name> <operator>+=</operator> <name>out_size</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>out_size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>BROTLI_TRUE</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>test_integrity</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>BROTLI_TRUE</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>fwrite</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>output</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>out_size</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>fout</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>ferror</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>fout</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"failed to write output [%s]: %s\n"</literal></expr></argument>,
            <argument><expr><call><name>PrintablePath</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>current_output_path</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>BROTLI_FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BROTLI_BOOL</name></type> <name>ProvideOutput</name><parameter_list>(<parameter><decl><type><name>Context</name><modifier>*</modifier></type> <name>context</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>WriteOutput</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>BROTLI_FALSE</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>available_out</name></name> <operator>=</operator> <name>kFileBufferSize</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>next_out</name></name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>output</name></name></expr>;</expr_stmt>
  <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BROTLI_BOOL</name></type> <name>FlushOutput</name><parameter_list>(<parameter><decl><type><name>Context</name><modifier>*</modifier></type> <name>context</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>WriteOutput</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>BROTLI_FALSE</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>available_out</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>PrintBytes</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>value</name> <operator>&lt;</operator> <literal type="number">1024</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%d B"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>value</name> <operator>&lt;</operator> <literal type="number">1048576</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%0.3f KiB"</literal></expr></argument>, <argument><expr><operator>(</operator><name>double</name><operator>)</operator><name>value</name> <operator>/</operator> <literal type="number">1024.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>value</name> <operator>&lt;</operator> <literal type="number">1073741824</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%0.3f MiB"</literal></expr></argument>, <argument><expr><operator>(</operator><name>double</name><operator>)</operator><name>value</name> <operator>/</operator> <literal type="number">1048576.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%0.3f GiB"</literal></expr></argument>, <argument><expr><operator>(</operator><name>double</name><operator>)</operator><name>value</name> <operator>/</operator> <literal type="number">1073741824.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>PrintFileProcessingProgress</name><parameter_list>(<parameter><decl><type><name>Context</name><modifier>*</modifier></type> <name>context</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"[%s]: "</literal></expr></argument>, <argument><expr><call><name>PrintablePath</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>current_input_path</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>PrintBytes</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>total_in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">" -&gt; "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>PrintBytes</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>total_out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">" in %1.2f sec"</literal></expr></argument>, <argument><expr><operator>(</operator><name>double</name><operator>)</operator><operator>(</operator><name><name>context</name><operator>-&gt;</operator><name>end_time</name></name> <operator>-</operator> <name><name>context</name><operator>-&gt;</operator><name>start_time</name></name><operator>)</operator> <operator>/</operator> <name>CLOCKS_PER_SEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BROTLI_BOOL</name></type> <name>DecompressFile</name><parameter_list>(<parameter><decl><type><name>Context</name><modifier>*</modifier></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>BrotliDecoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>BrotliDecoderResult</name></type> <name>result</name> <init>= <expr><name>BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>InitializeBuffers</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT</name></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HasMoreInput</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"corrupt input [%s]\n"</literal></expr></argument>,
                <argument><expr><call><name>PrintablePath</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>current_input_path</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>BROTLI_FALSE</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ProvideInput</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>BROTLI_FALSE</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>result</name> <operator>==</operator> <name>BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT</name></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ProvideOutput</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>BROTLI_FALSE</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>result</name> <operator>==</operator> <name>BROTLI_DECODER_RESULT_SUCCESS</name></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>FlushOutput</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>BROTLI_FALSE</name></expr>;</return></block_content></block></if></if_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>has_more_input</name> <init>=
          <expr><operator>(</operator><name><name>context</name><operator>-&gt;</operator><name>available_in</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><call><name>fgetc</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>fin</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>EOF</name><operator>)</operator></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>has_more_input</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"corrupt input [%s]\n"</literal></expr></argument>,
                <argument><expr><call><name>PrintablePath</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>current_input_path</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>BROTLI_FALSE</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>verbosity</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>end_time</name></name> <operator>=</operator> <call><name>clock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Decompressed "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PrintFileProcessingProgress</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"corrupt input [%s]\n"</literal></expr></argument>,
              <argument><expr><call><name>PrintablePath</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>current_input_path</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>BROTLI_FALSE</name></expr>;</return>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>BrotliDecoderDecompressStream</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>available_in</name></name></expr></argument>,
        <argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>next_in</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>available_out</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>next_out</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BROTLI_BOOL</name></type> <name>DecompressFiles</name><parameter_list>(<parameter><decl><type><name>Context</name><modifier>*</modifier></type> <name>context</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <while>while <condition>(<expr><call><name>NextFile</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>BROTLI_BOOL</name></type> <name>is_ok</name> <init>= <expr><name>BROTLI_TRUE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BrotliDecoderState</name><modifier>*</modifier></type> <name>s</name> <init>= <expr><call><name>BrotliDecoderCreateInstance</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>s</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"out of memory\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>BROTLI_FALSE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* This allows decoding "large-window" streams. Though it creates
       fragmentation (new builds decode streams that old builds don't),
       it is better from used experience perspective. */</comment>
    <expr_stmt><expr><call><name>BrotliDecoderSetParameter</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>BROTLI_DECODER_PARAM_LARGE_WINDOW</name></expr></argument>, <argument><expr><literal type="number">1u</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>dictionary</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>BrotliDecoderAttachDictionary</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>BROTLI_SHARED_DICTIONARY_RAW</name></expr></argument>,
          <argument><expr><name><name>context</name><operator>-&gt;</operator><name>dictionary_size</name></name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>dictionary</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>is_ok</name> <operator>=</operator> <call><name>OpenFiles</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>is_ok</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>context</name><operator>-&gt;</operator><name>current_input_path</name></name> <operator>&amp;&amp;</operator>
        <operator>!</operator><name><name>context</name><operator>-&gt;</operator><name>force_overwrite</name></name> <operator>&amp;&amp;</operator> <call><name>isatty</name><argument_list>(<argument><expr><name>STDIN_FILENO</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Use -h help. Use -f to force input from a terminal.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>is_ok</name> <operator>=</operator> <name>BROTLI_FALSE</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>is_ok</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>is_ok</name> <operator>=</operator> <call><name>DecompressFile</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>BrotliDecoderDestroyInstance</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CloseFiles</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>is_ok</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>is_ok</name> <operator>=</operator> <name>BROTLI_FALSE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_ok</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>BROTLI_FALSE</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></while>
  <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BROTLI_BOOL</name></type> <name>CompressFile</name><parameter_list>(<parameter><decl><type><name>Context</name><modifier>*</modifier></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>BrotliEncoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>BROTLI_BOOL</name></type> <name>is_eof</name> <init>= <expr><name>BROTLI_FALSE</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>InitializeBuffers</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>available_in</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_eof</name></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ProvideInput</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>BROTLI_FALSE</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>is_eof</name> <operator>=</operator> <operator>!</operator><call><name>HasMoreInput</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BrotliEncoderCompressStream</name><argument_list>(<argument><expr><name>s</name></expr></argument>,
        <argument><expr><ternary><condition><expr><name>is_eof</name></expr> ?</condition><then> <expr><name>BROTLI_OPERATION_FINISH</name></expr> </then><else>: <expr><name>BROTLI_OPERATION_PROCESS</name></expr></else></ternary></expr></argument>,
        <argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>available_in</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>next_in</name></name></expr></argument>,
        <argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>available_out</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>next_out</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <comment type="block">/* Should detect OOM? */</comment>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"failed to compress data [%s]\n"</literal></expr></argument>,
              <argument><expr><call><name>PrintablePath</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>current_input_path</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>BROTLI_FALSE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>available_out</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ProvideOutput</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>BROTLI_FALSE</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>BrotliEncoderIsFinished</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>FlushOutput</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>BROTLI_FALSE</name></expr>;</return></block_content></block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>verbosity</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>end_time</name></name> <operator>=</operator> <call><name>clock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Compressed "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PrintFileProcessingProgress</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BROTLI_BOOL</name></type> <name>CompressFiles</name><parameter_list>(<parameter><decl><type><name>Context</name><modifier>*</modifier></type> <name>context</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <while>while <condition>(<expr><call><name>NextFile</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>BROTLI_BOOL</name></type> <name>is_ok</name> <init>= <expr><name>BROTLI_TRUE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BrotliEncoderState</name><modifier>*</modifier></type> <name>s</name> <init>= <expr><call><name>BrotliEncoderCreateInstance</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>s</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"out of memory\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>BROTLI_FALSE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>BrotliEncoderSetParameter</name><argument_list>(<argument><expr><name>s</name></expr></argument>,
        <argument><expr><name>BROTLI_PARAM_QUALITY</name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>context</name><operator>-&gt;</operator><name>quality</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>lgwin</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <comment type="block">/* Specified by user. */</comment>
      <comment type="block">/* Do not enable "large-window" extension, if not required. */</comment>
      <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>lgwin</name></name> <operator>&gt;</operator> <name>BROTLI_MAX_WINDOW_BITS</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>BrotliEncoderSetParameter</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>BROTLI_PARAM_LARGE_WINDOW</name></expr></argument>, <argument><expr><literal type="number">1u</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>BrotliEncoderSetParameter</name><argument_list>(<argument><expr><name>s</name></expr></argument>,
          <argument><expr><name>BROTLI_PARAM_LGWIN</name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>context</name><operator>-&gt;</operator><name>lgwin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <comment type="block">/* 0, or not specified by user; could be chosen by compressor. */</comment>
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>lgwin</name> <init>= <expr><name>DEFAULT_LGWIN</name></expr></init></decl>;</decl_stmt>
      <comment type="block">/* Use file size to limit lgwin. */</comment>
      <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>input_file_length</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>lgwin</name> <operator>=</operator> <name>BROTLI_MIN_WINDOW_BITS</name></expr>;</expr_stmt>
        <while>while <condition>(<expr><call><name>BROTLI_MAX_BACKWARD_LIMIT</name><argument_list>(<argument><expr><name>lgwin</name></expr></argument>)</argument_list></call> <operator>&lt;</operator>
               <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>context</name><operator>-&gt;</operator><name>input_file_length</name></name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>lgwin</name><operator>++</operator></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>lgwin</name> <operator>==</operator> <name>BROTLI_MAX_WINDOW_BITS</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></while>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>BrotliEncoderSetParameter</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>BROTLI_PARAM_LGWIN</name></expr></argument>, <argument><expr><name>lgwin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>input_file_length</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>size_hint</name> <init>= <expr><ternary><condition><expr><name><name>context</name><operator>-&gt;</operator><name>input_file_length</name></name> <operator>&lt;</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">30</literal><operator>)</operator></expr> ?</condition><then>
          <expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>context</name><operator>-&gt;</operator><name>input_file_length</name></name></expr> </then><else>: <expr><operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <literal type="number">30</literal><operator>)</operator></expr></else></ternary></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>BrotliEncoderSetParameter</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>BROTLI_PARAM_SIZE_HINT</name></expr></argument>, <argument><expr><name>size_hint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>dictionary</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>BrotliEncoderAttachPreparedDictionary</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>prepared_dictionary</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>is_ok</name> <operator>=</operator> <call><name>OpenFiles</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>is_ok</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>context</name><operator>-&gt;</operator><name>current_output_path</name></name> <operator>&amp;&amp;</operator>
        <operator>!</operator><name><name>context</name><operator>-&gt;</operator><name>force_overwrite</name></name> <operator>&amp;&amp;</operator> <call><name>isatty</name><argument_list>(<argument><expr><name>STDOUT_FILENO</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Use -h help. Use -f to force output to a terminal.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>is_ok</name> <operator>=</operator> <name>BROTLI_FALSE</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>is_ok</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>is_ok</name> <operator>=</operator> <call><name>CompressFile</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>BrotliEncoderDestroyInstance</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CloseFiles</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>is_ok</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>is_ok</name> <operator>=</operator> <name>BROTLI_FALSE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_ok</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>BROTLI_FALSE</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></while>
  <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>main</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier><modifier>*</modifier></type> <name>argv</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>Command</name></type> <name>command</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Context</name></type> <name>context</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BROTLI_BOOL</name></type> <name>is_ok</name> <init>= <expr><name>BROTLI_TRUE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>context</name><operator>.</operator><name>quality</name></name> <operator>=</operator> <literal type="number">11</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>context</name><operator>.</operator><name>lgwin</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>context</name><operator>.</operator><name>verbosity</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>context</name><operator>.</operator><name>force_overwrite</name></name> <operator>=</operator> <name>BROTLI_FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>context</name><operator>.</operator><name>junk_source</name></name> <operator>=</operator> <name>BROTLI_FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>context</name><operator>.</operator><name>copy_stat</name></name> <operator>=</operator> <name>BROTLI_TRUE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>context</name><operator>.</operator><name>test_integrity</name></name> <operator>=</operator> <name>BROTLI_FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>context</name><operator>.</operator><name>write_to_stdout</name></name> <operator>=</operator> <name>BROTLI_FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>context</name><operator>.</operator><name>decompress</name></name> <operator>=</operator> <name>BROTLI_FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>context</name><operator>.</operator><name>large_window</name></name> <operator>=</operator> <name>BROTLI_FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>context</name><operator>.</operator><name>output_path</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>context</name><operator>.</operator><name>dictionary_path</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>context</name><operator>.</operator><name>suffix</name></name> <operator>=</operator> <name>DEFAULT_SUFFIX</name></expr>;</expr_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MAX_OPTIONS</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>context</name><operator>.</operator><name>not_input_indices</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>
  <expr_stmt><expr><name><name>context</name><operator>.</operator><name>longest_path_len</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>context</name><operator>.</operator><name>input_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>context</name><operator>.</operator><name>argc</name></name> <operator>=</operator> <name>argc</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>context</name><operator>.</operator><name>argv</name></name> <operator>=</operator> <name>argv</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>context</name><operator>.</operator><name>dictionary</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>context</name><operator>.</operator><name>dictionary_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>context</name><operator>.</operator><name>prepared_dictionary</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>context</name><operator>.</operator><name>modified_path</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>context</name><operator>.</operator><name>iterator</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>context</name><operator>.</operator><name>ignore</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>context</name><operator>.</operator><name>iterator_error</name></name> <operator>=</operator> <name>BROTLI_FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>context</name><operator>.</operator><name>buffer</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>context</name><operator>.</operator><name>current_input_path</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>context</name><operator>.</operator><name>current_output_path</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>context</name><operator>.</operator><name>fin</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>context</name><operator>.</operator><name>fout</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>command</name> <operator>=</operator> <call><name>ParseParams</name><argument_list>(<argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>command</name> <operator>==</operator> <name>COMMAND_COMPRESS</name> <operator>||</operator> <name>command</name> <operator>==</operator> <name>COMMAND_DECOMPRESS</name> <operator>||</operator>
      <name>command</name> <operator>==</operator> <name>COMMAND_TEST_INTEGRITY</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ReadDictionary</name><argument_list>(<argument><expr><operator>&amp;</operator><name>context</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>is_ok</name> <operator>=</operator> <name>BROTLI_FALSE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>is_ok</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>size_t</name></type> <name>modified_path_len</name> <init>=
          <expr><name><name>context</name><operator>.</operator><name>longest_path_len</name></name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>suffix</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>context</name><operator>.</operator><name>modified_path</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><name>modified_path_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>context</name><operator>.</operator><name>buffer</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><name>kFileBufferSize</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>context</name><operator>.</operator><name>modified_path</name></name> <operator>||</operator> <operator>!</operator><name><name>context</name><operator>.</operator><name>buffer</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"out of memory\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>is_ok</name> <operator>=</operator> <name>BROTLI_FALSE</name></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name><name>context</name><operator>.</operator><name>input</name></name> <operator>=</operator> <name><name>context</name><operator>.</operator><name>buffer</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>context</name><operator>.</operator><name>output</name></name> <operator>=</operator> <name><name>context</name><operator>.</operator><name>buffer</name></name> <operator>+</operator> <name>kFileBufferSize</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_ok</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>command</name> <operator>=</operator> <name>COMMAND_NOOP</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <switch>switch <condition>(<expr><name>command</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>COMMAND_NOOP</name></expr>:</case>
      <break>break;</break>

    <case>case <expr><name>COMMAND_VERSION</name></expr>:</case>
      <expr_stmt><expr><call><name>PrintVersion</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    <case>case <expr><name>COMMAND_COMPRESS</name></expr>:</case>
      <expr_stmt><expr><name>is_ok</name> <operator>=</operator> <call><name>CompressFiles</name><argument_list>(<argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    <case>case <expr><name>COMMAND_DECOMPRESS</name></expr>:</case>
    <case>case <expr><name>COMMAND_TEST_INTEGRITY</name></expr>:</case>
      <expr_stmt><expr><name>is_ok</name> <operator>=</operator> <call><name>DecompressFiles</name><argument_list>(<argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    <case>case <expr><name>COMMAND_HELP</name></expr>:</case>
    <case>case <expr><name>COMMAND_INVALID</name></expr>:</case>
    <default>default:</default>
      <expr_stmt><expr><name>is_ok</name> <operator>=</operator> <operator>(</operator><name>command</name> <operator>==</operator> <name>COMMAND_HELP</name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>PrintHelp</name><argument_list>(<argument><expr><call><name>FileName</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>is_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
  </block_content>}</block></switch>

  <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>.</operator><name>iterator_error</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>is_ok</name> <operator>=</operator> <name>BROTLI_FALSE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>BrotliEncoderDestroyPreparedDictionary</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>prepared_dictionary</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>dictionary</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>modified_path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_ok</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
</unit>
