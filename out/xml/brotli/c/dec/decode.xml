<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="../out/cloned_projects/brotli/c/dec/decode.c"><comment type="block">/* Copyright 2013 Google Inc. All Rights Reserved.

   Distributed under MIT license.
   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT
*/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;brotli/decode.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>  <comment type="block">/* free, malloc */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>  <comment type="block">/* memcpy, memset */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../common/constants.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../common/context.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../common/dictionary.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../common/platform.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../common/shared_dictionary_internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../common/transform.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../common/version.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"bit_reader.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"huffman.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"prefix.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"state.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>BROTLI_TARGET_NEON</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;arm_neon.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>c_plusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
<extern>extern <literal type="string">"C"</literal> <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_FAILURE</name><parameter_list>(<parameter><type><name>CODE</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(BROTLI_DUMP(), CODE)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_LOG_UINT</name><parameter_list>(<parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro>                                       \
  <cpp:value>BROTLI_LOG(("[%s] %s = %lu\n", __func__, #name, (unsigned long)(name)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_LOG_ARRAY_INDEX</name><parameter_list>(<parameter><type><name>array_name</name></type></parameter>, <parameter><type><name>idx</name></type></parameter>)</parameter_list></cpp:macro>                     \
  <cpp:value>BROTLI_LOG(("[%s] %s[%lu] = %lu\n", __func__, #array_name,        \
         (unsigned long)(idx), (unsigned long)array_name[idx]))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HUFFMAN_TABLE_BITS</name></cpp:macro> <cpp:value>8U</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HUFFMAN_TABLE_MASK</name></cpp:macro> <cpp:value>0xFF</cpp:value></cpp:define>

<comment type="block">/* We need the slack region for the following reasons:
    - doing up to two 16-byte copies for fast backward copying
    - inserting transformed dictionary word:
        255 prefix + 32 base + 255 suffix */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint32_t</name></type> <name>kRingBufferWriteAheadSlack</name> <init>= <expr><literal type="number">542</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint8_t</name></type> <name><name>kCodeLengthCodeOrder</name><index>[<expr><name>BROTLI_CODE_LENGTH_CODES</name></expr>]</index></name> <init>= <expr><block>{
  <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">17</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">16</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">8</literal></expr>, <expr><literal type="number">9</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">11</literal></expr>, <expr><literal type="number">12</literal></expr>, <expr><literal type="number">13</literal></expr>, <expr><literal type="number">14</literal></expr>, <expr><literal type="number">15</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Static prefix code for the complex code length code lengths. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint8_t</name></type> <name><name>kCodeLengthPrefixLength</name><index>[<expr><literal type="number">16</literal></expr>]</index></name> <init>= <expr><block>{
  <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">4</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint8_t</name></type> <name><name>kCodeLengthPrefixValue</name><index>[<expr><literal type="number">16</literal></expr>]</index></name> <init>= <expr><block>{
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">5</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>

<function><type><name>BROTLI_BOOL</name></type> <name>BrotliDecoderSetParameter</name><parameter_list>(
    <parameter><decl><type><name>BrotliDecoderState</name><modifier>*</modifier></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>BrotliDecoderParameter</name></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>BROTLI_STATE_UNINITED</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>BROTLI_FALSE</name></expr>;</return></block_content></block></if></if_stmt>
  <switch>switch <condition>(<expr><name>p</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION</name></expr>:</case>
      <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>canny_ringbuffer_allocation</name></name> <operator>=</operator> <ternary><condition><expr><operator>!</operator><operator>!</operator><name>value</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
      <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>

    <case>case <expr><name>BROTLI_DECODER_PARAM_LARGE_WINDOW</name></expr>:</case>
      <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>large_window</name></name> <operator>=</operator> <call><name>TO_BROTLI_BOOL</name><argument_list>(<argument><expr><operator>!</operator><operator>!</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>

    <default>default:</default> <return>return <expr><name>BROTLI_FALSE</name></expr>;</return>
  </block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>BrotliDecoderState</name><modifier>*</modifier></type> <name>BrotliDecoderCreateInstance</name><parameter_list>(
    <parameter><decl><type><name>brotli_alloc_func</name></type> <name>alloc_func</name></decl></parameter>, <parameter><decl><type><name>brotli_free_func</name></type> <name>free_func</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>opaque</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>BrotliDecoderState</name><modifier>*</modifier></type> <name>state</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>alloc_func</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>free_func</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator><name>BrotliDecoderState</name><operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BrotliDecoderState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>alloc_func</name> <operator>&amp;&amp;</operator> <name>free_func</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator><name>BrotliDecoderState</name><operator>*</operator><operator>)</operator><call><name>alloc_func</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BrotliDecoderState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>BROTLI_DUMP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BrotliDecoderStateInit</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>alloc_func</name></expr></argument>, <argument><expr><name>free_func</name></expr></argument>, <argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>BROTLI_DUMP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>alloc_func</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>free_func</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>alloc_func</name> <operator>&amp;&amp;</operator> <name>free_func</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>free_func</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>state</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Deinitializes and frees BrotliDecoderState instance. */</comment>
<function><type><name>void</name></type> <name>BrotliDecoderDestroyInstance</name><parameter_list>(<parameter><decl><type><name>BrotliDecoderState</name><modifier>*</modifier></type> <name>state</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>state</name></expr>)</condition> <block>{<block_content>
    <return>return;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>brotli_free_func</name></type> <name>free_func</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>free_func</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>opaque</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>memory_manager_opaque</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>BrotliDecoderStateCleanup</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free_func</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Saves error code and converts it to BrotliDecoderResult. */</comment>
<function><type><specifier>static</specifier> <name>BROTLI_NOINLINE</name> <name>BrotliDecoderResult</name></type> <name>SaveErrorCode</name><parameter_list>(
    <parameter><decl><type><name>BrotliDecoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>BrotliDecoderErrorCode</name></type> <name>e</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>consumed_input</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>error_code</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>e</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>used_input</name></name> <operator>+=</operator> <name>consumed_input</name></expr>;</expr_stmt>
  <switch>switch <condition>(<expr><name>e</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>BROTLI_DECODER_SUCCESS</name></expr>:</case>
      <return>return <expr><name>BROTLI_DECODER_RESULT_SUCCESS</name></expr>;</return>

    <case>case <expr><name>BROTLI_DECODER_NEEDS_MORE_INPUT</name></expr>:</case>
      <return>return <expr><name>BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT</name></expr>;</return>

    <case>case <expr><name>BROTLI_DECODER_NEEDS_MORE_OUTPUT</name></expr>:</case>
      <return>return <expr><name>BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT</name></expr>;</return>

    <default>default:</default>
      <return>return <expr><name>BROTLI_DECODER_RESULT_ERROR</name></expr>;</return>
  </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/* Decodes WBITS by reading 1 - 7 bits, or 0x11 for "Large Window Brotli".
   Precondition: bit-reader accumulator has at least 8 bits. */</comment>
<function><type><specifier>static</specifier> <name>BrotliDecoderErrorCode</name></type> <name>DecodeWindowBits</name><parameter_list>(<parameter><decl><type><name>BrotliDecoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>,
                                               <parameter><decl><type><name>BrotliBitReader</name><modifier>*</modifier></type> <name>br</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BROTLI_BOOL</name></type> <name>large_window</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>large_window</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>large_window</name></name> <operator>=</operator> <name>BROTLI_FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>BrotliTakeBits</name><argument_list>(<argument><expr><name>br</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>window_bits</name></name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
    <return>return <expr><name>BROTLI_DECODER_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>BrotliTakeBits</name><argument_list>(<argument><expr><name>br</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>n</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>window_bits</name></name> <operator>=</operator> <literal type="number">17</literal> <operator>+</operator> <name>n</name></expr>;</expr_stmt>
    <return>return <expr><name>BROTLI_DECODER_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>BrotliTakeBits</name><argument_list>(<argument><expr><name>br</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>large_window</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>BrotliTakeBits</name><argument_list>(<argument><expr><name>br</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name>BROTLI_FAILURE</name><argument_list>(<argument><expr><name>BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS</name></expr></argument>)</argument_list></call></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>large_window</name></name> <operator>=</operator> <name>BROTLI_TRUE</name></expr>;</expr_stmt>
      <return>return <expr><name>BROTLI_DECODER_SUCCESS</name></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <return>return <expr><call><name>BROTLI_FAILURE</name><argument_list>(<argument><expr><name>BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>n</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>window_bits</name></name> <operator>=</operator> <literal type="number">8</literal> <operator>+</operator> <name>n</name></expr>;</expr_stmt>
    <return>return <expr><name>BROTLI_DECODER_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>window_bits</name></name> <operator>=</operator> <literal type="number">17</literal></expr>;</expr_stmt>
  <return>return <expr><name>BROTLI_DECODER_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BROTLI_INLINE</name> <name>void</name></type> <name>memmove16</name><parameter_list>(<parameter><decl><type><name>uint8_t</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name><modifier>*</modifier></type> <name>src</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>BROTLI_TARGET_NEON</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <expr_stmt><expr><call><name>vst1q_u8</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><call><name>vld1q_u8</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name><name>buffer</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/* Decodes a number in the range [0..255], by reading 1 - 11 bits. */</comment>
<function><type><specifier>static</specifier> <name>BROTLI_NOINLINE</name> <name>BrotliDecoderErrorCode</name></type> <name>DecodeVarLenUint8</name><parameter_list>(
    <parameter><decl><type><name>BrotliDecoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>BrotliBitReader</name><modifier>*</modifier></type> <name>br</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name><modifier>*</modifier></type> <name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>bits</name></decl>;</decl_stmt>
  <switch>switch <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>substate_decode_uint8</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>BROTLI_STATE_DECODE_UINT8_NONE</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><call><name>BROTLI_PREDICT_FALSE</name><argument_list>(<argument><expr><operator>!</operator><call><name>BrotliSafeReadBits</name><argument_list>(<argument><expr><name>br</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>BROTLI_DECODER_NEEDS_MORE_INPUT</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>bits</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <return>return <expr><name>BROTLI_DECODER_SUCCESS</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    <comment type="block">/* Fall through. */</comment>

    <case>case <expr><name>BROTLI_STATE_DECODE_UINT8_SHORT</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><call><name>BROTLI_PREDICT_FALSE</name><argument_list>(<argument><expr><operator>!</operator><call><name>BrotliSafeReadBits</name><argument_list>(<argument><expr><name>br</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>substate_decode_uint8</name></name> <operator>=</operator> <name>BROTLI_STATE_DECODE_UINT8_SHORT</name></expr>;</expr_stmt>
        <return>return <expr><name>BROTLI_DECODER_NEEDS_MORE_INPUT</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>bits</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>substate_decode_uint8</name></name> <operator>=</operator> <name>BROTLI_STATE_DECODE_UINT8_NONE</name></expr>;</expr_stmt>
        <return>return <expr><name>BROTLI_DECODER_SUCCESS</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <comment type="block">/* Use output value as a temporary storage. It MUST be persisted. */</comment>
      <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <name>bits</name></expr>;</expr_stmt>
    <comment type="block">/* Fall through. */</comment>

    <case>case <expr><name>BROTLI_STATE_DECODE_UINT8_LONG</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><call><name>BROTLI_PREDICT_FALSE</name><argument_list>(<argument><expr><operator>!</operator><call><name>BrotliSafeReadBits</name><argument_list>(<argument><expr><name>br</name></expr></argument>, <argument><expr><operator>*</operator><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>substate_decode_uint8</name></name> <operator>=</operator> <name>BROTLI_STATE_DECODE_UINT8_LONG</name></expr>;</expr_stmt>
        <return>return <expr><name>BROTLI_DECODER_NEEDS_MORE_INPUT</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <operator>(</operator><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <operator>*</operator><name>value</name><operator>)</operator> <operator>+</operator> <name>bits</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>substate_decode_uint8</name></name> <operator>=</operator> <name>BROTLI_STATE_DECODE_UINT8_NONE</name></expr>;</expr_stmt>
      <return>return <expr><name>BROTLI_DECODER_SUCCESS</name></expr>;</return>

    <default>default:</default>
      <return>return
          <expr><call><name>BROTLI_FAILURE</name><argument_list>(<argument><expr><name>BROTLI_DECODER_ERROR_UNREACHABLE</name></expr></argument>)</argument_list></call></expr>;</return>  <comment type="block">/* COV_NF_LINE */</comment>
  </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/* Decodes a metablock length and flags by reading 2 - 31 bits. */</comment>
<function><type><specifier>static</specifier> <name>BrotliDecoderErrorCode</name> <name>BROTLI_NOINLINE</name></type> <name>DecodeMetaBlockLength</name><parameter_list>(
    <parameter><decl><type><name>BrotliDecoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>BrotliBitReader</name><modifier>*</modifier></type> <name>br</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>bits</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
    <switch>switch <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>substate_metablock_header</name></name></expr>)</condition> <block>{<block_content>
      <case>case <expr><name>BROTLI_STATE_METABLOCK_HEADER_NONE</name></expr>:</case>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BrotliSafeReadBits</name><argument_list>(<argument><expr><name>br</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>bits</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <return>return <expr><name>BROTLI_DECODER_NEEDS_MORE_INPUT</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>is_last_metablock</name></name> <operator>=</operator> <ternary><condition><expr><name>bits</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>meta_block_remaining_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>is_uncompressed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>is_metadata</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>is_last_metablock</name></name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>substate_metablock_header</name></name> <operator>=</operator> <name>BROTLI_STATE_METABLOCK_HEADER_NIBBLES</name></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>substate_metablock_header</name></name> <operator>=</operator> <name>BROTLI_STATE_METABLOCK_HEADER_EMPTY</name></expr>;</expr_stmt>
      <comment type="block">/* Fall through. */</comment>

      <case>case <expr><name>BROTLI_STATE_METABLOCK_HEADER_EMPTY</name></expr>:</case>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BrotliSafeReadBits</name><argument_list>(<argument><expr><name>br</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>bits</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <return>return <expr><name>BROTLI_DECODER_NEEDS_MORE_INPUT</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>bits</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>substate_metablock_header</name></name> <operator>=</operator> <name>BROTLI_STATE_METABLOCK_HEADER_NONE</name></expr>;</expr_stmt>
          <return>return <expr><name>BROTLI_DECODER_SUCCESS</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>substate_metablock_header</name></name> <operator>=</operator> <name>BROTLI_STATE_METABLOCK_HEADER_NIBBLES</name></expr>;</expr_stmt>
      <comment type="block">/* Fall through. */</comment>

      <case>case <expr><name>BROTLI_STATE_METABLOCK_HEADER_NIBBLES</name></expr>:</case>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BrotliSafeReadBits</name><argument_list>(<argument><expr><name>br</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>bits</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <return>return <expr><name>BROTLI_DECODER_NEEDS_MORE_INPUT</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>size_nibbles</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><operator>(</operator><name>bits</name> <operator>+</operator> <literal type="number">4</literal><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>loop_counter</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>bits</name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>is_metadata</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>substate_metablock_header</name></name> <operator>=</operator> <name>BROTLI_STATE_METABLOCK_HEADER_RESERVED</name></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>substate_metablock_header</name></name> <operator>=</operator> <name>BROTLI_STATE_METABLOCK_HEADER_SIZE</name></expr>;</expr_stmt>
      <comment type="block">/* Fall through. */</comment>

      <case>case <expr><name>BROTLI_STATE_METABLOCK_HEADER_SIZE</name></expr>:</case>
        <expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>loop_counter</name></name></expr>;</expr_stmt>
        <for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>size_nibbles</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BrotliSafeReadBits</name><argument_list>(<argument><expr><name>br</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>bits</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>loop_counter</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
            <return>return <expr><name>BROTLI_DECODER_NEEDS_MORE_INPUT</name></expr>;</return>
          </block_content>}</block></if></if_stmt>
          <if_stmt><if>if <condition>(<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal> <operator>==</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>size_nibbles</name></name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>size_nibbles</name></name> <operator>&gt;</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator>
              <name>bits</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <return>return <expr><call><name>BROTLI_FAILURE</name><argument_list>(<argument><expr><name>BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE</name></expr></argument>)</argument_list></call></expr>;</return>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>meta_block_remaining_len</name></name> <operator>|=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>bits</name> <operator>&lt;&lt;</operator> <operator>(</operator><name>i</name> <operator>*</operator> <literal type="number">4</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>substate_metablock_header</name></name> <operator>=</operator>
            <name>BROTLI_STATE_METABLOCK_HEADER_UNCOMPRESSED</name></expr>;</expr_stmt>
      <comment type="block">/* Fall through. */</comment>

      <case>case <expr><name>BROTLI_STATE_METABLOCK_HEADER_UNCOMPRESSED</name></expr>:</case>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>is_last_metablock</name></name></expr>)</condition> <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BrotliSafeReadBits</name><argument_list>(<argument><expr><name>br</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>bits</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <return>return <expr><name>BROTLI_DECODER_NEEDS_MORE_INPUT</name></expr>;</return>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>is_uncompressed</name></name> <operator>=</operator> <ternary><condition><expr><name>bits</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><operator>++</operator><name><name>s</name><operator>-&gt;</operator><name>meta_block_remaining_len</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>substate_metablock_header</name></name> <operator>=</operator> <name>BROTLI_STATE_METABLOCK_HEADER_NONE</name></expr>;</expr_stmt>
        <return>return <expr><name>BROTLI_DECODER_SUCCESS</name></expr>;</return>

      <case>case <expr><name>BROTLI_STATE_METABLOCK_HEADER_RESERVED</name></expr>:</case>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BrotliSafeReadBits</name><argument_list>(<argument><expr><name>br</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>bits</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <return>return <expr><name>BROTLI_DECODER_NEEDS_MORE_INPUT</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>bits</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
          <return>return <expr><call><name>BROTLI_FAILURE</name><argument_list>(<argument><expr><name>BROTLI_DECODER_ERROR_FORMAT_RESERVED</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>substate_metablock_header</name></name> <operator>=</operator> <name>BROTLI_STATE_METABLOCK_HEADER_BYTES</name></expr>;</expr_stmt>
      <comment type="block">/* Fall through. */</comment>

      <case>case <expr><name>BROTLI_STATE_METABLOCK_HEADER_BYTES</name></expr>:</case>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BrotliSafeReadBits</name><argument_list>(<argument><expr><name>br</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>bits</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <return>return <expr><name>BROTLI_DECODER_NEEDS_MORE_INPUT</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>bits</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>substate_metablock_header</name></name> <operator>=</operator> <name>BROTLI_STATE_METABLOCK_HEADER_NONE</name></expr>;</expr_stmt>
          <return>return <expr><name>BROTLI_DECODER_SUCCESS</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>size_nibbles</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name>bits</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>substate_metablock_header</name></name> <operator>=</operator> <name>BROTLI_STATE_METABLOCK_HEADER_METADATA</name></expr>;</expr_stmt>
      <comment type="block">/* Fall through. */</comment>

      <case>case <expr><name>BROTLI_STATE_METABLOCK_HEADER_METADATA</name></expr>:</case>
        <expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>loop_counter</name></name></expr>;</expr_stmt>
        <for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>size_nibbles</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BrotliSafeReadBits</name><argument_list>(<argument><expr><name>br</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>bits</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>loop_counter</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
            <return>return <expr><name>BROTLI_DECODER_NEEDS_MORE_INPUT</name></expr>;</return>
          </block_content>}</block></if></if_stmt>
          <if_stmt><if>if <condition>(<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal> <operator>==</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>size_nibbles</name></name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>size_nibbles</name></name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
              <name>bits</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <return>return <expr><call><name>BROTLI_FAILURE</name><argument_list>(
                <argument><expr><name>BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE</name></expr></argument>)</argument_list></call></expr>;</return>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>meta_block_remaining_len</name></name> <operator>|=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>bits</name> <operator>&lt;&lt;</operator> <operator>(</operator><name>i</name> <operator>*</operator> <literal type="number">8</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><operator>++</operator><name><name>s</name><operator>-&gt;</operator><name>meta_block_remaining_len</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>substate_metablock_header</name></name> <operator>=</operator> <name>BROTLI_STATE_METABLOCK_HEADER_NONE</name></expr>;</expr_stmt>
        <return>return <expr><name>BROTLI_DECODER_SUCCESS</name></expr>;</return>

      <default>default:</default>
        <return>return
            <expr><call><name>BROTLI_FAILURE</name><argument_list>(<argument><expr><name>BROTLI_DECODER_ERROR_UNREACHABLE</name></expr></argument>)</argument_list></call></expr>;</return>  <comment type="block">/* COV_NF_LINE */</comment>
    </block_content>}</block></switch>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* Decodes the Huffman code.
   This method doesn't read data from the bit reader, BUT drops the amount of
   bits that correspond to the decoded symbol.
   bits MUST contain at least 15 (BROTLI_HUFFMAN_MAX_CODE_LENGTH) valid bits. */</comment>
<function><type><specifier>static</specifier> <name>BROTLI_INLINE</name> <name>uint32_t</name></type> <name>DecodeSymbol</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>bits</name></decl></parameter>,
                                           <parameter><decl><type><specifier>const</specifier> <name>HuffmanCode</name><modifier>*</modifier></type> <name>table</name></decl></parameter>,
                                           <parameter><decl><type><name>BrotliBitReader</name><modifier>*</modifier></type> <name>br</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>BROTLI_HC_MARK_TABLE_FOR_FAST_LOAD</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>BROTLI_HC_ADJUST_TABLE_INDEX</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>bits</name> <operator>&amp;</operator> <name>HUFFMAN_TABLE_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>BROTLI_HC_FAST_LOAD_BITS</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>HUFFMAN_TABLE_BITS</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>nbits</name> <init>= <expr><call><name>BROTLI_HC_FAST_LOAD_BITS</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>HUFFMAN_TABLE_BITS</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>BrotliDropBits</name><argument_list>(<argument><expr><name>br</name></expr></argument>, <argument><expr><name>HUFFMAN_TABLE_BITS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BROTLI_HC_ADJUST_TABLE_INDEX</name><argument_list>(<argument><expr><name>table</name></expr></argument>,
        <argument><expr><call><name>BROTLI_HC_FAST_LOAD_VALUE</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call> <operator>+</operator>
        <operator>(</operator><operator>(</operator><name>bits</name> <operator>&gt;&gt;</operator> <name>HUFFMAN_TABLE_BITS</name><operator>)</operator> <operator>&amp;</operator> <call><name>BitMask</name><argument_list>(<argument><expr><name>nbits</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>BrotliDropBits</name><argument_list>(<argument><expr><name>br</name></expr></argument>, <argument><expr><call><name>BROTLI_HC_FAST_LOAD_BITS</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>BROTLI_HC_FAST_LOAD_VALUE</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Reads and decodes the next Huffman code from bit-stream.
   This method peeks 16 bits of input and drops 0 - 15 of them. */</comment>
<function><type><specifier>static</specifier> <name>BROTLI_INLINE</name> <name>uint32_t</name></type> <name>ReadSymbol</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>HuffmanCode</name><modifier>*</modifier></type> <name>table</name></decl></parameter>,
                                         <parameter><decl><type><name>BrotliBitReader</name><modifier>*</modifier></type> <name>br</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>DecodeSymbol</name><argument_list>(<argument><expr><call><name>BrotliGet16BitsUnmasked</name><argument_list>(<argument><expr><name>br</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>table</name></expr></argument>, <argument><expr><name>br</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Same as DecodeSymbol, but it is known that there is less than 15 bits of
   input are currently available. */</comment>
<function><type><specifier>static</specifier> <name>BROTLI_NOINLINE</name> <name>BROTLI_BOOL</name></type> <name>SafeDecodeSymbol</name><parameter_list>(
    <parameter><decl><type><specifier>const</specifier> <name>HuffmanCode</name><modifier>*</modifier></type> <name>table</name></decl></parameter>, <parameter><decl><type><name>BrotliBitReader</name><modifier>*</modifier></type> <name>br</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name><modifier>*</modifier></type> <name>result</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>val</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>available_bits</name> <init>= <expr><call><name>BrotliGetAvailableBits</name><argument_list>(<argument><expr><name>br</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>BROTLI_HC_MARK_TABLE_FOR_FAST_LOAD</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>available_bits</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>BROTLI_HC_FAST_LOAD_BITS</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <call><name>BROTLI_HC_FAST_LOAD_VALUE</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>BROTLI_FALSE</name></expr>;</return>  <comment type="block">/* No valid bits at all. */</comment>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>val</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><call><name>BrotliGetBitsUnmasked</name><argument_list>(<argument><expr><name>br</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>BROTLI_HC_ADJUST_TABLE_INDEX</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>val</name> <operator>&amp;</operator> <name>HUFFMAN_TABLE_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>BROTLI_HC_FAST_LOAD_BITS</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>HUFFMAN_TABLE_BITS</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>BROTLI_HC_FAST_LOAD_BITS</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>available_bits</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>BrotliDropBits</name><argument_list>(<argument><expr><name>br</name></expr></argument>, <argument><expr><call><name>BROTLI_HC_FAST_LOAD_BITS</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <call><name>BROTLI_HC_FAST_LOAD_VALUE</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <return>return <expr><name>BROTLI_FALSE</name></expr>;</return>  <comment type="block">/* Not enough bits for the first level. */</comment>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>available_bits</name> <operator>&lt;=</operator> <name>HUFFMAN_TABLE_BITS</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>BROTLI_FALSE</name></expr>;</return>  <comment type="block">/* Not enough bits to move to the second level. */</comment>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Speculatively drop HUFFMAN_TABLE_BITS. */</comment>
  <expr_stmt><expr><name>val</name> <operator>=</operator> <operator>(</operator><name>val</name> <operator>&amp;</operator> <call><name>BitMask</name><argument_list>(<argument><expr><call><name>BROTLI_HC_FAST_LOAD_BITS</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;&gt;</operator> <name>HUFFMAN_TABLE_BITS</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>available_bits</name> <operator>-=</operator> <name>HUFFMAN_TABLE_BITS</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>BROTLI_HC_ADJUST_TABLE_INDEX</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><call><name>BROTLI_HC_FAST_LOAD_VALUE</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>available_bits</name> <operator>&lt;</operator> <call><name>BROTLI_HC_FAST_LOAD_BITS</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>BROTLI_FALSE</name></expr>;</return>  <comment type="block">/* Not enough bits for the second level. */</comment>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>BrotliDropBits</name><argument_list>(<argument><expr><name>br</name></expr></argument>, <argument><expr><name>HUFFMAN_TABLE_BITS</name> <operator>+</operator> <call><name>BROTLI_HC_FAST_LOAD_BITS</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <call><name>BROTLI_HC_FAST_LOAD_VALUE</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BROTLI_INLINE</name> <name>BROTLI_BOOL</name></type> <name>SafeReadSymbol</name><parameter_list>(
    <parameter><decl><type><specifier>const</specifier> <name>HuffmanCode</name><modifier>*</modifier></type> <name>table</name></decl></parameter>, <parameter><decl><type><name>BrotliBitReader</name><modifier>*</modifier></type> <name>br</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name><modifier>*</modifier></type> <name>result</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>val</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>BROTLI_PREDICT_TRUE</name><argument_list>(<argument><expr><call><name>BrotliSafeGetBits</name><argument_list>(<argument><expr><name>br</name></expr></argument>, <argument><expr><literal type="number">15</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <call><name>DecodeSymbol</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>table</name></expr></argument>, <argument><expr><name>br</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>SafeDecodeSymbol</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>br</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Makes a look-up in first level Huffman table. Peeks 8 bits. */</comment>
<function><type><specifier>static</specifier> <name>BROTLI_INLINE</name> <name>void</name></type> <name>PreloadSymbol</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>safe</name></decl></parameter>,
                                        <parameter><decl><type><specifier>const</specifier> <name>HuffmanCode</name><modifier>*</modifier></type> <name>table</name></decl></parameter>,
                                        <parameter><decl><type><name>BrotliBitReader</name><modifier>*</modifier></type> <name>br</name></decl></parameter>,
                                        <parameter><decl><type><name>uint32_t</name><modifier>*</modifier></type> <name>bits</name></decl></parameter>,
                                        <parameter><decl><type><name>uint32_t</name><modifier>*</modifier></type> <name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>safe</name></expr>)</condition> <block>{<block_content>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>BROTLI_HC_MARK_TABLE_FOR_FAST_LOAD</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>BROTLI_HC_ADJUST_TABLE_INDEX</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><call><name>BrotliGetBits</name><argument_list>(<argument><expr><name>br</name></expr></argument>, <argument><expr><name>HUFFMAN_TABLE_BITS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>bits</name> <operator>=</operator> <call><name>BROTLI_HC_FAST_LOAD_BITS</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <call><name>BROTLI_HC_FAST_LOAD_VALUE</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Decodes the next Huffman code using data prepared by PreloadSymbol.
   Reads 0 - 15 bits. Also peeks 8 following bits. */</comment>
<function><type><specifier>static</specifier> <name>BROTLI_INLINE</name> <name>uint32_t</name></type> <name>ReadPreloadedSymbol</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>HuffmanCode</name><modifier>*</modifier></type> <name>table</name></decl></parameter>,
                                                  <parameter><decl><type><name>BrotliBitReader</name><modifier>*</modifier></type> <name>br</name></decl></parameter>,
                                                  <parameter><decl><type><name>uint32_t</name><modifier>*</modifier></type> <name>bits</name></decl></parameter>,
                                                  <parameter><decl><type><name>uint32_t</name><modifier>*</modifier></type> <name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>result</name> <init>= <expr><operator>*</operator><name>value</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>BROTLI_PREDICT_FALSE</name><argument_list>(<argument><expr><operator>*</operator><name>bits</name> <operator>&gt;</operator> <name>HUFFMAN_TABLE_BITS</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>val</name> <init>= <expr><call><name>BrotliGet16BitsUnmasked</name><argument_list>(<argument><expr><name>br</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>HuffmanCode</name><modifier>*</modifier></type> <name>ext</name> <init>= <expr><name>table</name> <operator>+</operator> <operator>(</operator><name>val</name> <operator>&amp;</operator> <name>HUFFMAN_TABLE_MASK</name><operator>)</operator> <operator>+</operator> <operator>*</operator><name>value</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>mask</name> <init>= <expr><call><name>BitMask</name><argument_list>(<argument><expr><operator>(</operator><operator>*</operator><name>bits</name> <operator>-</operator> <name>HUFFMAN_TABLE_BITS</name><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>BROTLI_HC_MARK_TABLE_FOR_FAST_LOAD</name><argument_list>(<argument><expr><name>ext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BrotliDropBits</name><argument_list>(<argument><expr><name>br</name></expr></argument>, <argument><expr><name>HUFFMAN_TABLE_BITS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BROTLI_HC_ADJUST_TABLE_INDEX</name><argument_list>(<argument><expr><name>ext</name></expr></argument>, <argument><expr><operator>(</operator><name>val</name> <operator>&gt;&gt;</operator> <name>HUFFMAN_TABLE_BITS</name><operator>)</operator> <operator>&amp;</operator> <name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BrotliDropBits</name><argument_list>(<argument><expr><name>br</name></expr></argument>, <argument><expr><call><name>BROTLI_HC_FAST_LOAD_BITS</name><argument_list>(<argument><expr><name>ext</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>BROTLI_HC_FAST_LOAD_VALUE</name><argument_list>(<argument><expr><name>ext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>BrotliDropBits</name><argument_list>(<argument><expr><name>br</name></expr></argument>, <argument><expr><operator>*</operator><name>bits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>PreloadSymbol</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>table</name></expr></argument>, <argument><expr><name>br</name></expr></argument>, <argument><expr><name>bits</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BROTLI_INLINE</name> <name>uint32_t</name></type> <name>Log2Floor</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>x</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr><name>x</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>x</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>++</operator><name>result</name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Reads (s-&gt;symbol + 1) symbols.
   Totally 1..4 symbols are read, 1..11 bits each.
   The list of symbols MUST NOT contain duplicates. */</comment>
<function><type><specifier>static</specifier> <name>BrotliDecoderErrorCode</name></type> <name>ReadSimpleHuffmanSymbols</name><parameter_list>(
    <parameter><decl><type><name>uint32_t</name></type> <name>alphabet_size_max</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>alphabet_size_limit</name></decl></parameter>,
    <parameter><decl><type><name>BrotliDecoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* max_bits == 1..11; symbol == 0..3; 1..44 bits will be read. */</comment>
  <decl_stmt><decl><type><name>BrotliBitReader</name><modifier>*</modifier></type> <name>br</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>br</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BrotliMetablockHeaderArena</name><modifier>*</modifier></type> <name>h</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>arena</name><operator>.</operator><name>header</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>max_bits</name> <init>= <expr><call><name>Log2Floor</name><argument_list>(<argument><expr><name>alphabet_size_max</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name> <init>= <expr><name><name>h</name><operator>-&gt;</operator><name>sub_loop_counter</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>num_symbols</name> <init>= <expr><name><name>h</name><operator>-&gt;</operator><name>symbol</name></name></expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr><name>i</name> <operator>&lt;=</operator> <name>num_symbols</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>v</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>BROTLI_PREDICT_FALSE</name><argument_list>(<argument><expr><operator>!</operator><call><name>BrotliSafeReadBits</name><argument_list>(<argument><expr><name>br</name></expr></argument>, <argument><expr><name>max_bits</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>sub_loop_counter</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>substate_huffman</name></name> <operator>=</operator> <name>BROTLI_STATE_HUFFMAN_SIMPLE_READ</name></expr>;</expr_stmt>
      <return>return <expr><name>BROTLI_DECODER_NEEDS_MORE_INPUT</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>v</name> <operator>&gt;=</operator> <name>alphabet_size_limit</name></expr>)</condition> <block>{<block_content>
      <return>return
          <expr><call><name>BROTLI_FAILURE</name><argument_list>(<argument><expr><name>BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>symbols_lists_array</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator><name>v</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BROTLI_LOG_UINT</name><argument_list>(<argument><expr><name><name>h</name><operator>-&gt;</operator><name>symbols_lists_array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>++</operator><name>i</name></expr>;</expr_stmt>
  </block_content>}</block></while>

  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_symbols</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>k</name> <init>= <expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init>;</init> <condition><expr><name>k</name> <operator>&lt;=</operator> <name>num_symbols</name></expr>;</condition> <incr><expr><operator>++</operator><name>k</name></expr></incr>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>symbols_lists_array</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name><name>h</name><operator>-&gt;</operator><name>symbols_lists_array</name><index>[<expr><name>k</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name>BROTLI_FAILURE</name><argument_list>(<argument><expr><name>BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME</name></expr></argument>)</argument_list></call></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></for>

  <return>return <expr><name>BROTLI_DECODER_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Process single decoded symbol code length:
    A) reset the repeat variable
    B) remember code length (if it is not 0)
    C) extend corresponding index-chain
    D) reduce the Huffman space
    E) update the histogram */</comment>
<function><type><specifier>static</specifier> <name>BROTLI_INLINE</name> <name>void</name></type> <name>ProcessSingleCodeLength</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>code_len</name></decl></parameter>,
    <parameter><decl><type><name>uint32_t</name><modifier>*</modifier></type> <name>symbol</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name><modifier>*</modifier></type> <name>repeat</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name><modifier>*</modifier></type> <name>space</name></decl></parameter>,
    <parameter><decl><type><name>uint32_t</name><modifier>*</modifier></type> <name>prev_code_len</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name><modifier>*</modifier></type> <name>symbol_lists</name></decl></parameter>,
    <parameter><decl><type><name>uint16_t</name><modifier>*</modifier></type> <name>code_length_histo</name></decl></parameter>, <parameter><decl><type><name>int</name><modifier>*</modifier></type> <name>next_symbol</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><operator>*</operator><name>repeat</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>code_len</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* code_len == 1..15 */</comment>
    <expr_stmt><expr><name><name>symbol_lists</name><index>[<expr><name><name>next_symbol</name><index>[<expr><name>code_len</name></expr>]</index></name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator><operator>(</operator><operator>*</operator><name>symbol</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>next_symbol</name><index>[<expr><name>code_len</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>*</operator><name>symbol</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>prev_code_len</name> <operator>=</operator> <name>code_len</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>space</name> <operator>-=</operator> <literal type="number">32768U</literal> <operator>&gt;&gt;</operator> <name>code_len</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>code_length_histo</name><index>[<expr><name>code_len</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BROTLI_LOG</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"[ReadHuffmanCode] code_length[%d] = %d\n"</literal><operator>,</operator>
        <operator>(</operator><name>int</name><operator>)</operator><operator>*</operator><name>symbol</name><operator>,</operator> <operator>(</operator><name>int</name><operator>)</operator><name>code_len</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>(</operator><operator>*</operator><name>symbol</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Process repeated symbol code length.
    A) Check if it is the extension of previous repeat sequence; if the decoded
       value is not BROTLI_REPEAT_PREVIOUS_CODE_LENGTH, then it is a new
       symbol-skip
    B) Update repeat variable
    C) Check if operation is feasible (fits alphabet)
    D) For each symbol do the same operations as in ProcessSingleCodeLength

   PRECONDITION: code_len == BROTLI_REPEAT_PREVIOUS_CODE_LENGTH or
                 code_len == BROTLI_REPEAT_ZERO_CODE_LENGTH */</comment>
<function><type><specifier>static</specifier> <name>BROTLI_INLINE</name> <name>void</name></type> <name>ProcessRepeatedCodeLength</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>code_len</name></decl></parameter>,
    <parameter><decl><type><name>uint32_t</name></type> <name>repeat_delta</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>alphabet_size</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name><modifier>*</modifier></type> <name>symbol</name></decl></parameter>,
    <parameter><decl><type><name>uint32_t</name><modifier>*</modifier></type> <name>repeat</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name><modifier>*</modifier></type> <name>space</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name><modifier>*</modifier></type> <name>prev_code_len</name></decl></parameter>,
    <parameter><decl><type><name>uint32_t</name><modifier>*</modifier></type> <name>repeat_code_len</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name><modifier>*</modifier></type> <name>symbol_lists</name></decl></parameter>,
    <parameter><decl><type><name>uint16_t</name><modifier>*</modifier></type> <name>code_length_histo</name></decl></parameter>, <parameter><decl><type><name>int</name><modifier>*</modifier></type> <name>next_symbol</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>old_repeat</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>extra_bits</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* for BROTLI_REPEAT_ZERO_CODE_LENGTH */</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>new_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* for BROTLI_REPEAT_ZERO_CODE_LENGTH */</comment>
  <if_stmt><if>if <condition>(<expr><name>code_len</name> <operator>==</operator> <name>BROTLI_REPEAT_PREVIOUS_CODE_LENGTH</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>new_len</name> <operator>=</operator> <operator>*</operator><name>prev_code_len</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>extra_bits</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>repeat_code_len</name> <operator>!=</operator> <name>new_len</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>repeat</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>repeat_code_len</name> <operator>=</operator> <name>new_len</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>old_repeat</name> <operator>=</operator> <operator>*</operator><name>repeat</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>repeat</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>repeat</name> <operator>-=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>repeat</name> <operator>&lt;&lt;=</operator> <name>extra_bits</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>repeat</name> <operator>+=</operator> <name>repeat_delta</name> <operator>+</operator> <literal type="number">3U</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>repeat_delta</name> <operator>=</operator> <operator>*</operator><name>repeat</name> <operator>-</operator> <name>old_repeat</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>symbol</name> <operator>+</operator> <name>repeat_delta</name> <operator>&gt;</operator> <name>alphabet_size</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>BROTLI_DUMP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>symbol</name> <operator>=</operator> <name>alphabet_size</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>space</name> <operator>=</operator> <literal type="number">0xFFFFF</literal></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>BROTLI_LOG</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"[ReadHuffmanCode] code_length[%d..%d] = %d\n"</literal><operator>,</operator>
      <operator>(</operator><name>int</name><operator>)</operator><operator>*</operator><name>symbol</name><operator>,</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>*</operator><name>symbol</name> <operator>+</operator> <name>repeat_delta</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>,</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>*</operator><name>repeat_code_len</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>repeat_code_len</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>last</name> <init>= <expr><operator>*</operator><name>symbol</name> <operator>+</operator> <name>repeat_delta</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>next</name> <init>= <expr><name><name>next_symbol</name><index>[<expr><operator>*</operator><name>repeat_code_len</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <do>do <block>{<block_content>
      <expr_stmt><expr><name><name>symbol_lists</name><index>[<expr><name>next</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator><operator>*</operator><name>symbol</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>next</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>*</operator><name>symbol</name></expr>;</expr_stmt>
    </block_content>}</block> while <condition>(<expr><operator>++</operator><operator>(</operator><operator>*</operator><name>symbol</name><operator>)</operator> <operator>!=</operator> <name>last</name></expr>)</condition>;</do>
    <expr_stmt><expr><name><name>next_symbol</name><index>[<expr><operator>*</operator><name>repeat_code_len</name></expr>]</index></name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>space</name> <operator>-=</operator> <name>repeat_delta</name> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">15</literal> <operator>-</operator> <operator>*</operator><name>repeat_code_len</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>code_length_histo</name><index>[<expr><operator>*</operator><name>repeat_code_len</name></expr>]</index></name> <operator>=</operator>
        <operator>(</operator><name>uint16_t</name><operator>)</operator><operator>(</operator><name><name>code_length_histo</name><index>[<expr><operator>*</operator><name>repeat_code_len</name></expr>]</index></name> <operator>+</operator> <name>repeat_delta</name><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>symbol</name> <operator>+=</operator> <name>repeat_delta</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Reads and decodes symbol codelengths. */</comment>
<function><type><specifier>static</specifier> <name>BrotliDecoderErrorCode</name></type> <name>ReadSymbolCodeLengths</name><parameter_list>(
    <parameter><decl><type><name>uint32_t</name></type> <name>alphabet_size</name></decl></parameter>, <parameter><decl><type><name>BrotliDecoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>BrotliBitReader</name><modifier>*</modifier></type> <name>br</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>br</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BrotliMetablockHeaderArena</name><modifier>*</modifier></type> <name>h</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>arena</name><operator>.</operator><name>header</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>symbol</name> <init>= <expr><name><name>h</name><operator>-&gt;</operator><name>symbol</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>repeat</name> <init>= <expr><name><name>h</name><operator>-&gt;</operator><name>repeat</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>space</name> <init>= <expr><name><name>h</name><operator>-&gt;</operator><name>space</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>prev_code_len</name> <init>= <expr><name><name>h</name><operator>-&gt;</operator><name>prev_code_len</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>repeat_code_len</name> <init>= <expr><name><name>h</name><operator>-&gt;</operator><name>repeat_code_len</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint16_t</name><modifier>*</modifier></type> <name>symbol_lists</name> <init>= <expr><name><name>h</name><operator>-&gt;</operator><name>symbol_lists</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint16_t</name><modifier>*</modifier></type> <name>code_length_histo</name> <init>= <expr><name><name>h</name><operator>-&gt;</operator><name>code_length_histo</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name><modifier>*</modifier></type> <name>next_symbol</name> <init>= <expr><name><name>h</name><operator>-&gt;</operator><name>next_symbol</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BrotliWarmupBitReader</name><argument_list>(<argument><expr><name>br</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>BROTLI_DECODER_NEEDS_MORE_INPUT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <while>while <condition>(<expr><name><name>symbol</name> <argument_list type="generic">&lt; <argument><expr><name>alphabet_size</name> <operator>&amp;&amp;</operator> <name>space</name></expr></argument> &gt;</argument_list></name> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>HuffmanCode</name><modifier>*</modifier></type> <name>p</name> <init>= <expr><name><name>h</name><operator>-&gt;</operator><name>table</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>code_len</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>BROTLI_HC_MARK_TABLE_FOR_FAST_LOAD</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BrotliCheckInputAmount</name><argument_list>(<argument><expr><name>br</name></expr></argument>, <argument><expr><name>BROTLI_SHORT_FILL_BIT_WINDOW_READ</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>symbol</name></name> <operator>=</operator> <name>symbol</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>repeat</name></name> <operator>=</operator> <name>repeat</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>prev_code_len</name></name> <operator>=</operator> <name>prev_code_len</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>repeat_code_len</name></name> <operator>=</operator> <name>repeat_code_len</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>space</name></name> <operator>=</operator> <name>space</name></expr>;</expr_stmt>
      <return>return <expr><name>BROTLI_DECODER_NEEDS_MORE_INPUT</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>BrotliFillBitWindow16</name><argument_list>(<argument><expr><name>br</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BROTLI_HC_ADJUST_TABLE_INDEX</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>BrotliGetBitsUnmasked</name><argument_list>(<argument><expr><name>br</name></expr></argument>)</argument_list></call> <operator>&amp;</operator>
        <call><name>BitMask</name><argument_list>(<argument><expr><name>BROTLI_HUFFMAN_MAX_CODE_LENGTH_CODE_LENGTH</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BrotliDropBits</name><argument_list>(<argument><expr><name>br</name></expr></argument>, <argument><expr><call><name>BROTLI_HC_FAST_LOAD_BITS</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Use 1..5 bits. */</comment>
    <expr_stmt><expr><name>code_len</name> <operator>=</operator> <call><name>BROTLI_HC_FAST_LOAD_VALUE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* code_len == 0..17 */</comment>
    <if_stmt><if>if <condition>(<expr><name>code_len</name> <operator>&lt;</operator> <name>BROTLI_REPEAT_PREVIOUS_CODE_LENGTH</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>ProcessSingleCodeLength</name><argument_list>(<argument><expr><name>code_len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>symbol</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>repeat</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>space</name></expr></argument>,
          <argument><expr><operator>&amp;</operator><name>prev_code_len</name></expr></argument>, <argument><expr><name>symbol_lists</name></expr></argument>, <argument><expr><name>code_length_histo</name></expr></argument>, <argument><expr><name>next_symbol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* code_len == 16..17, extra_bits == 2..3 */</comment>
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>extra_bits</name> <init>=
          <expr><ternary><condition><expr><operator>(</operator><name>code_len</name> <operator>==</operator> <name>BROTLI_REPEAT_PREVIOUS_CODE_LENGTH</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">3</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>repeat_delta</name> <init>=
          <expr><operator>(</operator><name>uint32_t</name><operator>)</operator><call><name>BrotliGetBitsUnmasked</name><argument_list>(<argument><expr><name>br</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <call><name>BitMask</name><argument_list>(<argument><expr><name>extra_bits</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>BrotliDropBits</name><argument_list>(<argument><expr><name>br</name></expr></argument>, <argument><expr><name>extra_bits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>ProcessRepeatedCodeLength</name><argument_list>(<argument><expr><name>code_len</name></expr></argument>, <argument><expr><name>repeat_delta</name></expr></argument>, <argument><expr><name>alphabet_size</name></expr></argument>,
          <argument><expr><operator>&amp;</operator><name>symbol</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>repeat</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>space</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prev_code_len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>repeat_code_len</name></expr></argument>,
          <argument><expr><name>symbol_lists</name></expr></argument>, <argument><expr><name>code_length_histo</name></expr></argument>, <argument><expr><name>next_symbol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>space</name></name> <operator>=</operator> <name>space</name></expr>;</expr_stmt>
  <return>return <expr><name>BROTLI_DECODER_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BrotliDecoderErrorCode</name></type> <name>SafeReadSymbolCodeLengths</name><parameter_list>(
    <parameter><decl><type><name>uint32_t</name></type> <name>alphabet_size</name></decl></parameter>, <parameter><decl><type><name>BrotliDecoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>BrotliBitReader</name><modifier>*</modifier></type> <name>br</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>br</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BrotliMetablockHeaderArena</name><modifier>*</modifier></type> <name>h</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>arena</name><operator>.</operator><name>header</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BROTLI_BOOL</name></type> <name>get_byte</name> <init>= <expr><name>BROTLI_FALSE</name></expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>symbol</name></name> <operator>&lt;</operator> <name>alphabet_size</name> <operator>&amp;&amp;</operator> <name><name>h</name><operator>-&gt;</operator><name>space</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>HuffmanCode</name><modifier>*</modifier></type> <name>p</name> <init>= <expr><name><name>h</name><operator>-&gt;</operator><name>table</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>code_len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>available_bits</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>bits</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>BROTLI_HC_MARK_TABLE_FOR_FAST_LOAD</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>get_byte</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>BrotliPullByte</name><argument_list>(<argument><expr><name>br</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>BROTLI_DECODER_NEEDS_MORE_INPUT</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>get_byte</name> <operator>=</operator> <name>BROTLI_FALSE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>available_bits</name> <operator>=</operator> <call><name>BrotliGetAvailableBits</name><argument_list>(<argument><expr><name>br</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>available_bits</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>bits</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><call><name>BrotliGetBitsUnmasked</name><argument_list>(<argument><expr><name>br</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>BROTLI_HC_ADJUST_TABLE_INDEX</name><argument_list>(<argument><expr><name>p</name></expr></argument>,
        <argument><expr><name>bits</name> <operator>&amp;</operator> <call><name>BitMask</name><argument_list>(<argument><expr><name>BROTLI_HUFFMAN_MAX_CODE_LENGTH_CODE_LENGTH</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>BROTLI_HC_FAST_LOAD_BITS</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>available_bits</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>get_byte</name> <operator>=</operator> <name>BROTLI_TRUE</name></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>code_len</name> <operator>=</operator> <call><name>BROTLI_HC_FAST_LOAD_VALUE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* code_len == 0..17 */</comment>
    <if_stmt><if>if <condition>(<expr><name>code_len</name> <operator>&lt;</operator> <name>BROTLI_REPEAT_PREVIOUS_CODE_LENGTH</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>BrotliDropBits</name><argument_list>(<argument><expr><name>br</name></expr></argument>, <argument><expr><call><name>BROTLI_HC_FAST_LOAD_BITS</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>ProcessSingleCodeLength</name><argument_list>(<argument><expr><name>code_len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>symbol</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>repeat</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>space</name></name></expr></argument>,
          <argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>prev_code_len</name></name></expr></argument>, <argument><expr><name><name>h</name><operator>-&gt;</operator><name>symbol_lists</name></name></expr></argument>, <argument><expr><name><name>h</name><operator>-&gt;</operator><name>code_length_histo</name></name></expr></argument>,
          <argument><expr><name><name>h</name><operator>-&gt;</operator><name>next_symbol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* code_len == 16..17, extra_bits == 2..3 */</comment>
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>extra_bits</name> <init>= <expr><name>code_len</name> <operator>-</operator> <literal type="number">14U</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>repeat_delta</name> <init>= <expr><operator>(</operator><name>bits</name> <operator>&gt;&gt;</operator> <call><name>BROTLI_HC_FAST_LOAD_BITS</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;</operator>
          <call><name>BitMask</name><argument_list>(<argument><expr><name>extra_bits</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>available_bits</name> <operator>&lt;</operator> <call><name>BROTLI_HC_FAST_LOAD_BITS</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>extra_bits</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>get_byte</name> <operator>=</operator> <name>BROTLI_TRUE</name></expr>;</expr_stmt>
        <continue>continue;</continue>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>BrotliDropBits</name><argument_list>(<argument><expr><name>br</name></expr></argument>, <argument><expr><call><name>BROTLI_HC_FAST_LOAD_BITS</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>extra_bits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>ProcessRepeatedCodeLength</name><argument_list>(<argument><expr><name>code_len</name></expr></argument>, <argument><expr><name>repeat_delta</name></expr></argument>, <argument><expr><name>alphabet_size</name></expr></argument>,
          <argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>symbol</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>repeat</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>space</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>prev_code_len</name></name></expr></argument>,
          <argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>repeat_code_len</name></name></expr></argument>, <argument><expr><name><name>h</name><operator>-&gt;</operator><name>symbol_lists</name></name></expr></argument>, <argument><expr><name><name>h</name><operator>-&gt;</operator><name>code_length_histo</name></name></expr></argument>,
          <argument><expr><name><name>h</name><operator>-&gt;</operator><name>next_symbol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>
  <return>return <expr><name>BROTLI_DECODER_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Reads and decodes 15..18 codes using static prefix code.
   Each code is 2..4 bits long. In total 30..72 bits are used. */</comment>
<function><type><specifier>static</specifier> <name>BrotliDecoderErrorCode</name></type> <name>ReadCodeLengthCodeLengths</name><parameter_list>(<parameter><decl><type><name>BrotliDecoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>BrotliBitReader</name><modifier>*</modifier></type> <name>br</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>br</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BrotliMetablockHeaderArena</name><modifier>*</modifier></type> <name>h</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>arena</name><operator>.</operator><name>header</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>num_codes</name> <init>= <expr><name><name>h</name><operator>-&gt;</operator><name>repeat</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>space</name> <init>= <expr><name><name>h</name><operator>-&gt;</operator><name>space</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name> <init>= <expr><name><name>h</name><operator>-&gt;</operator><name>sub_loop_counter</name></name></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>BROTLI_CODE_LENGTH_CODES</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name></type> <name>code_len_idx</name> <init>= <expr><name><name>kCodeLengthCodeOrder</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>ix</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>v</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>BROTLI_PREDICT_FALSE</name><argument_list>(<argument><expr><operator>!</operator><call><name>BrotliSafeGetBits</name><argument_list>(<argument><expr><name>br</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>ix</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>available_bits</name> <init>= <expr><call><name>BrotliGetAvailableBits</name><argument_list>(<argument><expr><name>br</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>available_bits</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>ix</name> <operator>=</operator> <call><name>BrotliGetBitsUnmasked</name><argument_list>(<argument><expr><name>br</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <literal type="number">0xF</literal></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>ix</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>kCodeLengthPrefixLength</name><index>[<expr><name>ix</name></expr>]</index></name> <operator>&gt;</operator> <name>available_bits</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>sub_loop_counter</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>repeat</name></name> <operator>=</operator> <name>num_codes</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>space</name></name> <operator>=</operator> <name>space</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>substate_huffman</name></name> <operator>=</operator> <name>BROTLI_STATE_HUFFMAN_COMPLEX</name></expr>;</expr_stmt>
        <return>return <expr><name>BROTLI_DECODER_NEEDS_MORE_INPUT</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>v</name> <operator>=</operator> <name><name>kCodeLengthPrefixValue</name><index>[<expr><name>ix</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BrotliDropBits</name><argument_list>(<argument><expr><name>br</name></expr></argument>, <argument><expr><name><name>kCodeLengthPrefixLength</name><index>[<expr><name>ix</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>code_length_code_lengths</name><index>[<expr><name>code_len_idx</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name>v</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BROTLI_LOG_ARRAY_INDEX</name><argument_list>(<argument><expr><name><name>h</name><operator>-&gt;</operator><name>code_length_code_lengths</name></name></expr></argument>, <argument><expr><name>code_len_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>v</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>space</name> <operator>=</operator> <name>space</name> <operator>-</operator> <operator>(</operator><literal type="number">32U</literal> <operator>&gt;&gt;</operator> <name>v</name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><operator>++</operator><name>num_codes</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>++</operator><name><name>h</name><operator>-&gt;</operator><name>code_length_histo</name><index>[<expr><name>v</name></expr>]</index></name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>space</name> <operator>-</operator> <literal type="number">1U</literal> <operator>&gt;=</operator> <literal type="number">32U</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* space is 0 or wrapped around. */</comment>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>num_codes</name> <operator>==</operator> <literal type="number">1</literal> <operator>||</operator> <name>space</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
    <return>return <expr><call><name>BROTLI_FAILURE</name><argument_list>(<argument><expr><name>BROTLI_DECODER_ERROR_FORMAT_CL_SPACE</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>BROTLI_DECODER_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Decodes the Huffman tables.
   There are 2 scenarios:
    A) Huffman code contains only few symbols (1..4). Those symbols are read
       directly; their code lengths are defined by the number of symbols.
       For this scenario 4 - 49 bits will be read.

    B) 2-phase decoding:
    B.1) Small Huffman table is decoded; it is specified with code lengths
         encoded with predefined entropy code. 32 - 74 bits are used.
    B.2) Decoded table is used to decode code lengths of symbols in resulting
         Huffman table. In worst case 3520 bits are read. */</comment>
<function><type><specifier>static</specifier> <name>BrotliDecoderErrorCode</name></type> <name>ReadHuffmanCode</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>alphabet_size_max</name></decl></parameter>,
                                              <parameter><decl><type><name>uint32_t</name></type> <name>alphabet_size_limit</name></decl></parameter>,
                                              <parameter><decl><type><name>HuffmanCode</name><modifier>*</modifier></type> <name>table</name></decl></parameter>,
                                              <parameter><decl><type><name>uint32_t</name><modifier>*</modifier></type> <name>opt_table_size</name></decl></parameter>,
                                              <parameter><decl><type><name>BrotliDecoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>BrotliBitReader</name><modifier>*</modifier></type> <name>br</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>br</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BrotliMetablockHeaderArena</name><modifier>*</modifier></type> <name>h</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>arena</name><operator>.</operator><name>header</name></name></expr></init></decl>;</decl_stmt>
  <comment type="block">/* State machine. */</comment>
  <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
    <switch>switch <condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>substate_huffman</name></name></expr>)</condition> <block>{<block_content>
      <case>case <expr><name>BROTLI_STATE_HUFFMAN_NONE</name></expr>:</case>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BrotliSafeReadBits</name><argument_list>(<argument><expr><name>br</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>sub_loop_counter</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <return>return <expr><name>BROTLI_DECODER_NEEDS_MORE_INPUT</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>BROTLI_LOG_UINT</name><argument_list>(<argument><expr><name><name>h</name><operator>-&gt;</operator><name>sub_loop_counter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* The value is used as follows:
           1 for simple code;
           0 for no skipping, 2 skips 2 code lengths, 3 skips 3 code lengths */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>sub_loop_counter</name></name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>space</name></name> <operator>=</operator> <literal type="number">32</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>repeat</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* num_codes */</comment>
          <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>code_length_histo</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>h</name><operator>-&gt;</operator><name>code_length_histo</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof> <operator>*</operator>
              <operator>(</operator><name>BROTLI_HUFFMAN_MAX_CODE_LENGTH_CODE_LENGTH</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>code_length_code_lengths</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
              <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>h</name><operator>-&gt;</operator><name>code_length_code_lengths</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>substate_huffman</name></name> <operator>=</operator> <name>BROTLI_STATE_HUFFMAN_COMPLEX</name></expr>;</expr_stmt>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
      <comment type="block">/* Fall through. */</comment>

      <case>case <expr><name>BROTLI_STATE_HUFFMAN_SIMPLE_SIZE</name></expr>:</case>
        <comment type="block">/* Read symbols, codes &amp; code lengths directly. */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BrotliSafeReadBits</name><argument_list>(<argument><expr><name>br</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>symbol</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* num_symbols */</comment>
          <expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>substate_huffman</name></name> <operator>=</operator> <name>BROTLI_STATE_HUFFMAN_SIMPLE_SIZE</name></expr>;</expr_stmt>
          <return>return <expr><name>BROTLI_DECODER_NEEDS_MORE_INPUT</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>sub_loop_counter</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <comment type="block">/* Fall through. */</comment>

      <case>case <expr><name>BROTLI_STATE_HUFFMAN_SIMPLE_READ</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>BrotliDecoderErrorCode</name></type> <name>result</name> <init>=
            <expr><call><name>ReadSimpleHuffmanSymbols</name><argument_list>(<argument><expr><name>alphabet_size_max</name></expr></argument>, <argument><expr><name>alphabet_size_limit</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>BROTLI_DECODER_SUCCESS</name></expr>)</condition> <block>{<block_content>
          <return>return <expr><name>result</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block>
      <comment type="block">/* Fall through. */</comment>

      <case>case <expr><name>BROTLI_STATE_HUFFMAN_SIMPLE_BUILD</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>uint32_t</name></type> <name>table_size</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>symbol</name></name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
          <decl_stmt><decl><type><name>uint32_t</name></type> <name>bits</name></decl>;</decl_stmt>
          <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BrotliSafeReadBits</name><argument_list>(<argument><expr><name>br</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>bits</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>substate_huffman</name></name> <operator>=</operator> <name>BROTLI_STATE_HUFFMAN_SIMPLE_BUILD</name></expr>;</expr_stmt>
            <return>return <expr><name>BROTLI_DECODER_NEEDS_MORE_INPUT</name></expr>;</return>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>symbol</name></name> <operator>+=</operator> <name>bits</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>BROTLI_LOG_UINT</name><argument_list>(<argument><expr><name><name>h</name><operator>-&gt;</operator><name>symbol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>table_size</name> <operator>=</operator> <call><name>BrotliBuildSimpleHuffmanTable</name><argument_list>(
            <argument><expr><name>table</name></expr></argument>, <argument><expr><name>HUFFMAN_TABLE_BITS</name></expr></argument>, <argument><expr><name><name>h</name><operator>-&gt;</operator><name>symbols_lists_array</name></name></expr></argument>, <argument><expr><name><name>h</name><operator>-&gt;</operator><name>symbol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>opt_table_size</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><operator>*</operator><name>opt_table_size</name> <operator>=</operator> <name>table_size</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>substate_huffman</name></name> <operator>=</operator> <name>BROTLI_STATE_HUFFMAN_NONE</name></expr>;</expr_stmt>
        <return>return <expr><name>BROTLI_DECODER_SUCCESS</name></expr>;</return>
      </block_content>}</block>

      <comment type="block">/* Decode Huffman-coded code lengths. */</comment>
      <case>case <expr><name>BROTLI_STATE_HUFFMAN_COMPLEX</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BrotliDecoderErrorCode</name></type> <name>result</name> <init>= <expr><call><name>ReadCodeLengthCodeLengths</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>BROTLI_DECODER_SUCCESS</name></expr>)</condition> <block>{<block_content>
          <return>return <expr><name>result</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>BrotliBuildCodeLengthsHuffmanTable</name><argument_list>(<argument><expr><name><name>h</name><operator>-&gt;</operator><name>table</name></name></expr></argument>,
                                           <argument><expr><name><name>h</name><operator>-&gt;</operator><name>code_length_code_lengths</name></name></expr></argument>,
                                           <argument><expr><name><name>h</name><operator>-&gt;</operator><name>code_length_histo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>code_length_histo</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>h</name><operator>-&gt;</operator><name>code_length_histo</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>BROTLI_HUFFMAN_MAX_CODE_LENGTH</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
          <expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>next_symbol</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>i</name> <operator>-</operator> <operator>(</operator><name>BROTLI_HUFFMAN_MAX_CODE_LENGTH</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>symbol_lists</name><index>[<expr><name><name>h</name><operator>-&gt;</operator><name>next_symbol</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name> <operator>=</operator> <literal type="number">0xFFFF</literal></expr>;</expr_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>symbol</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>prev_code_len</name></name> <operator>=</operator> <name>BROTLI_INITIAL_REPEATED_CODE_LENGTH</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>repeat</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>repeat_code_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>space</name></name> <operator>=</operator> <literal type="number">32768</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>substate_huffman</name></name> <operator>=</operator> <name>BROTLI_STATE_HUFFMAN_LENGTH_SYMBOLS</name></expr>;</expr_stmt>
      </block_content>}</block>
      <comment type="block">/* Fall through. */</comment>

      <case>case <expr><name>BROTLI_STATE_HUFFMAN_LENGTH_SYMBOLS</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>uint32_t</name></type> <name>table_size</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BrotliDecoderErrorCode</name></type> <name>result</name> <init>= <expr><call><name>ReadSymbolCodeLengths</name><argument_list>(
            <argument><expr><name>alphabet_size_limit</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>BROTLI_DECODER_NEEDS_MORE_INPUT</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>SafeReadSymbolCodeLengths</name><argument_list>(<argument><expr><name>alphabet_size_limit</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>BROTLI_DECODER_SUCCESS</name></expr>)</condition> <block>{<block_content>
          <return>return <expr><name>result</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>space</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>BROTLI_LOG</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"[ReadHuffmanCode] space = %d\n"</literal><operator>,</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>h</name><operator>-&gt;</operator><name>space</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><call><name>BROTLI_FAILURE</name><argument_list>(<argument><expr><name>BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>table_size</name> <operator>=</operator> <call><name>BrotliBuildHuffmanTable</name><argument_list>(
            <argument><expr><name>table</name></expr></argument>, <argument><expr><name>HUFFMAN_TABLE_BITS</name></expr></argument>, <argument><expr><name><name>h</name><operator>-&gt;</operator><name>symbol_lists</name></name></expr></argument>, <argument><expr><name><name>h</name><operator>-&gt;</operator><name>code_length_histo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>opt_table_size</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><operator>*</operator><name>opt_table_size</name> <operator>=</operator> <name>table_size</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>substate_huffman</name></name> <operator>=</operator> <name>BROTLI_STATE_HUFFMAN_NONE</name></expr>;</expr_stmt>
        <return>return <expr><name>BROTLI_DECODER_SUCCESS</name></expr>;</return>
      </block_content>}</block>

      <default>default:</default>
        <return>return
            <expr><call><name>BROTLI_FAILURE</name><argument_list>(<argument><expr><name>BROTLI_DECODER_ERROR_UNREACHABLE</name></expr></argument>)</argument_list></call></expr>;</return>  <comment type="block">/* COV_NF_LINE */</comment>
    </block_content>}</block></switch>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* Decodes a block length by reading 3..39 bits. */</comment>
<function><type><specifier>static</specifier> <name>BROTLI_INLINE</name> <name>uint32_t</name></type> <name>ReadBlockLength</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>HuffmanCode</name><modifier>*</modifier></type> <name>table</name></decl></parameter>,
                                              <parameter><decl><type><name>BrotliBitReader</name><modifier>*</modifier></type> <name>br</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>code</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>nbits</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>ReadSymbol</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>br</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nbits</name> <operator>=</operator> <name><name>_kBrotliPrefixCodeRanges</name><index>[<expr><name>code</name></expr>]</index></name><operator>.</operator><name>nbits</name></expr>;</expr_stmt>  <comment type="block">/* nbits == 2..24 */</comment>
  <return>return <expr><name><name>_kBrotliPrefixCodeRanges</name><index>[<expr><name>code</name></expr>]</index></name><operator>.</operator><name>offset</name> <operator>+</operator> <call><name>BrotliReadBits24</name><argument_list>(<argument><expr><name>br</name></expr></argument>, <argument><expr><name>nbits</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* WARNING: if state is not BROTLI_STATE_READ_BLOCK_LENGTH_NONE, then
   reading can't be continued with ReadBlockLength. */</comment>
<function><type><specifier>static</specifier> <name>BROTLI_INLINE</name> <name>BROTLI_BOOL</name></type> <name>SafeReadBlockLength</name><parameter_list>(
    <parameter><decl><type><name>BrotliDecoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name><modifier>*</modifier></type> <name>result</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>HuffmanCode</name><modifier>*</modifier></type> <name>table</name></decl></parameter>,
    <parameter><decl><type><name>BrotliBitReader</name><modifier>*</modifier></type> <name>br</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>index</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>substate_read_block_length</name></name> <operator>==</operator> <name>BROTLI_STATE_READ_BLOCK_LENGTH_NONE</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SafeReadSymbol</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>br</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>index</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>BROTLI_FALSE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name>index</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>block_length_index</name></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <block>{<block_content>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>bits</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>nbits</name> <init>= <expr><name><name>_kBrotliPrefixCodeRanges</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>nbits</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>offset</name> <init>= <expr><name><name>_kBrotliPrefixCodeRanges</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>offset</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BrotliSafeReadBits</name><argument_list>(<argument><expr><name>br</name></expr></argument>, <argument><expr><name>nbits</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bits</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>block_length_index</name></name> <operator>=</operator> <name>index</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>substate_read_block_length</name></name> <operator>=</operator> <name>BROTLI_STATE_READ_BLOCK_LENGTH_SUFFIX</name></expr>;</expr_stmt>
      <return>return <expr><name>BROTLI_FALSE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>offset</name> <operator>+</operator> <name>bits</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>substate_read_block_length</name></name> <operator>=</operator> <name>BROTLI_STATE_READ_BLOCK_LENGTH_NONE</name></expr>;</expr_stmt>
    <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>
  </block_content>}</block>
</block_content>}</block></function>

<comment type="block">/* Transform:
    1) initialize list L with values 0, 1,... 255
    2) For each input element X:
    2.1) let Y = L[X]
    2.2) remove X-th element from L
    2.3) prepend Y to L
    2.4) append Y to output

   In most cases max(Y) &lt;= 7, so most of L remains intact.
   To reduce the cost of initialization, we reuse L, remember the upper bound
   of Y values, and reinitialize only first elements in L.

   Most of input values are 0 and 1. To reduce number of branches, we replace
   inner for loop with do-while. */</comment>
<function><type><specifier>static</specifier> <name>BROTLI_NOINLINE</name> <name>void</name></type> <name>InverseMoveToFrontTransform</name><parameter_list>(
    <parameter><decl><type><name>uint8_t</name><modifier>*</modifier></type> <name>v</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>v_len</name></decl></parameter>, <parameter><decl><type><name>BrotliDecoderState</name><modifier>*</modifier></type> <name>state</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* Reinitialize elements that could have been changed. */</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>upper_bound</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>mtf_upper_bound</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name><modifier>*</modifier></type> <name>mtf</name> <init>= <expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>mtf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>  <comment type="block">/* Make mtf[-1] addressable. */</comment>
  <decl_stmt><decl><type><name>uint8_t</name><modifier>*</modifier></type> <name>mtf_u8</name> <init>= <expr><operator>(</operator><name>uint8_t</name><operator>*</operator><operator>)</operator><name>mtf</name></expr></init></decl>;</decl_stmt>
  <comment type="block">/* Load endian-aware constant. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name></type> <name><name>b0123</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">3</literal></expr>}</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>pattern</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pattern</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>b0123</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Initialize list using 4 consequent values pattern. */</comment>
  <expr_stmt><expr><name><name>mtf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>pattern</name></expr>;</expr_stmt>
  <do>do <block>{<block_content>
    <expr_stmt><expr><name>pattern</name> <operator>+=</operator> <literal type="number">0x04040404</literal></expr>;</expr_stmt>  <comment type="block">/* Advance all 4 values by 4. */</comment>
    <expr_stmt><expr><name><name>mtf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>pattern</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block> while <condition>(<expr><name>i</name> <operator>&lt;=</operator> <name>upper_bound</name></expr>)</condition>;</do>

  <comment type="block">/* Transform the input. */</comment>
  <expr_stmt><expr><name>upper_bound</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>v_len</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><name><name>v</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint8_t</name></type> <name>value</name> <init>= <expr><name><name>mtf_u8</name><index>[<expr><name>index</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>upper_bound</name> <operator>|=</operator> <name><name>v</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>v</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mtf_u8</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
    <do>do <block>{<block_content>
      <expr_stmt><expr><name>index</name><operator>--</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>mtf_u8</name><index>[<expr><name>index</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>mtf_u8</name><index>[<expr><name>index</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block> while <condition>(<expr><name>index</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>;</do>
  </block_content>}</block></for>
  <comment type="block">/* Remember amount of elements to be reinitialized. */</comment>
  <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mtf_upper_bound</name></name> <operator>=</operator> <name>upper_bound</name> <operator>&gt;&gt;</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Decodes a series of Huffman table using ReadHuffmanCode function. */</comment>
<function><type><specifier>static</specifier> <name>BrotliDecoderErrorCode</name></type> <name>HuffmanTreeGroupDecode</name><parameter_list>(
    <parameter><decl><type><name>HuffmanTreeGroup</name><modifier>*</modifier></type> <name>group</name></decl></parameter>, <parameter><decl><type><name>BrotliDecoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>BrotliMetablockHeaderArena</name><modifier>*</modifier></type> <name>h</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>arena</name><operator>.</operator><name>header</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>substate_tree_group</name></name> <operator>!=</operator> <name>BROTLI_STATE_TREE_GROUP_LOOP</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>group</name><operator>-&gt;</operator><name>codes</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>htree_index</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>substate_tree_group</name></name> <operator>=</operator> <name>BROTLI_STATE_TREE_GROUP_LOOP</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <while>while <condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>htree_index</name></name> <operator>&lt;</operator> <name><name>group</name><operator>-&gt;</operator><name>num_htrees</name></name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>table_size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BrotliDecoderErrorCode</name></type> <name>result</name> <init>= <expr><call><name>ReadHuffmanCode</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>alphabet_size_max</name></name></expr></argument>,
        <argument><expr><name><name>group</name><operator>-&gt;</operator><name>alphabet_size_limit</name></name></expr></argument>, <argument><expr><name><name>h</name><operator>-&gt;</operator><name>next</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>table_size</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>BROTLI_DECODER_SUCCESS</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>group</name><operator>-&gt;</operator><name>htrees</name><index>[<expr><name><name>h</name><operator>-&gt;</operator><name>htree_index</name></name></expr>]</index></name> <operator>=</operator> <name><name>h</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>next</name></name> <operator>+=</operator> <name>table_size</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>++</operator><name><name>h</name><operator>-&gt;</operator><name>htree_index</name></name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>substate_tree_group</name></name> <operator>=</operator> <name>BROTLI_STATE_TREE_GROUP_NONE</name></expr>;</expr_stmt>
  <return>return <expr><name>BROTLI_DECODER_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Decodes a context map.
   Decoding is done in 4 phases:
    1) Read auxiliary information (6..16 bits) and allocate memory.
       In case of trivial context map, decoding is finished at this phase.
    2) Decode Huffman table using ReadHuffmanCode function.
       This table will be used for reading context map items.
    3) Read context map items; "0" values could be run-length encoded.
    4) Optionally, apply InverseMoveToFront transform to the resulting map. */</comment>
<function><type><specifier>static</specifier> <name>BrotliDecoderErrorCode</name></type> <name>DecodeContextMap</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>context_map_size</name></decl></parameter>,
                                               <parameter><decl><type><name>uint32_t</name><modifier>*</modifier></type> <name>num_htrees</name></decl></parameter>,
                                               <parameter><decl><type><name>uint8_t</name><modifier>*</modifier><modifier>*</modifier></type> <name>context_map_arg</name></decl></parameter>,
                                               <parameter><decl><type><name>BrotliDecoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>BrotliBitReader</name><modifier>*</modifier></type> <name>br</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>br</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BrotliDecoderErrorCode</name></type> <name>result</name> <init>= <expr><name>BROTLI_DECODER_SUCCESS</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BrotliMetablockHeaderArena</name><modifier>*</modifier></type> <name>h</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>arena</name><operator>.</operator><name>header</name></name></expr></init></decl>;</decl_stmt>

  <switch>switch <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator><name><name>h</name><operator>-&gt;</operator><name>substate_context_map</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>BROTLI_STATE_CONTEXT_MAP_NONE</name></expr>:</case>
      <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DecodeVarLenUint8</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>br</name></expr></argument>, <argument><expr><name>num_htrees</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>BROTLI_DECODER_SUCCESS</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>result</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><operator>(</operator><operator>*</operator><name>num_htrees</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>context_index</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>BROTLI_LOG_UINT</name><argument_list>(<argument><expr><name>context_map_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>BROTLI_LOG_UINT</name><argument_list>(<argument><expr><operator>*</operator><name>num_htrees</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>context_map_arg</name> <operator>=</operator>
          <operator>(</operator><name>uint8_t</name><operator>*</operator><operator>)</operator><call><name>BROTLI_DECODER_ALLOC</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>context_map_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>*</operator><name>context_map_arg</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name>BROTLI_FAILURE</name><argument_list>(<argument><expr><name>BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP</name></expr></argument>)</argument_list></call></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><operator>*</operator><name>num_htrees</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>*</operator><name>context_map_arg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>context_map_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>BROTLI_DECODER_SUCCESS</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>substate_context_map</name></name> <operator>=</operator> <name>BROTLI_STATE_CONTEXT_MAP_READ_PREFIX</name></expr>;</expr_stmt>
    <comment type="block">/* Fall through. */</comment>

    <case>case <expr><name>BROTLI_STATE_CONTEXT_MAP_READ_PREFIX</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>bits</name></decl>;</decl_stmt>
      <comment type="block">/* In next stage ReadHuffmanCode uses at least 4 bits, so it is safe
         to peek 4 bits ahead. */</comment>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BrotliSafeGetBits</name><argument_list>(<argument><expr><name>br</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>bits</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>BROTLI_DECODER_NEEDS_MORE_INPUT</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>bits</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> <comment type="block">/* Use RLE for zeros. */</comment>
        <expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>max_run_length_prefix</name></name> <operator>=</operator> <operator>(</operator><name>bits</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BrotliDropBits</name><argument_list>(<argument><expr><name>br</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>max_run_length_prefix</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BrotliDropBits</name><argument_list>(<argument><expr><name>br</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>BROTLI_LOG_UINT</name><argument_list>(<argument><expr><name><name>h</name><operator>-&gt;</operator><name>max_run_length_prefix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>substate_context_map</name></name> <operator>=</operator> <name>BROTLI_STATE_CONTEXT_MAP_HUFFMAN</name></expr>;</expr_stmt>
    </block_content>}</block>
    <comment type="block">/* Fall through. */</comment>

    <case>case <expr><name>BROTLI_STATE_CONTEXT_MAP_HUFFMAN</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>alphabet_size</name> <init>= <expr><operator>*</operator><name>num_htrees</name> <operator>+</operator> <name><name>h</name><operator>-&gt;</operator><name>max_run_length_prefix</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ReadHuffmanCode</name><argument_list>(<argument><expr><name>alphabet_size</name></expr></argument>, <argument><expr><name>alphabet_size</name></expr></argument>,
                               <argument><expr><name><name>h</name><operator>-&gt;</operator><name>context_map_table</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>BROTLI_DECODER_SUCCESS</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>code</name></name> <operator>=</operator> <literal type="number">0xFFFF</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>substate_context_map</name></name> <operator>=</operator> <name>BROTLI_STATE_CONTEXT_MAP_DECODE</name></expr>;</expr_stmt>
    </block_content>}</block>
    <comment type="block">/* Fall through. */</comment>

    <case>case <expr><name>BROTLI_STATE_CONTEXT_MAP_DECODE</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>context_index</name> <init>= <expr><name><name>h</name><operator>-&gt;</operator><name>context_index</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>max_run_length_prefix</name> <init>= <expr><name><name>h</name><operator>-&gt;</operator><name>max_run_length_prefix</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>uint8_t</name><modifier>*</modifier></type> <name>context_map</name> <init>= <expr><operator>*</operator><name>context_map_arg</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>code</name> <init>= <expr><name><name>h</name><operator>-&gt;</operator><name>code</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>BROTLI_BOOL</name></type> <name>skip_preamble</name> <init>= <expr><operator>(</operator><name>code</name> <operator>!=</operator> <literal type="number">0xFFFF</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
      <while>while <condition>(<expr><name>context_index</name> <operator>&lt;</operator> <name>context_map_size</name> <operator>||</operator> <name>skip_preamble</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>skip_preamble</name></expr>)</condition> <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SafeReadSymbol</name><argument_list>(<argument><expr><name><name>h</name><operator>-&gt;</operator><name>context_map_table</name></name></expr></argument>, <argument><expr><name>br</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>code</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>code</name></name> <operator>=</operator> <literal type="number">0xFFFF</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>context_index</name></name> <operator>=</operator> <name>context_index</name></expr>;</expr_stmt>
            <return>return <expr><name>BROTLI_DECODER_NEEDS_MORE_INPUT</name></expr>;</return>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><call><name>BROTLI_LOG_UINT</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <if_stmt><if>if <condition>(<expr><name>code</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>context_map</name><index>[<expr><name>context_index</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <continue>continue;</continue>
          </block_content>}</block></if></if_stmt>
          <if_stmt><if>if <condition>(<expr><name>code</name> <operator>&gt;</operator> <name>max_run_length_prefix</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>context_map</name><index>[<expr><name>context_index</name><operator>++</operator></expr>]</index></name> <operator>=</operator>
                <operator>(</operator><name>uint8_t</name><operator>)</operator><operator>(</operator><name>code</name> <operator>-</operator> <name>max_run_length_prefix</name><operator>)</operator></expr>;</expr_stmt>
            <continue>continue;</continue>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
          <expr_stmt><expr><name>skip_preamble</name> <operator>=</operator> <name>BROTLI_FALSE</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <comment type="block">/* RLE sub-stage. */</comment>
        <block>{<block_content>
          <decl_stmt><decl><type><name>uint32_t</name></type> <name>reps</name></decl>;</decl_stmt>
          <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BrotliSafeReadBits</name><argument_list>(<argument><expr><name>br</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reps</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>code</name></name> <operator>=</operator> <name>code</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>context_index</name></name> <operator>=</operator> <name>context_index</name></expr>;</expr_stmt>
            <return>return <expr><name>BROTLI_DECODER_NEEDS_MORE_INPUT</name></expr>;</return>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>reps</name> <operator>+=</operator> <literal type="number">1U</literal> <operator>&lt;&lt;</operator> <name>code</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>BROTLI_LOG_UINT</name><argument_list>(<argument><expr><name>reps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>context_index</name> <operator>+</operator> <name>reps</name> <operator>&gt;</operator> <name>context_map_size</name></expr>)</condition> <block>{<block_content>
            <return>return
                <expr><call><name>BROTLI_FAILURE</name><argument_list>(<argument><expr><name>BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT</name></expr></argument>)</argument_list></call></expr>;</return>
          </block_content>}</block></if></if_stmt>
          <do>do <block>{<block_content>
            <expr_stmt><expr><name><name>context_map</name><index>[<expr><name>context_index</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          </block_content>}</block> while <condition>(<expr><operator>--</operator><name>reps</name></expr>)</condition>;</do>
        </block_content>}</block>
      </block_content>}</block></while>
    </block_content>}</block>
    <comment type="block">/* Fall through. */</comment>

    <case>case <expr><name>BROTLI_STATE_CONTEXT_MAP_TRANSFORM</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>bits</name></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BrotliSafeReadBits</name><argument_list>(<argument><expr><name>br</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>bits</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>substate_context_map</name></name> <operator>=</operator> <name>BROTLI_STATE_CONTEXT_MAP_TRANSFORM</name></expr>;</expr_stmt>
        <return>return <expr><name>BROTLI_DECODER_NEEDS_MORE_INPUT</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>bits</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>InverseMoveToFrontTransform</name><argument_list>(<argument><expr><operator>*</operator><name>context_map_arg</name></expr></argument>, <argument><expr><name>context_map_size</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>substate_context_map</name></name> <operator>=</operator> <name>BROTLI_STATE_CONTEXT_MAP_NONE</name></expr>;</expr_stmt>
      <return>return <expr><name>BROTLI_DECODER_SUCCESS</name></expr>;</return>
    </block_content>}</block>

    <default>default:</default>
      <return>return
          <expr><call><name>BROTLI_FAILURE</name><argument_list>(<argument><expr><name>BROTLI_DECODER_ERROR_UNREACHABLE</name></expr></argument>)</argument_list></call></expr>;</return>  <comment type="block">/* COV_NF_LINE */</comment>
  </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/* Decodes a command or literal and updates block type ring-buffer.
   Reads 3..54 bits. */</comment>
<function><type><specifier>static</specifier> <name>BROTLI_INLINE</name> <name>BROTLI_BOOL</name></type> <name>DecodeBlockTypeAndLength</name><parameter_list>(
    <parameter><decl><type><name>int</name></type> <name>safe</name></decl></parameter>, <parameter><decl><type><name>BrotliDecoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tree_type</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>max_block_type</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>num_block_types</name><index>[<expr><name>tree_type</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>HuffmanCode</name><modifier>*</modifier></type> <name>type_tree</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>block_type_trees</name><index>[
      <expr><name>tree_type</name> <operator>*</operator> <name>BROTLI_HUFFMAN_MAX_SIZE_258</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>HuffmanCode</name><modifier>*</modifier></type> <name>len_tree</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>block_len_trees</name><index>[
      <expr><name>tree_type</name> <operator>*</operator> <name>BROTLI_HUFFMAN_MAX_SIZE_26</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BrotliBitReader</name><modifier>*</modifier></type> <name>br</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>br</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name><modifier>*</modifier></type> <name>ringbuffer</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>block_type_rb</name><index>[<expr><name>tree_type</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>block_type</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>max_block_type</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>BROTLI_FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Read 0..15 + 3..39 bits. */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>safe</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>block_type</name> <operator>=</operator> <call><name>ReadSymbol</name><argument_list>(<argument><expr><name>type_tree</name></expr></argument>, <argument><expr><name>br</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>block_length</name><index>[<expr><name>tree_type</name></expr>]</index></name> <operator>=</operator> <call><name>ReadBlockLength</name><argument_list>(<argument><expr><name>len_tree</name></expr></argument>, <argument><expr><name>br</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>BrotliBitReaderState</name></type> <name>memento</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>BrotliBitReaderSaveState</name><argument_list>(<argument><expr><name>br</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>memento</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SafeReadSymbol</name><argument_list>(<argument><expr><name>type_tree</name></expr></argument>, <argument><expr><name>br</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>block_type</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>BROTLI_FALSE</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SafeReadBlockLength</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>block_length</name><index>[<expr><name>tree_type</name></expr>]</index></name></expr></argument>, <argument><expr><name>len_tree</name></expr></argument>, <argument><expr><name>br</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>substate_read_block_length</name></name> <operator>=</operator> <name>BROTLI_STATE_READ_BLOCK_LENGTH_NONE</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>BrotliBitReaderRestoreState</name><argument_list>(<argument><expr><name>br</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>memento</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>BROTLI_FALSE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>block_type</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>block_type</name> <operator>=</operator> <name><name>ringbuffer</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>block_type</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>block_type</name> <operator>=</operator> <name><name>ringbuffer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name>block_type</name> <operator>-=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>block_type</name> <operator>&gt;=</operator> <name>max_block_type</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>block_type</name> <operator>-=</operator> <name>max_block_type</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>ringbuffer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>ringbuffer</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ringbuffer</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>block_type</name></expr>;</expr_stmt>
  <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BROTLI_INLINE</name> <name>void</name></type> <name>DetectTrivialLiteralBlockTypes</name><parameter_list>(
    <parameter><decl><type><name>BrotliDecoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">8</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>trivial_literal_contexts</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>num_block_types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>offset</name> <init>= <expr><name>i</name> <operator>&lt;&lt;</operator> <name>BROTLI_LITERAL_CONTEXT_BITS</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>error</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>sample</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>context_map</name><index>[<expr><name>offset</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>j</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <name>BROTLI_LITERAL_CONTEXT_BITS</name><operator>)</operator></expr>;</condition><incr/>)</control> <block>{<block_content>
      <macro><name>BROTLI_REPEAT_4</name><argument_list>(<argument>{ error |= s-&gt;context_map[offset + j++] ^ sample; }</argument>)</argument_list></macro>
    </block_content>}</block></for>
    <if_stmt><if>if <condition>(<expr><name>error</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>trivial_literal_contexts</name><index>[<expr><name>i</name> <operator>&gt;&gt;</operator> <literal type="number">5</literal></expr>]</index></name> <operator>|=</operator> <literal type="number">1u</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>i</name> <operator>&amp;</operator> <literal type="number">31</literal><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BROTLI_INLINE</name> <name>void</name></type> <name>PrepareLiteralDecoding</name><parameter_list>(<parameter><decl><type><name>BrotliDecoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>context_mode</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>trivial</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>block_type</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>block_type_rb</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>context_offset</name> <init>= <expr><name>block_type</name> <operator>&lt;&lt;</operator> <name>BROTLI_LITERAL_CONTEXT_BITS</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>context_map_slice</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>context_map</name></name> <operator>+</operator> <name>context_offset</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>trivial</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>trivial_literal_contexts</name><index>[<expr><name>block_type</name> <operator>&gt;&gt;</operator> <literal type="number">5</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>trivial_literal_context</name></name> <operator>=</operator> <operator>(</operator><name>trivial</name> <operator>&gt;&gt;</operator> <operator>(</operator><name>block_type</name> <operator>&amp;</operator> <literal type="number">31</literal><operator>)</operator><operator>)</operator> <operator>&amp;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>literal_htree</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>literal_hgroup</name><operator>.</operator><name>htrees</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>context_map_slice</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>context_mode</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>context_modes</name><index>[<expr><name>block_type</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">3</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>context_lookup</name></name> <operator>=</operator> <call><name>BROTLI_CONTEXT_LUT</name><argument_list>(<argument><expr><name>context_mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Decodes the block type and updates the state for literal context.
   Reads 3..54 bits. */</comment>
<function><type><specifier>static</specifier> <name>BROTLI_INLINE</name> <name>BROTLI_BOOL</name></type> <name>DecodeLiteralBlockSwitchInternal</name><parameter_list>(
    <parameter><decl><type><name>int</name></type> <name>safe</name></decl></parameter>, <parameter><decl><type><name>BrotliDecoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DecodeBlockTypeAndLength</name><argument_list>(<argument><expr><name>safe</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>BROTLI_FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>PrepareLiteralDecoding</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>BROTLI_NOINLINE</name></type> <name>DecodeLiteralBlockSwitch</name><parameter_list>(<parameter><decl><type><name>BrotliDecoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>DecodeLiteralBlockSwitchInternal</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BROTLI_BOOL</name> <name>BROTLI_NOINLINE</name></type> <name>SafeDecodeLiteralBlockSwitch</name><parameter_list>(
    <parameter><decl><type><name>BrotliDecoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>DecodeLiteralBlockSwitchInternal</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Block switch for insert/copy length.
   Reads 3..54 bits. */</comment>
<function><type><specifier>static</specifier> <name>BROTLI_INLINE</name> <name>BROTLI_BOOL</name></type> <name>DecodeCommandBlockSwitchInternal</name><parameter_list>(
    <parameter><decl><type><name>int</name></type> <name>safe</name></decl></parameter>, <parameter><decl><type><name>BrotliDecoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DecodeBlockTypeAndLength</name><argument_list>(<argument><expr><name>safe</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>BROTLI_FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>htree_command</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>insert_copy_hgroup</name><operator>.</operator><name>htrees</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>block_type_rb</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt>
  <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>BROTLI_NOINLINE</name></type> <name>DecodeCommandBlockSwitch</name><parameter_list>(<parameter><decl><type><name>BrotliDecoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>DecodeCommandBlockSwitchInternal</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BROTLI_BOOL</name> <name>BROTLI_NOINLINE</name></type> <name>SafeDecodeCommandBlockSwitch</name><parameter_list>(
    <parameter><decl><type><name>BrotliDecoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>DecodeCommandBlockSwitchInternal</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Block switch for distance codes.
   Reads 3..54 bits. */</comment>
<function><type><specifier>static</specifier> <name>BROTLI_INLINE</name> <name>BROTLI_BOOL</name></type> <name>DecodeDistanceBlockSwitchInternal</name><parameter_list>(
    <parameter><decl><type><name>int</name></type> <name>safe</name></decl></parameter>, <parameter><decl><type><name>BrotliDecoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DecodeBlockTypeAndLength</name><argument_list>(<argument><expr><name>safe</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>BROTLI_FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>dist_context_map_slice</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>dist_context_map</name></name> <operator>+</operator>
      <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>block_type_rb</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <name>BROTLI_DISTANCE_CONTEXT_BITS</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>dist_htree_index</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>dist_context_map_slice</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>distance_context</name></name></expr>]</index></name></expr>;</expr_stmt>
  <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>BROTLI_NOINLINE</name></type> <name>DecodeDistanceBlockSwitch</name><parameter_list>(<parameter><decl><type><name>BrotliDecoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>DecodeDistanceBlockSwitchInternal</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BROTLI_BOOL</name> <name>BROTLI_NOINLINE</name></type> <name>SafeDecodeDistanceBlockSwitch</name><parameter_list>(
    <parameter><decl><type><name>BrotliDecoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>DecodeDistanceBlockSwitchInternal</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>UnwrittenBytes</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BrotliDecoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>BROTLI_BOOL</name></type> <name>wrap</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>size_t</name></type> <name>pos</name> <init>= <expr><ternary><condition><expr><name>wrap</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>pos</name></name> <operator>&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ringbuffer_size</name></name></expr> ?</condition><then>
      <expr><operator>(</operator><name>size_t</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>ringbuffer_size</name></name></expr> </then><else>: <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>pos</name></name><operator>)</operator></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>partial_pos_rb</name> <init>= <expr><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>rb_roundtrips</name></name> <operator>*</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>ringbuffer_size</name></name><operator>)</operator> <operator>+</operator> <name>pos</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><name>partial_pos_rb</name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>partial_pos_out</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Dumps output.
   Returns BROTLI_DECODER_NEEDS_MORE_OUTPUT only if there is more output to push
   and either ring-buffer is as big as window size, or |force| is true. */</comment>
<function><type><specifier>static</specifier> <name>BrotliDecoderErrorCode</name> <name>BROTLI_NOINLINE</name></type> <name>WriteRingBuffer</name><parameter_list>(
    <parameter><decl><type><name>BrotliDecoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>size_t</name><modifier>*</modifier></type> <name>available_out</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name><modifier>*</modifier><modifier>*</modifier></type> <name>next_out</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name><modifier>*</modifier></type> <name>total_out</name></decl></parameter>, <parameter><decl><type><name>BROTLI_BOOL</name></type> <name>force</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint8_t</name><modifier>*</modifier></type> <name>start</name> <init>=
      <expr><name><name>s</name><operator>-&gt;</operator><name>ringbuffer</name></name> <operator>+</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>partial_pos_out</name></name> <operator>&amp;</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>ringbuffer_mask</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>to_write</name> <init>= <expr><call><name>UnwrittenBytes</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>BROTLI_TRUE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>num_written</name> <init>= <expr><operator>*</operator><name>available_out</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>num_written</name> <operator>&gt;</operator> <name>to_write</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>num_written</name> <operator>=</operator> <name>to_write</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>meta_block_remaining_len</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <return>return <expr><call><name>BROTLI_FAILURE</name><argument_list>(<argument><expr><name>BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>next_out</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>*</operator><name>next_out</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>next_out</name> <operator>=</operator> <name>start</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>next_out</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>*</operator><name>next_out</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>num_written</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>next_out</name> <operator>+=</operator> <name>num_written</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>available_out</name> <operator>-=</operator> <name>num_written</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>BROTLI_LOG_UINT</name><argument_list>(<argument><expr><name>to_write</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>BROTLI_LOG_UINT</name><argument_list>(<argument><expr><name>num_written</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>partial_pos_out</name></name> <operator>+=</operator> <name>num_written</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>total_out</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>total_out</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>partial_pos_out</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>num_written</name> <operator>&lt;</operator> <name>to_write</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ringbuffer_size</name></name> <operator>==</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>window_bits</name></name><operator>)</operator> <operator>||</operator> <name>force</name></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>BROTLI_DECODER_NEEDS_MORE_OUTPUT</name></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <return>return <expr><name>BROTLI_DECODER_SUCCESS</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* Wrap ring buffer only if it has reached its maximal size. */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ringbuffer_size</name></name> <operator>==</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>window_bits</name></name><operator>)</operator> <operator>&amp;&amp;</operator>
      <name><name>s</name><operator>-&gt;</operator><name>pos</name></name> <operator>&gt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>ringbuffer_size</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>pos</name></name> <operator>-=</operator> <name><name>s</name><operator>-&gt;</operator><name>ringbuffer_size</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>rb_roundtrips</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>should_wrap_ringbuffer</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>size_t</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>pos</name></name> <operator>!=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>BROTLI_DECODER_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>BROTLI_NOINLINE</name></type> <name>WrapRingBuffer</name><parameter_list>(<parameter><decl><type><name>BrotliDecoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>should_wrap_ringbuffer</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>ringbuffer</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>ringbuffer_end</name></name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>pos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>should_wrap_ringbuffer</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Allocates ring-buffer.

   s-&gt;ringbuffer_size MUST be updated by BrotliCalculateRingBufferSize before
   this function is called.

   Last two bytes of ring-buffer are initialized to 0, so context calculation
   could be done uniformly for the first two and all other positions. */</comment>
<function><type><specifier>static</specifier> <name>BROTLI_BOOL</name> <name>BROTLI_NOINLINE</name></type> <name>BrotliEnsureRingBuffer</name><parameter_list>(
    <parameter><decl><type><name>BrotliDecoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint8_t</name><modifier>*</modifier></type> <name>old_ringbuffer</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ringbuffer</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ringbuffer_size</name></name> <operator>==</operator> <name><name>s</name><operator>-&gt;</operator><name>new_ringbuffer_size</name></name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ringbuffer</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>*</operator><operator>)</operator><call><name>BROTLI_DECODER_ALLOC</name><argument_list>(<argument><expr><name>s</name></expr></argument>,
      <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>new_ringbuffer_size</name></name><operator>)</operator> <operator>+</operator> <name>kRingBufferWriteAheadSlack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ringbuffer</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <comment type="block">/* Restore previous value. */</comment>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ringbuffer</name></name> <operator>=</operator> <name>old_ringbuffer</name></expr>;</expr_stmt>
    <return>return <expr><name>BROTLI_FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ringbuffer</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>new_ringbuffer_size</name></name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ringbuffer</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>new_ringbuffer_size</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>!</operator><name>old_ringbuffer</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>ringbuffer</name></name></expr></argument>, <argument><expr><name>old_ringbuffer</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>pos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BROTLI_DECODER_FREE</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>old_ringbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ringbuffer_size</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>new_ringbuffer_size</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ringbuffer_mask</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>new_ringbuffer_size</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ringbuffer_end</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>ringbuffer</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>ringbuffer_size</name></name></expr>;</expr_stmt>

  <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BrotliDecoderErrorCode</name> <name>BROTLI_NOINLINE</name></type> <name>CopyUncompressedBlockToOutput</name><parameter_list>(
    <parameter><decl><type><name>size_t</name><modifier>*</modifier></type> <name>available_out</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name><modifier>*</modifier><modifier>*</modifier></type> <name>next_out</name></decl></parameter>, <parameter><decl><type><name>size_t</name><modifier>*</modifier></type> <name>total_out</name></decl></parameter>,
    <parameter><decl><type><name>BrotliDecoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* TODO(eustas): avoid allocation for single uncompressed block. */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BrotliEnsureRingBuffer</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><call><name>BROTLI_FAILURE</name><argument_list>(<argument><expr><name>BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* State machine */</comment>
  <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
    <switch>switch <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>substate_uncompressed</name></name></expr>)</condition> <block>{<block_content>
      <case>case <expr><name>BROTLI_STATE_UNCOMPRESSED_NONE</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>nbytes</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>BrotliGetRemainingBytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>br</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>nbytes</name> <operator>&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>meta_block_remaining_len</name></name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>nbytes</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>meta_block_remaining_len</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>pos</name></name> <operator>+</operator> <name>nbytes</name> <operator>&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ringbuffer_size</name></name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>nbytes</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>ringbuffer_size</name></name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>pos</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* Copy remaining bytes from s-&gt;br.buf_ to ring-buffer. */</comment>
        <expr_stmt><expr><call><name>BrotliCopyBytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>ringbuffer</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>pos</name></name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>br</name></name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>pos</name></name> <operator>+=</operator> <name>nbytes</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>meta_block_remaining_len</name></name> <operator>-=</operator> <name>nbytes</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>pos</name></name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>window_bits</name></name></expr>)</condition> <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>meta_block_remaining_len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <return>return <expr><name>BROTLI_DECODER_SUCCESS</name></expr>;</return>
          </block_content>}</block></if></if_stmt>
          <return>return <expr><name>BROTLI_DECODER_NEEDS_MORE_INPUT</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>substate_uncompressed</name></name> <operator>=</operator> <name>BROTLI_STATE_UNCOMPRESSED_WRITE</name></expr>;</expr_stmt>
      </block_content>}</block>
      <comment type="block">/* Fall through. */</comment>

      <case>case <expr><name>BROTLI_STATE_UNCOMPRESSED_WRITE</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>BrotliDecoderErrorCode</name></type> <name>result</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>WriteRingBuffer</name><argument_list>(
            <argument><expr><name>s</name></expr></argument>, <argument><expr><name>available_out</name></expr></argument>, <argument><expr><name>next_out</name></expr></argument>, <argument><expr><name>total_out</name></expr></argument>, <argument><expr><name>BROTLI_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>BROTLI_DECODER_SUCCESS</name></expr>)</condition> <block>{<block_content>
          <return>return <expr><name>result</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ringbuffer_size</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>window_bits</name></name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>max_distance</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>max_backward_distance</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>substate_uncompressed</name></name> <operator>=</operator> <name>BROTLI_STATE_UNCOMPRESSED_NONE</name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
    </block_content>}</block></switch>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>BROTLI_DCHECK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Unreachable */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BROTLI_BOOL</name></type> <name>AttachCompoundDictionary</name><parameter_list>(
    <parameter><decl><type><name>BrotliDecoderState</name><modifier>*</modifier></type> <name>state</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name><modifier>*</modifier></type> <name>data</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>BrotliDecoderCompoundDictionary</name><modifier>*</modifier></type> <name>addon</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>compound_dictionary</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>BROTLI_STATE_UNINITED</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>BROTLI_FALSE</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>addon</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>addon</name> <operator>=</operator> <operator>(</operator><name>BrotliDecoderCompoundDictionary</name><operator>*</operator><operator>)</operator><call><name>BROTLI_DECODER_ALLOC</name><argument_list>(
        <argument><expr><name>state</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BrotliDecoderCompoundDictionary</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>addon</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>BROTLI_FALSE</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>addon</name><operator>-&gt;</operator><name>num_chunks</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>addon</name><operator>-&gt;</operator><name>total_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>addon</name><operator>-&gt;</operator><name>br_length</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>addon</name><operator>-&gt;</operator><name>br_copied</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>addon</name><operator>-&gt;</operator><name>block_bits</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>addon</name><operator>-&gt;</operator><name>chunk_offsets</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>compound_dictionary</name></name> <operator>=</operator> <name>addon</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>addon</name><operator>-&gt;</operator><name>num_chunks</name></name> <operator>==</operator> <literal type="number">15</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>BROTLI_FALSE</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>addon</name><operator>-&gt;</operator><name>chunks</name><index>[<expr><name><name>addon</name><operator>-&gt;</operator><name>num_chunks</name></name></expr>]</index></name> <operator>=</operator> <name>data</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>addon</name><operator>-&gt;</operator><name>num_chunks</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>addon</name><operator>-&gt;</operator><name>total_size</name></name> <operator>+=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>size</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>addon</name><operator>-&gt;</operator><name>chunk_offsets</name><index>[<expr><name><name>addon</name><operator>-&gt;</operator><name>num_chunks</name></name></expr>]</index></name> <operator>=</operator> <name><name>addon</name><operator>-&gt;</operator><name>total_size</name></name></expr>;</expr_stmt>
  <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>EnsureCoumpoundDictionaryInitialized</name><parameter_list>(<parameter><decl><type><name>BrotliDecoderState</name><modifier>*</modifier></type> <name>state</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>BrotliDecoderCompoundDictionary</name><modifier>*</modifier></type> <name>addon</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>compound_dictionary</name></name></expr></init></decl>;</decl_stmt>
  <comment type="block">/* 256 = (1 &lt;&lt; 8) slots in block map. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>block_bits</name> <init>= <expr><literal type="number">8</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>cursor</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>addon</name><operator>-&gt;</operator><name>block_bits</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <while>while <condition>(<expr><operator>(</operator><operator>(</operator><name><name>addon</name><operator>-&gt;</operator><name>total_size</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&gt;&gt;</operator> <name>block_bits</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>block_bits</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
  <expr_stmt><expr><name>block_bits</name> <operator>-=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>addon</name><operator>-&gt;</operator><name>block_bits</name></name> <operator>=</operator> <name>block_bits</name></expr>;</expr_stmt>
  <while>while <condition>(<expr><name>cursor</name> <operator>&lt;</operator> <name><name>addon</name><operator>-&gt;</operator><name>total_size</name></name></expr>)</condition> <block>{<block_content>
    <while>while <condition>(<expr><name><name>addon</name><operator>-&gt;</operator><name>chunk_offsets</name><index>[<expr><name>index</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&lt;</operator> <name>cursor</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>index</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
    <expr_stmt><expr><name><name>addon</name><operator>-&gt;</operator><name>block_map</name><index>[<expr><name>cursor</name> <operator>&gt;&gt;</operator> <name>block_bits</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name>index</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>cursor</name> <operator>+=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>block_bits</name></expr>;</expr_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BROTLI_BOOL</name></type> <name>InitializeCompoundDictionaryCopy</name><parameter_list>(<parameter><decl><type><name>BrotliDecoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>,
    <parameter><decl><type><name>int</name></type> <name>address</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>length</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>BrotliDecoderCompoundDictionary</name><modifier>*</modifier></type> <name>addon</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>compound_dictionary</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>index</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>EnsureCoumpoundDictionaryInitialized</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>index</name> <operator>=</operator> <name><name>addon</name><operator>-&gt;</operator><name>block_map</name><index>[<expr><name>address</name> <operator>&gt;&gt;</operator> <name><name>addon</name><operator>-&gt;</operator><name>block_bits</name></name></expr>]</index></name></expr>;</expr_stmt>
  <while>while <condition>(<expr><name>address</name> <operator>&gt;=</operator> <name><name>addon</name><operator>-&gt;</operator><name>chunk_offsets</name><index>[<expr><name>index</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>index</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
  <if_stmt><if>if <condition>(<expr><name><name>addon</name><operator>-&gt;</operator><name>total_size</name></name> <operator>&lt;</operator> <name>address</name> <operator>+</operator> <name>length</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>BROTLI_FALSE</name></expr>;</return></block_content></block></if></if_stmt>
  <comment type="block">/* Update the recent distances cache. */</comment>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>dist_rb</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>dist_rb_idx</name></name> <operator>&amp;</operator> <literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>distance_code</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>++</operator><name><name>s</name><operator>-&gt;</operator><name>dist_rb_idx</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>meta_block_remaining_len</name></name> <operator>-=</operator> <name>length</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>addon</name><operator>-&gt;</operator><name>br_index</name></name> <operator>=</operator> <name>index</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>addon</name><operator>-&gt;</operator><name>br_offset</name></name> <operator>=</operator> <name>address</name> <operator>-</operator> <name><name>addon</name><operator>-&gt;</operator><name>chunk_offsets</name><index>[<expr><name>index</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>addon</name><operator>-&gt;</operator><name>br_length</name></name> <operator>=</operator> <name>length</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>addon</name><operator>-&gt;</operator><name>br_copied</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>GetCompoundDictionarySize</name><parameter_list>(<parameter><decl><type><name>BrotliDecoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>compound_dictionary</name></name></expr> ?</condition><then> <expr><name><name>s</name><operator>-&gt;</operator><name>compound_dictionary</name><operator>-&gt;</operator><name>total_size</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>CopyFromCompoundDictionary</name><parameter_list>(<parameter><decl><type><name>BrotliDecoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>BrotliDecoderCompoundDictionary</name><modifier>*</modifier></type> <name>addon</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>compound_dictionary</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>orig_pos</name> <init>= <expr><name>pos</name></expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr><name><name>addon</name><operator>-&gt;</operator><name>br_length</name></name> <operator>!=</operator> <name><name>addon</name><operator>-&gt;</operator><name>br_copied</name></name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>uint8_t</name><modifier>*</modifier></type> <name>copy_dst</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>ringbuffer</name><index>[<expr><name>pos</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name><modifier>*</modifier></type> <name>copy_src</name> <init>=
        <expr><name><name>addon</name><operator>-&gt;</operator><name>chunks</name><index>[<expr><name><name>addon</name><operator>-&gt;</operator><name>br_index</name></name></expr>]</index></name> <operator>+</operator> <name><name>addon</name><operator>-&gt;</operator><name>br_offset</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>space</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ringbuffer_size</name></name> <operator>-</operator> <name>pos</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rem_chunk_length</name> <init>= <expr><operator>(</operator><name><name>addon</name><operator>-&gt;</operator><name>chunk_offsets</name><index>[<expr><name><name>addon</name><operator>-&gt;</operator><name>br_index</name></name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>-</operator>
        <name><name>addon</name><operator>-&gt;</operator><name>chunk_offsets</name><index>[<expr><name><name>addon</name><operator>-&gt;</operator><name>br_index</name></name></expr>]</index></name><operator>)</operator> <operator>-</operator> <name><name>addon</name><operator>-&gt;</operator><name>br_offset</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>length</name> <init>= <expr><name><name>addon</name><operator>-&gt;</operator><name>br_length</name></name> <operator>-</operator> <name><name>addon</name><operator>-&gt;</operator><name>br_copied</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>length</name> <operator>&gt;</operator> <name>rem_chunk_length</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>length</name> <operator>=</operator> <name>rem_chunk_length</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>length</name> <operator>&gt;</operator> <name>space</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>length</name> <operator>=</operator> <name>space</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>copy_dst</name></expr></argument>, <argument><expr><name>copy_src</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pos</name> <operator>+=</operator> <name>length</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>addon</name><operator>-&gt;</operator><name>br_offset</name></name> <operator>+=</operator> <name>length</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>addon</name><operator>-&gt;</operator><name>br_copied</name></name> <operator>+=</operator> <name>length</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>length</name> <operator>==</operator> <name>rem_chunk_length</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>addon</name><operator>-&gt;</operator><name>br_index</name></name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>addon</name><operator>-&gt;</operator><name>br_offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>pos</name> <operator>==</operator> <name><name>s</name><operator>-&gt;</operator><name>ringbuffer_size</name></name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
  </block_content>}</block></while>
  <return>return <expr><name>pos</name> <operator>-</operator> <name>orig_pos</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>BROTLI_BOOL</name></type> <name>BrotliDecoderAttachDictionary</name><parameter_list>(
    <parameter><decl><type><name>BrotliDecoderState</name><modifier>*</modifier></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>BrotliSharedDictionaryType</name></type> <name>type</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>data_size</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name></type> <name><name>data</name><index>[<expr><call><name>BROTLI_ARRAY_PARAM</name><argument_list>(<argument><expr><name>data_size</name></expr></argument>)</argument_list></call></expr>]</index></name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>num_prefix_before</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>dictionary</name><operator>-&gt;</operator><name>num_prefix</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>BROTLI_STATE_UNINITED</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>BROTLI_FALSE</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BrotliSharedDictionaryAttach</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>dictionary</name></name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>data_size</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>BROTLI_FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>num_prefix_before</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>dictionary</name><operator>-&gt;</operator><name>num_prefix</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AttachCompoundDictionary</name><argument_list>(
        <argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>dictionary</name><operator>-&gt;</operator><name>prefix</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
        <argument><expr><name><name>state</name><operator>-&gt;</operator><name>dictionary</name><operator>-&gt;</operator><name>prefix_size</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>BROTLI_FALSE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Calculates the smallest feasible ring buffer.

   If we know the data size is small, do not allocate more ring buffer
   size than needed to reduce memory usage.

   When this method is called, metablock size and flags MUST be decoded. */</comment>
<function><type><specifier>static</specifier> <name>void</name> <name>BROTLI_NOINLINE</name></type> <name>BrotliCalculateRingBufferSize</name><parameter_list>(
    <parameter><decl><type><name>BrotliDecoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>window_size</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>window_bits</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>new_ringbuffer_size</name> <init>= <expr><name>window_size</name></expr></init></decl>;</decl_stmt>
  <comment type="block">/* We need at least 2 bytes of ring buffer size to get the last two
     bytes for context from there */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>min_size</name> <init>= <expr><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>ringbuffer_size</name></name></expr> ?</condition><then> <expr><name><name>s</name><operator>-&gt;</operator><name>ringbuffer_size</name></name></expr> </then><else>: <expr><literal type="number">1024</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>output_size</name></decl>;</decl_stmt>

  <comment type="block">/* If maximum is already reached, no further extension is retired. */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ringbuffer_size</name></name> <operator>==</operator> <name>window_size</name></expr>)</condition> <block>{<block_content>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Metadata blocks does not touch ring buffer. */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>is_metadata</name></name></expr>)</condition> <block>{<block_content>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>ringbuffer</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>output_size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name>output_size</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>pos</name></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>output_size</name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>meta_block_remaining_len</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>min_size</name> <operator>=</operator> <ternary><condition><expr><name>min_size</name> <operator>&lt;</operator> <name>output_size</name></expr> ?</condition><then> <expr><name>output_size</name></expr> </then><else>: <expr><name>min_size</name></expr></else></ternary></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>canny_ringbuffer_allocation</name></name></expr>)</condition> <block>{<block_content>
    <comment type="block">/* Reduce ring buffer size to save memory when server is unscrupulous.
       In worst case memory usage might be 1.5x bigger for a short period of
       ring buffer reallocation. */</comment>
    <while>while <condition>(<expr><operator>(</operator><name>new_ringbuffer_size</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>&gt;=</operator> <name>min_size</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>new_ringbuffer_size</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>new_ringbuffer_size</name></name> <operator>=</operator> <name>new_ringbuffer_size</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Reads 1..256 2-bit context modes. */</comment>
<function><type><specifier>static</specifier> <name>BrotliDecoderErrorCode</name></type> <name>ReadContextModes</name><parameter_list>(<parameter><decl><type><name>BrotliDecoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>BrotliBitReader</name><modifier>*</modifier></type> <name>br</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>br</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>loop_counter</name></name></expr></init></decl>;</decl_stmt>

  <while>while <condition>(<expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>num_block_types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>bits</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BrotliSafeReadBits</name><argument_list>(<argument><expr><name>br</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>bits</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>loop_counter</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
      <return>return <expr><name>BROTLI_DECODER_NEEDS_MORE_INPUT</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>context_modes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name>bits</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BROTLI_LOG_ARRAY_INDEX</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>context_modes</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
  <return>return <expr><name>BROTLI_DECODER_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BROTLI_INLINE</name> <name>void</name></type> <name>TakeDistanceFromRingBuffer</name><parameter_list>(<parameter><decl><type><name>BrotliDecoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>distance_code</name></name> <operator>-</operator> <literal type="number">3</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>distance_code</name></name> <operator>&lt;=</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
    <comment type="block">/* Compensate double distance-ring-buffer roll for dictionary items. */</comment>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>distance_context</name></name> <operator>=</operator> <literal type="number">1</literal> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>distance_code</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>distance_code</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>dist_rb</name><index>[<expr><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>dist_rb_idx</name></name> <operator>-</operator> <name>offset</name><operator>)</operator> <operator>&amp;</operator> <literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>dist_rb_idx</name></name> <operator>-=</operator> <name><name>s</name><operator>-&gt;</operator><name>distance_context</name></name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>index_delta</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>delta</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>base</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>distance_code</name></name> <operator>-</operator> <literal type="number">10</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>distance_code</name></name> <operator>&lt;</operator> <literal type="number">10</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>base</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>distance_code</name></name> <operator>-</operator> <literal type="number">4</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>index_delta</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <comment type="block">/* Unpack one of six 4-bit values. */</comment>
    <expr_stmt><expr><name>delta</name> <operator>=</operator> <operator>(</operator><operator>(</operator><literal type="number">0x605142</literal> <operator>&gt;&gt;</operator> <operator>(</operator><literal type="number">4</literal> <operator>*</operator> <name>base</name><operator>)</operator><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xF</literal><operator>)</operator> <operator>-</operator> <literal type="number">3</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>distance_code</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>dist_rb</name><index>[<expr><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>dist_rb_idx</name></name> <operator>+</operator> <name>index_delta</name><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3</literal></expr>]</index></name> <operator>+</operator> <name>delta</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>distance_code</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <comment type="block">/* A huge distance will cause a BROTLI_FAILURE() soon.
         This is a little faster than failing here. */</comment>
      <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>distance_code</name></name> <operator>=</operator> <literal type="number">0x7FFFFFFF</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BROTLI_INLINE</name> <name>BROTLI_BOOL</name></type> <name>SafeReadBits</name><parameter_list>(
    <parameter><decl><type><name>BrotliBitReader</name><modifier>*</modifier> <specifier>const</specifier></type> <name>br</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>n_bits</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name><modifier>*</modifier></type> <name>val</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>n_bits</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <return>return <expr><call><name>BrotliSafeReadBits</name><argument_list>(<argument><expr><name>br</name></expr></argument>, <argument><expr><name>n_bits</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>val</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BROTLI_INLINE</name> <name>BROTLI_BOOL</name></type> <name>SafeReadBits32</name><parameter_list>(
    <parameter><decl><type><name>BrotliBitReader</name><modifier>*</modifier> <specifier>const</specifier></type> <name>br</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>n_bits</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name><modifier>*</modifier></type> <name>val</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>n_bits</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <return>return <expr><call><name>BrotliSafeReadBits32</name><argument_list>(<argument><expr><name>br</name></expr></argument>, <argument><expr><name>n_bits</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>val</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
   RFC 7932 Section 4 with "..." shortenings and "[]" emendations.

   Each distance ... is represented with a pair &lt;distance code, extra bits&gt;...
   The distance code is encoded using a prefix code... The number of extra bits
   can be 0..24... Two additional parameters: NPOSTFIX (0..3), and ...
   NDIRECT (0..120) ... are encoded in the meta-block header...

   The first 16 distance symbols ... reference past distances... ring buffer ...
   Next NDIRECT distance symbols ... represent distances from 1 to NDIRECT...
   [For] distance symbols 16 + NDIRECT and greater ... the number of extra bits
   ... is given by the following formula:

   [ xcode = dcode - NDIRECT - 16 ]
   ndistbits = 1 + [ xcode ] &gt;&gt; (NPOSTFIX + 1)

   ...
*/</comment>

<comment type="block">/*
   RFC 7932 Section 9.2 with "..." shortenings and "[]" emendations.

   ... to get the actual value of the parameter NDIRECT, left-shift this
   four-bit number by NPOSTFIX bits ...
*/</comment>

<comment type="block">/* Remaining formulas from RFC 7932 Section 4 could be rewritten as following:

     alphabet_size = 16 + NDIRECT + (max_distbits &lt;&lt; (NPOSTFIX + 1))

     half = ((xcode &gt;&gt; NPOSTFIX) &amp; 1) &lt;&lt; ndistbits
     postfix = xcode &amp; ((1 &lt;&lt; NPOSTFIX) - 1)
     range_start = 2 * (1 &lt;&lt; ndistbits - 1 - 1)

     distance = (range_start + half + extra) &lt;&lt; NPOSTFIX + postfix + NDIRECT + 1

   NB: ndistbits &gt;= 1 -&gt; range_start &gt;= 0
   NB: range_start has factor 2, as the range is covered by 2 "halves"
   NB: extra -1 offset in range_start formula covers the absence of
       ndistbits = 0 case
   NB: when NPOSTFIX = 0, NDIRECT is not greater than 15

   In other words, xcode has the following binary structure - XXXHPPP:
    - XXX represent the number of extra distance bits
    - H selects upper / lower range of distances
    - PPP represent "postfix"

  "Regular" distance encoding has NPOSTFIX = 0; omitting the postfix part
  simplifies distance calculation.

  Using NPOSTFIX &gt; 0 allows cheaper encoding of regular structures, e.g. where
  most of distances have the same reminder of division by 2/4/8. For example,
  the table of int32_t values that come from different sources; if it is likely
  that 3 highest bytes of values from the same source are the same, then
  copy distance often looks like 4x + y.

  Distance calculation could be rewritten to:

    ndistbits = NDISTBITS(NDIRECT, NPOSTFIX)[dcode]
    distance = OFFSET(NDIRECT, NPOSTFIX)[dcode] + extra &lt;&lt; NPOSTFIX

  NDISTBITS and OFFSET could be pre-calculated, as NDIRECT and NPOSTFIX could
  change only once per meta-block.
*/</comment>

<comment type="block">/* Calculates distance lookup table.
   NB: it is possible to have all 64 tables precalculated. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>CalculateDistanceLut</name><parameter_list>(<parameter><decl><type><name>BrotliDecoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>BrotliMetablockBodyArena</name><modifier>*</modifier></type> <name>b</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>arena</name><operator>.</operator><name>body</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>npostfix</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>distance_postfix_bits</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>ndirect</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>num_direct_distance_codes</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>alphabet_size_limit</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>distance_hgroup</name><operator>.</operator><name>alphabet_size_limit</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>postfix</name> <init>= <expr><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <name>npostfix</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>j</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>bits</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>half</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Skip short codes. */</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name> <init>= <expr><name>BROTLI_NUM_DISTANCE_SHORT_CODES</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Fill direct codes. */</comment>
  <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>ndirect</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control> <block>{<block_content>
    <expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>dist_extra_bits</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>dist_offset</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>j</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>++</operator><name>i</name></expr>;</expr_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Fill regular distance codes. */</comment>
  <while>while <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>alphabet_size_limit</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>base</name> <init>= <expr><name>ndirect</name> <operator>+</operator> <operator>(</operator><operator>(</operator><operator>(</operator><operator>(</operator><literal type="number">2</literal> <operator>+</operator> <name>half</name><operator>)</operator> <operator>&lt;&lt;</operator> <name>bits</name><operator>)</operator> <operator>-</operator> <literal type="number">4</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name>npostfix</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <comment type="block">/* Always fill the complete group. */</comment>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>postfix</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control> <block>{<block_content>
      <expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>dist_extra_bits</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name>bits</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>dist_offset</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>base</name> <operator>+</operator> <name>j</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>++</operator><name>i</name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name>bits</name> <operator>=</operator> <name>bits</name> <operator>+</operator> <name>half</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>half</name> <operator>=</operator> <name>half</name> <operator>^</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/* Precondition: s-&gt;distance_code &lt; 0. */</comment>
<function><type><specifier>static</specifier> <name>BROTLI_INLINE</name> <name>BROTLI_BOOL</name></type> <name>ReadDistanceInternal</name><parameter_list>(
    <parameter><decl><type><name>int</name></type> <name>safe</name></decl></parameter>, <parameter><decl><type><name>BrotliDecoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>BrotliBitReader</name><modifier>*</modifier></type> <name>br</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>BrotliMetablockBodyArena</name><modifier>*</modifier></type> <name>b</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>arena</name><operator>.</operator><name>body</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>code</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>bits</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BrotliBitReaderState</name></type> <name>memento</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>HuffmanCode</name><modifier>*</modifier></type> <name>distance_tree</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>distance_hgroup</name><operator>.</operator><name>htrees</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>dist_htree_index</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>safe</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>ReadSymbol</name><argument_list>(<argument><expr><name>distance_tree</name></expr></argument>, <argument><expr><name>br</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>BrotliBitReaderSaveState</name><argument_list>(<argument><expr><name>br</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>memento</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SafeReadSymbol</name><argument_list>(<argument><expr><name>distance_tree</name></expr></argument>, <argument><expr><name>br</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>code</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>BROTLI_FALSE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><operator>--</operator><name><name>s</name><operator>-&gt;</operator><name>block_length</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
  <comment type="block">/* Convert the distance code to the actual distance by possibly
     looking up past distances from the s-&gt;dist_rb. */</comment>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>distance_context</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>code</name> <operator>&amp;</operator> <operator>~</operator><literal type="number">0xFu</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>distance_code</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>code</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TakeDistanceFromRingBuffer</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>safe</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>bits</name> <operator>=</operator> <call><name>BrotliReadBits32</name><argument_list>(<argument><expr><name>br</name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>dist_extra_bits</name><index>[<expr><name>code</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SafeReadBits32</name><argument_list>(<argument><expr><name>br</name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>dist_extra_bits</name><index>[<expr><name>code</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bits</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><operator>++</operator><name><name>s</name><operator>-&gt;</operator><name>block_length</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>BrotliBitReaderRestoreState</name><argument_list>(<argument><expr><name>br</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>memento</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>BROTLI_FALSE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>distance_code</name></name> <operator>=</operator>
      <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>b</name><operator>-&gt;</operator><name>dist_offset</name><index>[<expr><name>code</name></expr>]</index></name> <operator>+</operator> <operator>(</operator><name>bits</name> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>distance_postfix_bits</name></name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
  <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BROTLI_INLINE</name> <name>void</name></type> <name>ReadDistance</name><parameter_list>(
    <parameter><decl><type><name>BrotliDecoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>BrotliBitReader</name><modifier>*</modifier></type> <name>br</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>ReadDistanceInternal</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>br</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BROTLI_INLINE</name> <name>BROTLI_BOOL</name></type> <name>SafeReadDistance</name><parameter_list>(
    <parameter><decl><type><name>BrotliDecoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>BrotliBitReader</name><modifier>*</modifier></type> <name>br</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>ReadDistanceInternal</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>br</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BROTLI_INLINE</name> <name>BROTLI_BOOL</name></type> <name>ReadCommandInternal</name><parameter_list>(
    <parameter><decl><type><name>int</name></type> <name>safe</name></decl></parameter>, <parameter><decl><type><name>BrotliDecoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>BrotliBitReader</name><modifier>*</modifier></type> <name>br</name></decl></parameter>, <parameter><decl><type><name>int</name><modifier>*</modifier></type> <name>insert_length</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>cmd_code</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>insert_len_extra</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>copy_length</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CmdLutElement</name></type> <name>v</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BrotliBitReaderState</name></type> <name>memento</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>safe</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>cmd_code</name> <operator>=</operator> <call><name>ReadSymbol</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>htree_command</name></name></expr></argument>, <argument><expr><name>br</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>BrotliBitReaderSaveState</name><argument_list>(<argument><expr><name>br</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>memento</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SafeReadSymbol</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>htree_command</name></name></expr></argument>, <argument><expr><name>br</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cmd_code</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>BROTLI_FALSE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>v</name> <operator>=</operator> <name><name>kCmdLut</name><index>[<expr><name>cmd_code</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>distance_code</name></name> <operator>=</operator> <name><name>v</name><operator>.</operator><name>distance_code</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>distance_context</name></name> <operator>=</operator> <name><name>v</name><operator>.</operator><name>context</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>dist_htree_index</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>dist_context_map_slice</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>distance_context</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>insert_length</name> <operator>=</operator> <name><name>v</name><operator>.</operator><name>insert_len_offset</name></name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>safe</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>BROTLI_PREDICT_FALSE</name><argument_list>(<argument><expr><name><name>v</name><operator>.</operator><name>insert_len_extra_bits</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>insert_len_extra</name> <operator>=</operator> <call><name>BrotliReadBits24</name><argument_list>(<argument><expr><name>br</name></expr></argument>, <argument><expr><name><name>v</name><operator>.</operator><name>insert_len_extra_bits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>copy_length</name> <operator>=</operator> <call><name>BrotliReadBits24</name><argument_list>(<argument><expr><name>br</name></expr></argument>, <argument><expr><name><name>v</name><operator>.</operator><name>copy_len_extra_bits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SafeReadBits</name><argument_list>(<argument><expr><name>br</name></expr></argument>, <argument><expr><name><name>v</name><operator>.</operator><name>insert_len_extra_bits</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>insert_len_extra</name></expr></argument>)</argument_list></call> <operator>||</operator>
        <operator>!</operator><call><name>SafeReadBits</name><argument_list>(<argument><expr><name>br</name></expr></argument>, <argument><expr><name><name>v</name><operator>.</operator><name>copy_len_extra_bits</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>copy_length</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>BrotliBitReaderRestoreState</name><argument_list>(<argument><expr><name>br</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>memento</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>BROTLI_FALSE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>copy_length</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>copy_length</name> <operator>+</operator> <name><name>v</name><operator>.</operator><name>copy_len_offset</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>--</operator><name><name>s</name><operator>-&gt;</operator><name>block_length</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>insert_length</name> <operator>+=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>insert_len_extra</name></expr>;</expr_stmt>
  <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BROTLI_INLINE</name> <name>void</name></type> <name>ReadCommand</name><parameter_list>(
    <parameter><decl><type><name>BrotliDecoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>BrotliBitReader</name><modifier>*</modifier></type> <name>br</name></decl></parameter>, <parameter><decl><type><name>int</name><modifier>*</modifier></type> <name>insert_length</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>ReadCommandInternal</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>br</name></expr></argument>, <argument><expr><name>insert_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BROTLI_INLINE</name> <name>BROTLI_BOOL</name></type> <name>SafeReadCommand</name><parameter_list>(
    <parameter><decl><type><name>BrotliDecoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>BrotliBitReader</name><modifier>*</modifier></type> <name>br</name></decl></parameter>, <parameter><decl><type><name>int</name><modifier>*</modifier></type> <name>insert_length</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>ReadCommandInternal</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>br</name></expr></argument>, <argument><expr><name>insert_length</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BROTLI_INLINE</name> <name>BROTLI_BOOL</name></type> <name>CheckInputAmount</name><parameter_list>(
    <parameter><decl><type><name>int</name></type> <name>safe</name></decl></parameter>, <parameter><decl><type><name>BrotliBitReader</name><modifier>*</modifier> <specifier>const</specifier></type> <name>br</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>num</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>safe</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>BrotliCheckInputAmount</name><argument_list>(<argument><expr><name>br</name></expr></argument>, <argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_SAFE</name><parameter_list>(<parameter><type><name>METHOD</name></type></parameter>)</parameter_list></cpp:macro>                       \
  <cpp:value>{                                               \
    if (safe) {                                   \
      if (!Safe##METHOD) {                        \
        result = BROTLI_DECODER_NEEDS_MORE_INPUT; \
        goto saveStateAndReturn;                  \
      }                                           \
    } else {                                      \
      METHOD;                                     \
    }                                             \
  }</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>BROTLI_INLINE</name> <name>BrotliDecoderErrorCode</name></type> <name>ProcessCommandsInternal</name><parameter_list>(
    <parameter><decl><type><name>int</name></type> <name>safe</name></decl></parameter>, <parameter><decl><type><name>BrotliDecoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>pos</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>pos</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>loop_counter</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BrotliDecoderErrorCode</name></type> <name>result</name> <init>= <expr><name>BROTLI_DECODER_SUCCESS</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BrotliBitReader</name><modifier>*</modifier></type> <name>br</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>br</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>compound_dictionary_size</name> <init>= <expr><call><name>GetCompoundDictionarySize</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CheckInputAmount</name><argument_list>(<argument><expr><name>safe</name></expr></argument>, <argument><expr><name>br</name></expr></argument>, <argument><expr><literal type="number">28</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <name>BROTLI_DECODER_NEEDS_MORE_INPUT</name></expr>;</expr_stmt>
    <goto>goto <name>saveStateAndReturn</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>safe</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>BROTLI_UNUSED</name><argument_list>(<argument><expr><call><name>BrotliWarmupBitReader</name><argument_list>(<argument><expr><name>br</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Jump into state machine. */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>BROTLI_STATE_COMMAND_BEGIN</name></expr>)</condition> <block>{<block_content>
    <goto>goto <name>CommandBegin</name>;</goto>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>BROTLI_STATE_COMMAND_INNER</name></expr>)</condition> <block>{<block_content>
    <goto>goto <name>CommandInner</name>;</goto>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>BROTLI_STATE_COMMAND_POST_DECODE_LITERALS</name></expr>)</condition> <block>{<block_content>
    <goto>goto <name>CommandPostDecodeLiterals</name>;</goto>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>BROTLI_STATE_COMMAND_POST_WRAP_COPY</name></expr>)</condition> <block>{<block_content>
    <goto>goto <name>CommandPostWrapCopy</name>;</goto>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <return>return <expr><call><name>BROTLI_FAILURE</name><argument_list>(<argument><expr><name>BROTLI_DECODER_ERROR_UNREACHABLE</name></expr></argument>)</argument_list></call></expr>;</return>  <comment type="block">/* COV_NF_LINE */</comment>
  </block_content>}</block></else></if_stmt>

<label><name>CommandBegin</name>:</label>
  <if_stmt><if>if <condition>(<expr><name>safe</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>BROTLI_STATE_COMMAND_BEGIN</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CheckInputAmount</name><argument_list>(<argument><expr><name>safe</name></expr></argument>, <argument><expr><name>br</name></expr></argument>, <argument><expr><literal type="number">28</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* 156 bits + 7 bytes */</comment>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>BROTLI_STATE_COMMAND_BEGIN</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <name>BROTLI_DECODER_NEEDS_MORE_INPUT</name></expr>;</expr_stmt>
    <goto>goto <name>saveStateAndReturn</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>BROTLI_PREDICT_FALSE</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>block_length</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>BROTLI_SAFE</name><argument_list>(<argument><expr><call><name>DecodeCommandBlockSwitch</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>CommandBegin</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* Read the insert/copy length in the command. */</comment>
  <expr_stmt><expr><call><name>BROTLI_SAFE</name><argument_list>(<argument><expr><call><name>ReadCommand</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>br</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>BROTLI_LOG</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"[ProcessCommandsInternal] pos = %d insert = %d copy = %d\n"</literal><operator>,</operator>
              <name>pos</name><operator>,</operator> <name>i</name><operator>,</operator> <name><name>s</name><operator>-&gt;</operator><name>copy_length</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <goto>goto <name>CommandPostDecodeLiterals</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>meta_block_remaining_len</name></name> <operator>-=</operator> <name>i</name></expr>;</expr_stmt>

<label><name>CommandInner</name>:</label>
  <if_stmt><if>if <condition>(<expr><name>safe</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>BROTLI_STATE_COMMAND_INNER</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* Read the literals in the command. */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>trivial_literal_context</name></name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>bits</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>value</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>PreloadSymbol</name><argument_list>(<argument><expr><name>safe</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>literal_htree</name></name></expr></argument>, <argument><expr><name>br</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bits</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <do>do <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CheckInputAmount</name><argument_list>(<argument><expr><name>safe</name></expr></argument>, <argument><expr><name>br</name></expr></argument>, <argument><expr><literal type="number">28</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* 162 bits + 7 bytes */</comment>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>BROTLI_STATE_COMMAND_INNER</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <name>BROTLI_DECODER_NEEDS_MORE_INPUT</name></expr>;</expr_stmt>
        <goto>goto <name>saveStateAndReturn</name>;</goto>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>BROTLI_PREDICT_FALSE</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>block_length</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>BROTLI_SAFE</name><argument_list>(<argument><expr><call><name>DecodeLiteralBlockSwitch</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PreloadSymbol</name><argument_list>(<argument><expr><name>safe</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>literal_htree</name></name></expr></argument>, <argument><expr><name>br</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bits</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>trivial_literal_context</name></name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>CommandInner</name>;</goto></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>safe</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ringbuffer</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>=</operator>
            <operator>(</operator><name>uint8_t</name><operator>)</operator><call><name>ReadPreloadedSymbol</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>literal_htree</name></name></expr></argument>, <argument><expr><name>br</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bits</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <decl_stmt><decl><type><name>uint32_t</name></type> <name>literal</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SafeReadSymbol</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>literal_htree</name></name></expr></argument>, <argument><expr><name>br</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>literal</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>result</name> <operator>=</operator> <name>BROTLI_DECODER_NEEDS_MORE_INPUT</name></expr>;</expr_stmt>
          <goto>goto <name>saveStateAndReturn</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ringbuffer</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name>literal</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><operator>--</operator><name><name>s</name><operator>-&gt;</operator><name>block_length</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>BROTLI_LOG_ARRAY_INDEX</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>ringbuffer</name></name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>++</operator><name>pos</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>BROTLI_PREDICT_FALSE</name><argument_list>(<argument><expr><name>pos</name> <operator>==</operator> <name><name>s</name><operator>-&gt;</operator><name>ringbuffer_size</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>BROTLI_STATE_COMMAND_INNER_WRITE</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>--</operator><name>i</name></expr>;</expr_stmt>
        <goto>goto <name>saveStateAndReturn</name>;</goto>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block> while <condition>(<expr><operator>--</operator><name>i</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>;</do>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>uint8_t</name></type> <name>p1</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ringbuffer</name><index>[<expr><operator>(</operator><name>pos</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>ringbuffer_mask</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint8_t</name></type> <name>p2</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ringbuffer</name><index>[<expr><operator>(</operator><name>pos</name> <operator>-</operator> <literal type="number">2</literal><operator>)</operator> <operator>&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>ringbuffer_mask</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <do>do <block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>HuffmanCode</name><modifier>*</modifier></type> <name>hc</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>uint8_t</name></type> <name>context</name></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CheckInputAmount</name><argument_list>(<argument><expr><name>safe</name></expr></argument>, <argument><expr><name>br</name></expr></argument>, <argument><expr><literal type="number">28</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* 162 bits + 7 bytes */</comment>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>BROTLI_STATE_COMMAND_INNER</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <name>BROTLI_DECODER_NEEDS_MORE_INPUT</name></expr>;</expr_stmt>
        <goto>goto <name>saveStateAndReturn</name>;</goto>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>BROTLI_PREDICT_FALSE</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>block_length</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>BROTLI_SAFE</name><argument_list>(<argument><expr><call><name>DecodeLiteralBlockSwitch</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>trivial_literal_context</name></name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>CommandInner</name>;</goto></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>context</name> <operator>=</operator> <call><name>BROTLI_CONTEXT</name><argument_list>(<argument><expr><name>p1</name></expr></argument>, <argument><expr><name>p2</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>context_lookup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>BROTLI_LOG_UINT</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>hc</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>literal_hgroup</name><operator>.</operator><name>htrees</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>context_map_slice</name><index>[<expr><name>context</name></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>p2</name> <operator>=</operator> <name>p1</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>safe</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>p1</name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><call><name>ReadSymbol</name><argument_list>(<argument><expr><name>hc</name></expr></argument>, <argument><expr><name>br</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <decl_stmt><decl><type><name>uint32_t</name></type> <name>literal</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SafeReadSymbol</name><argument_list>(<argument><expr><name>hc</name></expr></argument>, <argument><expr><name>br</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>literal</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>result</name> <operator>=</operator> <name>BROTLI_DECODER_NEEDS_MORE_INPUT</name></expr>;</expr_stmt>
          <goto>goto <name>saveStateAndReturn</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>p1</name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name>literal</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ringbuffer</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>=</operator> <name>p1</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>--</operator><name><name>s</name><operator>-&gt;</operator><name>block_length</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>BROTLI_LOG_UINT</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>context_map_slice</name><index>[<expr><name>context</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>BROTLI_LOG_ARRAY_INDEX</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>ringbuffer</name></name></expr></argument>, <argument><expr><name>pos</name> <operator>&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>ringbuffer_mask</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>++</operator><name>pos</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>BROTLI_PREDICT_FALSE</name><argument_list>(<argument><expr><name>pos</name> <operator>==</operator> <name><name>s</name><operator>-&gt;</operator><name>ringbuffer_size</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>BROTLI_STATE_COMMAND_INNER_WRITE</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>--</operator><name>i</name></expr>;</expr_stmt>
        <goto>goto <name>saveStateAndReturn</name>;</goto>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block> while <condition>(<expr><operator>--</operator><name>i</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>;</do>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>BROTLI_LOG_UINT</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>meta_block_remaining_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>BROTLI_PREDICT_FALSE</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>meta_block_remaining_len</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>BROTLI_STATE_METABLOCK_DONE</name></expr>;</expr_stmt>
    <goto>goto <name>saveStateAndReturn</name>;</goto>
  </block_content>}</block></if></if_stmt>

<label><name>CommandPostDecodeLiterals</name>:</label>
  <if_stmt><if>if <condition>(<expr><name>safe</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>BROTLI_STATE_COMMAND_POST_DECODE_LITERALS</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>distance_code</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <comment type="block">/* Implicit distance case. */</comment>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>distance_context</name></name> <operator>=</operator> <ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>distance_code</name></name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><operator>--</operator><name><name>s</name><operator>-&gt;</operator><name>dist_rb_idx</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>distance_code</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>dist_rb</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>dist_rb_idx</name></name> <operator>&amp;</operator> <literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <comment type="block">/* Read distance code in the command, unless it was implicitly zero. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>BROTLI_PREDICT_FALSE</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>block_length</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>BROTLI_SAFE</name><argument_list>(<argument><expr><call><name>DecodeDistanceBlockSwitch</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>BROTLI_SAFE</name><argument_list>(<argument><expr><call><name>ReadDistance</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>br</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>BROTLI_LOG</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"[ProcessCommandsInternal] pos = %d distance = %d\n"</literal><operator>,</operator>
              <name>pos</name><operator>,</operator> <name><name>s</name><operator>-&gt;</operator><name>distance_code</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>max_distance</name></name> <operator>!=</operator> <name><name>s</name><operator>-&gt;</operator><name>max_backward_distance</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>max_distance</name></name> <operator>=</operator>
        <ternary><condition><expr><operator>(</operator><name>pos</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>max_backward_distance</name></name><operator>)</operator></expr> ?</condition><then> <expr><name>pos</name></expr> </then><else>: <expr><name><name>s</name><operator>-&gt;</operator><name>max_backward_distance</name></name></expr></else></ternary></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>copy_length</name></name></expr>;</expr_stmt>
  <comment type="block">/* Apply copy of LZ77 back-reference, or static dictionary reference if
     the distance is larger than the max LZ77 distance */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>distance_code</name></name> <operator>&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>max_distance</name></name></expr>)</condition> <block>{<block_content>
    <comment type="block">/* The maximum allowed distance is BROTLI_MAX_ALLOWED_DISTANCE = 0x7FFFFFFC.
       With this choice, no signed overflow can occur after decoding
       a special distance code (e.g., after adding 3 to the last distance). */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>distance_code</name></name> <operator>&gt;</operator> <name>BROTLI_MAX_ALLOWED_DISTANCE</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>BROTLI_LOG</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"Invalid backward reference. pos: %d distance: %d "</literal>
          <literal type="string">"len: %d bytes left: %d\n"</literal><operator>,</operator>
          <name>pos</name><operator>,</operator> <name><name>s</name><operator>-&gt;</operator><name>distance_code</name></name><operator>,</operator> <name>i</name><operator>,</operator> <name><name>s</name><operator>-&gt;</operator><name>meta_block_remaining_len</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><call><name>BROTLI_FAILURE</name><argument_list>(<argument><expr><name>BROTLI_DECODER_ERROR_FORMAT_DISTANCE</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>distance_code</name></name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>max_distance</name></name> <operator>-</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>compound_dictionary_size</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>address</name> <init>= <expr><name>compound_dictionary_size</name> <operator>-</operator>
          <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>distance_code</name></name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>max_distance</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>InitializeCompoundDictionaryCopy</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>address</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name>BROTLI_FAILURE</name><argument_list>(<argument><expr><name>BROTLI_DECODER_ERROR_COMPOUND_DICTIONARY</name></expr></argument>)</argument_list></call></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>pos</name> <operator>+=</operator> <call><name>CopyFromCompoundDictionary</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&gt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>ringbuffer_size</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>BROTLI_STATE_COMMAND_POST_WRITE_1</name></expr>;</expr_stmt>
        <goto>goto <name>saveStateAndReturn</name>;</goto>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name>SHARED_BROTLI_MIN_DICTIONARY_WORD_LENGTH</name> <operator>&amp;&amp;</operator>
               <name>i</name> <operator>&lt;=</operator> <name>SHARED_BROTLI_MAX_DICTIONARY_WORD_LENGTH</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>uint8_t</name></type> <name>p1</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ringbuffer</name><index>[<expr><operator>(</operator><name>pos</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>ringbuffer_mask</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>uint8_t</name></type> <name>p2</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ringbuffer</name><index>[<expr><operator>(</operator><name>pos</name> <operator>-</operator> <literal type="number">2</literal><operator>)</operator> <operator>&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>ringbuffer_mask</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>uint8_t</name></type> <name>dict_id</name> <init>= <expr><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>dictionary</name><operator>-&gt;</operator><name>context_based</name></name></expr> ?</condition><then>
          <expr><name><name>s</name><operator>-&gt;</operator><name>dictionary</name><operator>-&gt;</operator><name>context_map</name><index>[<expr><call><name>BROTLI_CONTEXT</name><argument_list>(<argument><expr><name>p1</name></expr></argument>, <argument><expr><name>p2</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>context_lookup</name></name></expr></argument>)</argument_list></call></expr>]</index></name></expr>
          </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>BrotliDictionary</name><modifier>*</modifier></type> <name>words</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>dictionary</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>dict_id</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>BrotliTransforms</name><modifier>*</modifier></type> <name>transforms</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>dictionary</name><operator>-&gt;</operator><name>transforms</name><index>[<expr><name>dict_id</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><name><name>words</name><operator>-&gt;</operator><name>offsets_by_length</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>shift</name> <init>= <expr><name><name>words</name><operator>-&gt;</operator><name>size_bits_by_length</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>address</name> <init>=
          <expr><name><name>s</name><operator>-&gt;</operator><name>distance_code</name></name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>max_distance</name></name> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <name>compound_dictionary_size</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>mask</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>BitMask</name><argument_list>(<argument><expr><name>shift</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>word_idx</name> <init>= <expr><name>address</name> <operator>&amp;</operator> <name>mask</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>transform_idx</name> <init>= <expr><name>address</name> <operator>&gt;&gt;</operator> <name>shift</name></expr></init></decl>;</decl_stmt>
      <comment type="block">/* Compensate double distance-ring-buffer roll. */</comment>
      <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>dist_rb_idx</name></name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>distance_context</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>offset</name> <operator>+=</operator> <name>word_idx</name> <operator>*</operator> <name>i</name></expr>;</expr_stmt>
      <comment type="block">/* If the distance is out of bound, select a next static dictionary if
         there exist multiple. */</comment>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>transform_idx</name> <operator>&gt;=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>transforms</name><operator>-&gt;</operator><name>num_transforms</name></name> <operator>||</operator>
          <name><name>words</name><operator>-&gt;</operator><name>size_bits_by_length</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator>
          <name><name>s</name><operator>-&gt;</operator><name>dictionary</name><operator>-&gt;</operator><name>num_dictionaries</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>uint8_t</name></type> <name>dict_id2</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>dist_remaining</name> <init>= <expr><name>address</name> <operator>-</operator>
            <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <name>shift</name><operator>)</operator> <operator>&amp;</operator> <operator>~</operator><literal type="number">1u</literal><operator>)</operator><operator>)</operator> <operator>*</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>transforms</name><operator>-&gt;</operator><name>num_transforms</name></name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><expr><name>dict_id2</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>dict_id2</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>dictionary</name><operator>-&gt;</operator><name>num_dictionaries</name></name></expr>;</condition>
            <incr><expr><name>dict_id2</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
          <decl_stmt><decl><type><specifier>const</specifier> <name>BrotliDictionary</name><modifier>*</modifier></type> <name>words2</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>dictionary</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>dict_id2</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if <condition>(<expr><name>dict_id2</name> <operator>!=</operator> <name>dict_id</name> <operator>&amp;&amp;</operator> <name><name>words2</name><operator>-&gt;</operator><name>size_bits_by_length</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>BrotliTransforms</name><modifier>*</modifier></type> <name>transforms2</name> <init>=
                <expr><name><name>s</name><operator>-&gt;</operator><name>dictionary</name><operator>-&gt;</operator><name>transforms</name><index>[<expr><name>dict_id2</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>uint32_t</name></type> <name>shift2</name> <init>= <expr><name><name>words2</name><operator>-&gt;</operator><name>size_bits_by_length</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>num</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <name>shift2</name><operator>)</operator> <operator>&amp;</operator> <operator>~</operator><literal type="number">1u</literal><operator>)</operator> <operator>*</operator>
                <operator>(</operator><name>int</name><operator>)</operator><name><name>transforms2</name><operator>-&gt;</operator><name>num_transforms</name></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>dist_remaining</name> <operator>&lt;</operator> <name>num</name></expr>)</condition> <block>{<block_content>
              <expr_stmt><expr><name>dict_id</name> <operator>=</operator> <name>dict_id2</name></expr>;</expr_stmt>
              <expr_stmt><expr><name>words</name> <operator>=</operator> <name>words2</name></expr>;</expr_stmt>
              <expr_stmt><expr><name>transforms</name> <operator>=</operator> <name>transforms2</name></expr>;</expr_stmt>
              <expr_stmt><expr><name>address</name> <operator>=</operator> <name>dist_remaining</name></expr>;</expr_stmt>
              <expr_stmt><expr><name>shift</name> <operator>=</operator> <name>shift2</name></expr>;</expr_stmt>
              <expr_stmt><expr><name>mask</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>BitMask</name><argument_list>(<argument><expr><name>shift</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>word_idx</name> <operator>=</operator> <name>address</name> <operator>&amp;</operator> <name>mask</name></expr>;</expr_stmt>
              <expr_stmt><expr><name>transform_idx</name> <operator>=</operator> <name>address</name> <operator>&gt;&gt;</operator> <name>shift</name></expr>;</expr_stmt>
              <expr_stmt><expr><name>offset</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>words</name><operator>-&gt;</operator><name>offsets_by_length</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <name>word_idx</name> <operator>*</operator> <name>i</name></expr>;</expr_stmt>
              <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>dist_remaining</name> <operator>-=</operator> <name>num</name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>BROTLI_PREDICT_FALSE</name><argument_list>(<argument><expr><name><name>words</name><operator>-&gt;</operator><name>size_bits_by_length</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>BROTLI_LOG</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"Invalid backward reference. pos: %d distance: %d "</literal>
            <literal type="string">"len: %d bytes left: %d\n"</literal><operator>,</operator>
            <name>pos</name><operator>,</operator> <name><name>s</name><operator>-&gt;</operator><name>distance_code</name></name><operator>,</operator> <name>i</name><operator>,</operator> <name><name>s</name><operator>-&gt;</operator><name>meta_block_remaining_len</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>BROTLI_FAILURE</name><argument_list>(<argument><expr><name>BROTLI_DECODER_ERROR_FORMAT_DICTIONARY</name></expr></argument>)</argument_list></call></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>BROTLI_PREDICT_FALSE</name><argument_list>(<argument><expr><operator>!</operator><name><name>words</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name>BROTLI_FAILURE</name><argument_list>(<argument><expr><name>BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET</name></expr></argument>)</argument_list></call></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>transform_idx</name> <operator>&lt;</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>transforms</name><operator>-&gt;</operator><name>num_transforms</name></name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name><modifier>*</modifier></type> <name>word</name> <init>= <expr><operator>&amp;</operator><name><name>words</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>offset</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><name>i</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>transform_idx</name> <operator>==</operator> <name><name>transforms</name><operator>-&gt;</operator><name>cutOffTransforms</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>ringbuffer</name><index>[<expr><name>pos</name></expr>]</index></name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>BROTLI_LOG</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"[ProcessCommandsInternal] dictionary word: [%.*s]\n"</literal><operator>,</operator>
                      <name>len</name><operator>,</operator> <name>word</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
          <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>BrotliTransformDictionaryWord</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>ringbuffer</name><index>[<expr><name>pos</name></expr>]</index></name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>len</name></expr></argument>,
              <argument><expr><name>transforms</name></expr></argument>, <argument><expr><name>transform_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>BROTLI_LOG</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"[ProcessCommandsInternal] dictionary word: [%.*s],"</literal>
                      <literal type="string">" transform_idx = %d, transformed: [%.*s]\n"</literal><operator>,</operator>
                      <name>i</name><operator>,</operator> <name>word</name><operator>,</operator> <name>transform_idx</name><operator>,</operator> <name>len</name><operator>,</operator> <operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>ringbuffer</name><index>[<expr><name>pos</name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>distance_code</name></name> <operator>&lt;=</operator> <literal type="number">120</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>BROTLI_LOG</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"Invalid length-0 dictionary word after transform\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><call><name>BROTLI_FAILURE</name><argument_list>(<argument><expr><name>BROTLI_DECODER_ERROR_FORMAT_TRANSFORM</name></expr></argument>)</argument_list></call></expr>;</return>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>pos</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>meta_block_remaining_len</name></name> <operator>-=</operator> <name>len</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&gt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>ringbuffer_size</name></name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>BROTLI_STATE_COMMAND_POST_WRITE_1</name></expr>;</expr_stmt>
          <goto>goto <name>saveStateAndReturn</name>;</goto>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>BROTLI_LOG</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"Invalid backward reference. pos: %d distance: %d "</literal>
            <literal type="string">"len: %d bytes left: %d\n"</literal><operator>,</operator>
            <name>pos</name><operator>,</operator> <name><name>s</name><operator>-&gt;</operator><name>distance_code</name></name><operator>,</operator> <name>i</name><operator>,</operator> <name><name>s</name><operator>-&gt;</operator><name>meta_block_remaining_len</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>BROTLI_FAILURE</name><argument_list>(<argument><expr><name>BROTLI_DECODER_ERROR_FORMAT_TRANSFORM</name></expr></argument>)</argument_list></call></expr>;</return>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><call><name>BROTLI_LOG</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"Invalid backward reference. pos: %d distance: %d "</literal>
          <literal type="string">"len: %d bytes left: %d\n"</literal><operator>,</operator>
          <name>pos</name><operator>,</operator> <name><name>s</name><operator>-&gt;</operator><name>distance_code</name></name><operator>,</operator> <name>i</name><operator>,</operator> <name><name>s</name><operator>-&gt;</operator><name>meta_block_remaining_len</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><call><name>BROTLI_FAILURE</name><argument_list>(<argument><expr><name>BROTLI_DECODER_ERROR_FORMAT_DICTIONARY</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>src_start</name> <init>= <expr><operator>(</operator><name>pos</name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>distance_code</name></name><operator>)</operator> <operator>&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>ringbuffer_mask</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint8_t</name><modifier>*</modifier></type> <name>copy_dst</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>ringbuffer</name><index>[<expr><name>pos</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint8_t</name><modifier>*</modifier></type> <name>copy_src</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>ringbuffer</name><index>[<expr><name>src_start</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>dst_end</name> <init>= <expr><name>pos</name> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>src_end</name> <init>= <expr><name>src_start</name> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>
    <comment type="block">/* Update the recent distances cache. */</comment>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>dist_rb</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>dist_rb_idx</name></name> <operator>&amp;</operator> <literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>distance_code</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>++</operator><name><name>s</name><operator>-&gt;</operator><name>dist_rb_idx</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>meta_block_remaining_len</name></name> <operator>-=</operator> <name>i</name></expr>;</expr_stmt>
    <comment type="block">/* There are 32+ bytes of slack in the ring-buffer allocation.
       Also, we have 16 short codes, that make these 16 bytes irrelevant
       in the ring-buffer. Let's copy over them as a first guess. */</comment>
    <expr_stmt><expr><call><name>memmove16</name><argument_list>(<argument><expr><name>copy_dst</name></expr></argument>, <argument><expr><name>copy_src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>src_end</name> <operator>&gt;</operator> <name>pos</name> <operator>&amp;&amp;</operator> <name>dst_end</name> <operator>&gt;</operator> <name>src_start</name></expr>)</condition> <block>{<block_content>
      <comment type="block">/* Regions intersect. */</comment>
      <goto>goto <name>CommandPostWrapCopy</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>dst_end</name> <operator>&gt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>ringbuffer_size</name></name> <operator>||</operator> <name>src_end</name> <operator>&gt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>ringbuffer_size</name></name></expr>)</condition> <block>{<block_content>
      <comment type="block">/* At least one region wraps. */</comment>
      <goto>goto <name>CommandPostWrapCopy</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>pos</name> <operator>+=</operator> <name>i</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">16</literal></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">32</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>copy_dst</name> <operator>+</operator> <literal type="number">16</literal></expr></argument>, <argument><expr><name>copy_src</name> <operator>+</operator> <literal type="number">16</literal></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>i</name> <operator>-</operator> <literal type="number">16</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="block">/* This branch covers about 45% cases.
           Fixed size short copy allows more compiler optimizations. */</comment>
        <expr_stmt><expr><call><name>memmove16</name><argument_list>(<argument><expr><name>copy_dst</name> <operator>+</operator> <literal type="number">16</literal></expr></argument>, <argument><expr><name>copy_src</name> <operator>+</operator> <literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>BROTLI_LOG_UINT</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>meta_block_remaining_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>meta_block_remaining_len</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <comment type="block">/* Next metablock, if any. */</comment>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>BROTLI_STATE_METABLOCK_DONE</name></expr>;</expr_stmt>
    <goto>goto <name>saveStateAndReturn</name>;</goto>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <goto>goto <name>CommandBegin</name>;</goto>
  </block_content>}</block></else></if_stmt>
<label><name>CommandPostWrapCopy</name>:</label>
  <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>wrap_guard</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ringbuffer_size</name></name> <operator>-</operator> <name>pos</name></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><operator>--</operator><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ringbuffer</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>=</operator>
          <name><name>s</name><operator>-&gt;</operator><name>ringbuffer</name><index>[<expr><operator>(</operator><name>pos</name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>distance_code</name></name><operator>)</operator> <operator>&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>ringbuffer_mask</name></name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>++</operator><name>pos</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>BROTLI_PREDICT_FALSE</name><argument_list>(<argument><expr><operator>--</operator><name>wrap_guard</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>BROTLI_STATE_COMMAND_POST_WRITE_2</name></expr>;</expr_stmt>
        <goto>goto <name>saveStateAndReturn</name>;</goto>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
  </block_content>}</block>
  <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>meta_block_remaining_len</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <comment type="block">/* Next metablock, if any. */</comment>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>BROTLI_STATE_METABLOCK_DONE</name></expr>;</expr_stmt>
    <goto>goto <name>saveStateAndReturn</name>;</goto>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <goto>goto <name>CommandBegin</name>;</goto>
  </block_content>}</block></else></if_stmt>

<label><name>saveStateAndReturn</name>:</label>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <name>pos</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>loop_counter</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
  <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BROTLI_SAFE</name></cpp:undef>

<function><type><specifier>static</specifier> <name>BROTLI_NOINLINE</name> <name>BrotliDecoderErrorCode</name></type> <name>ProcessCommands</name><parameter_list>(
    <parameter><decl><type><name>BrotliDecoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>ProcessCommandsInternal</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BROTLI_NOINLINE</name> <name>BrotliDecoderErrorCode</name></type> <name>SafeProcessCommands</name><parameter_list>(
    <parameter><decl><type><name>BrotliDecoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>ProcessCommandsInternal</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>BrotliDecoderResult</name></type> <name>BrotliDecoderDecompress</name><parameter_list>(
    <parameter><decl><type><name>size_t</name></type> <name>encoded_size</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name></type> <name><name>encoded_buffer</name><index>[<expr><call><name>BROTLI_ARRAY_PARAM</name><argument_list>(<argument><expr><name>encoded_size</name></expr></argument>)</argument_list></call></expr>]</index></name></decl></parameter>,
    <parameter><decl><type><name>size_t</name><modifier>*</modifier></type> <name>decoded_size</name></decl></parameter>,
    <parameter><decl><type><name>uint8_t</name></type> <name><name>decoded_buffer</name><index>[<expr><call><name>BROTLI_ARRAY_PARAM</name><argument_list>(<argument><expr><operator>*</operator><name>decoded_size</name></expr></argument>)</argument_list></call></expr>]</index></name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>BrotliDecoderState</name></type> <name>s</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BrotliDecoderResult</name></type> <name>result</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>total_out</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>available_in</name> <init>= <expr><name>encoded_size</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name><modifier>*</modifier></type> <name>next_in</name> <init>= <expr><name>encoded_buffer</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>available_out</name> <init>= <expr><operator>*</operator><name>decoded_size</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name><modifier>*</modifier></type> <name>next_out</name> <init>= <expr><name>decoded_buffer</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BrotliDecoderStateInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>BROTLI_DECODER_RESULT_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>BrotliDecoderDecompressStream</name><argument_list>(
      <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>available_in</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next_in</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>available_out</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next_out</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>total_out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>decoded_size</name> <operator>=</operator> <name>total_out</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>BrotliDecoderStateCleanup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>BROTLI_DECODER_RESULT_SUCCESS</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <name>BROTLI_DECODER_RESULT_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Invariant: input stream is never overconsumed:
    - invalid input implies that the whole stream is invalid -&gt; any amount of
      input could be read and discarded
    - when result is "needs more input", then at least one more byte is REQUIRED
      to complete decoding; all input data MUST be consumed by decoder, so
      client could swap the input buffer
    - when result is "needs more output" decoder MUST ensure that it doesn't
      hold more than 7 bits in bit reader; this saves client from swapping input
      buffer ahead of time
    - when result is "success" decoder MUST return all unused data back to input
      buffer; this is possible because the invariant is held on enter */</comment>
<function><type><name>BrotliDecoderResult</name></type> <name>BrotliDecoderDecompressStream</name><parameter_list>(
    <parameter><decl><type><name>BrotliDecoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>size_t</name><modifier>*</modifier></type> <name>available_in</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name><modifier>*</modifier><modifier>*</modifier></type> <name>next_in</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name><modifier>*</modifier></type> <name>available_out</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name><modifier>*</modifier><modifier>*</modifier></type> <name>next_out</name></decl></parameter>, <parameter><decl><type><name>size_t</name><modifier>*</modifier></type> <name>total_out</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>BrotliDecoderErrorCode</name></type> <name>result</name> <init>= <expr><name>BROTLI_DECODER_SUCCESS</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BrotliBitReader</name><modifier>*</modifier></type> <name>br</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>br</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>input_size</name> <init>= <expr><operator>*</operator><name>available_in</name></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_SAVE_ERROR_CODE</name><parameter_list>(<parameter><type><name>code</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>SaveErrorCode(s, (code), input_size - *available_in)</cpp:value></cpp:define>
  <comment type="block">/* Ensure that |total_out| is set, even if no data will ever be pushed out. */</comment>
  <if_stmt><if>if <condition>(<expr><name>total_out</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>total_out</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>partial_pos_out</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* Do not try to process further in a case of unrecoverable error. */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>error_code</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>BROTLI_DECODER_RESULT_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>available_out</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>next_out</name> <operator>||</operator> <operator>!</operator><operator>*</operator><name>next_out</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <return>return <expr><call><name>BROTLI_SAVE_ERROR_CODE</name><argument_list>(
        <argument><expr><call><name>BROTLI_FAILURE</name><argument_list>(<argument><expr><name>BROTLI_DECODER_ERROR_INVALID_ARGUMENTS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>available_out</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>next_out</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>buffer_length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* Just connect bit reader to input stream. */</comment>
    <expr_stmt><expr><name><name>br</name><operator>-&gt;</operator><name>avail_in</name></name> <operator>=</operator> <operator>*</operator><name>available_in</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>br</name><operator>-&gt;</operator><name>next_in</name></name> <operator>=</operator> <operator>*</operator><name>next_in</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <comment type="block">/* At least one byte of input is required. More than one byte of input may
       be required to complete the transaction -&gt; reading more data must be
       done in a loop -&gt; do it in a main loop. */</comment>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <name>BROTLI_DECODER_NEEDS_MORE_INPUT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>br</name><operator>-&gt;</operator><name>next_in</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>buffer</name><operator>.</operator><name>u8</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <comment type="block">/* State machine */</comment>
  <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>BROTLI_DECODER_SUCCESS</name></expr>)</condition> <block>{<block_content>
      <comment type="block">/* Error, needs more input/output. */</comment>
      <if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>BROTLI_DECODER_NEEDS_MORE_INPUT</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ringbuffer</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* Pro-actively push output. */</comment>
          <decl_stmt><decl><type><name>BrotliDecoderErrorCode</name></type> <name>intermediate_result</name> <init>= <expr><call><name>WriteRingBuffer</name><argument_list>(<argument><expr><name>s</name></expr></argument>,
              <argument><expr><name>available_out</name></expr></argument>, <argument><expr><name>next_out</name></expr></argument>, <argument><expr><name>total_out</name></expr></argument>, <argument><expr><name>BROTLI_TRUE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <comment type="block">/* WriteRingBuffer checks s-&gt;meta_block_remaining_len validity. */</comment>
          <if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator><name>intermediate_result</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>intermediate_result</name></expr>;</expr_stmt>
            <break>break;</break>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>buffer_length</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* Used with internal buffer. */</comment>
          <if_stmt><if>if <condition>(<expr><name><name>br</name><operator>-&gt;</operator><name>avail_in</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Successfully finished read transaction.
               Accumulator contains less than 8 bits, because internal buffer
               is expanded byte-by-byte until it is enough to complete read. */</comment>
            <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>buffer_length</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <comment type="block">/* Switch to input stream and restart. */</comment>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>BROTLI_DECODER_SUCCESS</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>br</name><operator>-&gt;</operator><name>avail_in</name></name> <operator>=</operator> <operator>*</operator><name>available_in</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>br</name><operator>-&gt;</operator><name>next_in</name></name> <operator>=</operator> <operator>*</operator><name>next_in</name></expr>;</expr_stmt>
            <continue>continue;</continue>
          </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>*</operator><name>available_in</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Not enough data in buffer, but can take one more byte from
               input stream. */</comment>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>BROTLI_DECODER_SUCCESS</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>buffer</name><operator>.</operator><name>u8</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>buffer_length</name></name></expr>]</index></name> <operator>=</operator> <operator>*</operator><operator>*</operator><name>next_in</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>buffer_length</name></name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>br</name><operator>-&gt;</operator><name>avail_in</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>buffer_length</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><operator>(</operator><operator>*</operator><name>next_in</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><operator>(</operator><operator>*</operator><name>available_in</name><operator>)</operator><operator>--</operator></expr>;</expr_stmt>
            <comment type="block">/* Retry with more data in buffer. */</comment>
            <continue>continue;</continue>
          </block_content>}</block></if></if_stmt>
          <comment type="block">/* Can't finish reading and no more input. */</comment>
          <break>break;</break>
        </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* Input stream doesn't contain enough input. */</comment>
          <comment type="block">/* Copy tail to internal buffer and return. */</comment>
          <expr_stmt><expr><operator>*</operator><name>next_in</name> <operator>=</operator> <name><name>br</name><operator>-&gt;</operator><name>next_in</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><operator>*</operator><name>available_in</name> <operator>=</operator> <name><name>br</name><operator>-&gt;</operator><name>avail_in</name></name></expr>;</expr_stmt>
          <while>while <condition>(<expr><operator>*</operator><name>available_in</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>buffer</name><operator>.</operator><name>u8</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>buffer_length</name></name></expr>]</index></name> <operator>=</operator> <operator>*</operator><operator>*</operator><name>next_in</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>buffer_length</name></name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><operator>(</operator><operator>*</operator><name>next_in</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><operator>(</operator><operator>*</operator><name>available_in</name><operator>)</operator><operator>--</operator></expr>;</expr_stmt>
          </block_content>}</block></while>
          <break>break;</break>
        </block_content>}</block></else></if_stmt>
        <comment type="block">/* Unreachable. */</comment>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* Fail or needs more output. */</comment>

      <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>buffer_length</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Just consumed the buffered input and produced some output. Otherwise
           it would result in "needs more input". Reset internal buffer. */</comment>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>buffer_length</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="block">/* Using input stream in last iteration. When decoder switches to input
           stream it has less than 8 bits in accumulator, so it is safe to
           return unused accumulator bits there. */</comment>
        <expr_stmt><expr><call><name>BrotliBitReaderUnload</name><argument_list>(<argument><expr><name>br</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>available_in</name> <operator>=</operator> <name><name>br</name><operator>-&gt;</operator><name>avail_in</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>next_in</name> <operator>=</operator> <name><name>br</name><operator>-&gt;</operator><name>next_in</name></name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
    <switch>switch <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name></expr>)</condition> <block>{<block_content>
      <case>case <expr><name>BROTLI_STATE_UNINITED</name></expr>:</case>
        <comment type="block">/* Prepare to the first read. */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BrotliWarmupBitReader</name><argument_list>(<argument><expr><name>br</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>result</name> <operator>=</operator> <name>BROTLI_DECODER_NEEDS_MORE_INPUT</name></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* Decode window size. */</comment>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DecodeWindowBits</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>br</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Reads 1..8 bits. */</comment>
        <if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>BROTLI_DECODER_SUCCESS</name></expr>)</condition> <block>{<block_content>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>large_window</name></name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>BROTLI_STATE_LARGE_WINDOW_BITS</name></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>BROTLI_STATE_INITIALIZE</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>BROTLI_STATE_LARGE_WINDOW_BITS</name></expr>:</case>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BrotliSafeReadBits</name><argument_list>(<argument><expr><name>br</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>window_bits</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>result</name> <operator>=</operator> <name>BROTLI_DECODER_NEEDS_MORE_INPUT</name></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>window_bits</name></name> <operator>&lt;</operator> <name>BROTLI_LARGE_MIN_WBITS</name> <operator>||</operator>
            <name><name>s</name><operator>-&gt;</operator><name>window_bits</name></name> <operator>&gt;</operator> <name>BROTLI_LARGE_MAX_WBITS</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>BROTLI_FAILURE</name><argument_list>(<argument><expr><name>BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>BROTLI_STATE_INITIALIZE</name></expr>;</expr_stmt>
      <comment type="block">/* Fall through. */</comment>

      <case>case <expr><name>BROTLI_STATE_INITIALIZE</name></expr>:</case>
        <expr_stmt><expr><call><name>BROTLI_LOG_UINT</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>window_bits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Maximum distance, see section 9.1. of the spec. */</comment>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>max_backward_distance</name></name> <operator>=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>window_bits</name></name><operator>)</operator> <operator>-</operator> <name>BROTLI_WINDOW_GAP</name></expr>;</expr_stmt>

        <comment type="block">/* Allocate memory for both block_type_trees and block_len_trees. */</comment>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>block_type_trees</name></name> <operator>=</operator> <operator>(</operator><name>HuffmanCode</name><operator>*</operator><operator>)</operator><call><name>BROTLI_DECODER_ALLOC</name><argument_list>(<argument><expr><name>s</name></expr></argument>,
            <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HuffmanCode</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">3</literal> <operator>*</operator>
                <operator>(</operator><name>BROTLI_HUFFMAN_MAX_SIZE_258</name> <operator>+</operator> <name>BROTLI_HUFFMAN_MAX_SIZE_26</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>block_type_trees</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>BROTLI_FAILURE</name><argument_list>(<argument><expr><name>BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>block_len_trees</name></name> <operator>=</operator>
            <name><name>s</name><operator>-&gt;</operator><name>block_type_trees</name></name> <operator>+</operator> <literal type="number">3</literal> <operator>*</operator> <name>BROTLI_HUFFMAN_MAX_SIZE_258</name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>BROTLI_STATE_METABLOCK_BEGIN</name></expr>;</expr_stmt>
      <comment type="block">/* Fall through. */</comment>

      <case>case <expr><name>BROTLI_STATE_METABLOCK_BEGIN</name></expr>:</case>
        <expr_stmt><expr><call><name>BrotliDecoderStateMetablockBegin</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BROTLI_LOG_UINT</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>pos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>BROTLI_STATE_METABLOCK_HEADER</name></expr>;</expr_stmt>
      <comment type="block">/* Fall through. */</comment>

      <case>case <expr><name>BROTLI_STATE_METABLOCK_HEADER</name></expr>:</case>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DecodeMetaBlockLength</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>br</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Reads 2 - 31 bits. */</comment>
        <if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>BROTLI_DECODER_SUCCESS</name></expr>)</condition> <block>{<block_content>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>BROTLI_LOG_UINT</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>is_last_metablock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BROTLI_LOG_UINT</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>meta_block_remaining_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BROTLI_LOG_UINT</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>is_metadata</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BROTLI_LOG_UINT</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>is_uncompressed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>is_metadata</name></name> <operator>||</operator> <name><name>s</name><operator>-&gt;</operator><name>is_uncompressed</name></name></expr>)</condition> <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BrotliJumpToByteBoundary</name><argument_list>(<argument><expr><name>br</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>BROTLI_FAILURE</name><argument_list>(<argument><expr><name>BROTLI_DECODER_ERROR_FORMAT_PADDING_1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>is_metadata</name></name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>BROTLI_STATE_METADATA</name></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>meta_block_remaining_len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>BROTLI_STATE_METABLOCK_DONE</name></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>BrotliCalculateRingBufferSize</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>is_uncompressed</name></name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>BROTLI_STATE_UNCOMPRESSED</name></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>BROTLI_STATE_BEFORE_COMPRESSED_METABLOCK_HEADER</name></expr>;</expr_stmt>
      <comment type="block">/* Fall through. */</comment>

      <case>case <expr><name>BROTLI_STATE_BEFORE_COMPRESSED_METABLOCK_HEADER</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>BrotliMetablockHeaderArena</name><modifier>*</modifier></type> <name>h</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>arena</name><operator>.</operator><name>header</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>loop_counter</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <comment type="block">/* Initialize compressed metablock header arena. */</comment>
        <expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>sub_loop_counter</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <comment type="block">/* Make small negative indexes addressable. */</comment>
        <expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>symbol_lists</name></name> <operator>=</operator>
            <operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>symbols_lists_array</name><index>[<expr><name>BROTLI_HUFFMAN_MAX_CODE_LENGTH</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>substate_huffman</name></name> <operator>=</operator> <name>BROTLI_STATE_HUFFMAN_NONE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>substate_tree_group</name></name> <operator>=</operator> <name>BROTLI_STATE_TREE_GROUP_NONE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>substate_context_map</name></name> <operator>=</operator> <name>BROTLI_STATE_CONTEXT_MAP_NONE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>BROTLI_STATE_HUFFMAN_CODE_0</name></expr>;</expr_stmt>
      </block_content>}</block>
      <comment type="block">/* Fall through. */</comment>

      <case>case <expr><name>BROTLI_STATE_HUFFMAN_CODE_0</name></expr>:</case>
        <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>loop_counter</name></name> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>BROTLI_STATE_METABLOCK_HEADER_2</name></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* Reads 1..11 bits. */</comment>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DecodeVarLenUint8</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>br</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>num_block_types</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>loop_counter</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>BROTLI_DECODER_SUCCESS</name></expr>)</condition> <block>{<block_content>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>num_block_types</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>loop_counter</name></name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BROTLI_LOG_UINT</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>num_block_types</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>loop_counter</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>num_block_types</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>loop_counter</name></name></expr>]</index></name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>loop_counter</name></name><operator>++</operator></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>BROTLI_STATE_HUFFMAN_CODE_1</name></expr>;</expr_stmt>
      <comment type="block">/* Fall through. */</comment>

      <case>case <expr><name>BROTLI_STATE_HUFFMAN_CODE_1</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>uint32_t</name></type> <name>alphabet_size</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>num_block_types</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>loop_counter</name></name></expr>]</index></name> <operator>+</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>tree_offset</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>loop_counter</name></name> <operator>*</operator> <name>BROTLI_HUFFMAN_MAX_SIZE_258</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ReadHuffmanCode</name><argument_list>(<argument><expr><name>alphabet_size</name></expr></argument>, <argument><expr><name>alphabet_size</name></expr></argument>,
            <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>block_type_trees</name><index>[<expr><name>tree_offset</name></expr>]</index></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>BROTLI_DECODER_SUCCESS</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>BROTLI_STATE_HUFFMAN_CODE_2</name></expr>;</expr_stmt>
      </block_content>}</block>
      <comment type="block">/* Fall through. */</comment>

      <case>case <expr><name>BROTLI_STATE_HUFFMAN_CODE_2</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>uint32_t</name></type> <name>alphabet_size</name> <init>= <expr><name>BROTLI_NUM_BLOCK_LEN_SYMBOLS</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>tree_offset</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>loop_counter</name></name> <operator>*</operator> <name>BROTLI_HUFFMAN_MAX_SIZE_26</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ReadHuffmanCode</name><argument_list>(<argument><expr><name>alphabet_size</name></expr></argument>, <argument><expr><name>alphabet_size</name></expr></argument>,
            <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>block_len_trees</name><index>[<expr><name>tree_offset</name></expr>]</index></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>BROTLI_DECODER_SUCCESS</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>BROTLI_STATE_HUFFMAN_CODE_3</name></expr>;</expr_stmt>
      </block_content>}</block>
      <comment type="block">/* Fall through. */</comment>

      <case>case <expr><name>BROTLI_STATE_HUFFMAN_CODE_3</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>tree_offset</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>loop_counter</name></name> <operator>*</operator> <name>BROTLI_HUFFMAN_MAX_SIZE_26</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SafeReadBlockLength</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>block_length</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>loop_counter</name></name></expr>]</index></name></expr></argument>,
            <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>block_len_trees</name><index>[<expr><name>tree_offset</name></expr>]</index></name></expr></argument>, <argument><expr><name>br</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>result</name> <operator>=</operator> <name>BROTLI_DECODER_NEEDS_MORE_INPUT</name></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>BROTLI_LOG_UINT</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>block_length</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>loop_counter</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>loop_counter</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>BROTLI_STATE_HUFFMAN_CODE_0</name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>

      <case>case <expr><name>BROTLI_STATE_UNCOMPRESSED</name></expr>:</case> <block>{<block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>CopyUncompressedBlockToOutput</name><argument_list>(
            <argument><expr><name>available_out</name></expr></argument>, <argument><expr><name>next_out</name></expr></argument>, <argument><expr><name>total_out</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>BROTLI_DECODER_SUCCESS</name></expr>)</condition> <block>{<block_content>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>BROTLI_STATE_METABLOCK_DONE</name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>

      <case>case <expr><name>BROTLI_STATE_METADATA</name></expr>:</case>
        <for>for <control>(<init>;</init> <condition><expr><name><name>s</name><operator>-&gt;</operator><name>meta_block_remaining_len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>--</operator><name><name>s</name><operator>-&gt;</operator><name>meta_block_remaining_len</name></name></expr></incr>)</control> <block>{<block_content>
          <decl_stmt><decl><type><name>uint32_t</name></type> <name>bits</name></decl>;</decl_stmt>
          <comment type="block">/* Read one byte and ignore it. */</comment>
          <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BrotliSafeReadBits</name><argument_list>(<argument><expr><name>br</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>bits</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>BROTLI_DECODER_NEEDS_MORE_INPUT</name></expr>;</expr_stmt>
            <break>break;</break>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>BROTLI_DECODER_SUCCESS</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>BROTLI_STATE_METABLOCK_DONE</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <break>break;</break>

      <case>case <expr><name>BROTLI_STATE_METABLOCK_HEADER_2</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>uint32_t</name></type> <name>bits</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BrotliSafeReadBits</name><argument_list>(<argument><expr><name>br</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>bits</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>result</name> <operator>=</operator> <name>BROTLI_DECODER_NEEDS_MORE_INPUT</name></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>distance_postfix_bits</name></name> <operator>=</operator> <name>bits</name> <operator>&amp;</operator> <call><name>BitMask</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> <operator>&gt;&gt;=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>num_direct_distance_codes</name></name> <operator>=</operator> <name>bits</name> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>distance_postfix_bits</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BROTLI_LOG_UINT</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>num_direct_distance_codes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BROTLI_LOG_UINT</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>distance_postfix_bits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>context_modes</name></name> <operator>=</operator>
            <operator>(</operator><name>uint8_t</name><operator>*</operator><operator>)</operator><call><name>BROTLI_DECODER_ALLOC</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>num_block_types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>context_modes</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>BROTLI_FAILURE</name><argument_list>(<argument><expr><name>BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>loop_counter</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>BROTLI_STATE_CONTEXT_MODES</name></expr>;</expr_stmt>
      </block_content>}</block>
      <comment type="block">/* Fall through. */</comment>

      <case>case <expr><name>BROTLI_STATE_CONTEXT_MODES</name></expr>:</case>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ReadContextModes</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>BROTLI_DECODER_SUCCESS</name></expr>)</condition> <block>{<block_content>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>BROTLI_STATE_CONTEXT_MAP_1</name></expr>;</expr_stmt>
      <comment type="block">/* Fall through. */</comment>

      <case>case <expr><name>BROTLI_STATE_CONTEXT_MAP_1</name></expr>:</case>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DecodeContextMap</name><argument_list>(
            <argument><expr><name><name>s</name><operator>-&gt;</operator><name>num_block_types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <name>BROTLI_LITERAL_CONTEXT_BITS</name></expr></argument>,
            <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>num_literal_htrees</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>context_map</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>BROTLI_DECODER_SUCCESS</name></expr>)</condition> <block>{<block_content>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>DetectTrivialLiteralBlockTypes</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>BROTLI_STATE_CONTEXT_MAP_2</name></expr>;</expr_stmt>
      <comment type="block">/* Fall through. */</comment>

      <case>case <expr><name>BROTLI_STATE_CONTEXT_MAP_2</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>uint32_t</name></type> <name>npostfix</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>distance_postfix_bits</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint32_t</name></type> <name>ndirect</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>num_direct_distance_codes</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint32_t</name></type> <name>distance_alphabet_size_max</name> <init>= <expr><call><name>BROTLI_DISTANCE_ALPHABET_SIZE</name><argument_list>(
            <argument><expr><name>npostfix</name></expr></argument>, <argument><expr><name>ndirect</name></expr></argument>, <argument><expr><name>BROTLI_MAX_DISTANCE_BITS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint32_t</name></type> <name>distance_alphabet_size_limit</name> <init>= <expr><name>distance_alphabet_size_max</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BROTLI_BOOL</name></type> <name>allocation_success</name> <init>= <expr><name>BROTLI_TRUE</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>large_window</name></name></expr>)</condition> <block>{<block_content>
          <decl_stmt><decl><type><name>BrotliDistanceCodeLimit</name></type> <name>limit</name> <init>= <expr><call><name>BrotliCalculateDistanceCodeLimit</name><argument_list>(
              <argument><expr><name>BROTLI_MAX_ALLOWED_DISTANCE</name></expr></argument>, <argument><expr><name>npostfix</name></expr></argument>, <argument><expr><name>ndirect</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>distance_alphabet_size_max</name> <operator>=</operator> <call><name>BROTLI_DISTANCE_ALPHABET_SIZE</name><argument_list>(
              <argument><expr><name>npostfix</name></expr></argument>, <argument><expr><name>ndirect</name></expr></argument>, <argument><expr><name>BROTLI_LARGE_MAX_DISTANCE_BITS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>distance_alphabet_size_limit</name> <operator>=</operator> <name><name>limit</name><operator>.</operator><name>max_alphabet_size</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DecodeContextMap</name><argument_list>(
            <argument><expr><name><name>s</name><operator>-&gt;</operator><name>num_block_types</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <name>BROTLI_DISTANCE_CONTEXT_BITS</name></expr></argument>,
            <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>num_dist_htrees</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>dist_context_map</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>BROTLI_DECODER_SUCCESS</name></expr>)</condition> <block>{<block_content>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>allocation_success</name> <operator>&amp;=</operator> <call><name>BrotliDecoderHuffmanTreeGroupInit</name><argument_list>(
            <argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>literal_hgroup</name></name></expr></argument>, <argument><expr><name>BROTLI_NUM_LITERAL_SYMBOLS</name></expr></argument>,
            <argument><expr><name>BROTLI_NUM_LITERAL_SYMBOLS</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>num_literal_htrees</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>allocation_success</name> <operator>&amp;=</operator> <call><name>BrotliDecoderHuffmanTreeGroupInit</name><argument_list>(
            <argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>insert_copy_hgroup</name></name></expr></argument>, <argument><expr><name>BROTLI_NUM_COMMAND_SYMBOLS</name></expr></argument>,
            <argument><expr><name>BROTLI_NUM_COMMAND_SYMBOLS</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>num_block_types</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>allocation_success</name> <operator>&amp;=</operator> <call><name>BrotliDecoderHuffmanTreeGroupInit</name><argument_list>(
            <argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>distance_hgroup</name></name></expr></argument>, <argument><expr><name>distance_alphabet_size_max</name></expr></argument>,
            <argument><expr><name>distance_alphabet_size_limit</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>num_dist_htrees</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>allocation_success</name></expr>)</condition> <block>{<block_content>
          <return>return <expr><call><name>BROTLI_SAVE_ERROR_CODE</name><argument_list>(
              <argument><expr><call><name>BROTLI_FAILURE</name><argument_list>(<argument><expr><name>BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>loop_counter</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>BROTLI_STATE_TREE_GROUP</name></expr>;</expr_stmt>
      </block_content>}</block>
      <comment type="block">/* Fall through. */</comment>

      <case>case <expr><name>BROTLI_STATE_TREE_GROUP</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>HuffmanTreeGroup</name><modifier>*</modifier></type> <name>hgroup</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <switch>switch <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>loop_counter</name></name></expr>)</condition> <block>{<block_content>
          <case>case <expr><literal type="number">0</literal></expr>:</case> <expr_stmt><expr><name>hgroup</name> <operator>=</operator> <operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>literal_hgroup</name></name></expr>;</expr_stmt> <break>break;</break>
          <case>case <expr><literal type="number">1</literal></expr>:</case> <expr_stmt><expr><name>hgroup</name> <operator>=</operator> <operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>insert_copy_hgroup</name></name></expr>;</expr_stmt> <break>break;</break>
          <case>case <expr><literal type="number">2</literal></expr>:</case> <expr_stmt><expr><name>hgroup</name> <operator>=</operator> <operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>distance_hgroup</name></name></expr>;</expr_stmt> <break>break;</break>
          <default>default:</default> <return>return <expr><call><name>BROTLI_SAVE_ERROR_CODE</name><argument_list>(<argument><expr><call><name>BROTLI_FAILURE</name><argument_list>(
              <argument><expr><name>BROTLI_DECODER_ERROR_UNREACHABLE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>  <comment type="block">/* COV_NF_LINE */</comment>
        </block_content>}</block></switch>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>HuffmanTreeGroupDecode</name><argument_list>(<argument><expr><name>hgroup</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>BROTLI_DECODER_SUCCESS</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>loop_counter</name></name><operator>++</operator></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>loop_counter</name></name> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>BROTLI_STATE_BEFORE_COMPRESSED_METABLOCK_BODY</name></expr>;</expr_stmt>
      </block_content>}</block>
      <comment type="block">/* Fall through. */</comment>

      <case>case <expr><name>BROTLI_STATE_BEFORE_COMPRESSED_METABLOCK_BODY</name></expr>:</case>
        <expr_stmt><expr><call><name>PrepareLiteralDecoding</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>dist_context_map_slice</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>dist_context_map</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>htree_command</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>insert_copy_hgroup</name><operator>.</operator><name>htrees</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BrotliEnsureRingBuffer</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>BROTLI_FAILURE</name><argument_list>(<argument><expr><name>BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>CalculateDistanceLut</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>BROTLI_STATE_COMMAND_BEGIN</name></expr>;</expr_stmt>
      <comment type="block">/* Fall through. */</comment>

      <case>case <expr><name>BROTLI_STATE_COMMAND_BEGIN</name></expr>:</case>
      <comment type="block">/* Fall through. */</comment>
      <case>case <expr><name>BROTLI_STATE_COMMAND_INNER</name></expr>:</case>
      <comment type="block">/* Fall through. */</comment>
      <case>case <expr><name>BROTLI_STATE_COMMAND_POST_DECODE_LITERALS</name></expr>:</case>
      <comment type="block">/* Fall through. */</comment>
      <case>case <expr><name>BROTLI_STATE_COMMAND_POST_WRAP_COPY</name></expr>:</case>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ProcessCommands</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>BROTLI_DECODER_NEEDS_MORE_INPUT</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>SafeProcessCommands</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <break>break;</break>

      <case>case <expr><name>BROTLI_STATE_COMMAND_INNER_WRITE</name></expr>:</case>
      <comment type="block">/* Fall through. */</comment>
      <case>case <expr><name>BROTLI_STATE_COMMAND_POST_WRITE_1</name></expr>:</case>
      <comment type="block">/* Fall through. */</comment>
      <case>case <expr><name>BROTLI_STATE_COMMAND_POST_WRITE_2</name></expr>:</case>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>WriteRingBuffer</name><argument_list>(
            <argument><expr><name>s</name></expr></argument>, <argument><expr><name>available_out</name></expr></argument>, <argument><expr><name>next_out</name></expr></argument>, <argument><expr><name>total_out</name></expr></argument>, <argument><expr><name>BROTLI_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>BROTLI_DECODER_SUCCESS</name></expr>)</condition> <block>{<block_content>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>WrapRingBuffer</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ringbuffer_size</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>window_bits</name></name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>max_distance</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>max_backward_distance</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>BROTLI_STATE_COMMAND_POST_WRITE_1</name></expr>)</condition> <block>{<block_content>
          <decl_stmt><decl><type><name>BrotliDecoderCompoundDictionary</name><modifier>*</modifier></type> <name>addon</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>compound_dictionary</name></name></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if <condition>(<expr><name>addon</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>addon</name><operator>-&gt;</operator><name>br_length</name></name> <operator>!=</operator> <name><name>addon</name><operator>-&gt;</operator><name>br_copied</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>pos</name></name> <operator>+=</operator> <call><name>CopyFromCompoundDictionary</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>pos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>pos</name></name> <operator>&gt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>ringbuffer_size</name></name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
          </block_content>}</block></if></if_stmt>
          <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>meta_block_remaining_len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Next metablock, if any. */</comment>
            <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>BROTLI_STATE_METABLOCK_DONE</name></expr>;</expr_stmt>
          </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>BROTLI_STATE_COMMAND_BEGIN</name></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
          <break>break;</break>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>BROTLI_STATE_COMMAND_POST_WRITE_2</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>BROTLI_STATE_COMMAND_POST_WRAP_COPY</name></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* BROTLI_STATE_COMMAND_INNER_WRITE */</comment>
          <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>loop_counter</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>meta_block_remaining_len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
              <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>BROTLI_STATE_METABLOCK_DONE</name></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
              <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>BROTLI_STATE_COMMAND_POST_DECODE_LITERALS</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <break>break;</break>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>BROTLI_STATE_COMMAND_INNER</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <break>break;</break>

      <case>case <expr><name>BROTLI_STATE_METABLOCK_DONE</name></expr>:</case>
        <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>meta_block_remaining_len</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>BROTLI_FAILURE</name><argument_list>(<argument><expr><name>BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>BrotliDecoderStateCleanupAfterMetablock</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>is_last_metablock</name></name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>BROTLI_STATE_METABLOCK_BEGIN</name></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BrotliJumpToByteBoundary</name><argument_list>(<argument><expr><name>br</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>BROTLI_FAILURE</name><argument_list>(<argument><expr><name>BROTLI_DECODER_ERROR_FORMAT_PADDING_2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>buffer_length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>BrotliBitReaderUnload</name><argument_list>(<argument><expr><name>br</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><operator>*</operator><name>available_in</name> <operator>=</operator> <name><name>br</name><operator>-&gt;</operator><name>avail_in</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><operator>*</operator><name>next_in</name> <operator>=</operator> <name><name>br</name><operator>-&gt;</operator><name>next_in</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>BROTLI_STATE_DONE</name></expr>;</expr_stmt>
      <comment type="block">/* Fall through. */</comment>

      <case>case <expr><name>BROTLI_STATE_DONE</name></expr>:</case>
        <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ringbuffer</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>WriteRingBuffer</name><argument_list>(
              <argument><expr><name>s</name></expr></argument>, <argument><expr><name>available_out</name></expr></argument>, <argument><expr><name>next_out</name></expr></argument>, <argument><expr><name>total_out</name></expr></argument>, <argument><expr><name>BROTLI_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>BROTLI_DECODER_SUCCESS</name></expr>)</condition> <block>{<block_content>
            <break>break;</break>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><call><name>BROTLI_SAVE_ERROR_CODE</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></switch>
  </block_content>}</block></for>
  <return>return <expr><call><name>BROTLI_SAVE_ERROR_CODE</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BROTLI_SAVE_ERROR_CODE</name></cpp:undef>
</block_content>}</block></function>

<function><type><name>BROTLI_BOOL</name></type> <name>BrotliDecoderHasMoreOutput</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BrotliDecoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* After unrecoverable error remaining output is considered nonsensical. */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>error_code</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>BROTLI_FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>TO_BROTLI_BOOL</name><argument_list>(
      <argument><expr><name><name>s</name><operator>-&gt;</operator><name>ringbuffer</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>UnwrittenBytes</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>BROTLI_FALSE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>uint8_t</name><modifier>*</modifier></type> <name>BrotliDecoderTakeOutput</name><parameter_list>(<parameter><decl><type><name>BrotliDecoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>size_t</name><modifier>*</modifier></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint8_t</name><modifier>*</modifier></type> <name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>available_out</name> <init>= <expr><ternary><condition><expr><operator>*</operator><name>size</name></expr> ?</condition><then> <expr><operator>*</operator><name>size</name></expr> </then><else>: <expr><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <literal type="number">24</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>requested_out</name> <init>= <expr><name>available_out</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BrotliDecoderErrorCode</name></type> <name>status</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>ringbuffer</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><operator>(</operator><name>int</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>error_code</name></name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>WrapRingBuffer</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>WriteRingBuffer</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>available_out</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BROTLI_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Either WriteRingBuffer returns those "success" codes... */</comment>
  <if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>BROTLI_DECODER_SUCCESS</name> <operator>||</operator>
      <name>status</name> <operator>==</operator> <name>BROTLI_DECODER_NEEDS_MORE_OUTPUT</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>size</name> <operator>=</operator> <name>requested_out</name> <operator>-</operator> <name>available_out</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <comment type="block">/* ... or stream is broken. Normally this should be caught by
       BrotliDecoderDecompressStream, this is just a safeguard. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator><name>status</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>SaveErrorCode</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>status</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>BROTLI_BOOL</name></type> <name>BrotliDecoderIsUsed</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BrotliDecoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>TO_BROTLI_BOOL</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>BROTLI_STATE_UNINITED</name> <operator>||</operator>
      <call><name>BrotliGetAvailableBits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>br</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>BROTLI_BOOL</name></type> <name>BrotliDecoderIsFinished</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BrotliDecoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>TO_BROTLI_BOOL</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>BROTLI_STATE_DONE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
      <operator>!</operator><call><name>BrotliDecoderHasMoreOutput</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>BrotliDecoderErrorCode</name></type> <name>BrotliDecoderGetErrorCode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BrotliDecoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><operator>(</operator><name>BrotliDecoderErrorCode</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>error_code</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>BrotliDecoderErrorString</name><parameter_list>(<parameter><decl><type><name>BrotliDecoderErrorCode</name></type> <name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_ERROR_CODE_CASE_</name><parameter_list>(<parameter><type><name>PREFIX</name></type></parameter>, <parameter><type><name>NAME</name></type></parameter>, <parameter><type><name>CODE</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>case BROTLI_DECODER ## PREFIX ## NAME: return #NAME;</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_NOTHING_</name></cpp:macro></cpp:define>
    <macro><name>BROTLI_DECODER_ERROR_CODES_LIST</name><argument_list>(<argument>BROTLI_ERROR_CODE_CASE_</argument>, <argument>BROTLI_NOTHING_</argument>)</argument_list></macro>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BROTLI_ERROR_CODE_CASE_</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BROTLI_NOTHING_</name></cpp:undef>
    <default>default:</default> <return>return <expr><literal type="string">"INVALID"</literal></expr>;</return>
  </block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>uint32_t</name></type> <name>BrotliDecoderVersion</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><name>BROTLI_VERSION</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Escalate internal functions visibility; for testing purposes only. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>BROTLI_TEST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name>BROTLI_BOOL</name></type> <name>SafeReadSymbolForTest</name><parameter_list>(
    <parameter><decl><type><specifier>const</specifier> <name>HuffmanCode</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>BrotliBitReader</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>uint32_t</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function><type><name>BROTLI_BOOL</name></type> <name>SafeReadSymbolForTest</name><parameter_list>(
    <parameter><decl><type><specifier>const</specifier> <name>HuffmanCode</name><modifier>*</modifier></type> <name>table</name></decl></parameter>, <parameter><decl><type><name>BrotliBitReader</name><modifier>*</modifier></type> <name>br</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name><modifier>*</modifier></type> <name>result</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>SafeReadSymbol</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>br</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function_decl><type><name>void</name></type> <name>InverseMoveToFrontTransformForTest</name><parameter_list>(
    <parameter><decl><type><name>uint8_t</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type></decl></parameter>, <parameter><decl><type><name>BrotliDecoderState</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function><type><name>void</name></type> <name>InverseMoveToFrontTransformForTest</name><parameter_list>(
    <parameter><decl><type><name>uint8_t</name><modifier>*</modifier></type> <name>v</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>l</name></decl></parameter>, <parameter><decl><type><name>BrotliDecoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>InverseMoveToFrontTransform</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>c_plusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
</block_content>}</block></extern>  <comment type="block">/* extern "C" */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
