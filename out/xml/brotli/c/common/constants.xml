<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="../out/cloned_projects/brotli/c/common/constants.h"><comment type="block">/* Copyright 2016 Google Inc. All Rights Reserved.

   Distributed under MIT license.
   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT
*/</comment>

<comment type="block" format="doxygen">/**
 * @file
 * Common constants used in decoder and encoder API.
 */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>BROTLI_COMMON_CONSTANTS_H_</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_COMMON_CONSTANTS_H_</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;brotli/port.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;brotli/types.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"platform.h"</cpp:file></cpp:include>

<comment type="block">/* Specification: 7.3. Encoding of the context map */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_CONTEXT_MAP_MAX_RLE</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>

<comment type="block">/* Specification: 2. Compressed representation overview */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_MAX_NUMBER_OF_BLOCK_TYPES</name></cpp:macro> <cpp:value>256</cpp:value></cpp:define>

<comment type="block">/* Specification: 3.3. Alphabet sizes: insert-and-copy length */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_NUM_LITERAL_SYMBOLS</name></cpp:macro> <cpp:value>256</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_NUM_COMMAND_SYMBOLS</name></cpp:macro> <cpp:value>704</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_NUM_BLOCK_LEN_SYMBOLS</name></cpp:macro> <cpp:value>26</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_MAX_CONTEXT_MAP_SYMBOLS</name></cpp:macro> <cpp:value>(BROTLI_MAX_NUMBER_OF_BLOCK_TYPES + \
                                        BROTLI_CONTEXT_MAP_MAX_RLE)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_MAX_BLOCK_TYPE_SYMBOLS</name></cpp:macro> <cpp:value>(BROTLI_MAX_NUMBER_OF_BLOCK_TYPES + 2)</cpp:value></cpp:define>

<comment type="block">/* Specification: 3.5. Complex prefix codes */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_REPEAT_PREVIOUS_CODE_LENGTH</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_REPEAT_ZERO_CODE_LENGTH</name></cpp:macro> <cpp:value>17</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_CODE_LENGTH_CODES</name></cpp:macro> <cpp:value>(BROTLI_REPEAT_ZERO_CODE_LENGTH + 1)</cpp:value></cpp:define>
<comment type="block">/* "code length of 8 is repeated" */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_INITIAL_REPEATED_CODE_LENGTH</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>

<comment type="block">/* "Large Window Brotli" */</comment>

<comment type="block" format="doxygen">/**
 * The theoretical maximum number of distance bits specified for large window
 * brotli, for 64-bit encoders and decoders. Even when in practice 32-bit
 * encoders and decoders only support up to 30 max distance bits, the value is
 * set to 62 because it affects the large window brotli file format.
 * Specifically, it affects the encoding of simple huffman tree for distances,
 * see Specification RFC 7932 chapter 3.4.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_LARGE_MAX_DISTANCE_BITS</name></cpp:macro> <cpp:value>62U</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_LARGE_MIN_WBITS</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>
<comment type="block" format="doxygen">/**
 * The maximum supported large brotli window bits by the encoder and decoder.
 * Large window brotli allows up to 62 bits, however the current encoder and
 * decoder, designed for 32-bit integers, only support up to 30 bits maximum.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_LARGE_MAX_WBITS</name></cpp:macro> <cpp:value>30</cpp:value></cpp:define>

<comment type="block">/* Specification: 4. Encoding of distances */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_NUM_DISTANCE_SHORT_CODES</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>
<comment type="block" format="doxygen">/**
 * Maximal number of "postfix" bits.
 *
 * Number of "postfix" bits is stored as 2 bits in meta-block header.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_MAX_NPOSTFIX</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_MAX_NDIRECT</name></cpp:macro> <cpp:value>120</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_MAX_DISTANCE_BITS</name></cpp:macro> <cpp:value>24U</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_DISTANCE_ALPHABET_SIZE</name><parameter_list>(<parameter><type><name>NPOSTFIX</name></type></parameter>, <parameter><type><name>NDIRECT</name></type></parameter>, <parameter><type><name>MAXNBITS</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>( \
    BROTLI_NUM_DISTANCE_SHORT_CODES + (NDIRECT) +                    \
    ((MAXNBITS) &lt;&lt; ((NPOSTFIX) + 1)))</cpp:value></cpp:define>
<comment type="block">/* BROTLI_NUM_DISTANCE_SYMBOLS == 1128 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_NUM_DISTANCE_SYMBOLS</name></cpp:macro> \
    <cpp:value>BROTLI_DISTANCE_ALPHABET_SIZE(  \
        BROTLI_MAX_NDIRECT, BROTLI_MAX_NPOSTFIX, BROTLI_LARGE_MAX_DISTANCE_BITS)</cpp:value></cpp:define>

<comment type="block">/* ((1 &lt;&lt; 26) - 4) is the maximal distance that can be expressed in RFC 7932
   brotli stream using NPOSTFIX = 0 and NDIRECT = 0. With other NPOSTFIX and
   NDIRECT values distances up to ((1 &lt;&lt; 29) + 88) could be expressed. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_MAX_DISTANCE</name></cpp:macro> <cpp:value>0x3FFFFFC</cpp:value></cpp:define>

<comment type="block">/* ((1 &lt;&lt; 31) - 4) is the safe distance limit. Using this number as a limit
   allows safe distance calculation without overflows, given the distance
   alphabet size is limited to corresponding size
   (see kLargeWindowDistanceCodeLimits). */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_MAX_ALLOWED_DISTANCE</name></cpp:macro> <cpp:value>0x7FFFFFFC</cpp:value></cpp:define>


<comment type="block">/* Specification: 4. Encoding of Literal Insertion Lengths and Copy Lengths */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_NUM_INS_COPY_CODES</name></cpp:macro> <cpp:value>24</cpp:value></cpp:define>

<comment type="block">/* 7.1. Context modes and context ID lookup for literals */</comment>
<comment type="block">/* "context IDs for literals are in the range of 0..63" */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_LITERAL_CONTEXT_BITS</name></cpp:macro> <cpp:value>6</cpp:value></cpp:define>

<comment type="block">/* 7.2. Context ID for distances */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_DISTANCE_CONTEXT_BITS</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

<comment type="block">/* 9.1. Format of the Stream Header */</comment>
<comment type="block">/* Number of slack bytes for window size. Don't confuse
   with BROTLI_NUM_DISTANCE_SHORT_CODES. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_WINDOW_GAP</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_MAX_BACKWARD_LIMIT</name><parameter_list>(<parameter><type><name>W</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((size_t)1 &lt;&lt; (W)) - BROTLI_WINDOW_GAP)</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>BrotliDistanceCodeLimit</name> <block>{
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>max_alphabet_size</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>max_distance</name></decl>;</decl_stmt>
}</block></struct></type> <name>BrotliDistanceCodeLimit</name>;</typedef>

<comment type="block">/* This function calculates maximal size of distance alphabet, such that the
   distances greater than the given values can not be represented.

   This limits are designed to support fast and safe 32-bit decoders.
   "32-bit" means that signed integer values up to ((1 &lt;&lt; 31) - 1) could be
   safely expressed.

   Brotli distance alphabet symbols do not represent consecutive distance
   ranges. Each distance alphabet symbol (excluding direct distances and short
   codes), represent interleaved (for NPOSTFIX &gt; 0) range of distances.
   A "group" of consecutive (1 &lt;&lt; NPOSTFIX) symbols represent non-interleaved
   range. Two consecutive groups require the same amount of "extra bits".

   It is important that distance alphabet represents complete "groups".
   To avoid complex logic on encoder side about interleaved ranges
   it was decided to restrict both sides to complete distance code "groups".
 */</comment>
<function><type><name>BROTLI_UNUSED_FUNCTION</name> <name>BrotliDistanceCodeLimit</name></type> <name>BrotliCalculateDistanceCodeLimit</name><parameter_list>(
    <parameter><decl><type><name>uint32_t</name></type> <name>max_distance</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>npostfix</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>ndirect</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>BrotliDistanceCodeLimit</name></type> <name>result</name></decl>;</decl_stmt>
  <comment type="block">/* Marking this function as unused, because not all files
     including "constants.h" use it -&gt; compiler warns about that. */</comment>
  <expr_stmt><expr><call><name>BROTLI_UNUSED</name><argument_list>(<argument><expr><operator>&amp;</operator><name>BrotliCalculateDistanceCodeLimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>max_distance</name> <operator>&lt;=</operator> <name>ndirect</name></expr>)</condition> <block>{<block_content>
    <comment type="block">/* This case never happens / exists only for the sake of completeness. */</comment>
    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>max_alphabet_size</name></name> <operator>=</operator> <name>max_distance</name> <operator>+</operator> <name>BROTLI_NUM_DISTANCE_SHORT_CODES</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>max_distance</name></name> <operator>=</operator> <name>max_distance</name></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <comment type="block">/* The first prohibited value. */</comment>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>forbidden_distance</name> <init>= <expr><name>max_distance</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <comment type="block">/* Subtract "directly" encoded region. */</comment>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>offset</name> <init>= <expr><name>forbidden_distance</name> <operator>-</operator> <name>ndirect</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>ndistbits</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>half</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>group</name></decl>;</decl_stmt>
    <comment type="block">/* Postfix for the last dcode in the group. */</comment>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>postfix</name> <init>= <expr><operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <name>npostfix</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>extra</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>start</name></decl>;</decl_stmt>
    <comment type="block">/* Remove postfix and "head-start". */</comment>
    <expr_stmt><expr><name>offset</name> <operator>=</operator> <operator>(</operator><name>offset</name> <operator>&gt;&gt;</operator> <name>npostfix</name><operator>)</operator> <operator>+</operator> <literal type="number">4</literal></expr>;</expr_stmt>
    <comment type="block">/* Calculate the number of distance bits. */</comment>
    <expr_stmt><expr><name>tmp</name> <operator>=</operator> <name>offset</name> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <comment type="block">/* Poor-man's log2floor, to avoid extra dependencies. */</comment>
    <while>while <condition>(<expr><name>tmp</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content><expr_stmt><expr><name>ndistbits</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>tmp</name> <operator>=</operator> <name>tmp</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content>}</block></while>
    <comment type="block">/* One bit is covered with subrange addressing ("half"). */</comment>
    <expr_stmt><expr><name>ndistbits</name><operator>--</operator></expr>;</expr_stmt>
    <comment type="block">/* Find subrange. */</comment>
    <expr_stmt><expr><name>half</name> <operator>=</operator> <operator>(</operator><name>offset</name> <operator>&gt;&gt;</operator> <name>ndistbits</name><operator>)</operator> <operator>&amp;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <comment type="block">/* Calculate the "group" part of dcode. */</comment>
    <expr_stmt><expr><name>group</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>ndistbits</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>|</operator> <name>half</name></expr>;</expr_stmt>
    <comment type="block">/* Calculated "group" covers the prohibited distance value. */</comment>
    <if_stmt><if>if <condition>(<expr><name>group</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <comment type="block">/* This case is added for correctness; does not occur for limit &gt; 128. */</comment>
      <expr_stmt><expr><name><name>result</name><operator>.</operator><name>max_alphabet_size</name></name> <operator>=</operator> <name>ndirect</name> <operator>+</operator> <name>BROTLI_NUM_DISTANCE_SHORT_CODES</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>result</name><operator>.</operator><name>max_distance</name></name> <operator>=</operator> <name>ndirect</name></expr>;</expr_stmt>
      <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Decrement "group", so it is the last permitted "group". */</comment>
    <expr_stmt><expr><name>group</name><operator>--</operator></expr>;</expr_stmt>
    <comment type="block">/* After group was decremented, ndistbits and half must be recalculated. */</comment>
    <expr_stmt><expr><name>ndistbits</name> <operator>=</operator> <operator>(</operator><name>group</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <comment type="block">/* The last available distance in the subrange has all extra bits set. */</comment>
    <expr_stmt><expr><name>extra</name> <operator>=</operator> <operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <name>ndistbits</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <comment type="block">/* Calculate region start. NB: ndistbits &gt;= 1. */</comment>
    <expr_stmt><expr><name>start</name> <operator>=</operator> <operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>ndistbits</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>-</operator> <literal type="number">4</literal></expr>;</expr_stmt>
    <comment type="block">/* Move to subregion. */</comment>
    <expr_stmt><expr><name>start</name> <operator>+=</operator> <operator>(</operator><name>group</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name>ndistbits</name></expr>;</expr_stmt>
    <comment type="block">/* Calculate the alphabet size. */</comment>
    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>max_alphabet_size</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>group</name> <operator>&lt;&lt;</operator> <name>npostfix</name><operator>)</operator> <operator>|</operator> <name>postfix</name><operator>)</operator> <operator>+</operator> <name>ndirect</name> <operator>+</operator>
        <name>BROTLI_NUM_DISTANCE_SHORT_CODES</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <comment type="block">/* Calculate the maximal distance representable by alphabet. */</comment>
    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>max_distance</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>start</name> <operator>+</operator> <name>extra</name><operator>)</operator> <operator>&lt;&lt;</operator> <name>npostfix</name><operator>)</operator> <operator>+</operator> <name>postfix</name> <operator>+</operator> <name>ndirect</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Represents the range of values belonging to a prefix code:
   [offset, offset + 2^nbits) */</comment>
<typedef>typedef <type><struct>struct <block>{
  <decl_stmt><decl><type><name>uint16_t</name></type> <name>offset</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>nbits</name></decl>;</decl_stmt>
}</block></struct></type> <name>BrotliPrefixCodeRange</name>;</typedef>

<comment type="block">/* "Soft-private", it is exported, but not "advertised" as API. */</comment>
<decl_stmt><decl><type><name>BROTLI_COMMON_API</name> <specifier>extern</specifier> <specifier>const</specifier> <name>BrotliPrefixCodeRange</name></type>
    <name><name>_kBrotliPrefixCodeRanges</name><index>[<expr><name>BROTLI_NUM_BLOCK_LEN_SYMBOLS</name></expr>]</index></name></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* BROTLI_COMMON_CONSTANTS_H_ */</comment>
</unit>
