<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="../out/cloned_projects/brotli/c/common/context.h"><comment type="block">/* Copyright 2013 Google Inc. All Rights Reserved.

   Distributed under MIT license.
   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT
*/</comment>

<comment type="block">/* Lookup table to map the previous two bytes to a context id.

  There are four different context modeling modes defined here:
    CONTEXT_LSB6: context id is the least significant 6 bits of the last byte,
    CONTEXT_MSB6: context id is the most significant 6 bits of the last byte,
    CONTEXT_UTF8: second-order context model tuned for UTF8-encoded text,
    CONTEXT_SIGNED: second-order context model tuned for signed integers.

  If |p1| and |p2| are the previous two bytes, and |mode| is current context
  mode, we calculate the context as:

    context = ContextLut(mode)[p1] | ContextLut(mode)[p2 + 256].

  For CONTEXT_UTF8 mode, if the previous two bytes are ASCII characters
  (i.e. &lt; 128), this will be equivalent to

    context = 4 * context1(p1) + context2(p2),

  where context1 is based on the previous byte in the following way:

    0  : non-ASCII control
    1  : \t, \n, \r
    2  : space
    3  : other punctuation
    4  : " '
    5  : %
    6  : ( &lt; [ {
    7  : ) &gt; ] }
    8  : , ; :
    9  : .
    10 : =
    11 : number
    12 : upper-case vowel
    13 : upper-case consonant
    14 : lower-case vowel
    15 : lower-case consonant

  and context2 is based on the second last byte:

    0 : control, space
    1 : punctuation
    2 : upper-case letter, number
    3 : lower-case letter

  If the last byte is ASCII, and the second last byte is not (in a valid UTF8
  stream it will be a continuation byte, value between 128 and 191), the
  context is the same as if the second last byte was an ASCII control or space.

  If the last byte is a UTF8 lead byte (value &gt;= 192), then the next byte will
  be a continuation byte and the context id is 2 or 3 depending on the LSB of
  the last byte and to a lesser extent on the second last byte if it is ASCII.

  If the last byte is a UTF8 continuation byte, the second last byte can be:
    - continuation byte: the next byte is probably ASCII or lead byte (assuming
      4-byte UTF8 characters are rare) and the context id is 0 or 1.
    - lead byte (192 - 207): next byte is ASCII or lead byte, context is 0 or 1
    - lead byte (208 - 255): next byte is continuation byte, context is 2 or 3

  The possible value combinations of the previous two bytes, the range of
  context ids and the type of the next byte is summarized in the table below:

  |--------\-----------------------------------------------------------------|
  |         \                         Last byte                              |
  | Second   \---------------------------------------------------------------|
  | last byte \    ASCII            |   cont. byte        |   lead byte      |
  |            \   (0-127)          |   (128-191)         |   (192-)         |
  |=============|===================|=====================|==================|
  |  ASCII      | next: ASCII/lead  |  not valid          |  next: cont.     |
  |  (0-127)    | context: 4 - 63   |                     |  context: 2 - 3  |
  |-------------|-------------------|---------------------|------------------|
  |  cont. byte | next: ASCII/lead  |  next: ASCII/lead   |  next: cont.     |
  |  (128-191)  | context: 4 - 63   |  context: 0 - 1     |  context: 2 - 3  |
  |-------------|-------------------|---------------------|------------------|
  |  lead byte  | not valid         |  next: ASCII/lead   |  not valid       |
  |  (192-207)  |                   |  context: 0 - 1     |                  |
  |-------------|-------------------|---------------------|------------------|
  |  lead byte  | not valid         |  next: cont.        |  not valid       |
  |  (208-)     |                   |  context: 2 - 3     |                  |
  |-------------|-------------------|---------------------|------------------|
*/</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>BROTLI_COMMON_CONTEXT_H_</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_COMMON_CONTEXT_H_</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;brotli/port.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;brotli/types.h&gt;</cpp:file></cpp:include>

<typedef>typedef <type><enum>enum <name>ContextType</name> <block>{
  <decl><name>CONTEXT_LSB6</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
  <decl><name>CONTEXT_MSB6</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,
  <decl><name>CONTEXT_UTF8</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>,
  <decl><name>CONTEXT_SIGNED</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>
}</block></enum></type> <name>ContextType</name>;</typedef>

<comment type="block">/* "Soft-private", it is exported, but not "advertised" as API. */</comment>
<comment type="block">/* Common context lookup table for all context modes. */</comment>
<decl_stmt><decl><type><name>BROTLI_COMMON_API</name> <specifier>extern</specifier> <specifier>const</specifier> <name>uint8_t</name></type> <name><name>_kBrotliContextLookupTable</name><index>[<expr><literal type="number">2048</literal></expr>]</index></name></decl>;</decl_stmt>

<typedef>typedef <type><specifier>const</specifier> <name>uint8_t</name><modifier>*</modifier></type> <name>ContextLut</name>;</typedef>

<comment type="block">/* typeof(MODE) == ContextType; returns ContextLut */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_CONTEXT_LUT</name><parameter_list>(<parameter><type><name>MODE</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(&amp;_kBrotliContextLookupTable[(MODE) &lt;&lt; 9])</cpp:value></cpp:define>

<comment type="block">/* typeof(LUT) == ContextLut */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_CONTEXT</name><parameter_list>(<parameter><type><name>P1</name></type></parameter>, <parameter><type><name>P2</name></type></parameter>, <parameter><type><name>LUT</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((LUT)[P1] | ((LUT) + 256)[P2])</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* BROTLI_COMMON_CONTEXT_H_ */</comment>
</unit>
