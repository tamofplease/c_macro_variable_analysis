<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="../out/cloned_projects/brotli/c/enc/hash.h"><comment type="block">/* Copyright 2010 Google Inc. All Rights Reserved.

   Distributed under MIT license.
   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT
*/</comment>

<comment type="block">/* A (forgetful) hash table to the data seen by the compressor, to
   help create backward references to previous data. */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>BROTLI_ENC_HASH_H_</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_ENC_HASH_H_</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>  <comment type="block">/* exit */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>  <comment type="block">/* memcmp, memset */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;brotli/types.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../common/constants.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../common/dictionary.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../common/platform.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compound_dictionary.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"encoder_dict.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fast_log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"find_match_length.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"memory.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"quality.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"static_dict.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>c_plusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
<extern>extern <literal type="string">"C"</literal> <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<typedef>typedef <type><struct>struct <block>{
  <comment type="block" format="doxygen">/**
   * Dynamically allocated areas; regular hasher uses one or two allocations;
   * "composite" hasher uses up to 4 allocations.
   */</comment>
  <decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name><name>extra</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>

  <comment type="block" format="doxygen">/**
   * False before the fisrt invocation of HasherSetup (where "extra" memory)
   * is allocated.
   */</comment>
  <decl_stmt><decl><type><name>BROTLI_BOOL</name></type> <name>is_setup_</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>size_t</name></type> <name>dict_num_lookups</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>dict_num_matches</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>BrotliHasherParams</name></type> <name>params</name></decl>;</decl_stmt>

  <comment type="block" format="doxygen">/**
   * False if hasher needs to be "prepared" before use (before the first
   * invocation of HasherSetup or after HasherReset). "preparation" is hasher
   * data initialization (using input ringbuffer).
   */</comment>
  <decl_stmt><decl><type><name>BROTLI_BOOL</name></type> <name>is_prepared_</name></decl>;</decl_stmt>
}</block></struct></type> <name>HasherCommon</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>score_t</name></cpp:macro> <cpp:value>size_t</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint32_t</name></type> <name>kCutoffTransformsCount</name> <init>= <expr><literal type="number">10</literal></expr></init></decl>;</decl_stmt>
<comment type="block">/*   0,  12,   27,    23,    42,    63,    56,    48,    59,    64 */</comment>
<comment type="block">/* 0+0, 4+8, 8+19, 12+11, 16+26, 20+43, 24+32, 28+20, 32+27, 36+28 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint64_t</name></type> <name>kCutoffTransforms</name> <init>=
    <expr><call><name>BROTLI_MAKE_UINT64_T</name><argument_list>(<argument><expr><literal type="number">0x071B520A</literal></expr></argument>, <argument><expr><literal type="number">0xDA2D3200</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<typedef>typedef <type><struct>struct <name>HasherSearchResult</name> <block>{
  <decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>distance</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>score_t</name></type> <name>score</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>len_code_delta</name></decl>;</decl_stmt> <comment type="block">/* == len_code - len */</comment>
}</block></struct></type> <name>HasherSearchResult</name>;</typedef>

<comment type="block">/* kHashMul32 multiplier has these properties:
   * The multiplier must be odd. Otherwise we may lose the highest bit.
   * No long streaks of ones or zeros.
   * There is no effort to ensure that it is a prime, the oddity is enough
     for this use.
   * The number has been tuned heuristically against compression benchmarks. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint32_t</name></type> <name>kHashMul32</name> <init>= <expr><literal type="number">0x1E35A7BD</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint64_t</name></type> <name>kHashMul64</name> <init>= <expr><call><name>BROTLI_MAKE_UINT64_T</name><argument_list>(<argument><expr><literal type="number">0x1E35A7BD</literal></expr></argument>, <argument><expr><literal type="number">0x1E35A7BD</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint64_t</name></type> <name>kHashMul64Long</name> <init>=
    <expr><call><name>BROTLI_MAKE_UINT64_T</name><argument_list>(<argument><expr><literal type="number">0x1FE35A7Bu</literal></expr></argument>, <argument><expr><literal type="number">0xD3579BD3u</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>BROTLI_INLINE</name> <name>uint32_t</name></type> <name>Hash14</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>uint8_t</name><modifier>*</modifier></type> <name>data</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>h</name> <init>= <expr><call><name>BROTLI_UNALIGNED_LOAD32LE</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call> <operator>*</operator> <name>kHashMul32</name></expr></init></decl>;</decl_stmt>
  <comment type="block">/* The higher bits contain more mixture from the multiplication,
     so we take our results from there. */</comment>
  <return>return <expr><name>h</name> <operator>&gt;&gt;</operator> <operator>(</operator><literal type="number">32</literal> <operator>-</operator> <literal type="number">14</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BROTLI_INLINE</name> <name>void</name></type> <name>PrepareDistanceCache</name><parameter_list>(
    <parameter><decl><type><name>int</name><modifier>*</modifier> <name>BROTLI_RESTRICT</name></type> <name>distance_cache</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>num_distances</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>num_distances</name> <operator>&gt;</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>last_distance</name> <init>= <expr><name><name>distance_cache</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>distance_cache</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>last_distance</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>distance_cache</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <name>last_distance</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>distance_cache</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <name>last_distance</name> <operator>-</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>distance_cache</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <name>last_distance</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>distance_cache</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>=</operator> <name>last_distance</name> <operator>-</operator> <literal type="number">3</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>distance_cache</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>=</operator> <name>last_distance</name> <operator>+</operator> <literal type="number">3</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>num_distances</name> <operator>&gt;</operator> <literal type="number">10</literal></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>next_last_distance</name> <init>= <expr><name><name>distance_cache</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>distance_cache</name><index>[<expr><literal type="number">10</literal></expr>]</index></name> <operator>=</operator> <name>next_last_distance</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>distance_cache</name><index>[<expr><literal type="number">11</literal></expr>]</index></name> <operator>=</operator> <name>next_last_distance</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>distance_cache</name><index>[<expr><literal type="number">12</literal></expr>]</index></name> <operator>=</operator> <name>next_last_distance</name> <operator>-</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>distance_cache</name><index>[<expr><literal type="number">13</literal></expr>]</index></name> <operator>=</operator> <name>next_last_distance</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>distance_cache</name><index>[<expr><literal type="number">14</literal></expr>]</index></name> <operator>=</operator> <name>next_last_distance</name> <operator>-</operator> <literal type="number">3</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>distance_cache</name><index>[<expr><literal type="number">15</literal></expr>]</index></name> <operator>=</operator> <name>next_last_distance</name> <operator>+</operator> <literal type="number">3</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_LITERAL_BYTE_SCORE</name></cpp:macro> <cpp:value>135</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_DISTANCE_BIT_PENALTY</name></cpp:macro> <cpp:value>30</cpp:value></cpp:define>
<comment type="block">/* Score must be positive after applying maximal penalty. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_SCORE_BASE</name></cpp:macro> <cpp:value>(BROTLI_DISTANCE_BIT_PENALTY * 8 * sizeof(size_t))</cpp:value></cpp:define>

<comment type="block">/* Usually, we always choose the longest backward reference. This function
   allows for the exception of that rule.

   If we choose a backward reference that is further away, it will
   usually be coded with more bits. We approximate this by assuming
   log2(distance). If the distance can be expressed in terms of the
   last four distances, we use some heuristic constants to estimate
   the bits cost. For the first up to four literals we use the bit
   cost of the literals from the literal cost model, after that we
   use the average bit cost of the cost model.

   This function is used to sometimes discard a longer backward reference
   when it is not much longer and the bit cost for encoding it is more
   than the saved literals.

   backward_reference_offset MUST be positive. */</comment>
<function><type><specifier>static</specifier> <name>BROTLI_INLINE</name> <name>score_t</name></type> <name>BackwardReferenceScore</name><parameter_list>(
    <parameter><decl><type><name>size_t</name></type> <name>copy_length</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>backward_reference_offset</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><name>BROTLI_SCORE_BASE</name> <operator>+</operator> <name>BROTLI_LITERAL_BYTE_SCORE</name> <operator>*</operator> <operator>(</operator><name>score_t</name><operator>)</operator><name>copy_length</name> <operator>-</operator>
      <name>BROTLI_DISTANCE_BIT_PENALTY</name> <operator>*</operator> <call><name>Log2FloorNonZero</name><argument_list>(<argument><expr><name>backward_reference_offset</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BROTLI_INLINE</name> <name>score_t</name></type> <name>BackwardReferenceScoreUsingLastDistance</name><parameter_list>(
    <parameter><decl><type><name>size_t</name></type> <name>copy_length</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><name>BROTLI_LITERAL_BYTE_SCORE</name> <operator>*</operator> <operator>(</operator><name>score_t</name><operator>)</operator><name>copy_length</name> <operator>+</operator>
      <name>BROTLI_SCORE_BASE</name> <operator>+</operator> <literal type="number">15</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BROTLI_INLINE</name> <name>score_t</name></type> <name>BackwardReferencePenaltyUsingLastDistance</name><parameter_list>(
    <parameter><decl><type><name>size_t</name></type> <name>distance_short_code</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><operator>(</operator><name>score_t</name><operator>)</operator><literal type="number">39</literal> <operator>+</operator> <operator>(</operator><operator>(</operator><literal type="number">0x1CA10</literal> <operator>&gt;&gt;</operator> <operator>(</operator><name>distance_short_code</name> <operator>&amp;</operator> <literal type="number">0xE</literal><operator>)</operator><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xE</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BROTLI_INLINE</name> <name>BROTLI_BOOL</name></type> <name>TestStaticDictionaryItem</name><parameter_list>(
    <parameter><decl><type><specifier>const</specifier> <name>BrotliEncoderDictionary</name><modifier>*</modifier></type> <name>dictionary</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>word_idx</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name><modifier>*</modifier></type> <name>data</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>max_length</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>max_backward</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>max_distance</name></decl></parameter>, <parameter><decl><type><name>HasherSearchResult</name><modifier>*</modifier></type> <name>out</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>size_t</name></type> <name>offset</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>matchlen</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>backward</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>score_t</name></type> <name>score</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>offset</name> <operator>=</operator> <name><name>dictionary</name><operator>-&gt;</operator><name>words</name><operator>-&gt;</operator><name>offsets_by_length</name><index>[<expr><name>len</name></expr>]</index></name> <operator>+</operator> <name>len</name> <operator>*</operator> <name>word_idx</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name>max_length</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>BROTLI_FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>matchlen</name> <operator>=</operator>
      <call><name>FindMatchLengthWithLimit</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dictionary</name><operator>-&gt;</operator><name>words</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>offset</name></expr>]</index></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>matchlen</name> <operator>+</operator> <name><name>dictionary</name><operator>-&gt;</operator><name>cutoffTransformsCount</name></name> <operator>&lt;=</operator> <name>len</name> <operator>||</operator> <name>matchlen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>BROTLI_FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>cut</name> <init>= <expr><name>len</name> <operator>-</operator> <name>matchlen</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>transform_id</name> <init>= <expr><operator>(</operator><name>cut</name> <operator>&lt;&lt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>+</operator>
        <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><operator>(</operator><name><name>dictionary</name><operator>-&gt;</operator><name>cutoffTransforms</name></name> <operator>&gt;&gt;</operator> <operator>(</operator><name>cut</name> <operator>*</operator> <literal type="number">6</literal><operator>)</operator><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3F</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>backward</name> <operator>=</operator> <name>max_backward</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>word_idx</name> <operator>+</operator>
        <operator>(</operator><name>transform_id</name> <operator>&lt;&lt;</operator> <name><name>dictionary</name><operator>-&gt;</operator><name>words</name><operator>-&gt;</operator><name>size_bits_by_length</name><index>[<expr><name>len</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block>
  <if_stmt><if>if <condition>(<expr><name>backward</name> <operator>&gt;</operator> <name>max_distance</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>BROTLI_FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>score</name> <operator>=</operator> <call><name>BackwardReferenceScore</name><argument_list>(<argument><expr><name>matchlen</name></expr></argument>, <argument><expr><name>backward</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>score</name> <operator>&lt;</operator> <name><name>out</name><operator>-&gt;</operator><name>score</name></name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>BROTLI_FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name>matchlen</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>len_code_delta</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>len</name> <operator>-</operator> <operator>(</operator><name>int</name><operator>)</operator><name>matchlen</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>distance</name></name> <operator>=</operator> <name>backward</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>score</name></name> <operator>=</operator> <name>score</name></expr>;</expr_stmt>
  <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BROTLI_INLINE</name> <name>void</name></type> <name>SearchInStaticDictionary</name><parameter_list>(
    <parameter><decl><type><specifier>const</specifier> <name>BrotliEncoderDictionary</name><modifier>*</modifier></type> <name>dictionary</name></decl></parameter>,
    <parameter><decl><type><name>HasherCommon</name><modifier>*</modifier></type> <name>common</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name><modifier>*</modifier></type> <name>data</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>max_length</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>max_backward</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>max_distance</name></decl></parameter>,
    <parameter><decl><type><name>HasherSearchResult</name><modifier>*</modifier></type> <name>out</name></decl></parameter>, <parameter><decl><type><name>BROTLI_BOOL</name></type> <name>shallow</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>size_t</name></type> <name>key</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>dict_num_matches</name></name> <operator>&lt;</operator> <operator>(</operator><name><name>common</name><operator>-&gt;</operator><name>dict_num_lookups</name></name> <operator>&gt;&gt;</operator> <literal type="number">7</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>key</name> <operator>=</operator> <call><name>Hash14</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><ternary><condition><expr><name>shallow</name></expr> ?</condition><then> <expr><literal type="number">1u</literal></expr> </then><else>: <expr><literal type="number">2u</literal></expr></else></ternary><operator>)</operator></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr><operator>,</operator> <expr><operator>++</operator><name>key</name></expr></incr>)</control> <block>{<block_content>
    <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>dict_num_lookups</name></name><operator>++</operator></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>dictionary</name><operator>-&gt;</operator><name>hash_table_lengths</name><index>[<expr><name>key</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>BROTLI_BOOL</name></type> <name>item_matches</name> <init>= <expr><call><name>TestStaticDictionaryItem</name><argument_list>(
          <argument><expr><name>dictionary</name></expr></argument>, <argument><expr><name><name>dictionary</name><operator>-&gt;</operator><name>hash_table_lengths</name><index>[<expr><name>key</name></expr>]</index></name></expr></argument>,
          <argument><expr><name><name>dictionary</name><operator>-&gt;</operator><name>hash_table_words</name><index>[<expr><name>key</name></expr>]</index></name></expr></argument>, <argument><expr><name>data</name></expr></argument>,
          <argument><expr><name>max_length</name></expr></argument>, <argument><expr><name>max_backward</name></expr></argument>, <argument><expr><name>max_distance</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>item_matches</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>dict_num_matches</name></name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <name>BackwardMatch</name> <block>{
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>distance</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>length_and_code</name></decl>;</decl_stmt>
}</block></struct></type> <name>BackwardMatch</name>;</typedef>

<function><type><specifier>static</specifier> <name>BROTLI_INLINE</name> <name>void</name></type> <name>InitBackwardMatch</name><parameter_list>(<parameter><decl><type><name>BackwardMatch</name><modifier>*</modifier></type> <name>self</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>dist</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>distance</name></name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>dist</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>length_and_code</name></name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>len</name> <operator>&lt;&lt;</operator> <literal type="number">5</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BROTLI_INLINE</name> <name>void</name></type> <name>InitDictionaryBackwardMatch</name><parameter_list>(<parameter><decl><type><name>BackwardMatch</name><modifier>*</modifier></type> <name>self</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>dist</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len_code</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>distance</name></name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>dist</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>length_and_code</name></name> <operator>=</operator>
      <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><operator>(</operator><name>len</name> <operator>&lt;&lt;</operator> <literal type="number">5</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><ternary><condition><expr><name>len</name> <operator>==</operator> <name>len_code</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>len_code</name></expr></else></ternary><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BROTLI_INLINE</name> <name>size_t</name></type> <name>BackwardMatchLength</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BackwardMatch</name><modifier>*</modifier></type> <name>self</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><name><name>self</name><operator>-&gt;</operator><name>length_and_code</name></name> <operator>&gt;&gt;</operator> <literal type="number">5</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BROTLI_INLINE</name> <name>size_t</name></type> <name>BackwardMatchLengthCode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BackwardMatch</name><modifier>*</modifier></type> <name>self</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>size_t</name></type> <name>code</name> <init>= <expr><name><name>self</name><operator>-&gt;</operator><name>length_and_code</name></name> <operator>&amp;</operator> <literal type="number">31</literal></expr></init></decl>;</decl_stmt>
  <return>return <expr><ternary><condition><expr><name>code</name></expr> ?</condition><then> <expr><name>code</name></expr> </then><else>: <expr><call><name>BackwardMatchLength</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPAND_CAT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>CAT(a, b)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CAT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>a ## b</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FN</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>EXPAND_CAT(X, HASHER())</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASHER</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>H10</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BUCKET_BITS</name></cpp:macro> <cpp:value>17</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_TREE_SEARCH_DEPTH</name></cpp:macro> <cpp:value>64</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_TREE_COMP_LENGTH</name></cpp:macro> <cpp:value>128</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hash_to_binary_tree_inc.h"</cpp:file></cpp:include>  <comment type="block">/* NOLINT(build/include) */</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>MAX_TREE_SEARCH_DEPTH</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>MAX_TREE_COMP_LENGTH</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BUCKET_BITS</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>HASHER</name></cpp:undef>
<comment type="block">/* MAX_NUM_MATCHES == 64 + MAX_TREE_SEARCH_DEPTH */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_NUM_MATCHES_H10</name></cpp:macro> <cpp:value>128</cpp:value></cpp:define>

<comment type="block">/* For BUCKET_SWEEP_BITS == 0, enabling the dictionary lookup makes compression
   a little faster (0.5% - 1%) and it compresses 0.15% better on small text
   and HTML inputs. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASHER</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>H2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BUCKET_BITS</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BUCKET_SWEEP_BITS</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_LEN</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_DICTIONARY</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hash_longest_match_quickly_inc.h"</cpp:file></cpp:include>  <comment type="block">/* NOLINT(build/include) */</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BUCKET_SWEEP_BITS</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>USE_DICTIONARY</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>HASHER</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASHER</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>H3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BUCKET_SWEEP_BITS</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_DICTIONARY</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hash_longest_match_quickly_inc.h"</cpp:file></cpp:include>  <comment type="block">/* NOLINT(build/include) */</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>USE_DICTIONARY</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BUCKET_SWEEP_BITS</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BUCKET_BITS</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>HASHER</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASHER</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>H4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BUCKET_BITS</name></cpp:macro> <cpp:value>17</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BUCKET_SWEEP_BITS</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_DICTIONARY</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hash_longest_match_quickly_inc.h"</cpp:file></cpp:include>  <comment type="block">/* NOLINT(build/include) */</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>USE_DICTIONARY</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>HASH_LEN</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BUCKET_SWEEP_BITS</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BUCKET_BITS</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>HASHER</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASHER</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>H5</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hash_longest_match_inc.h"</cpp:file></cpp:include>  <comment type="block">/* NOLINT(build/include) */</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>HASHER</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASHER</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>H6</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hash_longest_match64_inc.h"</cpp:file></cpp:include>  <comment type="block">/* NOLINT(build/include) */</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>HASHER</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BUCKET_BITS</name></cpp:macro> <cpp:value>15</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_LAST_DISTANCES_TO_CHECK</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_BANKS</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BANK_BITS</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASHER</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>H40</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hash_forgetful_chain_inc.h"</cpp:file></cpp:include>  <comment type="block">/* NOLINT(build/include) */</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>HASHER</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>NUM_LAST_DISTANCES_TO_CHECK</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_LAST_DISTANCES_TO_CHECK</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASHER</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>H41</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hash_forgetful_chain_inc.h"</cpp:file></cpp:include>  <comment type="block">/* NOLINT(build/include) */</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>HASHER</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>NUM_LAST_DISTANCES_TO_CHECK</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>NUM_BANKS</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BANK_BITS</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_LAST_DISTANCES_TO_CHECK</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_BANKS</name></cpp:macro> <cpp:value>512</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BANK_BITS</name></cpp:macro> <cpp:value>9</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASHER</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>H42</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hash_forgetful_chain_inc.h"</cpp:file></cpp:include>  <comment type="block">/* NOLINT(build/include) */</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>HASHER</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>NUM_LAST_DISTANCES_TO_CHECK</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>NUM_BANKS</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BANK_BITS</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BUCKET_BITS</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASHER</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>H54</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BUCKET_BITS</name></cpp:macro> <cpp:value>20</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BUCKET_SWEEP_BITS</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_LEN</name></cpp:macro> <cpp:value>7</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_DICTIONARY</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hash_longest_match_quickly_inc.h"</cpp:file></cpp:include>  <comment type="block">/* NOLINT(build/include) */</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>USE_DICTIONARY</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>HASH_LEN</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BUCKET_SWEEP_BITS</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BUCKET_BITS</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>HASHER</name></cpp:undef>

<comment type="block">/* fast large window hashers */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASHER</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>HROLLING_FAST</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHUNKLEN</name></cpp:macro> <cpp:value>32</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JUMP</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUMBUCKETS</name></cpp:macro> <cpp:value>16777216</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MASK</name></cpp:macro> <cpp:value>((NUMBUCKETS * 64) - 1)</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hash_rolling_inc.h"</cpp:file></cpp:include>  <comment type="block">/* NOLINT(build/include) */</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>JUMP</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>HASHER</name></cpp:undef>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASHER</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>HROLLING</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JUMP</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hash_rolling_inc.h"</cpp:file></cpp:include>  <comment type="block">/* NOLINT(build/include) */</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>MASK</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>NUMBUCKETS</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>JUMP</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CHUNKLEN</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>HASHER</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASHER</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>H35</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASHER_A</name></cpp:macro> <cpp:value>H3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASHER_B</name></cpp:macro> <cpp:value>HROLLING_FAST</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hash_composite_inc.h"</cpp:file></cpp:include>  <comment type="block">/* NOLINT(build/include) */</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>HASHER_A</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>HASHER_B</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>HASHER</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASHER</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>H55</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASHER_A</name></cpp:macro> <cpp:value>H54</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASHER_B</name></cpp:macro> <cpp:value>HROLLING_FAST</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hash_composite_inc.h"</cpp:file></cpp:include>  <comment type="block">/* NOLINT(build/include) */</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>HASHER_A</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>HASHER_B</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>HASHER</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASHER</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>H65</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASHER_A</name></cpp:macro> <cpp:value>H6</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASHER_B</name></cpp:macro> <cpp:value>HROLLING</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hash_composite_inc.h"</cpp:file></cpp:include>  <comment type="block">/* NOLINT(build/include) */</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>HASHER_A</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>HASHER_B</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>HASHER</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>FN</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CAT</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>EXPAND_CAT</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FOR_SIMPLE_HASHERS</name><parameter_list>(<parameter><type><name>H</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>H(2) H(3) H(4) H(5) H(6) H(40) H(41) H(42) H(54)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FOR_COMPOSITE_HASHERS</name><parameter_list>(<parameter><type><name>H</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>H(35) H(55) H(65)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FOR_GENERIC_HASHERS</name><parameter_list>(<parameter><type><name>H</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>FOR_SIMPLE_HASHERS(H) FOR_COMPOSITE_HASHERS(H)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FOR_ALL_HASHERS</name><parameter_list>(<parameter><type><name>H</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>FOR_GENERIC_HASHERS(H) H(10)</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <block>{
  <decl_stmt><decl><type><name>HasherCommon</name></type> <name>common</name></decl>;</decl_stmt>

  <union>union <block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MEMBER_</name><parameter_list>(<parameter><type><name>N</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>H ## N _H ## N;</cpp:value></cpp:define>
    <macro><name>FOR_ALL_HASHERS</name><argument_list>(<argument>MEMBER_</argument>)</argument_list></macro>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>MEMBER_</name></cpp:undef>
  }</block> <decl><name>privat</name></decl>;</union>
}</block></struct></type> <name>Hasher</name>;</typedef>

<comment type="block">/* MUST be invoked before any other method. */</comment>
<function><type><specifier>static</specifier> <name>BROTLI_INLINE</name> <name>void</name></type> <name>HasherInit</name><parameter_list>(<parameter><decl><type><name>Hasher</name><modifier>*</modifier></type> <name>hasher</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name><name>hasher</name><operator>-&gt;</operator><name>common</name><operator>.</operator><name>is_setup_</name></name> <operator>=</operator> <name>BROTLI_FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hasher</name><operator>-&gt;</operator><name>common</name><operator>.</operator><name>extra</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hasher</name><operator>-&gt;</operator><name>common</name><operator>.</operator><name>extra</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hasher</name><operator>-&gt;</operator><name>common</name><operator>.</operator><name>extra</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hasher</name><operator>-&gt;</operator><name>common</name><operator>.</operator><name>extra</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BROTLI_INLINE</name> <name>void</name></type> <name>DestroyHasher</name><parameter_list>(<parameter><decl><type><name>MemoryManager</name><modifier>*</modifier></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>Hasher</name><modifier>*</modifier></type> <name>hasher</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>hasher</name><operator>-&gt;</operator><name>common</name><operator>.</operator><name>extra</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>BROTLI_FREE</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name><name>hasher</name><operator>-&gt;</operator><name>common</name><operator>.</operator><name>extra</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>hasher</name><operator>-&gt;</operator><name>common</name><operator>.</operator><name>extra</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>BROTLI_FREE</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name><name>hasher</name><operator>-&gt;</operator><name>common</name><operator>.</operator><name>extra</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>hasher</name><operator>-&gt;</operator><name>common</name><operator>.</operator><name>extra</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>BROTLI_FREE</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name><name>hasher</name><operator>-&gt;</operator><name>common</name><operator>.</operator><name>extra</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>hasher</name><operator>-&gt;</operator><name>common</name><operator>.</operator><name>extra</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>BROTLI_FREE</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name><name>hasher</name><operator>-&gt;</operator><name>common</name><operator>.</operator><name>extra</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BROTLI_INLINE</name> <name>void</name></type> <name>HasherReset</name><parameter_list>(<parameter><decl><type><name>Hasher</name><modifier>*</modifier></type> <name>hasher</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name><name>hasher</name><operator>-&gt;</operator><name>common</name><operator>.</operator><name>is_prepared_</name></name> <operator>=</operator> <name>BROTLI_FALSE</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BROTLI_INLINE</name> <name>void</name></type> <name>HasherSize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BrotliEncoderParams</name><modifier>*</modifier></type> <name>params</name></decl></parameter>,
    <parameter><decl><type><name>BROTLI_BOOL</name></type> <name>one_shot</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>input_size</name></decl></parameter>, <parameter><decl><type><name>size_t</name><modifier>*</modifier></type> <name>alloc_size</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <switch>switch <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>hasher</name><operator>.</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIZE_</name><parameter_list>(<parameter><type><name>N</name></type></parameter>)</parameter_list></cpp:macro>                                                           \
    <cpp:value>case N:                                                                \
      HashMemAllocInBytesH ## N(params, one_shot, input_size, alloc_size); \
      break;</cpp:value></cpp:define>
    <macro><name>FOR_ALL_HASHERS</name><argument_list>(<argument>SIZE_</argument>)</argument_list></macro>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SIZE_</name></cpp:undef>
    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BROTLI_INLINE</name> <name>void</name></type> <name>HasherSetup</name><parameter_list>(<parameter><decl><type><name>MemoryManager</name><modifier>*</modifier></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>Hasher</name><modifier>*</modifier></type> <name>hasher</name></decl></parameter>,
    <parameter><decl><type><name>BrotliEncoderParams</name><modifier>*</modifier></type> <name>params</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name><modifier>*</modifier></type> <name>data</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>position</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>input_size</name></decl></parameter>, <parameter><decl><type><name>BROTLI_BOOL</name></type> <name>is_last</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>BROTLI_BOOL</name></type> <name>one_shot</name> <init>= <expr><operator>(</operator><name>position</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>is_last</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>hasher</name><operator>-&gt;</operator><name>common</name><operator>.</operator><name>is_setup_</name></name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name><name>alloc_size</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>ChooseHasher</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>params</name><operator>-&gt;</operator><name>hasher</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hasher</name><operator>-&gt;</operator><name>common</name><operator>.</operator><name>params</name></name> <operator>=</operator> <name><name>params</name><operator>-&gt;</operator><name>hasher</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hasher</name><operator>-&gt;</operator><name>common</name><operator>.</operator><name>dict_num_lookups</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hasher</name><operator>-&gt;</operator><name>common</name><operator>.</operator><name>dict_num_matches</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>HasherSize</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><name>one_shot</name></expr></argument>, <argument><expr><name>input_size</name></expr></argument>, <argument><expr><name>alloc_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>alloc_size</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>hasher</name><operator>-&gt;</operator><name>common</name><operator>.</operator><name>extra</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>BROTLI_ALLOC</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>uint8_t</name></expr></argument>, <argument><expr><name><name>alloc_size</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>BROTLI_IS_OOM</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>BROTLI_IS_NULL</name><argument_list>(<argument><expr><name><name>hasher</name><operator>-&gt;</operator><name>common</name><operator>.</operator><name>extra</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <switch>switch <condition>(<expr><name><name>hasher</name><operator>-&gt;</operator><name>common</name><operator>.</operator><name>params</name><operator>.</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INITIALIZE_</name><parameter_list>(<parameter><type><name>N</name></type></parameter>)</parameter_list></cpp:macro>                        \
      <cpp:value>case N:                                 \
        InitializeH ## N(&amp;hasher-&gt;common,     \
            &amp;hasher-&gt;privat._H ## N, params); \
        break;</cpp:value></cpp:define>
      <expr_stmt><expr><call><name>FOR_ALL_HASHERS</name><argument_list>(<argument><expr><name>INITIALIZE_</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>INITIALIZE_</name></cpp:undef>
      <default>default:</default>
        <break>break;</break>
    </block_content>}</block></switch>
    <expr_stmt><expr><call><name>HasherReset</name><argument_list>(<argument><expr><name>hasher</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hasher</name><operator>-&gt;</operator><name>common</name><operator>.</operator><name>is_setup_</name></name> <operator>=</operator> <name>BROTLI_TRUE</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>hasher</name><operator>-&gt;</operator><name>common</name><operator>.</operator><name>is_prepared_</name></name></expr>)</condition> <block>{<block_content>
    <switch>switch <condition>(<expr><name><name>hasher</name><operator>-&gt;</operator><name>common</name><operator>.</operator><name>params</name><operator>.</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PREPARE_</name><parameter_list>(<parameter><type><name>N</name></type></parameter>)</parameter_list></cpp:macro>                      \
      <cpp:value>case N:                            \
        PrepareH ## N(                   \
            &amp;hasher-&gt;privat._H ## N,     \
            one_shot, input_size, data); \
        break;</cpp:value></cpp:define>
      <macro><name>FOR_ALL_HASHERS</name><argument_list>(<argument>PREPARE_</argument>)</argument_list></macro>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PREPARE_</name></cpp:undef>
      <default>default:</default> <break>break;</break>
    </block_content>}</block></switch>
    <expr_stmt><expr><name><name>hasher</name><operator>-&gt;</operator><name>common</name><operator>.</operator><name>is_prepared_</name></name> <operator>=</operator> <name>BROTLI_TRUE</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BROTLI_INLINE</name> <name>void</name></type> <name>InitOrStitchToPreviousBlock</name><parameter_list>(
    <parameter><decl><type><name>MemoryManager</name><modifier>*</modifier></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>Hasher</name><modifier>*</modifier></type> <name>hasher</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name><modifier>*</modifier></type> <name>data</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>mask</name></decl></parameter>,
    <parameter><decl><type><name>BrotliEncoderParams</name><modifier>*</modifier></type> <name>params</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>position</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>input_size</name></decl></parameter>,
    <parameter><decl><type><name>BROTLI_BOOL</name></type> <name>is_last</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>HasherSetup</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>hasher</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>position</name></expr></argument>, <argument><expr><name>input_size</name></expr></argument>, <argument><expr><name>is_last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>BROTLI_IS_OOM</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <switch>switch <condition>(<expr><name><name>hasher</name><operator>-&gt;</operator><name>common</name><operator>.</operator><name>params</name><operator>.</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INIT_</name><parameter_list>(<parameter><type><name>N</name></type></parameter>)</parameter_list></cpp:macro>                             \
    <cpp:value>case N:                                  \
      StitchToPreviousBlockH ## N(           \
          &amp;hasher-&gt;privat._H ## N,           \
          input_size, position, data, mask); \
    break;</cpp:value></cpp:define>
    <macro><name>FOR_ALL_HASHERS</name><argument_list>(<argument>INIT_</argument>)</argument_list></macro>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>INIT_</name></cpp:undef>
    <default>default:</default> <break>break;</break>
  </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/* NB: when seamless dictionary-ring-buffer copies are implemented, don't forget
       to add proper guards for non-zero-BROTLI_PARAM_STREAM_OFFSET. */</comment>
<function><type><specifier>static</specifier> <name>BROTLI_INLINE</name> <name>void</name></type> <name>FindCompoundDictionaryMatch</name><parameter_list>(
    <parameter><decl><type><specifier>const</specifier> <name>PreparedDictionary</name><modifier>*</modifier></type> <name>self</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name><modifier>*</modifier> <name>BROTLI_RESTRICT</name></type> <name>data</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>ring_buffer_mask</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name><modifier>*</modifier> <name>BROTLI_RESTRICT</name></type> <name>distance_cache</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>cur_ix</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>max_length</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>distance_offset</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>max_distance</name></decl></parameter>, <parameter><decl><type><name>HasherSearchResult</name><modifier>*</modifier> <name>BROTLI_RESTRICT</name></type> <name>out</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>source_size</name> <init>= <expr><name><name>self</name><operator>-&gt;</operator><name>source_size</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>boundary</name> <init>= <expr><name>distance_offset</name> <operator>-</operator> <name>source_size</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>hash_bits</name> <init>= <expr><name><name>self</name><operator>-&gt;</operator><name>hash_bits</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>bucket_bits</name> <init>= <expr><name><name>self</name><operator>-&gt;</operator><name>bucket_bits</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>slot_bits</name> <init>= <expr><name><name>self</name><operator>-&gt;</operator><name>slot_bits</name></name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>hash_shift</name> <init>= <expr><literal type="number">64u</literal> <operator>-</operator> <name>bucket_bits</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>slot_mask</name> <init>= <expr><operator>(</operator><operator>~</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><literal type="number">0U</literal><operator>)</operator><operator>)</operator> <operator>&gt;&gt;</operator> <operator>(</operator><literal type="number">32</literal> <operator>-</operator> <name>slot_bits</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>uint64_t</name></type> <name>hash_mask</name> <init>= <expr><operator>(</operator><operator>~</operator><operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><literal type="number">0U</literal><operator>)</operator><operator>)</operator> <operator>&gt;&gt;</operator> <operator>(</operator><literal type="number">64</literal> <operator>-</operator> <name>hash_bits</name><operator>)</operator></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name><modifier>*</modifier></type> <name>slot_offsets</name> <init>= <expr><operator>(</operator><name>uint32_t</name><operator>*</operator><operator>)</operator><operator>(</operator><operator>&amp;</operator><name><name>self</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>uint16_t</name><modifier>*</modifier></type> <name>heads</name> <init>= <expr><operator>(</operator><name>uint16_t</name><operator>*</operator><operator>)</operator><operator>(</operator><operator>&amp;</operator><name><name>slot_offsets</name><index>[<expr><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <name>slot_bits</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name><modifier>*</modifier></type> <name>items</name> <init>= <expr><operator>(</operator><name>uint32_t</name><operator>*</operator><operator>)</operator><operator>(</operator><operator>&amp;</operator><name><name>heads</name><index>[<expr><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <name>bucket_bits</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name><modifier>*</modifier></type> <name>source</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>cur_ix_masked</name> <init>= <expr><name>cur_ix</name> <operator>&amp;</operator> <name>ring_buffer_mask</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>score_t</name></type> <name>best_score</name> <init>= <expr><name><name>out</name><operator>-&gt;</operator><name>score</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>best_len</name> <init>= <expr><name><name>out</name><operator>-&gt;</operator><name>len</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>uint64_t</name></type> <name>h</name> <init>=
      <expr><operator>(</operator><call><name>BROTLI_UNALIGNED_LOAD64LE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>cur_ix_masked</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>hash_mask</name><operator>)</operator> <operator>*</operator>
      <name>kPreparedDictionaryHashMul64Long</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>key</name> <init>= <expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>h</name> <operator>&gt;&gt;</operator> <name>hash_shift</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>slot</name> <init>= <expr><name>key</name> <operator>&amp;</operator> <name>slot_mask</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>head</name> <init>= <expr><name><name>heads</name><index>[<expr><name>key</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name><modifier>*</modifier> <name>BROTLI_RESTRICT</name></type> <name>chain</name> <init>= <expr><operator>&amp;</operator><name><name>items</name><index>[<expr><name><name>slot_offsets</name><index>[<expr><name>slot</name></expr>]</index></name> <operator>+</operator> <name>head</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>item</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>head</name> <operator>==</operator> <literal type="number">0xFFFF</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>tail</name> <init>= <expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>items</name><index>[<expr><name><name>self</name><operator>-&gt;</operator><name>num_items</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>self</name><operator>-&gt;</operator><name>magic</name></name> <operator>==</operator> <name>kPreparedDictionaryMagic</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>source</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>uint8_t</name><operator>*</operator><operator>)</operator><name>tail</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <comment type="block">/* kLeanPreparedDictionaryMagic */</comment>
    <expr_stmt><expr><name>source</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>uint8_t</name><operator>*</operator><operator>)</operator><call><name>BROTLI_UNALIGNED_LOAD_PTR</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>uint8_t</name><operator>*</operator><operator>*</operator><operator>)</operator><name>tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>distance</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><name><name>distance_cache</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>offset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>limit</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>distance</name> <operator>&lt;=</operator> <name>boundary</name> <operator>||</operator> <name>distance</name> <operator>&gt;</operator> <name>distance_offset</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>offset</name> <operator>=</operator> <name>distance_offset</name> <operator>-</operator> <name>distance</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>limit</name> <operator>=</operator> <name>source_size</name> <operator>-</operator> <name>offset</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>limit</name> <operator>=</operator> <ternary><condition><expr><name>limit</name> <operator>&gt;</operator> <name>max_length</name></expr> ?</condition><then> <expr><name>max_length</name></expr> </then><else>: <expr><name>limit</name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>FindMatchLengthWithLimit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>source</name><index>[<expr><name>offset</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>cur_ix_masked</name></expr>]</index></name></expr></argument>,
                                   <argument><expr><name>limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>score_t</name></type> <name>score</name> <init>= <expr><call><name>BackwardReferenceScoreUsingLastDistance</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>best_score</name> <operator>&lt;</operator> <name>score</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>score</name> <operator>-=</operator> <call><name>BackwardReferencePenaltyUsingLastDistance</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>best_score</name> <operator>&lt;</operator> <name>score</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>best_score</name> <operator>=</operator> <name>score</name></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name>best_len</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>best_len</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>len_code_delta</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>distance</name></name> <operator>=</operator> <name>distance</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>score</name></name> <operator>=</operator> <name>best_score</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <while>while <condition>(<expr><name>item</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>offset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>distance</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>limit</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>item</name> <operator>=</operator> <operator>*</operator><name>chain</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>chain</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>offset</name> <operator>=</operator> <name>item</name> <operator>&amp;</operator> <literal type="number">0x7FFFFFFF</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>item</name> <operator>&amp;=</operator> <literal type="number">0x80000000</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>distance</name> <operator>=</operator> <name>distance_offset</name> <operator>-</operator> <name>offset</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>limit</name> <operator>=</operator> <name>source_size</name> <operator>-</operator> <name>offset</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>limit</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>limit</name> <operator>&gt;</operator> <name>max_length</name><operator>)</operator></expr> ?</condition><then> <expr><name>max_length</name></expr> </then><else>: <expr><name>limit</name></expr></else></ternary></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>distance</name> <operator>&gt;</operator> <name>max_distance</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>cur_ix_masked</name> <operator>+</operator> <name>best_len</name> <operator>&gt;</operator> <name>ring_buffer_mask</name> <operator>||</operator>
        <name>best_len</name> <operator>&gt;=</operator> <name>limit</name> <operator>||</operator>
        <name><name>data</name><index>[<expr><name>cur_ix_masked</name> <operator>+</operator> <name>best_len</name></expr>]</index></name> <operator>!=</operator> <name><name>source</name><index>[<expr><name>offset</name> <operator>+</operator> <name>best_len</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>len</name> <init>= <expr><call><name>FindMatchLengthWithLimit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>source</name><index>[<expr><name>offset</name></expr>]</index></name></expr></argument>,
                                                  <argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>cur_ix_masked</name></expr>]</index></name></expr></argument>,
                                                  <argument><expr><name>limit</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;=</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>score_t</name></type> <name>score</name> <init>= <expr><call><name>BackwardReferenceScore</name><argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><name>distance</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>best_score</name> <operator>&lt;</operator> <name>score</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>best_score</name> <operator>=</operator> <name>score</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>best_len</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name>best_len</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>len_code_delta</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>distance</name></name> <operator>=</operator> <name>distance</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>score</name></name> <operator>=</operator> <name>best_score</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block>
  </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/* NB: when seamless dictionary-ring-buffer copies are implemented, don't forget
       to add proper guards for non-zero-BROTLI_PARAM_STREAM_OFFSET. */</comment>
<function><type><specifier>static</specifier> <name>BROTLI_INLINE</name> <name>size_t</name></type> <name>FindAllCompoundDictionaryMatches</name><parameter_list>(
    <parameter><decl><type><specifier>const</specifier> <name>PreparedDictionary</name><modifier>*</modifier></type> <name>self</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name><modifier>*</modifier> <name>BROTLI_RESTRICT</name></type> <name>data</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>ring_buffer_mask</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>cur_ix</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>min_length</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>max_length</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>distance_offset</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>max_distance</name></decl></parameter>, <parameter><decl><type><name>BackwardMatch</name><modifier>*</modifier></type> <name>matches</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>match_limit</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>source_size</name> <init>= <expr><name><name>self</name><operator>-&gt;</operator><name>source_size</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>hash_bits</name> <init>= <expr><name><name>self</name><operator>-&gt;</operator><name>hash_bits</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>bucket_bits</name> <init>= <expr><name><name>self</name><operator>-&gt;</operator><name>bucket_bits</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>slot_bits</name> <init>= <expr><name><name>self</name><operator>-&gt;</operator><name>slot_bits</name></name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>hash_shift</name> <init>= <expr><literal type="number">64u</literal> <operator>-</operator> <name>bucket_bits</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>slot_mask</name> <init>= <expr><operator>(</operator><operator>~</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><literal type="number">0U</literal><operator>)</operator><operator>)</operator> <operator>&gt;&gt;</operator> <operator>(</operator><literal type="number">32</literal> <operator>-</operator> <name>slot_bits</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>uint64_t</name></type> <name>hash_mask</name> <init>= <expr><operator>(</operator><operator>~</operator><operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><literal type="number">0U</literal><operator>)</operator><operator>)</operator> <operator>&gt;&gt;</operator> <operator>(</operator><literal type="number">64</literal> <operator>-</operator> <name>hash_bits</name><operator>)</operator></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name><modifier>*</modifier></type> <name>slot_offsets</name> <init>= <expr><operator>(</operator><name>uint32_t</name><operator>*</operator><operator>)</operator><operator>(</operator><operator>&amp;</operator><name><name>self</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>uint16_t</name><modifier>*</modifier></type> <name>heads</name> <init>= <expr><operator>(</operator><name>uint16_t</name><operator>*</operator><operator>)</operator><operator>(</operator><operator>&amp;</operator><name><name>slot_offsets</name><index>[<expr><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <name>slot_bits</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name><modifier>*</modifier></type> <name>items</name> <init>= <expr><operator>(</operator><name>uint32_t</name><operator>*</operator><operator>)</operator><operator>(</operator><operator>&amp;</operator><name><name>heads</name><index>[<expr><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <name>bucket_bits</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name><modifier>*</modifier></type> <name>source</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>cur_ix_masked</name> <init>= <expr><name>cur_ix</name> <operator>&amp;</operator> <name>ring_buffer_mask</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>best_len</name> <init>= <expr><name>min_length</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>uint64_t</name></type> <name>h</name> <init>=
      <expr><operator>(</operator><call><name>BROTLI_UNALIGNED_LOAD64LE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>cur_ix_masked</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>hash_mask</name><operator>)</operator> <operator>*</operator>
      <name>kPreparedDictionaryHashMul64Long</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>key</name> <init>= <expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>h</name> <operator>&gt;&gt;</operator> <name>hash_shift</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>slot</name> <init>= <expr><name>key</name> <operator>&amp;</operator> <name>slot_mask</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>head</name> <init>= <expr><name><name>heads</name><index>[<expr><name>key</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name><modifier>*</modifier> <name>BROTLI_RESTRICT</name></type> <name>chain</name> <init>= <expr><operator>&amp;</operator><name><name>items</name><index>[<expr><name><name>slot_offsets</name><index>[<expr><name>slot</name></expr>]</index></name> <operator>+</operator> <name>head</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>item</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>head</name> <operator>==</operator> <literal type="number">0xFFFF</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>found</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>tail</name> <init>= <expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>items</name><index>[<expr><name><name>self</name><operator>-&gt;</operator><name>num_items</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>self</name><operator>-&gt;</operator><name>magic</name></name> <operator>==</operator> <name>kPreparedDictionaryMagic</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>source</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>uint8_t</name><operator>*</operator><operator>)</operator><name>tail</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <comment type="block">/* kLeanPreparedDictionaryMagic */</comment>
    <expr_stmt><expr><name>source</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>uint8_t</name><operator>*</operator><operator>)</operator><call><name>BROTLI_UNALIGNED_LOAD_PTR</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>uint8_t</name><operator>*</operator><operator>*</operator><operator>)</operator><name>tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <while>while <condition>(<expr><name>item</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>offset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>distance</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>limit</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>item</name> <operator>=</operator> <operator>*</operator><name>chain</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>chain</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>offset</name> <operator>=</operator> <name>item</name> <operator>&amp;</operator> <literal type="number">0x7FFFFFFF</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>item</name> <operator>&amp;=</operator> <literal type="number">0x80000000</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>distance</name> <operator>=</operator> <name>distance_offset</name> <operator>-</operator> <name>offset</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>limit</name> <operator>=</operator> <name>source_size</name> <operator>-</operator> <name>offset</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>limit</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>limit</name> <operator>&gt;</operator> <name>max_length</name><operator>)</operator></expr> ?</condition><then> <expr><name>max_length</name></expr> </then><else>: <expr><name>limit</name></expr></else></ternary></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>distance</name> <operator>&gt;</operator> <name>max_distance</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>cur_ix_masked</name> <operator>+</operator> <name>best_len</name> <operator>&gt;</operator> <name>ring_buffer_mask</name> <operator>||</operator>
        <name>best_len</name> <operator>&gt;=</operator> <name>limit</name> <operator>||</operator>
        <name><name>data</name><index>[<expr><name>cur_ix_masked</name> <operator>+</operator> <name>best_len</name></expr>]</index></name> <operator>!=</operator> <name><name>source</name><index>[<expr><name>offset</name> <operator>+</operator> <name>best_len</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>FindMatchLengthWithLimit</name><argument_list>(
        <argument><expr><operator>&amp;</operator><name><name>source</name><index>[<expr><name>offset</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>cur_ix_masked</name></expr>]</index></name></expr></argument>, <argument><expr><name>limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name>best_len</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>best_len</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>InitBackwardMatch</name><argument_list>(<argument><expr><name>matches</name><operator>++</operator></expr></argument>, <argument><expr><name>distance</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>found</name><operator>++</operator></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>found</name> <operator>==</operator> <name>match_limit</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>
  <return>return <expr><name>found</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BROTLI_INLINE</name> <name>void</name></type> <name>LookupCompoundDictionaryMatch</name><parameter_list>(
    <parameter><decl><type><specifier>const</specifier> <name>CompoundDictionary</name><modifier>*</modifier></type> <name>addon</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name><modifier>*</modifier> <name>BROTLI_RESTRICT</name></type> <name>data</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>ring_buffer_mask</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name><modifier>*</modifier> <name>BROTLI_RESTRICT</name></type> <name>distance_cache</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>cur_ix</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>max_length</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>max_ring_buffer_distance</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>max_distance</name></decl></parameter>,
    <parameter><decl><type><name>HasherSearchResult</name><modifier>*</modifier></type> <name>sr</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>size_t</name></type> <name>base_offset</name> <init>= <expr><name>max_ring_buffer_distance</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name><name>addon</name><operator>-&gt;</operator><name>total_size</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>d</name></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>d</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>d</name> <operator>&lt;</operator> <name><name>addon</name><operator>-&gt;</operator><name>num_chunks</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>d</name></expr></incr>)</control> <block>{<block_content>
    <comment type="block">/* Only one prepared dictionary type is currently supported. */</comment>
    <expr_stmt><expr><call><name>FindCompoundDictionaryMatch</name><argument_list>(
        <argument><expr><operator>(</operator><specifier>const</specifier> <name>PreparedDictionary</name><operator>*</operator><operator>)</operator><name><name>addon</name><operator>-&gt;</operator><name>chunks</name><index>[<expr><name>d</name></expr>]</index></name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>ring_buffer_mask</name></expr></argument>,
        <argument><expr><name>distance_cache</name></expr></argument>, <argument><expr><name>cur_ix</name></expr></argument>, <argument><expr><name>max_length</name></expr></argument>,
        <argument><expr><name>base_offset</name> <operator>-</operator> <name><name>addon</name><operator>-&gt;</operator><name>chunk_offsets</name><index>[<expr><name>d</name></expr>]</index></name></expr></argument>, <argument><expr><name>max_distance</name></expr></argument>, <argument><expr><name>sr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BROTLI_INLINE</name> <name>size_t</name></type> <name>LookupAllCompoundDictionaryMatches</name><parameter_list>(
    <parameter><decl><type><specifier>const</specifier> <name>CompoundDictionary</name><modifier>*</modifier></type> <name>addon</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name><modifier>*</modifier> <name>BROTLI_RESTRICT</name></type> <name>data</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>ring_buffer_mask</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>cur_ix</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>min_length</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>max_length</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>max_ring_buffer_distance</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>max_distance</name></decl></parameter>, <parameter><decl><type><name>BackwardMatch</name><modifier>*</modifier></type> <name>matches</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>match_limit</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>size_t</name></type> <name>base_offset</name> <init>= <expr><name>max_ring_buffer_distance</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name><name>addon</name><operator>-&gt;</operator><name>total_size</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>d</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>total_found</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>d</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>d</name> <operator>&lt;</operator> <name><name>addon</name><operator>-&gt;</operator><name>num_chunks</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>d</name></expr></incr>)</control> <block>{<block_content>
    <comment type="block">/* Only one prepared dictionary type is currently supported. */</comment>
    <expr_stmt><expr><name>total_found</name> <operator>+=</operator> <call><name>FindAllCompoundDictionaryMatches</name><argument_list>(
        <argument><expr><operator>(</operator><specifier>const</specifier> <name>PreparedDictionary</name><operator>*</operator><operator>)</operator><name><name>addon</name><operator>-&gt;</operator><name>chunks</name><index>[<expr><name>d</name></expr>]</index></name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>ring_buffer_mask</name></expr></argument>,
        <argument><expr><name>cur_ix</name></expr></argument>, <argument><expr><name>min_length</name></expr></argument>, <argument><expr><name>max_length</name></expr></argument>, <argument><expr><name>base_offset</name> <operator>-</operator> <name><name>addon</name><operator>-&gt;</operator><name>chunk_offsets</name><index>[<expr><name>d</name></expr>]</index></name></expr></argument>,
        <argument><expr><name>max_distance</name></expr></argument>, <argument><expr><name>matches</name> <operator>+</operator> <name>total_found</name></expr></argument>, <argument><expr><name>match_limit</name> <operator>-</operator> <name>total_found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>total_found</name> <operator>==</operator> <name>match_limit</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>total_found</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>min_length</name> <operator>=</operator> <call><name>BackwardMatchLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>matches</name><index>[<expr><name>total_found</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>total_found</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>c_plusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
</block_content>}</block></extern>  <comment type="block">/* extern "C" */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* BROTLI_ENC_HASH_H_ */</comment>
</unit>
