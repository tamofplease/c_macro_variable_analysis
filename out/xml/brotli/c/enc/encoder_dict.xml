<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="../out/cloned_projects/brotli/c/enc/encoder_dict.h"><comment type="block">/* Copyright 2017 Google Inc. All Rights Reserved.

   Distributed under MIT license.
   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT
*/</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>BROTLI_ENC_ENCODER_DICT_H_</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_ENC_ENCODER_DICT_H_</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;brotli/shared_dictionary.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;brotli/types.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../common/dictionary.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../common/platform.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compound_dictionary.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"memory.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"static_dict_lut.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>c_plusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
<extern>extern <literal type="string">"C"</literal> <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
Dictionary hierarchy for Encoder:
-SharedEncoderDictionary
--CompoundDictionary
---PreparedDictionary [up to 15x]
   = prefix dictionary with precomputed hashes
--ContextualEncoderDictionary
---BrotliEncoderDictionary [up to 64x]
   = for each context, precomputed static dictionary with words + transforms

Dictionary hiearchy from common: similar, but without precomputed hashes
-BrotliSharedDictionary
--BrotliDictionary [up to 64x]
--BrotliTransforms [up to 64x]
--const uint8_t* prefix [up to 15x]: compound dictionaries
*/</comment>

<typedef>typedef <type><struct>struct <name>BrotliTrieNode</name> <block>{
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>single</name></decl>;</decl_stmt>  <comment type="block">/* if 1, sub is a single node for c instead of 256 */</comment>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>c</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>len_</name></decl>;</decl_stmt>  <comment type="block">/* untransformed length */</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>idx_</name></decl>;</decl_stmt>  <comment type="block">/* word index + num words * transform index */</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>sub</name></decl>;</decl_stmt>  <comment type="block">/* index of sub node(s) in the pool */</comment>
}</block></struct></type> <name>BrotliTrieNode</name>;</typedef>

<typedef>typedef <type><struct>struct <name>BrotliTrie</name> <block>{
  <decl_stmt><decl><type><name>BrotliTrieNode</name><modifier>*</modifier></type> <name>pool</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>pool_capacity</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>pool_size</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BrotliTrieNode</name></type> <name>root</name></decl>;</decl_stmt>
}</block></struct></type> <name>BrotliTrie</name>;</typedef>

<function_decl><type><name>BROTLI_INTERNAL</name> <specifier>const</specifier> <name>BrotliTrieNode</name><modifier>*</modifier></type> <name>BrotliTrieSub</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BrotliTrie</name><modifier>*</modifier></type> <name>trie</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>BrotliTrieNode</name><modifier>*</modifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>c</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block">/* Dictionary data (words and transforms) for 1 possible context */</comment>
<typedef>typedef <type><struct>struct <name>BrotliEncoderDictionary</name> <block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>BrotliDictionary</name><modifier>*</modifier></type> <name>words</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>num_transforms</name></decl>;</decl_stmt>

  <comment type="block">/* cut off for fast encoder */</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>cutoffTransformsCount</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint64_t</name></type> <name>cutoffTransforms</name></decl>;</decl_stmt>

  <comment type="block">/* from dictionary_hash.h, for fast encoder */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>uint16_t</name><modifier>*</modifier></type> <name>hash_table_words</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name><modifier>*</modifier></type> <name>hash_table_lengths</name></decl>;</decl_stmt>

  <comment type="block">/* from static_dict_lut.h, for slow encoder */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>uint16_t</name><modifier>*</modifier></type> <name>buckets</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>DictWord</name><modifier>*</modifier></type> <name>dict_words</name></decl>;</decl_stmt>
  <comment type="block">/* Heavy version, for use by slow encoder when there are custom transforms.
     Contains every possible transformed dictionary word in a trie. It encodes
     about as fast as the non-heavy encoder but consumes a lot of memory and
     takes time to build. */</comment>
  <decl_stmt><decl><type><name>BrotliTrie</name></type> <name>trie</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BROTLI_BOOL</name></type> <name>has_words_heavy</name></decl>;</decl_stmt>

  <comment type="block">/* Reference to other dictionaries. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ContextualEncoderDictionary</name></name><modifier>*</modifier></type> <name>parent</name></decl>;</decl_stmt>

  <comment type="block">/* Allocated memory, used only when not using the Brotli defaults */</comment>
  <decl_stmt><decl><type><name>uint16_t</name><modifier>*</modifier></type> <name>hash_table_data_words_</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name><modifier>*</modifier></type> <name>hash_table_data_lengths_</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>buckets_alloc_size_</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint16_t</name><modifier>*</modifier></type> <name>buckets_data_</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>dict_words_alloc_size_</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DictWord</name><modifier>*</modifier></type> <name>dict_words_data_</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BrotliDictionary</name><modifier>*</modifier></type> <name>words_instance_</name></decl>;</decl_stmt>
}</block></struct></type> <name>BrotliEncoderDictionary</name>;</typedef>

<comment type="block">/* Dictionary data for all 64 contexts */</comment>
<typedef>typedef <type><struct>struct <name>ContextualEncoderDictionary</name> <block>{
  <decl_stmt><decl><type><name>BROTLI_BOOL</name></type> <name>context_based</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>num_dictionaries</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name><name>context_map</name><index>[<expr><name>SHARED_BROTLI_NUM_DICTIONARY_CONTEXTS</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>BrotliEncoderDictionary</name><modifier>*</modifier></type> <name><name>dict</name><index>[<expr><name>SHARED_BROTLI_NUM_DICTIONARY_CONTEXTS</name></expr>]</index></name></decl>;</decl_stmt>

  <comment type="block">/* If num_instances_ is 1, instance_ is used, else dynamic allocation with
     instances_ is used. */</comment>
  <decl_stmt><decl><type><name>size_t</name></type> <name>num_instances_</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BrotliEncoderDictionary</name></type> <name>instance_</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BrotliEncoderDictionary</name><modifier>*</modifier></type> <name>instances_</name></decl>;</decl_stmt>
}</block></struct></type> <name>ContextualEncoderDictionary</name>;</typedef>

<typedef>typedef <type><struct>struct <name>SharedEncoderDictionary</name> <block>{
  <comment type="block">/* Magic value to distinguish this struct from PreparedDictionary for
     certain external usages. */</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>magic</name></decl>;</decl_stmt>

  <comment type="block">/* LZ77 prefix, compound dictionary */</comment>
  <decl_stmt><decl><type><name>CompoundDictionary</name></type> <name>compound</name></decl>;</decl_stmt>

  <comment type="block">/* Custom static dictionary (optionally context-based) */</comment>
  <decl_stmt><decl><type><name>ContextualEncoderDictionary</name></type> <name>contextual</name></decl>;</decl_stmt>

  <comment type="block">/* The maximum quality the dictionary was computed for */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>max_quality</name></decl>;</decl_stmt>
}</block></struct></type> <name>SharedEncoderDictionary</name>;</typedef>

<typedef>typedef <type><struct>struct <name>ManagedDictionary</name> <block>{
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>magic</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MemoryManager</name></type> <name>memory_manager_</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name><modifier>*</modifier></type> <name>dictionary</name></decl>;</decl_stmt>
}</block></struct></type> <name>ManagedDictionary</name>;</typedef>

<comment type="block">/* Initializes to the brotli built-in dictionary */</comment>
<function_decl><type><name>BROTLI_INTERNAL</name> <name>void</name></type> <name>BrotliInitSharedEncoderDictionary</name><parameter_list>(
    <parameter><decl><type><name>SharedEncoderDictionary</name><modifier>*</modifier></type> <name>dict</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Initializes to shared dictionary that will be parsed from
   encoded_dict. Requires that you keep the encoded_dict buffer
   around, parts of data will point to it. */</comment>
<function_decl><type><name>BROTLI_INTERNAL</name> <name>BROTLI_BOOL</name></type> <name>BrotliInitCustomSharedEncoderDictionary</name><parameter_list>(
    <parameter><decl><type><name>MemoryManager</name><modifier>*</modifier></type> <name>m</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name><modifier>*</modifier></type> <name>encoded_dict</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>,
    <parameter><decl><type><name>int</name></type> <name>quality</name></decl></parameter>, <parameter><decl><type><name>SharedEncoderDictionary</name><modifier>*</modifier></type> <name>dict</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>BROTLI_INTERNAL</name> <name>void</name></type> <name>BrotliCleanupSharedEncoderDictionary</name><parameter_list>(
    <parameter><decl><type><name>MemoryManager</name><modifier>*</modifier></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>SharedEncoderDictionary</name><modifier>*</modifier></type> <name>dict</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>BROTLI_INTERNAL</name> <name>ManagedDictionary</name><modifier>*</modifier></type> <name>BrotliCreateManagedDictionary</name><parameter_list>(
    <parameter><decl><type><name>brotli_alloc_func</name></type> <name>alloc_func</name></decl></parameter>, <parameter><decl><type><name>brotli_free_func</name></type> <name>free_func</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>opaque</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>BROTLI_INTERNAL</name> <name>void</name></type> <name>BrotliDestroyManagedDictionary</name><parameter_list>(
    <parameter><decl><type><name>ManagedDictionary</name><modifier>*</modifier></type> <name>dictionary</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>c_plusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
</block_content>}</block></extern>  <comment type="block">/* extern "C" */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* BROTLI_ENC_ENCODER_DICT_H_ */</comment>
</unit>
