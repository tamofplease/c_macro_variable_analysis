<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="../out/cloned_projects/brotli/c/enc/memory.h"><comment type="block">/* Copyright 2016 Google Inc. All Rights Reserved.

   Distributed under MIT license.
   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT
*/</comment>

<comment type="block">/* Macros for memory management. */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>BROTLI_ENC_MEMORY_H_</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_ENC_MEMORY_H_</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>  <comment type="block">/* memcpy */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;brotli/types.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../common/platform.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>c_plusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
<extern>extern <literal type="string">"C"</literal> <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>BROTLI_ENCODER_CLEANUP_ON_OOM</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> \
    <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>BROTLI_ENCODER_EXIT_ON_OOM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_ENCODER_EXIT_ON_OOM</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<typedef>typedef <type><struct>struct <name>MemoryManager</name> <block>{
  <decl_stmt><decl><type><name>brotli_alloc_func</name></type> <name>alloc_func</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>brotli_free_func</name></type> <name>free_func</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>opaque</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>BROTLI_ENCODER_EXIT_ON_OOM</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <decl_stmt><decl><type><name>BROTLI_BOOL</name></type> <name>is_oom</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>perm_allocated</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>new_allocated</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>new_freed</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name><name>pointers</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* BROTLI_ENCODER_EXIT_ON_OOM */</comment>
}</block></struct></type> <name>MemoryManager</name>;</typedef>

<function_decl><type><name>BROTLI_INTERNAL</name> <name>void</name></type> <name>BrotliInitMemoryManager</name><parameter_list>(
    <parameter><decl><type><name>MemoryManager</name><modifier>*</modifier></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>brotli_alloc_func</name></type> <name>alloc_func</name></decl></parameter>, <parameter><decl><type><name>brotli_free_func</name></type> <name>free_func</name></decl></parameter>,
    <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>opaque</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>BROTLI_INTERNAL</name> <name>void</name><modifier>*</modifier></type> <name>BrotliAllocate</name><parameter_list>(<parameter><decl><type><name>MemoryManager</name><modifier>*</modifier></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_ALLOC</name><parameter_list>(<parameter><type><name>M</name></type></parameter>, <parameter><type><name>T</name></type></parameter>, <parameter><type><name>N</name></type></parameter>)</parameter_list></cpp:macro>                               \
  <cpp:value>((N) &gt; 0 ? ((T*)BrotliAllocate((M), (N) * sizeof(T))) : NULL)</cpp:value></cpp:define>

<function_decl><type><name>BROTLI_INTERNAL</name> <name>void</name></type> <name>BrotliFree</name><parameter_list>(<parameter><decl><type><name>MemoryManager</name><modifier>*</modifier></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>p</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_FREE</name><parameter_list>(<parameter><type><name>M</name></type></parameter>, <parameter><type><name>P</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ \
  BrotliFree((M), (P));     \
  P = NULL;                 \
}</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>BROTLI_ENCODER_EXIT_ON_OOM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_IS_OOM</name><parameter_list>(<parameter><type><name>M</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(!!0)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>  <comment type="block">/* BROTLI_ENCODER_EXIT_ON_OOM */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_IS_OOM</name><parameter_list>(<parameter><type><name>M</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(!!(M)-&gt;is_oom)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* BROTLI_ENCODER_EXIT_ON_OOM */</comment>

<comment type="block">/*
BROTLI_IS_NULL is a fake check, BROTLI_IS_OOM does the heavy lifting.
The only purpose of it is to explain static analyzers the state of things.
NB: use ONLY together with BROTLI_IS_OOM
    AND ONLY for allocations in the current scope.
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__clang_analyzer__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>BROTLI_ENCODER_EXIT_ON_OOM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_IS_NULL</name><parameter_list>(<parameter><type><name>A</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((A) == nullptr)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>  <comment type="block">/* defined(__clang_analyzer__) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_IS_NULL</name><parameter_list>(<parameter><type><name>A</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(!!0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* defined(__clang_analyzer__) */</comment>

<function_decl><type><name>BROTLI_INTERNAL</name> <name>void</name></type> <name>BrotliWipeOutMemoryManager</name><parameter_list>(<parameter><decl><type><name>MemoryManager</name><modifier>*</modifier></type> <name>m</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
Dynamically grows array capacity to at least the requested size
M: MemoryManager
T: data type
A: array
C: capacity
R: requested size
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_ENSURE_CAPACITY</name><parameter_list>(<parameter><type><name>M</name></type></parameter>, <parameter><type><name>T</name></type></parameter>, <parameter><type><name>A</name></type></parameter>, <parameter><type><name>C</name></type></parameter>, <parameter><type><name>R</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{                    \
  if (C &lt; (R)) {                                                   \
    size_t _new_size = (C == 0) ? (R) : C;                         \
    T* new_array;                                                  \
    while (_new_size &lt; (R)) _new_size *= 2;                        \
    new_array = BROTLI_ALLOC((M), T, _new_size);                   \
    if (!BROTLI_IS_OOM(M) &amp;&amp; !BROTLI_IS_NULL(new_array) &amp;&amp; C != 0) \
      memcpy(new_array, A, C * sizeof(T));                         \
    BROTLI_FREE((M), A);                                           \
    A = new_array;                                                 \
    C = _new_size;                                                 \
  }                                                                \
}</cpp:value></cpp:define>

<comment type="block">/*
Appends value and dynamically grows array capacity when needed
M: MemoryManager
T: data type
A: array
C: array capacity
S: array size
V: value to append
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_ENSURE_CAPACITY_APPEND</name><parameter_list>(<parameter><type><name>M</name></type></parameter>, <parameter><type><name>T</name></type></parameter>, <parameter><type><name>A</name></type></parameter>, <parameter><type><name>C</name></type></parameter>, <parameter><type><name>S</name></type></parameter>, <parameter><type><name>V</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ \
  (S)++;                                                  \
  BROTLI_ENSURE_CAPACITY(M, T, A, C, S);                  \
  A[(S) - 1] = (V);                                       \
}</cpp:value></cpp:define>

<comment type="block">/* "Bootstrap" allocations are not tracked by memory manager; should be used
   only to allocate MemoryManager itself (or structure containing it). */</comment>
<function_decl><type><name>BROTLI_INTERNAL</name> <name>void</name><modifier>*</modifier></type> <name>BrotliBootstrapAlloc</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>,
    <parameter><decl><type><name>brotli_alloc_func</name></type> <name>alloc_func</name></decl></parameter>, <parameter><decl><type><name>brotli_free_func</name></type> <name>free_func</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>opaque</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>BROTLI_INTERNAL</name> <name>void</name></type> <name>BrotliBootstrapFree</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>address</name></decl></parameter>, <parameter><decl><type><name>MemoryManager</name><modifier>*</modifier></type> <name>m</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>c_plusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
</block_content>}</block></extern>  <comment type="block">/* extern "C" */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* BROTLI_ENC_MEMORY_H_ */</comment>
</unit>
