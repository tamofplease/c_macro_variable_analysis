<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="../out/cloned_projects/brotli/c/enc/encode.c"><comment type="block">/* Copyright 2013 Google Inc. All Rights Reserved.

   Distributed under MIT license.
   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT
*/</comment>

<comment type="block">/* Implementation of Brotli compressor. */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;brotli/encode.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>  <comment type="block">/* free, malloc */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>  <comment type="block">/* memcpy, memset */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../common/constants.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../common/context.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../common/platform.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../common/version.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"backward_references.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"backward_references_hq.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"bit_cost.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"brotli_bit_stream.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compress_fragment.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compress_fragment_two_pass.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dictionary_hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"encoder_dict.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"entropy_encode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fast_log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"histogram.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"memory.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"metablock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"prefix.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"state.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"quality.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ringbuffer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utf8_util.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"write_bits.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>c_plusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
<extern>extern <literal type="string">"C"</literal> <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COPY_ARRAY</name><parameter_list>(<parameter><type><name>dst</name></type></parameter>, <parameter><type><name>src</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>memcpy(dst, src, sizeof(src));</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>InputBlockSize</name><parameter_list>(<parameter><decl><type><name>BrotliEncoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>lgblock</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint64_t</name></type> <name>UnprocessedInputSize</name><parameter_list>(<parameter><decl><type><name>BrotliEncoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><name><name>s</name><operator>-&gt;</operator><name>input_pos_</name></name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>last_processed_pos_</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>RemainingInputBlockSize</name><parameter_list>(<parameter><decl><type><name>BrotliEncoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>uint64_t</name></type> <name>delta</name> <init>= <expr><call><name>UnprocessedInputSize</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>block_size</name> <init>= <expr><call><name>InputBlockSize</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>delta</name> <operator>&gt;=</operator> <name>block_size</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name>block_size</name> <operator>-</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>delta</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>BROTLI_BOOL</name></type> <name>BrotliEncoderSetParameter</name><parameter_list>(
    <parameter><decl><type><name>BrotliEncoderState</name><modifier>*</modifier></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>BrotliEncoderParameter</name></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* Changing parameters on the fly is not implemented yet. */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>is_initialized_</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>BROTLI_FALSE</name></expr>;</return></block_content></block></if></if_stmt>
  <comment type="block">/* TODO(eustas): Validate/clamp parameters here. */</comment>
  <switch>switch <condition>(<expr><name>p</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>BROTLI_PARAM_MODE</name></expr>:</case>
      <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>mode</name></name> <operator>=</operator> <operator>(</operator><name>BrotliEncoderMode</name><operator>)</operator><name>value</name></expr>;</expr_stmt>
      <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>

    <case>case <expr><name>BROTLI_PARAM_QUALITY</name></expr>:</case>
      <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>quality</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>value</name></expr>;</expr_stmt>
      <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>

    <case>case <expr><name>BROTLI_PARAM_LGWIN</name></expr>:</case>
      <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>lgwin</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>value</name></expr>;</expr_stmt>
      <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>

    <case>case <expr><name>BROTLI_PARAM_LGBLOCK</name></expr>:</case>
      <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>lgblock</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>value</name></expr>;</expr_stmt>
      <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>

    <case>case <expr><name>BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>value</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>value</name> <operator>!=</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>BROTLI_FALSE</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>disable_literal_context_modeling</name></name> <operator>=</operator> <call><name>TO_BROTLI_BOOL</name><argument_list>(<argument><expr><operator>!</operator><operator>!</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>

    <case>case <expr><name>BROTLI_PARAM_SIZE_HINT</name></expr>:</case>
      <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>size_hint</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
      <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>

    <case>case <expr><name>BROTLI_PARAM_LARGE_WINDOW</name></expr>:</case>
      <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>large_window</name></name> <operator>=</operator> <call><name>TO_BROTLI_BOOL</name><argument_list>(<argument><expr><operator>!</operator><operator>!</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>

    <case>case <expr><name>BROTLI_PARAM_NPOSTFIX</name></expr>:</case>
      <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>dist</name><operator>.</operator><name>distance_postfix_bits</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
      <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>

    <case>case <expr><name>BROTLI_PARAM_NDIRECT</name></expr>:</case>
      <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>dist</name><operator>.</operator><name>num_direct_distance_codes</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
      <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>

    <case>case <expr><name>BROTLI_PARAM_STREAM_OFFSET</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>value</name> <operator>&gt;</operator> <operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <literal type="number">30</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>BROTLI_FALSE</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>stream_offset</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
      <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>

    <default>default:</default> <return>return <expr><name>BROTLI_FALSE</name></expr>;</return>
  </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/* Wraps 64-bit input position to 32-bit ring-buffer position preserving
   "not-a-first-lap" feature. */</comment>
<function><type><specifier>static</specifier> <name>uint32_t</name></type> <name>WrapPosition</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>position</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>result</name> <init>= <expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>position</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint64_t</name></type> <name>gb</name> <init>= <expr><name>position</name> <operator>&gt;&gt;</operator> <literal type="number">30</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>gb</name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
    <comment type="block">/* Wrap every 2GiB; The first 3GB are continuous. */</comment>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>result</name> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <literal type="number">30</literal><operator>)</operator> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>|</operator> <operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><operator>(</operator><name>gb</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">30</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint8_t</name><modifier>*</modifier></type> <name>GetBrotliStorage</name><parameter_list>(<parameter><decl><type><name>BrotliEncoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>MemoryManager</name><modifier>*</modifier></type> <name>m</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>memory_manager_</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>storage_size_</name></name> <operator>&lt;</operator> <name>size</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>BROTLI_FREE</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>storage_</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>storage_</name></name> <operator>=</operator> <call><name>BROTLI_ALLOC</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>uint8_t</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>BROTLI_IS_OOM</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>BROTLI_IS_NULL</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>storage_</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>storage_size_</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name><name>s</name><operator>-&gt;</operator><name>storage_</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>HashTableSize</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>max_table_size</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>input_size</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>size_t</name></type> <name>htsize</name> <init>= <expr><literal type="number">256</literal></expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr><name>htsize</name> <operator>&lt;</operator> <name>max_table_size</name> <operator>&amp;&amp;</operator> <name>htsize</name> <operator>&lt;</operator> <name>input_size</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>htsize</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></while>
  <return>return <expr><name>htsize</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name><modifier>*</modifier></type> <name>GetHashTable</name><parameter_list>(<parameter><decl><type><name>BrotliEncoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>quality</name></decl></parameter>,
                         <parameter><decl><type><name>size_t</name></type> <name>input_size</name></decl></parameter>, <parameter><decl><type><name>size_t</name><modifier>*</modifier></type> <name>table_size</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* Use smaller hash table when input.size() is smaller, since we
     fill the table, incurring O(hash table size) overhead for
     compression, and if the input is short, we won't need that
     many hash table entries anyway. */</comment>
  <decl_stmt><decl><type><name>MemoryManager</name><modifier>*</modifier></type> <name>m</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>memory_manager_</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>max_table_size</name> <init>= <expr><call><name>MaxHashTableSize</name><argument_list>(<argument><expr><name>quality</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>htsize</name> <init>= <expr><call><name>HashTableSize</name><argument_list>(<argument><expr><name>max_table_size</name></expr></argument>, <argument><expr><name>input_size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name><modifier>*</modifier></type> <name>table</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>BROTLI_DCHECK</name><argument_list>(<argument><expr><name>max_table_size</name> <operator>&gt;=</operator> <literal type="number">256</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>quality</name> <operator>==</operator> <name>FAST_ONE_PASS_COMPRESSION_QUALITY</name></expr>)</condition> <block>{<block_content>
    <comment type="block">/* Only odd shifts are supported by fast-one-pass. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>htsize</name> <operator>&amp;</operator> <literal type="number">0xAAAAA</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>htsize</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>htsize</name> <operator>&lt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>small_table_</name></name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>small_table_</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>table</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>small_table_</name></name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>htsize</name> <operator>&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>large_table_size_</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>large_table_size_</name></name> <operator>=</operator> <name>htsize</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>BROTLI_FREE</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>large_table_</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>large_table_</name></name> <operator>=</operator> <call><name>BROTLI_ALLOC</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>htsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>BROTLI_IS_OOM</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>BROTLI_IS_NULL</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>large_table_</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>table</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>large_table_</name></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>table_size</name> <operator>=</operator> <name>htsize</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>htsize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>table</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>table</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>EncodeWindowBits</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>lgwin</name></decl></parameter>, <parameter><decl><type><name>BROTLI_BOOL</name></type> <name>large_window</name></decl></parameter>,
    <parameter><decl><type><name>uint16_t</name><modifier>*</modifier></type> <name>last_bytes</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name><modifier>*</modifier></type> <name>last_bytes_bits</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>large_window</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>last_bytes</name> <operator>=</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>lgwin</name> <operator>&amp;</operator> <literal type="number">0x3F</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>|</operator> <literal type="number">0x11</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>last_bytes_bits</name> <operator>=</operator> <literal type="number">14</literal></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>lgwin</name> <operator>==</operator> <literal type="number">16</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>last_bytes</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>last_bytes_bits</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>lgwin</name> <operator>==</operator> <literal type="number">17</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>last_bytes</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>last_bytes_bits</name> <operator>=</operator> <literal type="number">7</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>lgwin</name> <operator>&gt;</operator> <literal type="number">17</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>last_bytes</name> <operator>=</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>lgwin</name> <operator>-</operator> <literal type="number">17</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>|</operator> <literal type="number">0x01</literal><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>last_bytes_bits</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>last_bytes</name> <operator>=</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>lgwin</name> <operator>-</operator> <literal type="number">8</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>|</operator> <literal type="number">0x01</literal><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>last_bytes_bits</name> <operator>=</operator> <literal type="number">7</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* TODO(eustas): move to compress_fragment.c? */</comment>
<comment type="block">/* Initializes the command and distance prefix codes for the first block. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>InitCommandPrefixCodes</name><parameter_list>(<parameter><decl><type><name>BrotliOnePassArena</name><modifier>*</modifier></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint8_t</name></type> <name><name>kDefaultCommandDepths</name><index>[<expr><literal type="number">128</literal></expr>]</index></name> <init>= <expr><block>{
    <expr><literal type="number">0</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">8</literal></expr>, <expr><literal type="number">8</literal></expr>, <expr><literal type="number">8</literal></expr>, <expr><literal type="number">8</literal></expr>, <expr><literal type="number">8</literal></expr>,
    <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">7</literal></expr>,
    <expr><literal type="number">7</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>,
    <expr><literal type="number">7</literal></expr>, <expr><literal type="number">8</literal></expr>, <expr><literal type="number">8</literal></expr>, <expr><literal type="number">9</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">10</literal></expr>,
    <expr><literal type="number">5</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
    <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">4</literal></expr>,
    <expr><literal type="number">4</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">8</literal></expr>, <expr><literal type="number">10</literal></expr>,
    <expr><literal type="number">12</literal></expr>, <expr><literal type="number">12</literal></expr>, <expr><literal type="number">12</literal></expr>, <expr><literal type="number">12</literal></expr>, <expr><literal type="number">12</literal></expr>, <expr><literal type="number">12</literal></expr>, <expr><literal type="number">12</literal></expr>, <expr><literal type="number">12</literal></expr>, <expr><literal type="number">12</literal></expr>, <expr><literal type="number">12</literal></expr>, <expr><literal type="number">12</literal></expr>, <expr><literal type="number">12</literal></expr>,
  }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint16_t</name></type> <name><name>kDefaultCommandBits</name><index>[<expr><literal type="number">128</literal></expr>]</index></name> <init>= <expr><block>{
    <expr><literal type="number">0</literal></expr>,   <expr><literal type="number">0</literal></expr>,   <expr><literal type="number">8</literal></expr>,   <expr><literal type="number">9</literal></expr>,   <expr><literal type="number">3</literal></expr>,  <expr><literal type="number">35</literal></expr>,   <expr><literal type="number">7</literal></expr>,   <expr><literal type="number">71</literal></expr>,
    <expr><literal type="number">39</literal></expr>, <expr><literal type="number">103</literal></expr>,  <expr><literal type="number">23</literal></expr>,  <expr><literal type="number">47</literal></expr>, <expr><literal type="number">175</literal></expr>, <expr><literal type="number">111</literal></expr>, <expr><literal type="number">239</literal></expr>,   <expr><literal type="number">31</literal></expr>,
    <expr><literal type="number">0</literal></expr>,   <expr><literal type="number">0</literal></expr>,   <expr><literal type="number">0</literal></expr>,   <expr><literal type="number">4</literal></expr>,  <expr><literal type="number">12</literal></expr>,   <expr><literal type="number">2</literal></expr>,  <expr><literal type="number">10</literal></expr>,    <expr><literal type="number">6</literal></expr>,
    <expr><literal type="number">13</literal></expr>,  <expr><literal type="number">29</literal></expr>,  <expr><literal type="number">11</literal></expr>,  <expr><literal type="number">43</literal></expr>,  <expr><literal type="number">27</literal></expr>,  <expr><literal type="number">59</literal></expr>,  <expr><literal type="number">87</literal></expr>,   <expr><literal type="number">55</literal></expr>,
    <expr><literal type="number">15</literal></expr>,  <expr><literal type="number">79</literal></expr>, <expr><literal type="number">319</literal></expr>, <expr><literal type="number">831</literal></expr>, <expr><literal type="number">191</literal></expr>, <expr><literal type="number">703</literal></expr>, <expr><literal type="number">447</literal></expr>,  <expr><literal type="number">959</literal></expr>,
    <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">14</literal></expr>,   <expr><literal type="number">1</literal></expr>,  <expr><literal type="number">25</literal></expr>,   <expr><literal type="number">5</literal></expr>,  <expr><literal type="number">21</literal></expr>,  <expr><literal type="number">19</literal></expr>,   <expr><literal type="number">51</literal></expr>,
    <expr><literal type="number">119</literal></expr>, <expr><literal type="number">159</literal></expr>,  <expr><literal type="number">95</literal></expr>, <expr><literal type="number">223</literal></expr>, <expr><literal type="number">479</literal></expr>, <expr><literal type="number">991</literal></expr>,  <expr><literal type="number">63</literal></expr>,  <expr><literal type="number">575</literal></expr>,
    <expr><literal type="number">127</literal></expr>, <expr><literal type="number">639</literal></expr>, <expr><literal type="number">383</literal></expr>, <expr><literal type="number">895</literal></expr>, <expr><literal type="number">255</literal></expr>, <expr><literal type="number">767</literal></expr>, <expr><literal type="number">511</literal></expr>, <expr><literal type="number">1023</literal></expr>,
    <expr><literal type="number">14</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
    <expr><literal type="number">27</literal></expr>, <expr><literal type="number">59</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">39</literal></expr>, <expr><literal type="number">23</literal></expr>, <expr><literal type="number">55</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">17</literal></expr>, <expr><literal type="number">9</literal></expr>, <expr><literal type="number">25</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">8</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">12</literal></expr>,
    <expr><literal type="number">2</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">21</literal></expr>, <expr><literal type="number">13</literal></expr>, <expr><literal type="number">29</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">19</literal></expr>, <expr><literal type="number">11</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">47</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">95</literal></expr>, <expr><literal type="number">63</literal></expr>, <expr><literal type="number">127</literal></expr>, <expr><literal type="number">255</literal></expr>,
    <expr><literal type="number">767</literal></expr>, <expr><literal type="number">2815</literal></expr>, <expr><literal type="number">1791</literal></expr>, <expr><literal type="number">3839</literal></expr>, <expr><literal type="number">511</literal></expr>, <expr><literal type="number">2559</literal></expr>, <expr><literal type="number">1535</literal></expr>, <expr><literal type="number">3583</literal></expr>, <expr><literal type="number">1023</literal></expr>, <expr><literal type="number">3071</literal></expr>, <expr><literal type="number">2047</literal></expr>, <expr><literal type="number">4095</literal></expr>,
  }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint8_t</name></type> <name><name>kDefaultCommandCode</name><index>[]</index></name> <init>= <expr><block>{
    <expr><literal type="number">0xff</literal></expr>, <expr><literal type="number">0x77</literal></expr>, <expr><literal type="number">0xd5</literal></expr>, <expr><literal type="number">0xbf</literal></expr>, <expr><literal type="number">0xe7</literal></expr>, <expr><literal type="number">0xde</literal></expr>, <expr><literal type="number">0xea</literal></expr>, <expr><literal type="number">0x9e</literal></expr>, <expr><literal type="number">0x51</literal></expr>, <expr><literal type="number">0x5d</literal></expr>, <expr><literal type="number">0xde</literal></expr>, <expr><literal type="number">0xc6</literal></expr>,
    <expr><literal type="number">0x70</literal></expr>, <expr><literal type="number">0x57</literal></expr>, <expr><literal type="number">0xbc</literal></expr>, <expr><literal type="number">0x58</literal></expr>, <expr><literal type="number">0x58</literal></expr>, <expr><literal type="number">0x58</literal></expr>, <expr><literal type="number">0xd8</literal></expr>, <expr><literal type="number">0xd8</literal></expr>, <expr><literal type="number">0x58</literal></expr>, <expr><literal type="number">0xd5</literal></expr>, <expr><literal type="number">0xcb</literal></expr>, <expr><literal type="number">0x8c</literal></expr>,
    <expr><literal type="number">0xea</literal></expr>, <expr><literal type="number">0xe0</literal></expr>, <expr><literal type="number">0xc3</literal></expr>, <expr><literal type="number">0x87</literal></expr>, <expr><literal type="number">0x1f</literal></expr>, <expr><literal type="number">0x83</literal></expr>, <expr><literal type="number">0xc1</literal></expr>, <expr><literal type="number">0x60</literal></expr>, <expr><literal type="number">0x1c</literal></expr>, <expr><literal type="number">0x67</literal></expr>, <expr><literal type="number">0xb2</literal></expr>, <expr><literal type="number">0xaa</literal></expr>,
    <expr><literal type="number">0x06</literal></expr>, <expr><literal type="number">0x83</literal></expr>, <expr><literal type="number">0xc1</literal></expr>, <expr><literal type="number">0x60</literal></expr>, <expr><literal type="number">0x30</literal></expr>, <expr><literal type="number">0x18</literal></expr>, <expr><literal type="number">0xcc</literal></expr>, <expr><literal type="number">0xa1</literal></expr>, <expr><literal type="number">0xce</literal></expr>, <expr><literal type="number">0x88</literal></expr>, <expr><literal type="number">0x54</literal></expr>, <expr><literal type="number">0x94</literal></expr>,
    <expr><literal type="number">0x46</literal></expr>, <expr><literal type="number">0xe1</literal></expr>, <expr><literal type="number">0xb0</literal></expr>, <expr><literal type="number">0xd0</literal></expr>, <expr><literal type="number">0x4e</literal></expr>, <expr><literal type="number">0xb2</literal></expr>, <expr><literal type="number">0xf7</literal></expr>, <expr><literal type="number">0x04</literal></expr>, <expr><literal type="number">0x00</literal></expr>,
  }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>size_t</name></type> <name>kDefaultCommandCodeNumBits</name> <init>= <expr><literal type="number">448</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>COPY_ARRAY</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>cmd_depth</name></name></expr></argument>, <argument><expr><name>kDefaultCommandDepths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>COPY_ARRAY</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>cmd_bits</name></name></expr></argument>, <argument><expr><name>kDefaultCommandBits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Initialize the pre-compressed form of the command and distance prefix
     codes. */</comment>
  <expr_stmt><expr><call><name>COPY_ARRAY</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>cmd_code</name></name></expr></argument>, <argument><expr><name>kDefaultCommandCode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>cmd_code_numbits</name></name> <operator>=</operator> <name>kDefaultCommandCodeNumBits</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Decide about the context map based on the ability of the prediction
   ability of the previous byte UTF8-prefix on the next byte. The
   prediction ability is calculated as Shannon entropy. Here we need
   Shannon entropy instead of 'BitsEntropy' since the prefix will be
   encoded with the remaining 6 bits of the following byte, and
   BitsEntropy will assume that symbol to be stored alone using Huffman
   coding. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ChooseContextMap</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>quality</name></decl></parameter>,
                             <parameter><decl><type><name>uint32_t</name><modifier>*</modifier></type> <name>bigram_histo</name></decl></parameter>,
                             <parameter><decl><type><name>size_t</name><modifier>*</modifier></type> <name>num_literal_contexts</name></decl></parameter>,
                             <parameter><decl><type><specifier>const</specifier> <name>uint32_t</name><modifier>*</modifier><modifier>*</modifier></type> <name>literal_context_map</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint32_t</name></type> <name><name>kStaticContextMapContinuation</name><index>[<expr><literal type="number">64</literal></expr>]</index></name> <init>= <expr><block>{
    <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
    <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
    <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
    <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
  }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint32_t</name></type> <name><name>kStaticContextMapSimpleUTF8</name><index>[<expr><literal type="number">64</literal></expr>]</index></name> <init>= <expr><block>{
    <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
    <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
    <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
    <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
  }</block></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>uint32_t</name></type> <name><name>monogram_histo</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name><name>two_prefix_histo</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>total</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>dummy</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>double</name></type> <name><name>entropy</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">9</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <expr_stmt><expr><name><name>monogram_histo</name><index>[<expr><name>i</name> <operator>%</operator> <literal type="number">3</literal></expr>]</index></name> <operator>+=</operator> <name><name>bigram_histo</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>two_prefix_histo</name><index>[<expr><name>i</name> <operator>%</operator> <literal type="number">6</literal></expr>]</index></name> <operator>+=</operator> <name><name>bigram_histo</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>entropy</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ShannonEntropy</name><argument_list>(<argument><expr><name>monogram_histo</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>dummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>entropy</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><call><name>ShannonEntropy</name><argument_list>(<argument><expr><name>two_prefix_histo</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>dummy</name></expr></argument>)</argument_list></call> <operator>+</operator>
                <call><name>ShannonEntropy</name><argument_list>(<argument><expr><name>two_prefix_histo</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>dummy</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>entropy</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <expr_stmt><expr><name><name>entropy</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>+=</operator> <call><name>ShannonEntropy</name><argument_list>(<argument><expr><name>bigram_histo</name> <operator>+</operator> <literal type="number">3</literal> <operator>*</operator> <name>i</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>dummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><name>total</name> <operator>=</operator> <name><name>monogram_histo</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name><name>monogram_histo</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name><name>monogram_histo</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>BROTLI_DCHECK</name><argument_list>(<argument><expr><name>total</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>entropy</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1.0</literal> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator><name>total</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>entropy</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>*=</operator> <name><name>entropy</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>entropy</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>*=</operator> <name><name>entropy</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>entropy</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>*=</operator> <name><name>entropy</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>quality</name> <operator>&lt;</operator> <name>MIN_QUALITY_FOR_HQ_CONTEXT_MODELING</name></expr>)</condition> <block>{<block_content>
    <comment type="block">/* 3 context models is a bit slower, don't use it at lower qualities. */</comment>
    <expr_stmt><expr><name><name>entropy</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name><name>entropy</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <literal type="number">10</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* If expected savings by symbol are less than 0.2 bits, skip the
     context modeling -- in exchange for faster decoding speed. */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>entropy</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>entropy</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0.2</literal> <operator>&amp;&amp;</operator>
      <name><name>entropy</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>entropy</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0.2</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>num_literal_contexts</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>entropy</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>-</operator> <name><name>entropy</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0.02</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>num_literal_contexts</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>literal_context_map</name> <operator>=</operator> <name>kStaticContextMapSimpleUTF8</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>num_literal_contexts</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>literal_context_map</name> <operator>=</operator> <name>kStaticContextMapContinuation</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Decide if we want to use a more complex static context map containing 13
   context values, based on the entropy reduction of histograms over the
   first 5 bits of literals. */</comment>
<function><type><specifier>static</specifier> <name>BROTLI_BOOL</name></type> <name>ShouldUseComplexStaticContextMap</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>uint8_t</name><modifier>*</modifier></type> <name>input</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>start_pos</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>length</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>mask</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>quality</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size_hint</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name><modifier>*</modifier></type> <name>num_literal_contexts</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint32_t</name><modifier>*</modifier><modifier>*</modifier></type> <name>literal_context_map</name></decl></parameter>,
    <parameter><decl><type><name>uint32_t</name><modifier>*</modifier></type> <name>arena</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint32_t</name></type> <name><name>kStaticContextMapComplexUTF8</name><index>[<expr><literal type="number">64</literal></expr>]</index></name> <init>= <expr><block>{
    <expr><literal type="number">11</literal></expr>, <expr><literal type="number">11</literal></expr>, <expr><literal type="number">12</literal></expr>, <expr><literal type="number">12</literal></expr>, <comment type="block">/* 0 special */</comment>
    <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <comment type="block">/* 4 lf */</comment>
    <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">9</literal></expr>, <expr><literal type="number">9</literal></expr>, <comment type="block">/* 8 space */</comment>
    <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <comment type="block">/* !, first after space/lf and after something else. */</comment>
    <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <comment type="block">/* " */</comment>
    <expr><literal type="number">8</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr>, <comment type="block">/* % */</comment>
    <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <comment type="block">/* ({[ */</comment>
    <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <comment type="block">/* }]) */</comment>
    <expr><literal type="number">8</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">4</literal></expr>, <comment type="block">/* :; */</comment>
    <expr><literal type="number">8</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">4</literal></expr>, <comment type="block">/* . */</comment>
    <expr><literal type="number">8</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <comment type="block">/* &gt; */</comment>
    <expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr>, <comment type="block">/* [0..9] */</comment>
    <expr><literal type="number">5</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">5</literal></expr>, <comment type="block">/* [A-Z] */</comment>
    <expr><literal type="number">5</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">5</literal></expr>,
    <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <comment type="block">/* [a-z] */</comment>
    <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>,
  }</block></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>BROTLI_UNUSED</name><argument_list>(<argument><expr><name>quality</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Try the more complex static context map only for long data. */</comment>
  <if_stmt><if>if <condition>(<expr><name>size_hint</name> <operator>&lt;</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">20</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>BROTLI_FALSE</name></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>end_pos</name> <init>= <expr><name>start_pos</name> <operator>+</operator> <name>length</name></expr></init></decl>;</decl_stmt>
    <comment type="block">/* To make entropy calculations faster, we collect histograms
       over the 5 most significant bits of literals. One histogram
       without context and 13 additional histograms for each context value. */</comment>
    <decl_stmt><decl><type><name>uint32_t</name><modifier>*</modifier> <name>BROTLI_RESTRICT</name> <specifier>const</specifier></type> <name>combined_histo</name> <init>= <expr><name>arena</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name><modifier>*</modifier> <name>BROTLI_RESTRICT</name> <specifier>const</specifier></type> <name>context_histo</name> <init>= <expr><name>arena</name> <operator>+</operator> <literal type="number">32</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>total</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name><name>entropy</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>dummy</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ContextLut</name></type> <name>utf8_lut</name> <init>= <expr><call><name>BROTLI_CONTEXT_LUT</name><argument_list>(<argument><expr><name>CONTEXT_UTF8</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>arena</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>arena</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">32</literal> <operator>*</operator> <literal type="number">14</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init>;</init> <condition><expr><name>start_pos</name> <operator>+</operator> <literal type="number">64</literal> <operator>&lt;=</operator> <name>end_pos</name></expr>;</condition> <incr><expr><name>start_pos</name> <operator>+=</operator> <literal type="number">4096</literal></expr></incr>)</control> <block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>stride_end_pos</name> <init>= <expr><name>start_pos</name> <operator>+</operator> <literal type="number">64</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>uint8_t</name></type> <name>prev2</name> <init>= <expr><name><name>input</name><index>[<expr><name>start_pos</name> <operator>&amp;</operator> <name>mask</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>uint8_t</name></type> <name>prev1</name> <init>= <expr><name><name>input</name><index>[<expr><operator>(</operator><name>start_pos</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;</operator> <name>mask</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>size_t</name></type> <name>pos</name></decl>;</decl_stmt>
      <comment type="block">/* To make the analysis of the data faster we only examine 64 byte long
         strides at every 4kB intervals. */</comment>
      <for>for <control>(<init><expr><name>pos</name> <operator>=</operator> <name>start_pos</name> <operator>+</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>pos</name> <operator>&lt;</operator> <name>stride_end_pos</name></expr>;</condition> <incr><expr><operator>++</operator><name>pos</name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name></type> <name>literal</name> <init>= <expr><name><name>input</name><index>[<expr><name>pos</name> <operator>&amp;</operator> <name>mask</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name></type> <name>context</name> <init>= <expr><operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>kStaticContextMapComplexUTF8</name><index>[
            <expr><call><name>BROTLI_CONTEXT</name><argument_list>(<argument><expr><name>prev1</name></expr></argument>, <argument><expr><name>prev2</name></expr></argument>, <argument><expr><name>utf8_lut</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><operator>++</operator><name>total</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>++</operator><name><name>combined_histo</name><index>[<expr><name>literal</name> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>++</operator><name><name>context_histo</name><index>[<expr><operator>(</operator><name>context</name> <operator>&lt;&lt;</operator> <literal type="number">5</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>literal</name> <operator>&gt;&gt;</operator> <literal type="number">3</literal><operator>)</operator></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>prev2</name> <operator>=</operator> <name>prev1</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>prev1</name> <operator>=</operator> <name>literal</name></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>entropy</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ShannonEntropy</name><argument_list>(<argument><expr><name>combined_histo</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>dummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>entropy</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">13</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
      <expr_stmt><expr><name><name>entropy</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>+=</operator> <call><name>ShannonEntropy</name><argument_list>(<argument><expr><name>context_histo</name> <operator>+</operator> <operator>(</operator><name>i</name> <operator>&lt;&lt;</operator> <literal type="number">5</literal><operator>)</operator></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>dummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>entropy</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1.0</literal> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator><name>total</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>entropy</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>*=</operator> <name><name>entropy</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>entropy</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>*=</operator> <name><name>entropy</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <comment type="block">/* The triggering heuristics below were tuned by compressing the individual
       files of the silesia corpus. If we skip this kind of context modeling
       for not very well compressible input (i.e. entropy using context modeling
       is 60% of maximal entropy) or if expected savings by symbol are less
       than 0.2 bits, then in every case when it triggers, the final compression
       ratio is improved. Note however that this heuristics might be too strict
       for some cases and could be tuned further. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>entropy</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&gt;</operator> <literal type="number">3.0</literal> <operator>||</operator> <name><name>entropy</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>entropy</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0.2</literal></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>BROTLI_FALSE</name></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>num_literal_contexts</name> <operator>=</operator> <literal type="number">13</literal></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>literal_context_map</name> <operator>=</operator> <name>kStaticContextMapComplexUTF8</name></expr>;</expr_stmt>
      <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>DecideOverLiteralContextModeling</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>uint8_t</name><modifier>*</modifier></type> <name>input</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>start_pos</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>length</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>mask</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>quality</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size_hint</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name><modifier>*</modifier></type> <name>num_literal_contexts</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint32_t</name><modifier>*</modifier><modifier>*</modifier></type> <name>literal_context_map</name></decl></parameter>,
    <parameter><decl><type><name>uint32_t</name><modifier>*</modifier></type> <name>arena</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>quality</name> <operator>&lt;</operator> <name>MIN_QUALITY_FOR_CONTEXT_MODELING</name> <operator>||</operator> <name>length</name> <operator>&lt;</operator> <literal type="number">64</literal></expr>)</condition> <block>{<block_content>
    <return>return;</return>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>ShouldUseComplexStaticContextMap</name><argument_list>(
      <argument><expr><name>input</name></expr></argument>, <argument><expr><name>start_pos</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name>quality</name></expr></argument>, <argument><expr><name>size_hint</name></expr></argument>,
      <argument><expr><name>num_literal_contexts</name></expr></argument>, <argument><expr><name>literal_context_map</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <comment type="block">/* Context map was already set, nothing else to do. */</comment>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <comment type="block">/* Gather bi-gram data of the UTF8 byte prefixes. To make the analysis of
       UTF8 data faster we only examine 64 byte long strides at every 4kB
       intervals. */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>end_pos</name> <init>= <expr><name>start_pos</name> <operator>+</operator> <name>length</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name><modifier>*</modifier> <name>BROTLI_RESTRICT</name> <specifier>const</specifier></type> <name>bigram_prefix_histo</name> <init>= <expr><name>arena</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>bigram_prefix_histo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>arena</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">9</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init>;</init> <condition><expr><name>start_pos</name> <operator>+</operator> <literal type="number">64</literal> <operator>&lt;=</operator> <name>end_pos</name></expr>;</condition> <incr><expr><name>start_pos</name> <operator>+=</operator> <literal type="number">4096</literal></expr></incr>)</control> <block>{<block_content>
      <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name><name>lut</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr> }</block></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>stride_end_pos</name> <init>= <expr><name>start_pos</name> <operator>+</operator> <literal type="number">64</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>prev</name> <init>= <expr><name><name>lut</name><index>[<expr><name><name>input</name><index>[<expr><name>start_pos</name> <operator>&amp;</operator> <name>mask</name></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">6</literal></expr>]</index></name> <operator>*</operator> <literal type="number">3</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>size_t</name></type> <name>pos</name></decl>;</decl_stmt>
      <for>for <control>(<init><expr><name>pos</name> <operator>=</operator> <name>start_pos</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>pos</name> <operator>&lt;</operator> <name>stride_end_pos</name></expr>;</condition> <incr><expr><operator>++</operator><name>pos</name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name></type> <name>literal</name> <init>= <expr><name><name>input</name><index>[<expr><name>pos</name> <operator>&amp;</operator> <name>mask</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><operator>++</operator><name><name>bigram_prefix_histo</name><index>[<expr><name>prev</name> <operator>+</operator> <name><name>lut</name><index>[<expr><name>literal</name> <operator>&gt;&gt;</operator> <literal type="number">6</literal></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>prev</name> <operator>=</operator> <name><name>lut</name><index>[<expr><name>literal</name> <operator>&gt;&gt;</operator> <literal type="number">6</literal></expr>]</index></name> <operator>*</operator> <literal type="number">3</literal></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>ChooseContextMap</name><argument_list>(<argument><expr><name>quality</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bigram_prefix_histo</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>num_literal_contexts</name></expr></argument>,
                     <argument><expr><name>literal_context_map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BROTLI_BOOL</name></type> <name>ShouldCompress</name><parameter_list>(
    <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name><modifier>*</modifier></type> <name>data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>mask</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint64_t</name></type> <name>last_flush_pos</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>bytes</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>num_literals</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>num_commands</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* TODO(eustas): find more precise minimal block overhead. */</comment>
  <if_stmt><if>if <condition>(<expr><name>bytes</name> <operator>&lt;=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>BROTLI_FALSE</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>num_commands</name> <operator>&lt;</operator> <operator>(</operator><name>bytes</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>+</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>double</name><operator>)</operator><name>num_literals</name> <operator>&gt;</operator> <literal type="number">0.99</literal> <operator>*</operator> <operator>(</operator><name>double</name><operator>)</operator><name>bytes</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>uint32_t</name></type> <name><name>literal_histo</name><index>[<expr><literal type="number">256</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint32_t</name></type> <name>kSampleRate</name> <init>= <expr><literal type="number">13</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>double</name></type> <name>kMinEntropy</name> <init>= <expr><literal type="number">7.92</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>double</name></type> <name>bit_cost_threshold</name> <init>=
          <expr><operator>(</operator><name>double</name><operator>)</operator><name>bytes</name> <operator>*</operator> <name>kMinEntropy</name> <operator>/</operator> <name>kSampleRate</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>size_t</name></type> <name>t</name> <init>= <expr><operator>(</operator><name>bytes</name> <operator>+</operator> <name>kSampleRate</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name>kSampleRate</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>pos</name> <init>= <expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>last_flush_pos</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
      <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>t</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><operator>++</operator><name><name>literal_histo</name><index>[<expr><name><name>data</name><index>[<expr><name>pos</name> <operator>&amp;</operator> <name>mask</name></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pos</name> <operator>+=</operator> <name>kSampleRate</name></expr>;</expr_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if <condition>(<expr><call><name>BitsEntropy</name><argument_list>(<argument><expr><name>literal_histo</name></expr></argument>, <argument><expr><literal type="number">256</literal></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>bit_cost_threshold</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>BROTLI_FALSE</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Chooses the literal context mode for a metablock */</comment>
<function><type><specifier>static</specifier> <name>ContextType</name></type> <name>ChooseContextMode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BrotliEncoderParams</name><modifier>*</modifier></type> <name>params</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name><modifier>*</modifier></type> <name>data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>mask</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>length</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* We only do the computation for the option of something else than
     CONTEXT_UTF8 for the highest qualities */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>quality</name></name> <operator>&gt;=</operator> <name>MIN_QUALITY_FOR_HQ_BLOCK_SPLITTING</name> <operator>&amp;&amp;</operator>
      <operator>!</operator><call><name>BrotliIsMostlyUTF8</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>kMinUTF8Ratio</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>CONTEXT_SIGNED</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>CONTEXT_UTF8</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>WriteMetaBlockInternal</name><parameter_list>(<parameter><decl><type><name>MemoryManager</name><modifier>*</modifier></type> <name>m</name></decl></parameter>,
                                   <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name><modifier>*</modifier></type> <name>data</name></decl></parameter>,
                                   <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>mask</name></decl></parameter>,
                                   <parameter><decl><type><specifier>const</specifier> <name>uint64_t</name></type> <name>last_flush_pos</name></decl></parameter>,
                                   <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>bytes</name></decl></parameter>,
                                   <parameter><decl><type><specifier>const</specifier> <name>BROTLI_BOOL</name></type> <name>is_last</name></decl></parameter>,
                                   <parameter><decl><type><name>ContextType</name></type> <name>literal_context_mode</name></decl></parameter>,
                                   <parameter><decl><type><specifier>const</specifier> <name>BrotliEncoderParams</name><modifier>*</modifier></type> <name>params</name></decl></parameter>,
                                   <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name></type> <name>prev_byte</name></decl></parameter>,
                                   <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name></type> <name>prev_byte2</name></decl></parameter>,
                                   <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>num_literals</name></decl></parameter>,
                                   <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>num_commands</name></decl></parameter>,
                                   <parameter><decl><type><name>Command</name><modifier>*</modifier></type> <name>commands</name></decl></parameter>,
                                   <parameter><decl><type><specifier>const</specifier> <name>int</name><modifier>*</modifier></type> <name>saved_dist_cache</name></decl></parameter>,
                                   <parameter><decl><type><name>int</name><modifier>*</modifier></type> <name>dist_cache</name></decl></parameter>,
                                   <parameter><decl><type><name>size_t</name><modifier>*</modifier></type> <name>storage_ix</name></decl></parameter>,
                                   <parameter><decl><type><name>uint8_t</name><modifier>*</modifier></type> <name>storage</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>wrapped_last_flush_pos</name> <init>= <expr><call><name>WrapPosition</name><argument_list>(<argument><expr><name>last_flush_pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint16_t</name></type> <name>last_bytes</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>last_bytes_bits</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ContextLut</name></type> <name>literal_context_lut</name> <init>= <expr><call><name>BROTLI_CONTEXT_LUT</name><argument_list>(<argument><expr><name>literal_context_mode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BrotliEncoderParams</name></type> <name>block_params</name> <init>= <expr><operator>*</operator><name>params</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>bytes</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <comment type="block">/* Write the ISLAST and ISEMPTY bits. */</comment>
    <expr_stmt><expr><call><name>BrotliWriteBits</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>storage_ix</name></expr></argument>, <argument><expr><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>storage_ix</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>storage_ix</name> <operator>+</operator> <literal type="number">7u</literal><operator>)</operator> <operator>&amp;</operator> <operator>~</operator><literal type="number">7u</literal></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ShouldCompress</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name>last_flush_pos</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>,
                      <argument><expr><name>num_literals</name></expr></argument>, <argument><expr><name>num_commands</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <comment type="block">/* Restore the distance cache, as its last update by
       CreateBackwardReferences is now unused. */</comment>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dist_cache</name></expr></argument>, <argument><expr><name>saved_dist_cache</name></expr></argument>, <argument><expr><literal type="number">4</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>dist_cache</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BrotliStoreUncompressedMetaBlock</name><argument_list>(<argument><expr><name>is_last</name></expr></argument>, <argument><expr><name>data</name></expr></argument>,
                                     <argument><expr><name>wrapped_last_flush_pos</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>,
                                     <argument><expr><name>storage_ix</name></expr></argument>, <argument><expr><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>BROTLI_DCHECK</name><argument_list>(<argument><expr><operator>*</operator><name>storage_ix</name> <operator>&lt;=</operator> <literal type="number">14</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>last_bytes</name> <operator>=</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator><operator>(</operator><operator>(</operator><name><name>storage</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>|</operator> <name><name>storage</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>last_bytes_bits</name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><operator>(</operator><operator>*</operator><name>storage_ix</name><operator>)</operator></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>quality</name></name> <operator>&lt;=</operator> <name>MAX_QUALITY_FOR_STATIC_ENTROPY_CODES</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>BrotliStoreMetaBlockFast</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>wrapped_last_flush_pos</name></expr></argument>,
                             <argument><expr><name>bytes</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name>is_last</name></expr></argument>, <argument><expr><name>params</name></expr></argument>,
                             <argument><expr><name>commands</name></expr></argument>, <argument><expr><name>num_commands</name></expr></argument>,
                             <argument><expr><name>storage_ix</name></expr></argument>, <argument><expr><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>BROTLI_IS_OOM</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>quality</name></name> <operator>&lt;</operator> <name>MIN_QUALITY_FOR_BLOCK_SPLIT</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>BrotliStoreMetaBlockTrivial</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>wrapped_last_flush_pos</name></expr></argument>,
                                <argument><expr><name>bytes</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name>is_last</name></expr></argument>, <argument><expr><name>params</name></expr></argument>,
                                <argument><expr><name>commands</name></expr></argument>, <argument><expr><name>num_commands</name></expr></argument>,
                                <argument><expr><name>storage_ix</name></expr></argument>, <argument><expr><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>BROTLI_IS_OOM</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>MetaBlockSplit</name></type> <name>mb</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>InitMetaBlockSplit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>quality</name></name> <operator>&lt;</operator> <name>MIN_QUALITY_FOR_HQ_BLOCK_SPLITTING</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>size_t</name></type> <name>num_literal_contexts</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name><modifier>*</modifier></type> <name>literal_context_map</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>params</name><operator>-&gt;</operator><name>disable_literal_context_modeling</name></name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* TODO(eustas): pull to higher level and reuse. */</comment>
        <decl_stmt><decl><type><name>uint32_t</name><modifier>*</modifier></type> <name>arena</name> <init>= <expr><call><name>BROTLI_ALLOC</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>uint32_t</name></expr></argument>, <argument><expr><literal type="number">14</literal> <operator>*</operator> <literal type="number">32</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>BROTLI_IS_OOM</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>BROTLI_IS_NULL</name><argument_list>(<argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>DecideOverLiteralContextModeling</name><argument_list>(
            <argument><expr><name>data</name></expr></argument>, <argument><expr><name>wrapped_last_flush_pos</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name><name>params</name><operator>-&gt;</operator><name>quality</name></name></expr></argument>,
            <argument><expr><name><name>params</name><operator>-&gt;</operator><name>size_hint</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num_literal_contexts</name></expr></argument>,
            <argument><expr><operator>&amp;</operator><name>literal_context_map</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BROTLI_FREE</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>BrotliBuildMetaBlockGreedy</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>wrapped_last_flush_pos</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>,
          <argument><expr><name>prev_byte</name></expr></argument>, <argument><expr><name>prev_byte2</name></expr></argument>, <argument><expr><name>literal_context_lut</name></expr></argument>, <argument><expr><name>num_literal_contexts</name></expr></argument>,
          <argument><expr><name>literal_context_map</name></expr></argument>, <argument><expr><name>commands</name></expr></argument>, <argument><expr><name>num_commands</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>BROTLI_IS_OOM</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><call><name>BrotliBuildMetaBlock</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>wrapped_last_flush_pos</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>block_params</name></expr></argument>,
                           <argument><expr><name>prev_byte</name></expr></argument>, <argument><expr><name>prev_byte2</name></expr></argument>,
                           <argument><expr><name>commands</name></expr></argument>, <argument><expr><name>num_commands</name></expr></argument>,
                           <argument><expr><name>literal_context_mode</name></expr></argument>,
                           <argument><expr><operator>&amp;</operator><name>mb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>BROTLI_IS_OOM</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>quality</name></name> <operator>&gt;=</operator> <name>MIN_QUALITY_FOR_OPTIMIZE_HISTOGRAMS</name></expr>)</condition> <block>{<block_content>
      <comment type="block">/* The number of distance symbols effectively used for distance
         histograms. It might be less than distance alphabet size
         for "Large Window Brotli" (32-bit). */</comment>
      <expr_stmt><expr><call><name>BrotliOptimizeHistograms</name><argument_list>(<argument><expr><name><name>block_params</name><operator>.</operator><name>dist</name><operator>.</operator><name>alphabet_size_limit</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>BrotliStoreMetaBlock</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>wrapped_last_flush_pos</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>,
                         <argument><expr><name>prev_byte</name></expr></argument>, <argument><expr><name>prev_byte2</name></expr></argument>,
                         <argument><expr><name>is_last</name></expr></argument>,
                         <argument><expr><operator>&amp;</operator><name>block_params</name></expr></argument>,
                         <argument><expr><name>literal_context_mode</name></expr></argument>,
                         <argument><expr><name>commands</name></expr></argument>, <argument><expr><name>num_commands</name></expr></argument>,
                         <argument><expr><operator>&amp;</operator><name>mb</name></expr></argument>,
                         <argument><expr><name>storage_ix</name></expr></argument>, <argument><expr><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>BROTLI_IS_OOM</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>DestroyMetaBlockSplit</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>bytes</name> <operator>+</operator> <literal type="number">4</literal> <operator>&lt;</operator> <operator>(</operator><operator>*</operator><name>storage_ix</name> <operator>&gt;&gt;</operator> <literal type="number">3</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
    <comment type="block">/* Restore the distance cache and last byte. */</comment>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dist_cache</name></expr></argument>, <argument><expr><name>saved_dist_cache</name></expr></argument>, <argument><expr><literal type="number">4</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>dist_cache</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>storage</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name>last_bytes</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>storage</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><operator>(</operator><name>last_bytes</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>storage_ix</name> <operator>=</operator> <name>last_bytes_bits</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BrotliStoreUncompressedMetaBlock</name><argument_list>(<argument><expr><name>is_last</name></expr></argument>, <argument><expr><name>data</name></expr></argument>,
                                     <argument><expr><name>wrapped_last_flush_pos</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>,
                                     <argument><expr><name>bytes</name></expr></argument>, <argument><expr><name>storage_ix</name></expr></argument>, <argument><expr><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>ChooseDistanceParams</name><parameter_list>(<parameter><decl><type><name>BrotliEncoderParams</name><modifier>*</modifier></type> <name>params</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>distance_postfix_bits</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>num_direct_distance_codes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>quality</name></name> <operator>&gt;=</operator> <name>MIN_QUALITY_FOR_NONZERO_DISTANCE_PARAMS</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>ndirect_msb</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>BROTLI_MODE_FONT</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>distance_postfix_bits</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>num_direct_distance_codes</name> <operator>=</operator> <literal type="number">12</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>distance_postfix_bits</name> <operator>=</operator> <name><name>params</name><operator>-&gt;</operator><name>dist</name><operator>.</operator><name>distance_postfix_bits</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>num_direct_distance_codes</name> <operator>=</operator> <name><name>params</name><operator>-&gt;</operator><name>dist</name><operator>.</operator><name>num_direct_distance_codes</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>ndirect_msb</name> <operator>=</operator> <operator>(</operator><name>num_direct_distance_codes</name> <operator>&gt;&gt;</operator> <name>distance_postfix_bits</name><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x0F</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>distance_postfix_bits</name> <operator>&gt;</operator> <name>BROTLI_MAX_NPOSTFIX</name> <operator>||</operator>
        <name>num_direct_distance_codes</name> <operator>&gt;</operator> <name>BROTLI_MAX_NDIRECT</name> <operator>||</operator>
        <operator>(</operator><name>ndirect_msb</name> <operator>&lt;&lt;</operator> <name>distance_postfix_bits</name><operator>)</operator> <operator>!=</operator> <name>num_direct_distance_codes</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>distance_postfix_bits</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>num_direct_distance_codes</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>BrotliInitDistanceParams</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>params</name><operator>-&gt;</operator><name>dist</name></name></expr></argument>, <argument><expr><name>distance_postfix_bits</name></expr></argument>,
                           <argument><expr><name>num_direct_distance_codes</name></expr></argument>, <argument><expr><name><name>params</name><operator>-&gt;</operator><name>large_window</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BROTLI_BOOL</name></type> <name>EnsureInitialized</name><parameter_list>(<parameter><decl><type><name>BrotliEncoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>MemoryManager</name><modifier>*</modifier></type> <name>m</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>memory_manager_</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>BROTLI_IS_OOM</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>BROTLI_FALSE</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>is_initialized_</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>BROTLI_TRUE</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>last_bytes_bits_</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>last_bytes_</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>flint_</name></name> <operator>=</operator> <name>BROTLI_FLINT_DONE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>remaining_metadata_bytes_</name></name> <operator>=</operator> <name>BROTLI_UINT32_MAX</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SanitizeParams</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>params</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>lgblock</name></name> <operator>=</operator> <call><name>ComputeLgBlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>params</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ChooseDistanceParams</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>params</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>stream_offset</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>flint_</name></name> <operator>=</operator> <name>BROTLI_FLINT_NEEDS_2_BYTES</name></expr>;</expr_stmt>
    <comment type="block">/* Poison the distance cache. -16 +- 3 is still less than zero (invalid). */</comment>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>dist_cache_</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">16</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>dist_cache_</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">16</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>dist_cache_</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">16</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>dist_cache_</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">16</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>saved_dist_cache_</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>dist_cache_</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>saved_dist_cache_</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>RingBufferSetup</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>params</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>ringbuffer_</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Initialize last byte with stream header. */</comment>
  <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>lgwin</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>lgwin</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>quality</name></name> <operator>==</operator> <name>FAST_ONE_PASS_COMPRESSION_QUALITY</name> <operator>||</operator>
        <name><name>s</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>quality</name></name> <operator>==</operator> <name>FAST_TWO_PASS_COMPRESSION_QUALITY</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>lgwin</name> <operator>=</operator> <call><name>BROTLI_MAX</name><argument_list>(<argument><expr><name>int</name></expr></argument>, <argument><expr><name>lgwin</name></expr></argument>, <argument><expr><literal type="number">18</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>stream_offset</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>EncodeWindowBits</name><argument_list>(<argument><expr><name>lgwin</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>large_window</name></name></expr></argument>,
                       <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>last_bytes_</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>last_bytes_bits_</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <comment type="block">/* Bigger values have the same effect, but could cause overflows. */</comment>
      <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>stream_offset</name></name> <operator>=</operator> <call><name>BROTLI_MIN</name><argument_list>(<argument><expr><name>size_t</name></expr></argument>,
          <argument><expr><name><name>s</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>stream_offset</name></name></expr></argument>, <argument><expr><call><name>BROTLI_MAX_BACKWARD_LIMIT</name><argument_list>(<argument><expr><name>lgwin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block>

  <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>quality</name></name> <operator>==</operator> <name>FAST_ONE_PASS_COMPRESSION_QUALITY</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>one_pass_arena_</name></name> <operator>=</operator> <call><name>BROTLI_ALLOC</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>BrotliOnePassArena</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>BROTLI_IS_OOM</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>BROTLI_FALSE</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>InitCommandPrefixCodes</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>one_pass_arena_</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>quality</name></name> <operator>==</operator> <name>FAST_TWO_PASS_COMPRESSION_QUALITY</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>two_pass_arena_</name></name> <operator>=</operator> <call><name>BROTLI_ALLOC</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>BrotliTwoPassArena</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>BROTLI_IS_OOM</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>BROTLI_FALSE</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>is_initialized_</name></name> <operator>=</operator> <name>BROTLI_TRUE</name></expr>;</expr_stmt>
  <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>BrotliEncoderInitParams</name><parameter_list>(<parameter><decl><type><name>BrotliEncoderParams</name><modifier>*</modifier></type> <name>params</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>BROTLI_DEFAULT_MODE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>large_window</name></name> <operator>=</operator> <name>BROTLI_FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>quality</name></name> <operator>=</operator> <name>BROTLI_DEFAULT_QUALITY</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>lgwin</name></name> <operator>=</operator> <name>BROTLI_DEFAULT_WINDOW</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>lgblock</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>stream_offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>size_hint</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>disable_literal_context_modeling</name></name> <operator>=</operator> <name>BROTLI_FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>BrotliInitSharedEncoderDictionary</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>params</name><operator>-&gt;</operator><name>dictionary</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>dist</name><operator>.</operator><name>distance_postfix_bits</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>dist</name><operator>.</operator><name>num_direct_distance_codes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>dist</name><operator>.</operator><name>alphabet_size_max</name></name> <operator>=</operator>
      <call><name>BROTLI_DISTANCE_ALPHABET_SIZE</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BROTLI_MAX_DISTANCE_BITS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>dist</name><operator>.</operator><name>alphabet_size_limit</name></name> <operator>=</operator> <name><name>params</name><operator>-&gt;</operator><name>dist</name><operator>.</operator><name>alphabet_size_max</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>dist</name><operator>.</operator><name>max_distance</name></name> <operator>=</operator> <name>BROTLI_MAX_DISTANCE</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>BrotliEncoderCleanupParams</name><parameter_list>(<parameter><decl><type><name>MemoryManager</name><modifier>*</modifier></type> <name>m</name></decl></parameter>,
    <parameter><decl><type><name>BrotliEncoderParams</name><modifier>*</modifier></type> <name>params</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>BrotliCleanupSharedEncoderDictionary</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>params</name><operator>-&gt;</operator><name>dictionary</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>BrotliEncoderInitState</name><parameter_list>(<parameter><decl><type><name>BrotliEncoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>BrotliEncoderInitParams</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>params</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>input_pos_</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>num_commands_</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>num_literals_</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>last_insert_len_</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>last_flush_pos_</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>last_processed_pos_</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>prev_byte_</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>prev_byte2_</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>storage_size_</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>storage_</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>HasherInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>hasher_</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>large_table_</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>large_table_size_</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>one_pass_arena_</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>two_pass_arena_</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>command_buf_</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>literal_buf_</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>total_in_</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>next_out_</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>available_out_</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>total_out_</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>stream_state_</name></name> <operator>=</operator> <name>BROTLI_STREAM_PROCESSING</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>is_last_block_emitted_</name></name> <operator>=</operator> <name>BROTLI_FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>is_initialized_</name></name> <operator>=</operator> <name>BROTLI_FALSE</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>RingBufferInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>ringbuffer_</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>commands_</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>cmd_alloc_size_</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <comment type="block">/* Initialize distance cache. */</comment>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>dist_cache_</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>dist_cache_</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">11</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>dist_cache_</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="number">15</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>dist_cache_</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
  <comment type="block">/* Save the state of the distance cache in case we need to restore it for
     emitting an uncompressed block. */</comment>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>saved_dist_cache_</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>dist_cache_</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>saved_dist_cache_</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>BrotliEncoderState</name><modifier>*</modifier></type> <name>BrotliEncoderCreateInstance</name><parameter_list>(
    <parameter><decl><type><name>brotli_alloc_func</name></type> <name>alloc_func</name></decl></parameter>, <parameter><decl><type><name>brotli_free_func</name></type> <name>free_func</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>opaque</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>BrotliEncoderState</name><modifier>*</modifier></type> <name>state</name> <init>= <expr><operator>(</operator><name>BrotliEncoderState</name><operator>*</operator><operator>)</operator><call><name>BrotliBootstrapAlloc</name><argument_list>(
      <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BrotliEncoderState</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>alloc_func</name></expr></argument>, <argument><expr><name>free_func</name></expr></argument>, <argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <comment type="block">/* BROTLI_DUMP(); */</comment>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>BrotliInitMemoryManager</name><argument_list>(
      <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>memory_manager_</name></name></expr></argument>, <argument><expr><name>alloc_func</name></expr></argument>, <argument><expr><name>free_func</name></expr></argument>, <argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>BrotliEncoderInitState</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>state</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>BROTLI_REPORTING</name></cpp:ifdef>
<comment type="block">/* When BROTLI_REPORTING is defined extra reporting module have to be linked. */</comment>
<function_decl><type><name>void</name></type> <name>BrotliEncoderOnFinish</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BrotliEncoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_ENCODER_ON_FINISH</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>BrotliEncoderOnFinish(s);</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>BROTLI_ENCODER_ON_FINISH</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_ENCODER_ON_FINISH</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(void)(s);</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type> <name>BrotliEncoderCleanupState</name><parameter_list>(<parameter><decl><type><name>BrotliEncoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>MemoryManager</name><modifier>*</modifier></type> <name>m</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>memory_manager_</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>BROTLI_ENCODER_ON_FINISH</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>BROTLI_IS_OOM</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>BrotliWipeOutMemoryManager</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>BROTLI_FREE</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>storage_</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>BROTLI_FREE</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>commands_</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>RingBufferFree</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>ringbuffer_</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>DestroyHasher</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>hasher_</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>BROTLI_FREE</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>large_table_</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>BROTLI_FREE</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>one_pass_arena_</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>BROTLI_FREE</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>two_pass_arena_</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>BROTLI_FREE</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>command_buf_</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>BROTLI_FREE</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>literal_buf_</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>BrotliEncoderCleanupParams</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>params</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Deinitializes and frees BrotliEncoderState instance. */</comment>
<function><type><name>void</name></type> <name>BrotliEncoderDestroyInstance</name><parameter_list>(<parameter><decl><type><name>BrotliEncoderState</name><modifier>*</modifier></type> <name>state</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>state</name></expr>)</condition> <block>{<block_content>
    <return>return;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>BrotliEncoderCleanupState</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BrotliBootstrapFree</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>memory_manager_</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
   Copies the given input data to the internal ring buffer of the compressor.
   No processing of the data occurs at this time and this function can be
   called multiple times before calling WriteBrotliData() to process the
   accumulated input. At most input_block_size() bytes of input data can be
   copied to the ring buffer, otherwise the next WriteBrotliData() will fail.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>CopyInputToRingBuffer</name><parameter_list>(<parameter><decl><type><name>BrotliEncoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>,
                                  <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>input_size</name></decl></parameter>,
                                  <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name><modifier>*</modifier></type> <name>input_buffer</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>RingBuffer</name><modifier>*</modifier></type> <name>ringbuffer_</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>ringbuffer_</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MemoryManager</name><modifier>*</modifier></type> <name>m</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>memory_manager_</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>RingBufferWrite</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>input_buffer</name></expr></argument>, <argument><expr><name>input_size</name></expr></argument>, <argument><expr><name>ringbuffer_</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>BROTLI_IS_OOM</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>input_pos_</name></name> <operator>+=</operator> <name>input_size</name></expr>;</expr_stmt>

  <comment type="block">/* TL;DR: If needed, initialize 7 more bytes in the ring buffer to make the
     hashing not depend on uninitialized data. This makes compression
     deterministic and it prevents uninitialized memory warnings in Valgrind.
     Even without erasing, the output would be valid (but nondeterministic).

     Background information: The compressor stores short (at most 8 bytes)
     substrings of the input already read in a hash table, and detects
     repetitions by looking up such substrings in the hash table. If it
     can find a substring, it checks whether the substring is really there
     in the ring buffer (or it's just a hash collision). Should the hash
     table become corrupt, this check makes sure that the output is
     still valid, albeit the compression ratio would be bad.

     The compressor populates the hash table from the ring buffer as it's
     reading new bytes from the input. However, at the last few indexes of
     the ring buffer, there are not enough bytes to build full-length
     substrings from. Since the hash table always contains full-length
     substrings, we erase with dummy zeros here to make sure that those
     substrings will contain zeros at the end instead of uninitialized
     data.

     Please note that erasing is not necessary (because the
     memory region is already initialized since he ring buffer
     has a `tail' that holds a copy of the beginning,) so we
     skip erasing if we have already gone around at least once in
     the ring buffer.

     Only clear during the first round of ring-buffer writes. On
     subsequent rounds data in the ring-buffer would be affected. */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>ringbuffer_</name><operator>-&gt;</operator><name>pos_</name></name> <operator>&lt;=</operator> <name><name>ringbuffer_</name><operator>-&gt;</operator><name>mask_</name></name></expr>)</condition> <block>{<block_content>
    <comment type="block">/* This is the first time when the ring buffer is being written.
       We clear 7 bytes just after the bytes that have been copied from
       the input buffer.

       The ring-buffer has a "tail" that holds a copy of the beginning,
       but only once the ring buffer has been fully written once, i.e.,
       pos &lt;= mask. For the first time, we need to write values
       in this tail (where index may be larger than mask), so that
       we have exactly defined behavior and don't read uninitialized
       memory. Due to performance reasons, hashing reads data using a
       LOAD64, which can go 7 bytes beyond the bytes written in the
       ring-buffer. */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>ringbuffer_</name><operator>-&gt;</operator><name>buffer_</name></name> <operator>+</operator> <name><name>ringbuffer_</name><operator>-&gt;</operator><name>pos_</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Marks all input as processed.
   Returns true if position wrapping occurs. */</comment>
<function><type><specifier>static</specifier> <name>BROTLI_BOOL</name></type> <name>UpdateLastProcessedPos</name><parameter_list>(<parameter><decl><type><name>BrotliEncoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>wrapped_last_processed_pos</name> <init>= <expr><call><name>WrapPosition</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>last_processed_pos_</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>wrapped_input_pos</name> <init>= <expr><call><name>WrapPosition</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>input_pos_</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>last_processed_pos_</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>input_pos_</name></name></expr>;</expr_stmt>
  <return>return <expr><call><name>TO_BROTLI_BOOL</name><argument_list>(<argument><expr><name>wrapped_input_pos</name> <operator>&lt;</operator> <name>wrapped_last_processed_pos</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>ExtendLastCommand</name><parameter_list>(<parameter><decl><type><name>BrotliEncoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name><modifier>*</modifier></type> <name>bytes</name></decl></parameter>,
                              <parameter><decl><type><name>uint32_t</name><modifier>*</modifier></type> <name>wrapped_last_processed_pos</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>Command</name><modifier>*</modifier></type> <name>last_command</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>commands_</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>num_commands_</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name><modifier>*</modifier></type> <name>data</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ringbuffer_</name><operator>.</operator><name>buffer_</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>mask</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ringbuffer_</name><operator>.</operator><name>mask_</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint64_t</name></type> <name>max_backward_distance</name> <init>=
      <expr><operator>(</operator><operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>lgwin</name></name><operator>)</operator> <operator>-</operator> <name>BROTLI_WINDOW_GAP</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint64_t</name></type> <name>last_copy_len</name> <init>= <expr><name><name>last_command</name><operator>-&gt;</operator><name>copy_len_</name></name> <operator>&amp;</operator> <literal type="number">0x1FFFFFF</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint64_t</name></type> <name>last_processed_pos</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>last_processed_pos_</name></name> <operator>-</operator> <name>last_copy_len</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint64_t</name></type> <name>max_distance</name> <init>= <expr><ternary><condition><expr><name>last_processed_pos</name> <operator>&lt;</operator> <name>max_backward_distance</name></expr> ?</condition><then>
      <expr><name>last_processed_pos</name></expr> </then><else>: <expr><name>max_backward_distance</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint64_t</name></type> <name>cmd_dist</name> <init>= <expr><operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>dist_cache_</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>distance_code</name> <init>= <expr><call><name>CommandRestoreDistanceCode</name><argument_list>(<argument><expr><name>last_command</name></expr></argument>,
                                                      <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>dist</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>CompoundDictionary</name><modifier>*</modifier></type> <name>dict</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>dictionary</name><operator>.</operator><name>compound</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>compound_dictionary_size</name> <init>= <expr><name><name>dict</name><operator>-&gt;</operator><name>total_size</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>distance_code</name> <operator>&lt;</operator> <name>BROTLI_NUM_DISTANCE_SHORT_CODES</name> <operator>||</operator>
      <name>distance_code</name> <operator>-</operator> <operator>(</operator><name>BROTLI_NUM_DISTANCE_SHORT_CODES</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <name>cmd_dist</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>cmd_dist</name> <operator>&lt;=</operator> <name>max_distance</name></expr>)</condition> <block>{<block_content>
      <while>while <condition>(<expr><operator>*</operator><name>bytes</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>data</name><index>[<expr><operator>*</operator><name>wrapped_last_processed_pos</name> <operator>&amp;</operator> <name>mask</name></expr>]</index></name> <operator>==</operator>
             <name><name>data</name><index>[<expr><operator>(</operator><operator>*</operator><name>wrapped_last_processed_pos</name> <operator>-</operator> <name>cmd_dist</name><operator>)</operator> <operator>&amp;</operator> <name>mask</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>last_command</name><operator>-&gt;</operator><name>copy_len_</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><operator>(</operator><operator>*</operator><name>bytes</name><operator>)</operator><operator>--</operator></expr>;</expr_stmt>
        <expr_stmt><expr><operator>(</operator><operator>*</operator><name>wrapped_last_processed_pos</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></while>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>cmd_dist</name> <operator>-</operator> <name>max_distance</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;</operator> <name>compound_dictionary_size</name> <operator>&amp;&amp;</operator>
          <name>last_copy_len</name> <operator>&lt;</operator> <name>cmd_dist</name> <operator>-</operator> <name>max_distance</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name></type> <name>address</name> <init>=
            <expr><name>compound_dictionary_size</name> <operator>-</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>cmd_dist</name> <operator>-</operator> <name>max_distance</name><operator>)</operator> <operator>+</operator>
            <operator>(</operator><name>size_t</name><operator>)</operator><name>last_copy_len</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>br_index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>br_offset</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name><modifier>*</modifier></type> <name>chunk</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>chunk_length</name></decl>;</decl_stmt>
        <while>while <condition>(<expr><name>address</name> <operator>&gt;=</operator> <name><name>dict</name><operator>-&gt;</operator><name>chunk_offsets</name><index>[<expr><name>br_index</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>br_index</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
        <expr_stmt><expr><name>br_offset</name> <operator>=</operator> <name>address</name> <operator>-</operator> <name><name>dict</name><operator>-&gt;</operator><name>chunk_offsets</name><index>[<expr><name>br_index</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>chunk</name> <operator>=</operator> <name><name>dict</name><operator>-&gt;</operator><name>chunk_source</name><index>[<expr><name>br_index</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>chunk_length</name> <operator>=</operator>
            <name><name>dict</name><operator>-&gt;</operator><name>chunk_offsets</name><index>[<expr><name>br_index</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>dict</name><operator>-&gt;</operator><name>chunk_offsets</name><index>[<expr><name>br_index</name></expr>]</index></name></expr>;</expr_stmt>
        <while>while <condition>(<expr><operator>*</operator><name>bytes</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>data</name><index>[<expr><operator>*</operator><name>wrapped_last_processed_pos</name> <operator>&amp;</operator> <name>mask</name></expr>]</index></name> <operator>==</operator>
               <name><name>chunk</name><index>[<expr><name>br_offset</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name><name>last_command</name><operator>-&gt;</operator><name>copy_len_</name></name><operator>++</operator></expr>;</expr_stmt>
          <expr_stmt><expr><operator>(</operator><operator>*</operator><name>bytes</name><operator>)</operator><operator>--</operator></expr>;</expr_stmt>
          <expr_stmt><expr><operator>(</operator><operator>*</operator><name>wrapped_last_processed_pos</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><operator>++</operator><name>br_offset</name> <operator>==</operator> <name>chunk_length</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>br_index</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>br_offset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>br_index</name> <operator>!=</operator> <name><name>dict</name><operator>-&gt;</operator><name>num_chunks</name></name></expr>)</condition> <block>{<block_content>
              <expr_stmt><expr><name>chunk</name> <operator>=</operator> <name><name>dict</name><operator>-&gt;</operator><name>chunk_source</name><index>[<expr><name>br_index</name></expr>]</index></name></expr>;</expr_stmt>
              <expr_stmt><expr><name>chunk_length</name> <operator>=</operator> <name><name>dict</name><operator>-&gt;</operator><name>chunk_offsets</name><index>[<expr><name>br_index</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>-</operator>
                  <name><name>dict</name><operator>-&gt;</operator><name>chunk_offsets</name><index>[<expr><name>br_index</name></expr>]</index></name></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
              <break>break;</break>
            </block_content>}</block></else></if_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></while>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <comment type="block">/* The copy length is at most the metablock size, and thus expressible. */</comment>
    <expr_stmt><expr><call><name>GetLengthCode</name><argument_list>(<argument><expr><name><name>last_command</name><operator>-&gt;</operator><name>insert_len_</name></name></expr></argument>,
                  <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>last_command</name><operator>-&gt;</operator><name>copy_len_</name></name> <operator>&amp;</operator> <literal type="number">0x1FFFFFF</literal><operator>)</operator> <operator>+</operator>
                           <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>last_command</name><operator>-&gt;</operator><name>copy_len_</name></name> <operator>&gt;&gt;</operator> <literal type="number">25</literal><operator>)</operator><operator>)</operator></expr></argument>,
                  <argument><expr><call><name>TO_BROTLI_BOOL</name><argument_list>(<argument><expr><operator>(</operator><name><name>last_command</name><operator>-&gt;</operator><name>dist_prefix_</name></name> <operator>&amp;</operator> <literal type="number">0x3FF</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
                  <argument><expr><operator>&amp;</operator><name><name>last_command</name><operator>-&gt;</operator><name>cmd_prefix_</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
   Processes the accumulated input data and sets |*out_size| to the length of
   the new output meta-block, or to zero if no new output meta-block has been
   created (in this case the processed input data is buffered internally).
   If |*out_size| is positive, |*output| points to the start of the output
   data. If |is_last| or |force_flush| is BROTLI_TRUE, an output meta-block is
   always created. However, until |is_last| is BROTLI_TRUE encoder may retain up
   to 7 bits of the last byte of output. To force encoder to dump the remaining
   bits use WriteMetadata() to append an empty meta-data block.
   Returns BROTLI_FALSE if the size of the input data is larger than
   input_block_size().
 */</comment>
<function><type><specifier>static</specifier> <name>BROTLI_BOOL</name></type> <name>EncodeData</name><parameter_list>(
    <parameter><decl><type><name>BrotliEncoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BROTLI_BOOL</name></type> <name>is_last</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>BROTLI_BOOL</name></type> <name>force_flush</name></decl></parameter>, <parameter><decl><type><name>size_t</name><modifier>*</modifier></type> <name>out_size</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name><modifier>*</modifier><modifier>*</modifier></type> <name>output</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>uint64_t</name></type> <name>delta</name> <init>= <expr><call><name>UnprocessedInputSize</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>bytes</name> <init>= <expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>delta</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>wrapped_last_processed_pos</name> <init>= <expr><call><name>WrapPosition</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>last_processed_pos_</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name><modifier>*</modifier></type> <name>data</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>mask</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MemoryManager</name><modifier>*</modifier></type> <name>m</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>memory_manager_</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ContextType</name></type> <name>literal_context_mode</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ContextLut</name></type> <name>literal_context_lut</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BROTLI_BOOL</name></type> <name>fast_compress</name> <init>=
      <expr><name><name>s</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>quality</name></name> <operator>==</operator> <name>FAST_ONE_PASS_COMPRESSION_QUALITY</name> <operator>||</operator>
      <name><name>s</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>quality</name></name> <operator>==</operator> <name>FAST_TWO_PASS_COMPRESSION_QUALITY</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>data</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>ringbuffer_</name><operator>.</operator><name>buffer_</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mask</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>ringbuffer_</name><operator>.</operator><name>mask_</name></name></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>delta</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* No new input; still might want to flush or finish. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>data</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* No input has been processed so far. */</comment>
      <if_stmt><if>if <condition>(<expr><name>is_last</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Emit complete finalized stream. */</comment>
        <expr_stmt><expr><call><name>BROTLI_DCHECK</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>last_bytes_bits_</name></name> <operator>&lt;=</operator> <literal type="number">14</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>last_bytes_</name></name> <operator>|=</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator><operator>(</operator><literal type="number">3u</literal> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>last_bytes_bits_</name></name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>last_bytes_bits_</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>last_bytes_bits_</name></name> <operator>+</operator> <literal type="number">2u</literal><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>tiny_buf_</name><operator>.</operator><name>u8</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>last_bytes_</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>tiny_buf_</name><operator>.</operator><name>u8</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>last_bytes_</name></name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>output</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>tiny_buf_</name><operator>.</operator><name>u8</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>out_size</name> <operator>=</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>last_bytes_bits_</name></name> <operator>+</operator> <literal type="number">7u</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">3u</literal></expr>;</expr_stmt>
        <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>
      </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* No data, not last -&gt; no-op. */</comment>
        <expr_stmt><expr><operator>*</operator><name>out_size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <comment type="block">/* Fast compress performs flush every block -&gt; flush is no-op. */</comment>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_last</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>force_flush</name> <operator>||</operator> <name>fast_compress</name><operator>)</operator></expr>)</condition> <block>{<block_content>  <comment type="block">/* Another no-op. */</comment>
        <expr_stmt><expr><operator>*</operator><name>out_size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>BROTLI_DCHECK</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>quality</name></name> <operator>&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>dictionary</name><operator>.</operator><name>max_quality</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>BROTLI_FALSE</name></expr>;</return></block_content></block></if></if_stmt>
  <comment type="block">/* Adding more blocks after "last" block is forbidden. */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>is_last_block_emitted_</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>BROTLI_FALSE</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>is_last</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>is_last_block_emitted_</name></name> <operator>=</operator> <name>BROTLI_TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>delta</name> <operator>&gt;</operator> <call><name>InputBlockSize</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>BROTLI_FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>quality</name></name> <operator>==</operator> <name>FAST_TWO_PASS_COMPRESSION_QUALITY</name> <operator>&amp;&amp;</operator>
      <operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>command_buf_</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>command_buf_</name></name> <operator>=</operator>
        <call><name>BROTLI_ALLOC</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>uint32_t</name></expr></argument>, <argument><expr><name>kCompressFragmentTwoPassBlockSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>literal_buf_</name></name> <operator>=</operator>
        <call><name>BROTLI_ALLOC</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>uint8_t</name></expr></argument>, <argument><expr><name>kCompressFragmentTwoPassBlockSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>BROTLI_IS_OOM</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>BROTLI_IS_NULL</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>command_buf_</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
        <call><name>BROTLI_IS_NULL</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>literal_buf_</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>BROTLI_FALSE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>fast_compress</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>uint8_t</name><modifier>*</modifier></type> <name>storage</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>storage_ix</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>last_bytes_bits_</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>table_size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name><modifier>*</modifier></type> <name>table</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>storage</name> <operator>=</operator> <call><name>GetBrotliStorage</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>*</operator> <name>bytes</name> <operator>+</operator> <literal type="number">503</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>BROTLI_IS_OOM</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>BROTLI_FALSE</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>storage</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>last_bytes_</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>storage</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>last_bytes_</name></name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>table</name> <operator>=</operator> <call><name>GetHashTable</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>quality</name></name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>table_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>BROTLI_IS_OOM</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>BROTLI_FALSE</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>quality</name></name> <operator>==</operator> <name>FAST_ONE_PASS_COMPRESSION_QUALITY</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>BrotliCompressFragmentFast</name><argument_list>(
          <argument><expr><name><name>s</name><operator>-&gt;</operator><name>one_pass_arena_</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>wrapped_last_processed_pos</name> <operator>&amp;</operator> <name>mask</name></expr>]</index></name></expr></argument>,
          <argument><expr><name>bytes</name></expr></argument>, <argument><expr><name>is_last</name></expr></argument>,
          <argument><expr><name>table</name></expr></argument>, <argument><expr><name>table_size</name></expr></argument>,
          <argument><expr><operator>&amp;</operator><name>storage_ix</name></expr></argument>, <argument><expr><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>BROTLI_IS_OOM</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>BROTLI_FALSE</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><call><name>BrotliCompressFragmentTwoPass</name><argument_list>(
          <argument><expr><name><name>s</name><operator>-&gt;</operator><name>two_pass_arena_</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>wrapped_last_processed_pos</name> <operator>&amp;</operator> <name>mask</name></expr>]</index></name></expr></argument>,
          <argument><expr><name>bytes</name></expr></argument>, <argument><expr><name>is_last</name></expr></argument>,
          <argument><expr><name><name>s</name><operator>-&gt;</operator><name>command_buf_</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>literal_buf_</name></name></expr></argument>,
          <argument><expr><name>table</name></expr></argument>, <argument><expr><name>table_size</name></expr></argument>,
          <argument><expr><operator>&amp;</operator><name>storage_ix</name></expr></argument>, <argument><expr><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>BROTLI_IS_OOM</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>BROTLI_FALSE</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>last_bytes_</name></name> <operator>=</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator><operator>(</operator><name><name>storage</name><index>[<expr><name>storage_ix</name> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>last_bytes_bits_</name></name> <operator>=</operator> <name>storage_ix</name> <operator>&amp;</operator> <literal type="number">7u</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UpdateLastProcessedPos</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>output</name> <operator>=</operator> <operator>&amp;</operator><name><name>storage</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>out_size</name> <operator>=</operator> <name>storage_ix</name> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr>;</expr_stmt>
    <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <block>{<block_content>
    <comment type="block">/* Theoretical max number of commands is 1 per 2 bytes. */</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>newsize</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>num_commands_</name></name> <operator>+</operator> <name>bytes</name> <operator>/</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>newsize</name> <operator>&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>cmd_alloc_size_</name></name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>Command</name><modifier>*</modifier></type> <name>new_commands</name></decl>;</decl_stmt>
      <comment type="block">/* Reserve a bit more memory to allow merging with a next block
         without reallocation: that would impact speed. */</comment>
      <expr_stmt><expr><name>newsize</name> <operator>+=</operator> <operator>(</operator><name>bytes</name> <operator>/</operator> <literal type="number">4</literal><operator>)</operator> <operator>+</operator> <literal type="number">16</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>cmd_alloc_size_</name></name> <operator>=</operator> <name>newsize</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>new_commands</name> <operator>=</operator> <call><name>BROTLI_ALLOC</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>Command</name></expr></argument>, <argument><expr><name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>BROTLI_IS_OOM</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>BROTLI_IS_NULL</name><argument_list>(<argument><expr><name>new_commands</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>BROTLI_FALSE</name></expr>;</return></block_content></block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>commands_</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>new_commands</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>commands_</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Command</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>num_commands_</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BROTLI_FREE</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>commands_</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>commands_</name></name> <operator>=</operator> <name>new_commands</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>

  <expr_stmt><expr><call><name>InitOrStitchToPreviousBlock</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>hasher_</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>params</name></name></expr></argument>,
      <argument><expr><name>wrapped_last_processed_pos</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>, <argument><expr><name>is_last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>literal_context_mode</name> <operator>=</operator> <call><name>ChooseContextMode</name><argument_list>(
      <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>params</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><call><name>WrapPosition</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>last_flush_pos_</name></name></expr></argument>)</argument_list></call></expr></argument>,
      <argument><expr><name>mask</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>input_pos_</name></name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>last_flush_pos_</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>literal_context_lut</name> <operator>=</operator> <call><name>BROTLI_CONTEXT_LUT</name><argument_list>(<argument><expr><name>literal_context_mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>BROTLI_IS_OOM</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>BROTLI_FALSE</name></expr>;</return></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>num_commands_</name></name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>last_insert_len_</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>ExtendLastCommand</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bytes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>wrapped_last_processed_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>quality</name></name> <operator>==</operator> <name>ZOPFLIFICATION_QUALITY</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>BROTLI_DCHECK</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>hasher</name><operator>.</operator><name>type</name></name> <operator>==</operator> <literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BrotliCreateZopfliBackwardReferences</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>, <argument><expr><name>wrapped_last_processed_pos</name></expr></argument>,
        <argument><expr><name>data</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name>literal_context_lut</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>params</name></name></expr></argument>,
        <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>hasher_</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>dist_cache_</name></name></expr></argument>,
        <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>last_insert_len_</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>commands_</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>num_commands_</name></name></expr>]</index></name></expr></argument>,
        <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>num_commands_</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>num_literals_</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>BROTLI_IS_OOM</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>BROTLI_FALSE</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>quality</name></name> <operator>==</operator> <name>HQ_ZOPFLIFICATION_QUALITY</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>BROTLI_DCHECK</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>hasher</name><operator>.</operator><name>type</name></name> <operator>==</operator> <literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BrotliCreateHqZopfliBackwardReferences</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>, <argument><expr><name>wrapped_last_processed_pos</name></expr></argument>,
        <argument><expr><name>data</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name>literal_context_lut</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>params</name></name></expr></argument>,
        <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>hasher_</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>dist_cache_</name></name></expr></argument>,
        <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>last_insert_len_</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>commands_</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>num_commands_</name></name></expr>]</index></name></expr></argument>,
        <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>num_commands_</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>num_literals_</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>BROTLI_IS_OOM</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>BROTLI_FALSE</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>BrotliCreateBackwardReferences</name><argument_list>(<argument><expr><name>bytes</name></expr></argument>, <argument><expr><name>wrapped_last_processed_pos</name></expr></argument>,
        <argument><expr><name>data</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name>literal_context_lut</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>params</name></name></expr></argument>,
        <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>hasher_</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>dist_cache_</name></name></expr></argument>,
        <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>last_insert_len_</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>commands_</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>num_commands_</name></name></expr>]</index></name></expr></argument>,
        <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>num_commands_</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>num_literals_</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>max_length</name> <init>= <expr><call><name>MaxMetablockSize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>params</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>max_literals</name> <init>= <expr><name>max_length</name> <operator>/</operator> <literal type="number">8</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>max_commands</name> <init>= <expr><name>max_length</name> <operator>/</operator> <literal type="number">8</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>processed_bytes</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>input_pos_</name></name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>last_flush_pos_</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <comment type="block">/* If maximal possible additional block doesn't fit metablock, flush now. */</comment>
    <comment type="block">/* TODO(eustas): Postpone decision until next block arrives? */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BROTLI_BOOL</name></type> <name>next_input_fits_metablock</name> <init>= <expr><call><name>TO_BROTLI_BOOL</name><argument_list>(
        <argument><expr><name>processed_bytes</name> <operator>+</operator> <call><name>InputBlockSize</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>max_length</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block">/* If block splitting is not used, then flush as soon as there is some
       amount of commands / literals produced. */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BROTLI_BOOL</name></type> <name>should_flush</name> <init>= <expr><call><name>TO_BROTLI_BOOL</name><argument_list>(
        <argument><expr><name><name>s</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>quality</name></name> <operator>&lt;</operator> <name>MIN_QUALITY_FOR_BLOCK_SPLIT</name> <operator>&amp;&amp;</operator>
        <name><name>s</name><operator>-&gt;</operator><name>num_literals_</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>num_commands_</name></name> <operator>&gt;=</operator> <name>MAX_NUM_DELAYED_SYMBOLS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_last</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>force_flush</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>should_flush</name> <operator>&amp;&amp;</operator>
        <name>next_input_fits_metablock</name> <operator>&amp;&amp;</operator>
        <name><name>s</name><operator>-&gt;</operator><name>num_literals_</name></name> <operator>&lt;</operator> <name>max_literals</name> <operator>&amp;&amp;</operator>
        <name><name>s</name><operator>-&gt;</operator><name>num_commands_</name></name> <operator>&lt;</operator> <name>max_commands</name></expr>)</condition> <block>{<block_content>
      <comment type="block">/* Merge with next input block. Everything will happen later. */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>UpdateLastProcessedPos</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>HasherReset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>hasher_</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>out_size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>

  <comment type="block">/* Create the last insert-only command. */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>last_insert_len_</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>InitInsertCommand</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>commands_</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>num_commands_</name></name><operator>++</operator></expr>]</index></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>last_insert_len_</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>num_literals_</name></name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>last_insert_len_</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>last_insert_len_</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_last</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>input_pos_</name></name> <operator>==</operator> <name><name>s</name><operator>-&gt;</operator><name>last_flush_pos_</name></name></expr>)</condition> <block>{<block_content>
    <comment type="block">/* We have no new input data and we don't have to finish the stream, so
       nothing to do. */</comment>
    <expr_stmt><expr><operator>*</operator><name>out_size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>BROTLI_DCHECK</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>input_pos_</name></name> <operator>&gt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>last_flush_pos_</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>BROTLI_DCHECK</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>input_pos_</name></name> <operator>&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>last_flush_pos_</name></name> <operator>||</operator> <name>is_last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>BROTLI_DCHECK</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>input_pos_</name></name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>last_flush_pos_</name></name> <operator>&lt;=</operator> <literal type="number">1u</literal> <operator>&lt;&lt;</operator> <literal type="number">24</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>metablock_size</name> <init>=
        <expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>input_pos_</name></name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>last_flush_pos_</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint8_t</name><modifier>*</modifier></type> <name>storage</name> <init>= <expr><call><name>GetBrotliStorage</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>*</operator> <name>metablock_size</name> <operator>+</operator> <literal type="number">503</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>storage_ix</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>last_bytes_bits_</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>BROTLI_IS_OOM</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>BROTLI_FALSE</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>storage</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>last_bytes_</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>storage</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>last_bytes_</name></name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>WriteMetaBlockInternal</name><argument_list>(
        <argument><expr><name>m</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>last_flush_pos_</name></name></expr></argument>, <argument><expr><name>metablock_size</name></expr></argument>, <argument><expr><name>is_last</name></expr></argument>,
        <argument><expr><name>literal_context_mode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>params</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>prev_byte_</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>prev_byte2_</name></name></expr></argument>,
        <argument><expr><name><name>s</name><operator>-&gt;</operator><name>num_literals_</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>num_commands_</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>commands_</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>saved_dist_cache_</name></name></expr></argument>,
        <argument><expr><name><name>s</name><operator>-&gt;</operator><name>dist_cache_</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>storage_ix</name></expr></argument>, <argument><expr><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>BROTLI_IS_OOM</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>BROTLI_FALSE</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>last_bytes_</name></name> <operator>=</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator><operator>(</operator><name><name>storage</name><index>[<expr><name>storage_ix</name> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>last_bytes_bits_</name></name> <operator>=</operator> <name>storage_ix</name> <operator>&amp;</operator> <literal type="number">7u</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>last_flush_pos_</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>input_pos_</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>UpdateLastProcessedPos</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>HasherReset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>hasher_</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>last_flush_pos_</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>prev_byte_</name></name> <operator>=</operator> <name><name>data</name><index>[<expr><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>last_flush_pos_</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;</operator> <name>mask</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>last_flush_pos_</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>prev_byte2_</name></name> <operator>=</operator> <name><name>data</name><index>[<expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>last_flush_pos_</name></name> <operator>-</operator> <literal type="number">2</literal><operator>)</operator> <operator>&amp;</operator> <name>mask</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>num_commands_</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>num_literals_</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <comment type="block">/* Save the state of the distance cache in case we need to restore it for
       emitting an uncompressed block. */</comment>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>saved_dist_cache_</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>dist_cache_</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>saved_dist_cache_</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>output</name> <operator>=</operator> <operator>&amp;</operator><name><name>storage</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>out_size</name> <operator>=</operator> <name>storage_ix</name> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr>;</expr_stmt>
    <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>
  </block_content>}</block>
</block_content>}</block></function>

<comment type="block">/* Dumps remaining output bits and metadata header to |header|.
   Returns number of produced bytes.
   REQUIRED: |header| should be 8-byte aligned and at least 16 bytes long.
   REQUIRED: |block_size| &lt;= (1 &lt;&lt; 24). */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>WriteMetadataHeader</name><parameter_list>(
    <parameter><decl><type><name>BrotliEncoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>block_size</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name><modifier>*</modifier></type> <name>header</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>size_t</name></type> <name>storage_ix</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>storage_ix</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>last_bytes_bits_</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>header</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>last_bytes_</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>header</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>last_bytes_</name></name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>last_bytes_</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>last_bytes_bits_</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>BrotliWriteBits</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>storage_ix</name></expr></argument>, <argument><expr><name>header</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>BrotliWriteBits</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>storage_ix</name></expr></argument>, <argument><expr><name>header</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>BrotliWriteBits</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>storage_ix</name></expr></argument>, <argument><expr><name>header</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>block_size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>BrotliWriteBits</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>storage_ix</name></expr></argument>, <argument><expr><name>header</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>nbits</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>block_size</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>:
        <expr><operator>(</operator><call><name>Log2FloorNonZero</name><argument_list>(<argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>block_size</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>nbytes</name> <init>= <expr><operator>(</operator><name>nbits</name> <operator>+</operator> <literal type="number">7</literal><operator>)</operator> <operator>/</operator> <literal type="number">8</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>BrotliWriteBits</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>storage_ix</name></expr></argument>, <argument><expr><name>header</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BrotliWriteBits</name><argument_list>(<argument><expr><literal type="number">8</literal> <operator>*</operator> <name>nbytes</name></expr></argument>, <argument><expr><name>block_size</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>storage_ix</name></expr></argument>, <argument><expr><name>header</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><operator>(</operator><name>storage_ix</name> <operator>+</operator> <literal type="number">7u</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>BrotliEncoderMaxCompressedSize</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>input_size</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* [window bits / empty metadata] + N * [uncompressed] + [last empty] */</comment>
  <decl_stmt><decl><type><name>size_t</name></type> <name>num_large_blocks</name> <init>= <expr><name>input_size</name> <operator>&gt;&gt;</operator> <literal type="number">14</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>overhead</name> <init>= <expr><literal type="number">2</literal> <operator>+</operator> <operator>(</operator><literal type="number">4</literal> <operator>*</operator> <name>num_large_blocks</name><operator>)</operator> <operator>+</operator> <literal type="number">3</literal> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>result</name> <init>= <expr><name>input_size</name> <operator>+</operator> <name>overhead</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>input_size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">2</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><ternary><condition><expr><operator>(</operator><name>result</name> <operator>&lt;</operator> <name>input_size</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>result</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Wraps data to uncompressed brotli stream with minimal window size.
   |output| should point at region with at least BrotliEncoderMaxCompressedSize
   addressable bytes.
   Returns the length of stream. */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>MakeUncompressedStream</name><parameter_list>(
    <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name><modifier>*</modifier></type> <name>input</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>input_size</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name><modifier>*</modifier></type> <name>output</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><name>input_size</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>input_size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>output</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">6</literal></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>output</name><index>[<expr><name>result</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0x21</literal></expr>;</expr_stmt>  <comment type="block">/* window bits = 10, is_last = false */</comment>
  <expr_stmt><expr><name><name>output</name><index>[<expr><name>result</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0x03</literal></expr>;</expr_stmt>  <comment type="block">/* empty metadata, padding */</comment>
  <while>while <condition>(<expr><name>size</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>nibbles</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>chunk_size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>bits</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>chunk_size</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>size</name> <operator>&gt;</operator> <operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <literal type="number">24</literal><operator>)</operator><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <literal type="number">24</literal><operator>)</operator></expr> </then><else>: <expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>size</name></expr></else></ternary></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>chunk_size</name> <operator>&gt;</operator> <operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nibbles</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>chunk_size</name> <operator>&gt;</operator> <operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <literal type="number">20</literal><operator>)</operator><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>bits</name> <operator>=</operator>
        <operator>(</operator><name>nibbles</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><operator>(</operator><name>chunk_size</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">19</literal> <operator>+</operator> <literal type="number">4</literal> <operator>*</operator> <name>nibbles</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>output</name><index>[<expr><name>result</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name>bits</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>output</name><index>[<expr><name>result</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><operator>(</operator><name>bits</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>output</name><index>[<expr><name>result</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><operator>(</operator><name>bits</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>nibbles</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>output</name><index>[<expr><name>result</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><operator>(</operator><name>bits</name> <operator>&gt;&gt;</operator> <literal type="number">24</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>output</name><index>[<expr><name>result</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>input</name><index>[<expr><name>offset</name></expr>]</index></name></expr></argument>, <argument><expr><name>chunk_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>+=</operator> <name>chunk_size</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>offset</name> <operator>+=</operator> <name>chunk_size</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>size</name> <operator>-=</operator> <name>chunk_size</name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><name><name>output</name><index>[<expr><name>result</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
  <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>BROTLI_BOOL</name></type> <name>BrotliEncoderCompress</name><parameter_list>(
    <parameter><decl><type><name>int</name></type> <name>quality</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lgwin</name></decl></parameter>, <parameter><decl><type><name>BrotliEncoderMode</name></type> <name>mode</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>input_size</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name></type> <name><name>input_buffer</name><index>[<expr><call><name>BROTLI_ARRAY_PARAM</name><argument_list>(<argument><expr><name>input_size</name></expr></argument>)</argument_list></call></expr>]</index></name></decl></parameter>,
    <parameter><decl><type><name>size_t</name><modifier>*</modifier></type> <name>encoded_size</name></decl></parameter>,
    <parameter><decl><type><name>uint8_t</name></type> <name><name>encoded_buffer</name><index>[<expr><call><name>BROTLI_ARRAY_PARAM</name><argument_list>(<argument><expr><operator>*</operator><name>encoded_size</name></expr></argument>)</argument_list></call></expr>]</index></name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>BrotliEncoderState</name><modifier>*</modifier></type> <name>s</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>out_size</name> <init>= <expr><operator>*</operator><name>encoded_size</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name><modifier>*</modifier></type> <name>input_start</name> <init>= <expr><name>input_buffer</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name><modifier>*</modifier></type> <name>output_start</name> <init>= <expr><name>encoded_buffer</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>max_out_size</name> <init>= <expr><call><name>BrotliEncoderMaxCompressedSize</name><argument_list>(<argument><expr><name>input_size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>out_size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <comment type="block">/* Output buffer needs at least one byte. */</comment>
    <return>return <expr><name>BROTLI_FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>input_size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <comment type="block">/* Handle the special case of empty input. */</comment>
    <expr_stmt><expr><operator>*</operator><name>encoded_size</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>encoded_buffer</name> <operator>=</operator> <literal type="number">6</literal></expr>;</expr_stmt>
    <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>BrotliEncoderCreateInstance</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>s</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>BROTLI_FALSE</name></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>available_in</name> <init>= <expr><name>input_size</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name><modifier>*</modifier></type> <name>next_in</name> <init>= <expr><name>input_buffer</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>available_out</name> <init>= <expr><operator>*</operator><name>encoded_size</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint8_t</name><modifier>*</modifier></type> <name>next_out</name> <init>= <expr><name>encoded_buffer</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>total_out</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BROTLI_BOOL</name></type> <name>result</name> <init>= <expr><name>BROTLI_FALSE</name></expr></init></decl>;</decl_stmt>
    <comment type="block">/* TODO(eustas): check that parameters are sane. */</comment>
    <expr_stmt><expr><call><name>BrotliEncoderSetParameter</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>BROTLI_PARAM_QUALITY</name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>quality</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BrotliEncoderSetParameter</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>BROTLI_PARAM_LGWIN</name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>lgwin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BrotliEncoderSetParameter</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>BROTLI_PARAM_MODE</name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BrotliEncoderSetParameter</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>BROTLI_PARAM_SIZE_HINT</name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>input_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>lgwin</name> <operator>&gt;</operator> <name>BROTLI_MAX_WINDOW_BITS</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>BrotliEncoderSetParameter</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>BROTLI_PARAM_LARGE_WINDOW</name></expr></argument>, <argument><expr><name>BROTLI_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>BrotliEncoderCompressStream</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>BROTLI_OPERATION_FINISH</name></expr></argument>,
        <argument><expr><operator>&amp;</operator><name>available_in</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next_in</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>available_out</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next_out</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>total_out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BrotliEncoderIsFinished</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>encoded_size</name> <operator>=</operator> <name>total_out</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BrotliEncoderDestroyInstance</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name> <operator>||</operator> <operator>(</operator><name>max_out_size</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>encoded_size</name> <operator>&gt;</operator> <name>max_out_size</name><operator>)</operator></expr>)</condition> <block>{<block_content>
      <goto>goto <name>fallback</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
<label><name>fallback</name>:</label>
  <expr_stmt><expr><operator>*</operator><name>encoded_size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>max_out_size</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>BROTLI_FALSE</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>out_size</name> <operator>&gt;=</operator> <name>max_out_size</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>encoded_size</name> <operator>=</operator>
        <call><name>MakeUncompressedStream</name><argument_list>(<argument><expr><name>input_start</name></expr></argument>, <argument><expr><name>input_size</name></expr></argument>, <argument><expr><name>output_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>BROTLI_FALSE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>InjectBytePaddingBlock</name><parameter_list>(<parameter><decl><type><name>BrotliEncoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>seal</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>last_bytes_</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>seal_bits</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>last_bytes_bits_</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name><modifier>*</modifier></type> <name>destination</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>last_bytes_</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>last_bytes_bits_</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <comment type="block">/* is_last = 0, data_nibbles = 11, reserved = 0, meta_nibbles = 00 */</comment>
  <expr_stmt><expr><name>seal</name> <operator>|=</operator> <literal type="number">0x6u</literal> <operator>&lt;&lt;</operator> <name>seal_bits</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>seal_bits</name> <operator>+=</operator> <literal type="number">6</literal></expr>;</expr_stmt>
  <comment type="block">/* If we have already created storage, then append to it.
     Storage is valid until next block is being compressed. */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>next_out_</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>destination</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>next_out_</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>available_out_</name></name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name>destination</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>tiny_buf_</name><operator>.</operator><name>u8</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>next_out_</name></name> <operator>=</operator> <name>destination</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>destination</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name>seal</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>seal_bits</name> <operator>&gt;</operator> <literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>destination</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><operator>(</operator><name>seal</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>seal_bits</name> <operator>&gt;</operator> <literal type="number">16</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>destination</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><operator>(</operator><name>seal</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>available_out_</name></name> <operator>+=</operator> <operator>(</operator><name>seal_bits</name> <operator>+</operator> <literal type="number">7</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Fills the |total_out|, if it is not NULL. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>SetTotalOut</name><parameter_list>(<parameter><decl><type><name>BrotliEncoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>size_t</name><modifier>*</modifier></type> <name>total_out</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>total_out</name></expr>)</condition> <block>{<block_content>
    <comment type="block">/* Saturating conversion uint64_t -&gt; size_t */</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>result</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>total_out_</name></name> <operator>&lt;</operator> <name>result</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>total_out_</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>total_out</name> <operator>=</operator> <name>result</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Injects padding bits or pushes compressed data to output.
   Returns false if nothing is done. */</comment>
<function><type><specifier>static</specifier> <name>BROTLI_BOOL</name></type> <name>InjectFlushOrPushOutput</name><parameter_list>(<parameter><decl><type><name>BrotliEncoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name><modifier>*</modifier></type> <name>available_out</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name><modifier>*</modifier><modifier>*</modifier></type> <name>next_out</name></decl></parameter>, <parameter><decl><type><name>size_t</name><modifier>*</modifier></type> <name>total_out</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>stream_state_</name></name> <operator>==</operator> <name>BROTLI_STREAM_FLUSH_REQUESTED</name> <operator>&amp;&amp;</operator>
      <name><name>s</name><operator>-&gt;</operator><name>last_bytes_bits_</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>InjectBytePaddingBlock</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>available_out_</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>available_out</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>copy_output_size</name> <init>=
        <expr><call><name>BROTLI_MIN</name><argument_list>(<argument><expr><name>size_t</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>available_out_</name></name></expr></argument>, <argument><expr><operator>*</operator><name>available_out</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>*</operator><name>next_out</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>next_out_</name></name></expr></argument>, <argument><expr><name>copy_output_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>next_out</name> <operator>+=</operator> <name>copy_output_size</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>available_out</name> <operator>-=</operator> <name>copy_output_size</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>next_out_</name></name> <operator>+=</operator> <name>copy_output_size</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>available_out_</name></name> <operator>-=</operator> <name>copy_output_size</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>total_out_</name></name> <operator>+=</operator> <name>copy_output_size</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SetTotalOut</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>total_out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>BROTLI_FALSE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>CheckFlushComplete</name><parameter_list>(<parameter><decl><type><name>BrotliEncoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>stream_state_</name></name> <operator>==</operator> <name>BROTLI_STREAM_FLUSH_REQUESTED</name> <operator>&amp;&amp;</operator>
      <name><name>s</name><operator>-&gt;</operator><name>available_out_</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>stream_state_</name></name> <operator>=</operator> <name>BROTLI_STREAM_PROCESSING</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>next_out_</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BROTLI_BOOL</name></type> <name>BrotliEncoderCompressStreamFast</name><parameter_list>(
    <parameter><decl><type><name>BrotliEncoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>BrotliEncoderOperation</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>size_t</name><modifier>*</modifier></type> <name>available_in</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name><modifier>*</modifier><modifier>*</modifier></type> <name>next_in</name></decl></parameter>, <parameter><decl><type><name>size_t</name><modifier>*</modifier></type> <name>available_out</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name><modifier>*</modifier><modifier>*</modifier></type> <name>next_out</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name><modifier>*</modifier></type> <name>total_out</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>block_size_limit</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>lgwin</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>buf_size</name> <init>= <expr><call><name>BROTLI_MIN</name><argument_list>(<argument><expr><name>size_t</name></expr></argument>, <argument><expr><name>kCompressFragmentTwoPassBlockSize</name></expr></argument>,
      <argument><expr><call><name>BROTLI_MIN</name><argument_list>(<argument><expr><name>size_t</name></expr></argument>, <argument><expr><operator>*</operator><name>available_in</name></expr></argument>, <argument><expr><name>block_size_limit</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name><modifier>*</modifier></type> <name>tmp_command_buf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name><modifier>*</modifier></type> <name>command_buf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name><modifier>*</modifier></type> <name>tmp_literal_buf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name><modifier>*</modifier></type> <name>literal_buf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MemoryManager</name><modifier>*</modifier></type> <name>m</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>memory_manager_</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>quality</name></name> <operator>!=</operator> <name>FAST_ONE_PASS_COMPRESSION_QUALITY</name> <operator>&amp;&amp;</operator>
      <name><name>s</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>quality</name></name> <operator>!=</operator> <name>FAST_TWO_PASS_COMPRESSION_QUALITY</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>BROTLI_FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>quality</name></name> <operator>==</operator> <name>FAST_TWO_PASS_COMPRESSION_QUALITY</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>command_buf_</name></name> <operator>&amp;&amp;</operator> <name>buf_size</name> <operator>==</operator> <name>kCompressFragmentTwoPassBlockSize</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>command_buf_</name></name> <operator>=</operator>
          <call><name>BROTLI_ALLOC</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>uint32_t</name></expr></argument>, <argument><expr><name>kCompressFragmentTwoPassBlockSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>literal_buf_</name></name> <operator>=</operator>
          <call><name>BROTLI_ALLOC</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>uint8_t</name></expr></argument>, <argument><expr><name>kCompressFragmentTwoPassBlockSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>BROTLI_IS_OOM</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>BROTLI_IS_NULL</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>command_buf_</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
          <call><name>BROTLI_IS_NULL</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>literal_buf_</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>BROTLI_FALSE</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>command_buf_</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>command_buf</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>command_buf_</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>literal_buf</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>literal_buf_</name></name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>tmp_command_buf</name> <operator>=</operator> <call><name>BROTLI_ALLOC</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>uint32_t</name></expr></argument>, <argument><expr><name>buf_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>tmp_literal_buf</name> <operator>=</operator> <call><name>BROTLI_ALLOC</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>uint8_t</name></expr></argument>, <argument><expr><name>buf_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>BROTLI_IS_OOM</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>BROTLI_IS_NULL</name><argument_list>(<argument><expr><name>tmp_command_buf</name></expr></argument>)</argument_list></call> <operator>||</operator>
          <call><name>BROTLI_IS_NULL</name><argument_list>(<argument><expr><name>tmp_literal_buf</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>BROTLI_FALSE</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>command_buf</name> <operator>=</operator> <name>tmp_command_buf</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>literal_buf</name> <operator>=</operator> <name>tmp_literal_buf</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <while>while <condition>(<expr><name>BROTLI_TRUE</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>InjectFlushOrPushOutput</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>available_out</name></expr></argument>, <argument><expr><name>next_out</name></expr></argument>, <argument><expr><name>total_out</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Compress block only when internal output buffer is empty, stream is not
       finished, there is no pending flush request, and there is either
       additional input or pending operation. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>available_out_</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
        <name><name>s</name><operator>-&gt;</operator><name>stream_state_</name></name> <operator>==</operator> <name>BROTLI_STREAM_PROCESSING</name> <operator>&amp;&amp;</operator>
        <operator>(</operator><operator>*</operator><name>available_in</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>op</name> <operator>!=</operator> <name>BROTLI_OPERATION_PROCESS</name><operator>)</operator></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>size_t</name></type> <name>block_size</name> <init>= <expr><call><name>BROTLI_MIN</name><argument_list>(<argument><expr><name>size_t</name></expr></argument>, <argument><expr><name>block_size_limit</name></expr></argument>, <argument><expr><operator>*</operator><name>available_in</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>BROTLI_BOOL</name></type> <name>is_last</name> <init>=
          <expr><operator>(</operator><operator>*</operator><name>available_in</name> <operator>==</operator> <name>block_size</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>op</name> <operator>==</operator> <name>BROTLI_OPERATION_FINISH</name><operator>)</operator></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>BROTLI_BOOL</name></type> <name>force_flush</name> <init>=
          <expr><operator>(</operator><operator>*</operator><name>available_in</name> <operator>==</operator> <name>block_size</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>op</name> <operator>==</operator> <name>BROTLI_OPERATION_FLUSH</name><operator>)</operator></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>size_t</name></type> <name>max_out_size</name> <init>= <expr><literal type="number">2</literal> <operator>*</operator> <name>block_size</name> <operator>+</operator> <literal type="number">503</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>BROTLI_BOOL</name></type> <name>inplace</name> <init>= <expr><name>BROTLI_TRUE</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>uint8_t</name><modifier>*</modifier></type> <name>storage</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>size_t</name></type> <name>storage_ix</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>last_bytes_bits_</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>size_t</name></type> <name>table_size</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name><modifier>*</modifier></type> <name>table</name></decl>;</decl_stmt>

      <if_stmt><if>if <condition>(<expr><name>force_flush</name> <operator>&amp;&amp;</operator> <name>block_size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>stream_state_</name></name> <operator>=</operator> <name>BROTLI_STREAM_FLUSH_REQUESTED</name></expr>;</expr_stmt>
        <continue>continue;</continue>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>max_out_size</name> <operator>&lt;=</operator> <operator>*</operator><name>available_out</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>storage</name> <operator>=</operator> <operator>*</operator><name>next_out</name></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>inplace</name> <operator>=</operator> <name>BROTLI_FALSE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>storage</name> <operator>=</operator> <call><name>GetBrotliStorage</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>max_out_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>BROTLI_IS_OOM</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>BROTLI_FALSE</name></expr>;</return></block_content></block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name><name>storage</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>last_bytes_</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>storage</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>last_bytes_</name></name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>table</name> <operator>=</operator> <call><name>GetHashTable</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>quality</name></name></expr></argument>, <argument><expr><name>block_size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>table_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>BROTLI_IS_OOM</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>BROTLI_FALSE</name></expr>;</return></block_content></block></if></if_stmt>

      <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>quality</name></name> <operator>==</operator> <name>FAST_ONE_PASS_COMPRESSION_QUALITY</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>BrotliCompressFragmentFast</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>one_pass_arena_</name></name></expr></argument>, <argument><expr><operator>*</operator><name>next_in</name></expr></argument>, <argument><expr><name>block_size</name></expr></argument>,
            <argument><expr><name>is_last</name></expr></argument>, <argument><expr><name>table</name></expr></argument>, <argument><expr><name>table_size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>storage_ix</name></expr></argument>, <argument><expr><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>BROTLI_IS_OOM</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>BROTLI_FALSE</name></expr>;</return></block_content></block></if></if_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>BrotliCompressFragmentTwoPass</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>two_pass_arena_</name></name></expr></argument>, <argument><expr><operator>*</operator><name>next_in</name></expr></argument>, <argument><expr><name>block_size</name></expr></argument>,
            <argument><expr><name>is_last</name></expr></argument>, <argument><expr><name>command_buf</name></expr></argument>, <argument><expr><name>literal_buf</name></expr></argument>, <argument><expr><name>table</name></expr></argument>, <argument><expr><name>table_size</name></expr></argument>,
            <argument><expr><operator>&amp;</operator><name>storage_ix</name></expr></argument>, <argument><expr><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>BROTLI_IS_OOM</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>BROTLI_FALSE</name></expr>;</return></block_content></block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>block_size</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>next_in</name> <operator>+=</operator> <name>block_size</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>available_in</name> <operator>-=</operator> <name>block_size</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>total_in_</name></name> <operator>+=</operator> <name>block_size</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>inplace</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name></type> <name>out_bytes</name> <init>= <expr><name>storage_ix</name> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>BROTLI_DCHECK</name><argument_list>(<argument><expr><name>out_bytes</name> <operator>&lt;=</operator> <operator>*</operator><name>available_out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BROTLI_DCHECK</name><argument_list>(<argument><expr><operator>(</operator><name>storage_ix</name> <operator>&amp;</operator> <literal type="number">7</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>out_bytes</name> <operator>&lt;</operator> <operator>*</operator><name>available_out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>next_out</name> <operator>+=</operator> <name>out_bytes</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>available_out</name> <operator>-=</operator> <name>out_bytes</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>total_out_</name></name> <operator>+=</operator> <name>out_bytes</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SetTotalOut</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>total_out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name></type> <name>out_bytes</name> <init>= <expr><name>storage_ix</name> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>next_out_</name></name> <operator>=</operator> <name>storage</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>available_out_</name></name> <operator>=</operator> <name>out_bytes</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>last_bytes_</name></name> <operator>=</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator><operator>(</operator><name><name>storage</name><index>[<expr><name>storage_ix</name> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>last_bytes_bits_</name></name> <operator>=</operator> <name>storage_ix</name> <operator>&amp;</operator> <literal type="number">7u</literal></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><name>force_flush</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>stream_state_</name></name> <operator>=</operator> <name>BROTLI_STREAM_FLUSH_REQUESTED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>is_last</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>stream_state_</name></name> <operator>=</operator> <name>BROTLI_STREAM_FINISHED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <break>break;</break>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>BROTLI_FREE</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>tmp_command_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>BROTLI_FREE</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>tmp_literal_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>CheckFlushComplete</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BROTLI_BOOL</name></type> <name>ProcessMetadata</name><parameter_list>(
    <parameter><decl><type><name>BrotliEncoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>size_t</name><modifier>*</modifier></type> <name>available_in</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name><modifier>*</modifier><modifier>*</modifier></type> <name>next_in</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name><modifier>*</modifier></type> <name>available_out</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name><modifier>*</modifier><modifier>*</modifier></type> <name>next_out</name></decl></parameter>, <parameter><decl><type><name>size_t</name><modifier>*</modifier></type> <name>total_out</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>available_in</name> <operator>&gt;</operator> <operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <literal type="number">24</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>BROTLI_FALSE</name></expr>;</return></block_content></block></if></if_stmt>
  <comment type="block">/* Switch to metadata block workflow, if required. */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>stream_state_</name></name> <operator>==</operator> <name>BROTLI_STREAM_PROCESSING</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>remaining_metadata_bytes_</name></name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>*</operator><name>available_in</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>stream_state_</name></name> <operator>=</operator> <name>BROTLI_STREAM_METADATA_HEAD</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>stream_state_</name></name> <operator>!=</operator> <name>BROTLI_STREAM_METADATA_HEAD</name> <operator>&amp;&amp;</operator>
      <name><name>s</name><operator>-&gt;</operator><name>stream_state_</name></name> <operator>!=</operator> <name>BROTLI_STREAM_METADATA_BODY</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>BROTLI_FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <while>while <condition>(<expr><name>BROTLI_TRUE</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>InjectFlushOrPushOutput</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>available_out</name></expr></argument>, <argument><expr><name>next_out</name></expr></argument>, <argument><expr><name>total_out</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>available_out_</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>input_pos_</name></name> <operator>!=</operator> <name><name>s</name><operator>-&gt;</operator><name>last_flush_pos_</name></name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>BROTLI_BOOL</name></type> <name>result</name> <init>= <expr><call><name>EncodeData</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>BROTLI_FALSE</name></expr></argument>, <argument><expr><name>BROTLI_TRUE</name></expr></argument>,
          <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>available_out_</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>next_out_</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>BROTLI_FALSE</name></expr>;</return></block_content></block></if></if_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>stream_state_</name></name> <operator>==</operator> <name>BROTLI_STREAM_METADATA_HEAD</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>next_out_</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>tiny_buf_</name><operator>.</operator><name>u8</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>available_out_</name></name> <operator>=</operator>
          <call><name>WriteMetadataHeader</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>remaining_metadata_bytes_</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>next_out_</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>stream_state_</name></name> <operator>=</operator> <name>BROTLI_STREAM_METADATA_BODY</name></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <comment type="block">/* Exit workflow only when there is no more input and no more output.
         Otherwise client may continue producing empty metadata blocks. */</comment>
      <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>remaining_metadata_bytes_</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>remaining_metadata_bytes_</name></name> <operator>=</operator> <name>BROTLI_UINT32_MAX</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>stream_state_</name></name> <operator>=</operator> <name>BROTLI_STREAM_PROCESSING</name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><operator>*</operator><name>available_out</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Directly copy input to output. */</comment>
        <decl_stmt><decl><type><name>uint32_t</name></type> <name>copy</name> <init>= <expr><operator>(</operator><name>uint32_t</name><operator>)</operator><call><name>BROTLI_MIN</name><argument_list>(
            <argument><expr><name>size_t</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>remaining_metadata_bytes_</name></name></expr></argument>, <argument><expr><operator>*</operator><name>available_out</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>*</operator><name>next_out</name></expr></argument>, <argument><expr><operator>*</operator><name>next_in</name></expr></argument>, <argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>next_in</name> <operator>+=</operator> <name>copy</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>available_in</name> <operator>-=</operator> <name>copy</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>total_in_</name></name> <operator>+=</operator> <name>copy</name></expr>;</expr_stmt>  <comment type="block">/* not actually data input, though */</comment>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>remaining_metadata_bytes_</name></name> <operator>-=</operator> <name>copy</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>next_out</name> <operator>+=</operator> <name>copy</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>available_out</name> <operator>-=</operator> <name>copy</name></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="block">/* This guarantees progress in "TakeOutput" workflow. */</comment>
        <decl_stmt><decl><type><name>uint32_t</name></type> <name>copy</name> <init>= <expr><call><name>BROTLI_MIN</name><argument_list>(<argument><expr><name>uint32_t</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>remaining_metadata_bytes_</name></name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>next_out_</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>tiny_buf_</name><operator>.</operator><name>u8</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>next_out_</name></name></expr></argument>, <argument><expr><operator>*</operator><name>next_in</name></expr></argument>, <argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>next_in</name> <operator>+=</operator> <name>copy</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>available_in</name> <operator>-=</operator> <name>copy</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>total_in_</name></name> <operator>+=</operator> <name>copy</name></expr>;</expr_stmt>  <comment type="block">/* not actually data input, though */</comment>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>remaining_metadata_bytes_</name></name> <operator>-=</operator> <name>copy</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>available_out_</name></name> <operator>=</operator> <name>copy</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <continue>continue;</continue>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>

  <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>UpdateSizeHint</name><parameter_list>(<parameter><decl><type><name>BrotliEncoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>available_in</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>size_hint</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>delta</name> <init>= <expr><call><name>UnprocessedInputSize</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>tail</name> <init>= <expr><name>available_in</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>limit</name> <init>= <expr><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <literal type="number">30</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>total</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>delta</name> <operator>&gt;=</operator> <name>limit</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>tail</name> <operator>&gt;=</operator> <name>limit</name><operator>)</operator> <operator>||</operator> <operator>(</operator><operator>(</operator><name>delta</name> <operator>+</operator> <name>tail</name><operator>)</operator> <operator>&gt;=</operator> <name>limit</name><operator>)</operator></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>total</name> <operator>=</operator> <name>limit</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>total</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>delta</name> <operator>+</operator> <name>tail</name><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>size_hint</name></name> <operator>=</operator> <name>total</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>BROTLI_BOOL</name></type> <name>BrotliEncoderCompressStream</name><parameter_list>(
    <parameter><decl><type><name>BrotliEncoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>BrotliEncoderOperation</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>size_t</name><modifier>*</modifier></type> <name>available_in</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name><modifier>*</modifier><modifier>*</modifier></type> <name>next_in</name></decl></parameter>, <parameter><decl><type><name>size_t</name><modifier>*</modifier></type> <name>available_out</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name><modifier>*</modifier><modifier>*</modifier></type> <name>next_out</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name><modifier>*</modifier></type> <name>total_out</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>EnsureInitialized</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>BROTLI_FALSE</name></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* Unfinished metadata block; check requirements. */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>remaining_metadata_bytes_</name></name> <operator>!=</operator> <name>BROTLI_UINT32_MAX</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>available_in</name> <operator>!=</operator> <name><name>s</name><operator>-&gt;</operator><name>remaining_metadata_bytes_</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>BROTLI_FALSE</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>op</name> <operator>!=</operator> <name>BROTLI_OPERATION_EMIT_METADATA</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>BROTLI_FALSE</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <name>BROTLI_OPERATION_EMIT_METADATA</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>UpdateSizeHint</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* First data metablock might be emitted here. */</comment>
    <return>return <expr><call><name>ProcessMetadata</name><argument_list>(
        <argument><expr><name>s</name></expr></argument>, <argument><expr><name>available_in</name></expr></argument>, <argument><expr><name>next_in</name></expr></argument>, <argument><expr><name>available_out</name></expr></argument>, <argument><expr><name>next_out</name></expr></argument>, <argument><expr><name>total_out</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>stream_state_</name></name> <operator>==</operator> <name>BROTLI_STREAM_METADATA_HEAD</name> <operator>||</operator>
      <name><name>s</name><operator>-&gt;</operator><name>stream_state_</name></name> <operator>==</operator> <name>BROTLI_STREAM_METADATA_BODY</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>BROTLI_FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>stream_state_</name></name> <operator>!=</operator> <name>BROTLI_STREAM_PROCESSING</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>available_in</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>BROTLI_FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>quality</name></name> <operator>==</operator> <name>FAST_ONE_PASS_COMPRESSION_QUALITY</name> <operator>||</operator>
      <name><name>s</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>quality</name></name> <operator>==</operator> <name>FAST_TWO_PASS_COMPRESSION_QUALITY</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><call><name>BrotliEncoderCompressStreamFast</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>available_in</name></expr></argument>, <argument><expr><name>next_in</name></expr></argument>,
        <argument><expr><name>available_out</name></expr></argument>, <argument><expr><name>next_out</name></expr></argument>, <argument><expr><name>total_out</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <while>while <condition>(<expr><name>BROTLI_TRUE</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>remaining_block_size</name> <init>= <expr><call><name>RemainingInputBlockSize</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block">/* Shorten input to flint size. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>flint_</name></name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>remaining_block_size</name> <operator>&gt;</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>flint_</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>remaining_block_size</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>flint_</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>remaining_block_size</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>available_in</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>size_t</name></type> <name>copy_input_size</name> <init>=
          <expr><call><name>BROTLI_MIN</name><argument_list>(<argument><expr><name>size_t</name></expr></argument>, <argument><expr><name>remaining_block_size</name></expr></argument>, <argument><expr><operator>*</operator><name>available_in</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>CopyInputToRingBuffer</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>copy_input_size</name></expr></argument>, <argument><expr><operator>*</operator><name>next_in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>next_in</name> <operator>+=</operator> <name>copy_input_size</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>available_in</name> <operator>-=</operator> <name>copy_input_size</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>total_in_</name></name> <operator>+=</operator> <name>copy_input_size</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>flint_</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>flint_</name></name> <operator>=</operator> <operator>(</operator><name>int8_t</name><operator>)</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>flint_</name></name> <operator>-</operator> <operator>(</operator><name>int</name><operator>)</operator><name>copy_input_size</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>InjectFlushOrPushOutput</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>available_out</name></expr></argument>, <argument><expr><name>next_out</name></expr></argument>, <argument><expr><name>total_out</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <comment type="block">/* Exit the "emit flint" workflow. */</comment>
      <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>flint_</name></name> <operator>==</operator> <name>BROTLI_FLINT_WAITING_FOR_FLUSHING</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>CheckFlushComplete</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>stream_state_</name></name> <operator>==</operator> <name>BROTLI_STREAM_PROCESSING</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>flint_</name></name> <operator>=</operator> <name>BROTLI_FLINT_DONE</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Compress data only when internal output buffer is empty, stream is not
       finished and there is no pending flush request. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>available_out_</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
        <name><name>s</name><operator>-&gt;</operator><name>stream_state_</name></name> <operator>==</operator> <name>BROTLI_STREAM_PROCESSING</name></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>remaining_block_size</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>op</name> <operator>!=</operator> <name>BROTLI_OPERATION_PROCESS</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>BROTLI_BOOL</name></type> <name>is_last</name> <init>= <expr><call><name>TO_BROTLI_BOOL</name><argument_list>(
            <argument><expr><operator>(</operator><operator>*</operator><name>available_in</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name>op</name> <operator>==</operator> <name>BROTLI_OPERATION_FINISH</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BROTLI_BOOL</name></type> <name>force_flush</name> <init>= <expr><call><name>TO_BROTLI_BOOL</name><argument_list>(
            <argument><expr><operator>(</operator><operator>*</operator><name>available_in</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name>op</name> <operator>==</operator> <name>BROTLI_OPERATION_FLUSH</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BROTLI_BOOL</name></type> <name>result</name></decl>;</decl_stmt>
        <comment type="block">/* Force emitting (uncompressed) piece containing flint. */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_last</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>flint_</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>flint_</name></name> <operator>=</operator> <name>BROTLI_FLINT_WAITING_FOR_FLUSHING</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>force_flush</name> <operator>=</operator> <name>BROTLI_TRUE</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>UpdateSizeHint</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>*</operator><name>available_in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>EncodeData</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>is_last</name></expr></argument>, <argument><expr><name>force_flush</name></expr></argument>,
            <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>available_out_</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>next_out_</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>BROTLI_FALSE</name></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>force_flush</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>stream_state_</name></name> <operator>=</operator> <name>BROTLI_STREAM_FLUSH_REQUESTED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>is_last</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>stream_state_</name></name> <operator>=</operator> <name>BROTLI_STREAM_FINISHED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <continue>continue;</continue>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <break>break;</break>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>CheckFlushComplete</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>BROTLI_BOOL</name></type> <name>BrotliEncoderIsFinished</name><parameter_list>(<parameter><decl><type><name>BrotliEncoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>TO_BROTLI_BOOL</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>stream_state_</name></name> <operator>==</operator> <name>BROTLI_STREAM_FINISHED</name> <operator>&amp;&amp;</operator>
      <operator>!</operator><call><name>BrotliEncoderHasMoreOutput</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>BROTLI_BOOL</name></type> <name>BrotliEncoderHasMoreOutput</name><parameter_list>(<parameter><decl><type><name>BrotliEncoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>TO_BROTLI_BOOL</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>available_out_</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>uint8_t</name><modifier>*</modifier></type> <name>BrotliEncoderTakeOutput</name><parameter_list>(<parameter><decl><type><name>BrotliEncoderState</name><modifier>*</modifier></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>size_t</name><modifier>*</modifier></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>size_t</name></type> <name>consumed_size</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>available_out_</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name><modifier>*</modifier></type> <name>result</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>next_out_</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>size</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>consumed_size</name> <operator>=</operator> <call><name>BROTLI_MIN</name><argument_list>(<argument><expr><name>size_t</name></expr></argument>, <argument><expr><operator>*</operator><name>size</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>available_out_</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>consumed_size</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>next_out_</name></name> <operator>+=</operator> <name>consumed_size</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>available_out_</name></name> <operator>-=</operator> <name>consumed_size</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>total_out_</name></name> <operator>+=</operator> <name>consumed_size</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CheckFlushComplete</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>size</name> <operator>=</operator> <name>consumed_size</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>uint32_t</name></type> <name>BrotliEncoderVersion</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><name>BROTLI_VERSION</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>BrotliEncoderPreparedDictionary</name><modifier>*</modifier></type> <name>BrotliEncoderPrepareDictionary</name><parameter_list>(
    <parameter><decl><type><name>BrotliSharedDictionaryType</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name></type> <name><name>data</name><index>[<expr><call><name>BROTLI_ARRAY_PARAM</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>quality</name></decl></parameter>,
    <parameter><decl><type><name>brotli_alloc_func</name></type> <name>alloc_func</name></decl></parameter>, <parameter><decl><type><name>brotli_free_func</name></type> <name>free_func</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>opaque</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>ManagedDictionary</name><modifier>*</modifier></type> <name>managed_dictionary</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>BROTLI_SHARED_DICTIONARY_RAW</name> <operator>&amp;&amp;</operator>
      <name>type</name> <operator>!=</operator> <name>BROTLI_SHARED_DICTIONARY_SERIALIZED</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>managed_dictionary</name> <operator>=</operator>
      <call><name>BrotliCreateManagedDictionary</name><argument_list>(<argument><expr><name>alloc_func</name></expr></argument>, <argument><expr><name>free_func</name></expr></argument>, <argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>managed_dictionary</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>BROTLI_SHARED_DICTIONARY_RAW</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>managed_dictionary</name><operator>-&gt;</operator><name>dictionary</name></name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>*</operator><operator>)</operator><call><name>CreatePreparedDictionary</name><argument_list>(
        <argument><expr><operator>&amp;</operator><name><name>managed_dictionary</name><operator>-&gt;</operator><name>memory_manager_</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>SharedEncoderDictionary</name><modifier>*</modifier></type> <name>dict</name> <init>= <expr><operator>(</operator><name>SharedEncoderDictionary</name><operator>*</operator><operator>)</operator><call><name>BrotliAllocate</name><argument_list>(
        <argument><expr><operator>&amp;</operator><name><name>managed_dictionary</name><operator>-&gt;</operator><name>memory_manager_</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SharedEncoderDictionary</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>managed_dictionary</name><operator>-&gt;</operator><name>dictionary</name></name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>*</operator><operator>)</operator><name>dict</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>dict</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>BROTLI_BOOL</name></type> <name>ok</name> <init>= <expr><call><name>BrotliInitCustomSharedEncoderDictionary</name><argument_list>(
          <argument><expr><operator>&amp;</operator><name><name>managed_dictionary</name><operator>-&gt;</operator><name>memory_manager_</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>quality</name></expr></argument>, <argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ok</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>BrotliFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>managed_dictionary</name><operator>-&gt;</operator><name>memory_manager_</name></name></expr></argument>, <argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>managed_dictionary</name><operator>-&gt;</operator><name>dictionary</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>managed_dictionary</name><operator>-&gt;</operator><name>dictionary</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>BrotliDestroyManagedDictionary</name><argument_list>(<argument><expr><name>managed_dictionary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><operator>(</operator><name>BrotliEncoderPreparedDictionary</name><operator>*</operator><operator>)</operator><name>managed_dictionary</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>BrotliEncoderDestroyPreparedDictionary</name><parameter_list>(
    <parameter><decl><type><name>BrotliEncoderPreparedDictionary</name><modifier>*</modifier></type> <name>dictionary</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>ManagedDictionary</name><modifier>*</modifier></type> <name>dict</name> <init>= <expr><operator>(</operator><name>ManagedDictionary</name><operator>*</operator><operator>)</operator><name>dictionary</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>dictionary</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <comment type="block">/* First field of dictionary structs. */</comment>
  <comment type="block">/* Only managed dictionaries are eligible for destruction by this method. */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>dict</name><operator>-&gt;</operator><name>magic</name></name> <operator>!=</operator> <name>kManagedDictionaryMagic</name></expr>)</condition> <block>{<block_content>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>dict</name><operator>-&gt;</operator><name>dictionary</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <comment type="block">/* This should never ever happen. */</comment>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>*</operator><name><name>dict</name><operator>-&gt;</operator><name>dictionary</name></name> <operator>==</operator> <name>kLeanPreparedDictionaryMagic</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>DestroyPreparedDictionary</name><argument_list>(
        <argument><expr><operator>&amp;</operator><name><name>dict</name><operator>-&gt;</operator><name>memory_manager_</name></name></expr></argument>, <argument><expr><operator>(</operator><name>PreparedDictionary</name><operator>*</operator><operator>)</operator><name><name>dict</name><operator>-&gt;</operator><name>dictionary</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>*</operator><name><name>dict</name><operator>-&gt;</operator><name>dictionary</name></name> <operator>==</operator> <name>kSharedDictionaryMagic</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>BrotliCleanupSharedEncoderDictionary</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dict</name><operator>-&gt;</operator><name>memory_manager_</name></name></expr></argument>,
        <argument><expr><operator>(</operator><name>SharedEncoderDictionary</name><operator>*</operator><operator>)</operator><name><name>dict</name><operator>-&gt;</operator><name>dictionary</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BrotliFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dict</name><operator>-&gt;</operator><name>memory_manager_</name></name></expr></argument>, <argument><expr><name><name>dict</name><operator>-&gt;</operator><name>dictionary</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <comment type="block">/* There is also kPreparedDictionaryMagic, but such instances should be
     * constructed and destroyed by different means. */</comment>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>dict</name><operator>-&gt;</operator><name>dictionary</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>BrotliDestroyManagedDictionary</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>BROTLI_BOOL</name></type> <name>BrotliEncoderAttachPreparedDictionary</name><parameter_list>(<parameter><decl><type><name>BrotliEncoderState</name><modifier>*</modifier></type> <name>state</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>BrotliEncoderPreparedDictionary</name><modifier>*</modifier></type> <name>dictionary</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* First field of dictionary structs */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>BrotliEncoderPreparedDictionary</name><modifier>*</modifier></type> <name>dict</name> <init>= <expr><name>dictionary</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>magic</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>uint32_t</name><operator>*</operator><operator>)</operator><name>dict</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SharedEncoderDictionary</name><modifier>*</modifier></type> <name>current</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>magic</name> <operator>==</operator> <name>kManagedDictionaryMagic</name></expr>)</condition> <block>{<block_content>
    <comment type="block">/* Unwrap managed dictionary. */</comment>
    <decl_stmt><decl><type><name>ManagedDictionary</name><modifier>*</modifier></type> <name>managed_dictionary</name> <init>= <expr><operator>(</operator><name>ManagedDictionary</name><operator>*</operator><operator>)</operator><name>dict</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>magic</name> <operator>=</operator> <operator>*</operator><name><name>managed_dictionary</name><operator>-&gt;</operator><name>dictionary</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>dict</name> <operator>=</operator> <operator>(</operator><name>BrotliEncoderPreparedDictionary</name><operator>*</operator><operator>)</operator><name><name>managed_dictionary</name><operator>-&gt;</operator><name>dictionary</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>current</name> <operator>=</operator> <operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>dictionary</name></name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>magic</name> <operator>==</operator> <name>kPreparedDictionaryMagic</name> <operator>||</operator>
      <name>magic</name> <operator>==</operator> <name>kLeanPreparedDictionaryMagic</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>PreparedDictionary</name><modifier>*</modifier></type> <name>prepared</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>PreparedDictionary</name><operator>*</operator><operator>)</operator><name>dict</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AttachPreparedDictionary</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>current</name><operator>-&gt;</operator><name>compound</name></name></expr></argument>, <argument><expr><name>prepared</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>BROTLI_FALSE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>magic</name> <operator>==</operator> <name>kSharedDictionaryMagic</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>SharedEncoderDictionary</name><modifier>*</modifier></type> <name>attached</name> <init>=
        <expr><operator>(</operator><specifier>const</specifier> <name>SharedEncoderDictionary</name><operator>*</operator><operator>)</operator><name>dict</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BROTLI_BOOL</name></type> <name>was_default</name> <init>= <expr><operator>!</operator><name><name>current</name><operator>-&gt;</operator><name>contextual</name><operator>.</operator><name>context_based</name></name> <operator>&amp;&amp;</operator>
        <name><name>current</name><operator>-&gt;</operator><name>contextual</name><operator>.</operator><name>num_dictionaries</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
        <name><name>current</name><operator>-&gt;</operator><name>contextual</name><operator>.</operator><name>dict</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>hash_table_words</name> <operator>==</operator>
        <name>kStaticDictionaryHashWords</name> <operator>&amp;&amp;</operator>
        <name><name>current</name><operator>-&gt;</operator><name>contextual</name><operator>.</operator><name>dict</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>hash_table_lengths</name> <operator>==</operator>
        <name>kStaticDictionaryHashLengths</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BROTLI_BOOL</name></type> <name>new_default</name> <init>= <expr><operator>!</operator><name><name>attached</name><operator>-&gt;</operator><name>contextual</name><operator>.</operator><name>context_based</name></name> <operator>&amp;&amp;</operator>
        <name><name>attached</name><operator>-&gt;</operator><name>contextual</name><operator>.</operator><name>num_dictionaries</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
        <name><name>attached</name><operator>-&gt;</operator><name>contextual</name><operator>.</operator><name>dict</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>hash_table_words</name> <operator>==</operator>
        <name>kStaticDictionaryHashWords</name> <operator>&amp;&amp;</operator>
        <name><name>attached</name><operator>-&gt;</operator><name>contextual</name><operator>.</operator><name>dict</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>hash_table_lengths</name> <operator>==</operator>
        <name>kStaticDictionaryHashLengths</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>is_initialized_</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>BROTLI_FALSE</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>current</name><operator>-&gt;</operator><name>max_quality</name></name> <operator>=</operator>
        <call><name>BROTLI_MIN</name><argument_list>(<argument><expr><name>int</name></expr></argument>, <argument><expr><name><name>current</name><operator>-&gt;</operator><name>max_quality</name></name></expr></argument>, <argument><expr><name><name>attached</name><operator>-&gt;</operator><name>max_quality</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>attached</name><operator>-&gt;</operator><name>compound</name><operator>.</operator><name>num_chunks</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AttachPreparedDictionary</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>current</name><operator>-&gt;</operator><name>compound</name></name></expr></argument>,
          <argument><expr><name><name>attached</name><operator>-&gt;</operator><name>compound</name><operator>.</operator><name>chunks</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>BROTLI_FALSE</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>new_default</name></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>was_default</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>BROTLI_FALSE</name></expr>;</return></block_content></block></if></if_stmt>
      <comment type="block">/* Copy by value, but then set num_instances_ to 0 because their memory
      is managed by attached, not by current */</comment>
      <expr_stmt><expr><name><name>current</name><operator>-&gt;</operator><name>contextual</name></name> <operator>=</operator> <name><name>attached</name><operator>-&gt;</operator><name>contextual</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>current</name><operator>-&gt;</operator><name>contextual</name><operator>.</operator><name>num_instances_</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <return>return <expr><name>BROTLI_FALSE</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>BROTLI_TRUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>BrotliEncoderEstimatePeakMemoryUsage</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>quality</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lgwin</name></decl></parameter>,
                                            <parameter><decl><type><name>size_t</name></type> <name>input_size</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>BrotliEncoderParams</name></type> <name>params</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>BrotliEncoderInitParams</name><argument_list>(<argument><expr><operator>&amp;</operator><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>params</name><operator>.</operator><name>quality</name></name> <operator>=</operator> <name>quality</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>params</name><operator>.</operator><name>lgwin</name></name> <operator>=</operator> <name>lgwin</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>params</name><operator>.</operator><name>size_hint</name></name> <operator>=</operator> <name>input_size</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SanitizeParams</name><argument_list>(<argument><expr><operator>&amp;</operator><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>params</name><operator>.</operator><name>lgblock</name></name> <operator>=</operator> <call><name>ComputeLgBlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ChooseHasher</name><argument_list>(<argument><expr><operator>&amp;</operator><name>params</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>params</name><operator>.</operator><name>hasher</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>params</name><operator>.</operator><name>quality</name></name> <operator>==</operator> <name>FAST_ONE_PASS_COMPRESSION_QUALITY</name> <operator>||</operator>
      <name><name>params</name><operator>.</operator><name>quality</name></name> <operator>==</operator> <name>FAST_TWO_PASS_COMPRESSION_QUALITY</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>state_size</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>BrotliEncoderState</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>block_size</name> <init>= <expr><call><name>BROTLI_MIN</name><argument_list>(<argument><expr><name>size_t</name></expr></argument>, <argument><expr><name>input_size</name></expr></argument>, <argument><expr><operator>(</operator><literal type="number">1ul</literal> <operator>&lt;&lt;</operator> <name><name>params</name><operator>.</operator><name>lgwin</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>hash_table_size</name> <init>=
        <expr><call><name>HashTableSize</name><argument_list>(<argument><expr><call><name>MaxHashTableSize</name><argument_list>(<argument><expr><name><name>params</name><operator>.</operator><name>quality</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>block_size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>hash_size</name> <init>=
        <expr><ternary><condition><expr><operator>(</operator><name>hash_table_size</name> <operator>&lt;</operator> <operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <literal type="number">10</literal><operator>)</operator><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>hash_table_size</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>cmdbuf_size</name> <init>= <expr><ternary><condition><expr><name><name>params</name><operator>.</operator><name>quality</name></name> <operator>==</operator> <name>FAST_TWO_PASS_COMPRESSION_QUALITY</name></expr> ?</condition><then>
        <expr><literal type="number">5</literal> <operator>*</operator> <call><name>BROTLI_MIN</name><argument_list>(<argument><expr><name>size_t</name></expr></argument>, <argument><expr><name>block_size</name></expr></argument>, <argument><expr><literal type="number">1ul</literal> <operator>&lt;&lt;</operator> <literal type="number">17</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>params</name><operator>.</operator><name>quality</name></name> <operator>==</operator> <name>FAST_ONE_PASS_COMPRESSION_QUALITY</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>state_size</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BrotliOnePassArena</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>state_size</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BrotliTwoPassArena</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><name>hash_size</name> <operator>+</operator> <name>cmdbuf_size</name> <operator>+</operator> <name>state_size</name></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>short_ringbuffer_size</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>params</name><operator>.</operator><name>lgblock</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ringbuffer_bits</name> <init>= <expr><call><name>ComputeRbBits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>params</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>ringbuffer_size</name> <init>= <expr><ternary><condition><expr><name>input_size</name> <operator>&lt;</operator> <name>short_ringbuffer_size</name></expr> ?</condition><then>
        <expr><name>input_size</name></expr> </then><else>: <expr><operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <name>ringbuffer_bits</name><operator>)</operator> <operator>+</operator> <name>short_ringbuffer_size</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name><name>hash_size</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>metablock_size</name> <init>=
        <expr><call><name>BROTLI_MIN</name><argument_list>(<argument><expr><name>size_t</name></expr></argument>, <argument><expr><name>input_size</name></expr></argument>, <argument><expr><call><name>MaxMetablockSize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>params</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>inputblock_size</name> <init>=
        <expr><call><name>BROTLI_MIN</name><argument_list>(<argument><expr><name>size_t</name></expr></argument>, <argument><expr><name>input_size</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>params</name><operator>.</operator><name>lgblock</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>cmdbuf_size</name> <init>= <expr><name>metablock_size</name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <name>inputblock_size</name> <operator>*</operator> <literal type="number">6</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>outbuf_size</name> <init>= <expr><name>metablock_size</name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">503</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>histogram_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>HasherSize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>params</name></expr></argument>, <argument><expr><name>BROTLI_TRUE</name></expr></argument>, <argument><expr><name>input_size</name></expr></argument>, <argument><expr><name>hash_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>params</name><operator>.</operator><name>quality</name></name> <operator>&lt;</operator> <name>MIN_QUALITY_FOR_BLOCK_SPLIT</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>cmdbuf_size</name> <operator>=</operator> <call><name>BROTLI_MIN</name><argument_list>(<argument><expr><name>size_t</name></expr></argument>, <argument><expr><name>cmdbuf_size</name></expr></argument>,
          <argument><expr><name>MAX_NUM_DELAYED_SYMBOLS</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Command</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>inputblock_size</name> <operator>*</operator> <literal type="number">12</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>params</name><operator>.</operator><name>quality</name></name> <operator>&gt;=</operator> <name>MIN_QUALITY_FOR_HQ_BLOCK_SPLITTING</name></expr>)</condition> <block>{<block_content>
      <comment type="block">/* Only a very rough estimation, based on enwik8. */</comment>
      <expr_stmt><expr><name>histogram_size</name> <operator>=</operator> <literal type="number">200</literal> <operator>&lt;&lt;</operator> <literal type="number">20</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>params</name><operator>.</operator><name>quality</name></name> <operator>&gt;=</operator> <name>MIN_QUALITY_FOR_BLOCK_SPLIT</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>size_t</name></type> <name>literal_histograms</name> <init>=
          <expr><call><name>BROTLI_MIN</name><argument_list>(<argument><expr><name>size_t</name></expr></argument>, <argument><expr><name>metablock_size</name> <operator>/</operator> <literal type="number">6144</literal></expr></argument>, <argument><expr><literal type="number">256</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>size_t</name></type> <name>command_histograms</name> <init>=
          <expr><call><name>BROTLI_MIN</name><argument_list>(<argument><expr><name>size_t</name></expr></argument>, <argument><expr><name>metablock_size</name> <operator>/</operator> <literal type="number">6144</literal></expr></argument>, <argument><expr><literal type="number">256</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>size_t</name></type> <name>distance_histograms</name> <init>=
          <expr><call><name>BROTLI_MIN</name><argument_list>(<argument><expr><name>size_t</name></expr></argument>, <argument><expr><name>metablock_size</name> <operator>/</operator> <literal type="number">6144</literal></expr></argument>, <argument><expr><literal type="number">256</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>histogram_size</name> <operator>=</operator> <name>literal_histograms</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HistogramLiteral</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
                       <name>command_histograms</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HistogramCommand</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
                       <name>distance_histograms</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HistogramDistance</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><operator>(</operator><name>ringbuffer_size</name> <operator>+</operator>
            <name><name>hash_size</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name><name>hash_size</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name><name>hash_size</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>+</operator> <name><name>hash_size</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>+</operator>
            <name>cmdbuf_size</name> <operator>+</operator>
            <name>outbuf_size</name> <operator>+</operator>
            <name>histogram_size</name><operator>)</operator></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><name>size_t</name></type> <name>BrotliEncoderGetPreparedDictionarySize</name><parameter_list>(
    <parameter><decl><type><specifier>const</specifier> <name>BrotliEncoderPreparedDictionary</name><modifier>*</modifier></type> <name>prepared_dictionary</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* First field of dictionary structs */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>BrotliEncoderPreparedDictionary</name><modifier>*</modifier></type> <name>prepared</name> <init>= <expr><name>prepared_dictionary</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>magic</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>uint32_t</name><operator>*</operator><operator>)</operator><name>prepared</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>overhead</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>magic</name> <operator>==</operator> <name>kManagedDictionaryMagic</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>ManagedDictionary</name><modifier>*</modifier></type> <name>managed</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>ManagedDictionary</name><operator>*</operator><operator>)</operator><name>prepared</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>overhead</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ManagedDictionary</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name>magic</name> <operator>=</operator> <operator>*</operator><name><name>managed</name><operator>-&gt;</operator><name>dictionary</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>prepared</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>BrotliEncoderPreparedDictionary</name><operator>*</operator><operator>)</operator><name><name>managed</name><operator>-&gt;</operator><name>dictionary</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>magic</name> <operator>==</operator> <name>kPreparedDictionaryMagic</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>PreparedDictionary</name><modifier>*</modifier></type> <name>dictionary</name> <init>=
        <expr><operator>(</operator><specifier>const</specifier> <name>PreparedDictionary</name><operator>*</operator><operator>)</operator><name>prepared</name></expr></init></decl>;</decl_stmt>
    <comment type="block">/* Keep in sync with step 3 of CreatePreparedDictionary */</comment>
    <return>return <expr><sizeof>sizeof<argument_list>(<argument><expr><name>PreparedDictionary</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>dictionary</name><operator>-&gt;</operator><name>source_size</name></name> <operator>+</operator>
        <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof> <operator>&lt;&lt;</operator> <name><name>dictionary</name><operator>-&gt;</operator><name>slot_bits</name></name><operator>)</operator> <operator>+</operator>
        <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>uint16_t</name></expr></argument>)</argument_list></sizeof> <operator>&lt;&lt;</operator> <name><name>dictionary</name><operator>-&gt;</operator><name>bucket_bits</name></name><operator>)</operator> <operator>+</operator>
        <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>dictionary</name><operator>-&gt;</operator><name>num_items</name></name><operator>)</operator> <operator>+</operator> <name>overhead</name></expr>;</return>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>magic</name> <operator>==</operator> <name>kLeanPreparedDictionaryMagic</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>PreparedDictionary</name><modifier>*</modifier></type> <name>dictionary</name> <init>=
        <expr><operator>(</operator><specifier>const</specifier> <name>PreparedDictionary</name><operator>*</operator><operator>)</operator><name>prepared</name></expr></init></decl>;</decl_stmt>
    <comment type="block">/* Keep in sync with step 3 of CreatePreparedDictionary */</comment>
    <return>return <expr><sizeof>sizeof<argument_list>(<argument><expr><name>PreparedDictionary</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint8_t</name><operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>+</operator>
        <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof> <operator>&lt;&lt;</operator> <name><name>dictionary</name><operator>-&gt;</operator><name>slot_bits</name></name><operator>)</operator> <operator>+</operator>
        <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>uint16_t</name></expr></argument>)</argument_list></sizeof> <operator>&lt;&lt;</operator> <name><name>dictionary</name><operator>-&gt;</operator><name>bucket_bits</name></name><operator>)</operator> <operator>+</operator>
        <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>dictionary</name><operator>-&gt;</operator><name>num_items</name></name><operator>)</operator> <operator>+</operator> <name>overhead</name></expr>;</return>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>magic</name> <operator>==</operator> <name>kSharedDictionaryMagic</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>SharedEncoderDictionary</name><modifier>*</modifier></type> <name>dictionary</name> <init>=
        <expr><operator>(</operator><specifier>const</specifier> <name>SharedEncoderDictionary</name><operator>*</operator><operator>)</operator><name>prepared</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>CompoundDictionary</name><modifier>*</modifier></type> <name>compound</name> <init>= <expr><operator>&amp;</operator><name><name>dictionary</name><operator>-&gt;</operator><name>compound</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>ContextualEncoderDictionary</name><modifier>*</modifier></type> <name>contextual</name> <init>= <expr><operator>&amp;</operator><name><name>dictionary</name><operator>-&gt;</operator><name>contextual</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>result</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>dictionary</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>num_instances</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BrotliEncoderDictionary</name><modifier>*</modifier></type> <name>instances</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>compound</name><operator>-&gt;</operator><name>num_prepared_instances_</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><call><name>BrotliEncoderGetPreparedDictionarySize</name><argument_list>(
          <argument><expr><operator>(</operator><specifier>const</specifier> <name>BrotliEncoderPreparedDictionary</name><operator>*</operator><operator>)</operator>
          <name><name>compound</name><operator>-&gt;</operator><name>prepared_instances_</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>size</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* error */</comment>
      <expr_stmt><expr><name>result</name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if <condition>(<expr><name><name>contextual</name><operator>-&gt;</operator><name>context_based</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>num_instances</name> <operator>=</operator> <name><name>contextual</name><operator>-&gt;</operator><name>num_instances_</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>instances</name> <operator>=</operator> <name><name>contextual</name><operator>-&gt;</operator><name>instances_</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>result</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>instances</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>num_instances</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>num_instances</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>instances</name> <operator>=</operator> <operator>&amp;</operator><name><name>contextual</name><operator>-&gt;</operator><name>instance_</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_instances</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>BrotliEncoderDictionary</name><modifier>*</modifier></type> <name>dict</name> <init>= <expr><operator>&amp;</operator><name><name>instances</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>result</name> <operator>+=</operator> <name><name>dict</name><operator>-&gt;</operator><name>trie</name><operator>.</operator><name>pool_capacity</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BrotliTrieNode</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>dict</name><operator>-&gt;</operator><name>hash_table_data_words_</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>result</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>kStaticDictionaryHashWords</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>dict</name><operator>-&gt;</operator><name>hash_table_data_lengths_</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>result</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>kStaticDictionaryHashLengths</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>dict</name><operator>-&gt;</operator><name>buckets_data_</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>result</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>dict</name><operator>-&gt;</operator><name>buckets_data_</name></name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>dict</name><operator>-&gt;</operator><name>buckets_alloc_size_</name></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>dict</name><operator>-&gt;</operator><name>dict_words_data_</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>result</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>dict</name><operator>-&gt;</operator><name>dict_words</name></name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>dict</name><operator>-&gt;</operator><name>dict_words_alloc_size_</name></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>dict</name><operator>-&gt;</operator><name>words_instance_</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>result</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>dict</name><operator>-&gt;</operator><name>words_instance_</name></name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        <comment type="block">/* data_size not added here: it is never allocated by the
           SharedEncoderDictionary, instead it always points to the file
           already loaded in memory. So if the caller wants to include
           this memory as well, add the size of the loaded dictionary
           file to this. */</comment>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>result</name> <operator>+</operator> <name>overhead</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>  <comment type="block">/* error */</comment>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>BROTLI_TEST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name>size_t</name></type> <name>MakeUncompressedStreamForTest</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>uint8_t</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>, <parameter><decl><type><name>uint8_t</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function><type><name>size_t</name></type> <name>MakeUncompressedStreamForTest</name><parameter_list>(
    <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name><modifier>*</modifier></type> <name>input</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>input_size</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name><modifier>*</modifier></type> <name>output</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>MakeUncompressedStream</name><argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><name>input_size</name></expr></argument>, <argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>c_plusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
</block_content>}</block></extern>  <comment type="block">/* extern "C" */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
