<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="../out/cloned_projects/brotli/c/enc/ringbuffer.h"><comment type="block">/* Copyright 2013 Google Inc. All Rights Reserved.

   Distributed under MIT license.
   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT
*/</comment>

<comment type="block">/* Sliding window over the input data. */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>BROTLI_ENC_RINGBUFFER_H_</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BROTLI_ENC_RINGBUFFER_H_</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>  <comment type="block">/* memcpy */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;brotli/types.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../common/platform.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"memory.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"quality.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>c_plusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
<extern>extern <literal type="string">"C"</literal> <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* A RingBuffer(window_bits, tail_bits) contains `1 &lt;&lt; window_bits' bytes of
   data in a circular manner: writing a byte writes it to:
     `position() % (1 &lt;&lt; window_bits)'.
   For convenience, the RingBuffer array contains another copy of the
   first `1 &lt;&lt; tail_bits' bytes:
     buffer_[i] == buffer_[i + (1 &lt;&lt; window_bits)], if i &lt; (1 &lt;&lt; tail_bits),
   and another copy of the last two bytes:
     buffer_[-1] == buffer_[(1 &lt;&lt; window_bits) - 1] and
     buffer_[-2] == buffer_[(1 &lt;&lt; window_bits) - 2]. */</comment>
<typedef>typedef <type><struct>struct <name>RingBuffer</name> <block>{
  <comment type="block">/* Size of the ring-buffer is (1 &lt;&lt; window_bits) + tail_size_. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>size_</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>mask_</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>tail_size_</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>total_size_</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>uint32_t</name></type> <name>cur_size_</name></decl>;</decl_stmt>
  <comment type="block">/* Position to write in the ring buffer. */</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>pos_</name></decl>;</decl_stmt>
  <comment type="block">/* The actual ring buffer containing the copy of the last two bytes, the data,
     and the copy of the beginning as a tail. */</comment>
  <decl_stmt><decl><type><name>uint8_t</name><modifier>*</modifier></type> <name>data_</name></decl>;</decl_stmt>
  <comment type="block">/* The start of the ring-buffer. */</comment>
  <decl_stmt><decl><type><name>uint8_t</name><modifier>*</modifier></type> <name>buffer_</name></decl>;</decl_stmt>
}</block></struct></type> <name>RingBuffer</name>;</typedef>

<function><type><specifier>static</specifier> <name>BROTLI_INLINE</name> <name>void</name></type> <name>RingBufferInit</name><parameter_list>(<parameter><decl><type><name>RingBuffer</name><modifier>*</modifier></type> <name>rb</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name><name>rb</name><operator>-&gt;</operator><name>cur_size_</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>rb</name><operator>-&gt;</operator><name>pos_</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>rb</name><operator>-&gt;</operator><name>data_</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>rb</name><operator>-&gt;</operator><name>buffer_</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BROTLI_INLINE</name> <name>void</name></type> <name>RingBufferSetup</name><parameter_list>(
    <parameter><decl><type><specifier>const</specifier> <name>BrotliEncoderParams</name><modifier>*</modifier></type> <name>params</name></decl></parameter>, <parameter><decl><type><name>RingBuffer</name><modifier>*</modifier></type> <name>rb</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>window_bits</name> <init>= <expr><call><name>ComputeRbBits</name><argument_list>(<argument><expr><name>params</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>tail_bits</name> <init>= <expr><name><name>params</name><operator>-&gt;</operator><name>lgblock</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint32_t</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>rb</name><operator>-&gt;</operator><name>size_</name></name> <operator>=</operator> <literal type="number">1u</literal> <operator>&lt;&lt;</operator> <name>window_bits</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint32_t</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>rb</name><operator>-&gt;</operator><name>mask_</name></name> <operator>=</operator> <operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <name>window_bits</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint32_t</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>rb</name><operator>-&gt;</operator><name>tail_size_</name></name> <operator>=</operator> <literal type="number">1u</literal> <operator>&lt;&lt;</operator> <name>tail_bits</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint32_t</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>rb</name><operator>-&gt;</operator><name>total_size_</name></name> <operator>=</operator> <name><name>rb</name><operator>-&gt;</operator><name>size_</name></name> <operator>+</operator> <name><name>rb</name><operator>-&gt;</operator><name>tail_size_</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BROTLI_INLINE</name> <name>void</name></type> <name>RingBufferFree</name><parameter_list>(<parameter><decl><type><name>MemoryManager</name><modifier>*</modifier></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>RingBuffer</name><modifier>*</modifier></type> <name>rb</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>BROTLI_FREE</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name><name>rb</name><operator>-&gt;</operator><name>data_</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Allocates or re-allocates data_ to the given length + plus some slack
   region before and after. Fills the slack regions with zeros. */</comment>
<function><type><specifier>static</specifier> <name>BROTLI_INLINE</name> <name>void</name></type> <name>RingBufferInitBuffer</name><parameter_list>(
    <parameter><decl><type><name>MemoryManager</name><modifier>*</modifier></type> <name>m</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>buflen</name></decl></parameter>, <parameter><decl><type><name>RingBuffer</name><modifier>*</modifier></type> <name>rb</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>size_t</name></type> <name>kSlackForEightByteHashingEverywhere</name> <init>= <expr><literal type="number">7</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name><modifier>*</modifier></type> <name>new_data</name> <init>= <expr><call><name>BROTLI_ALLOC</name><argument_list>(
      <argument><expr><name>m</name></expr></argument>, <argument><expr><name>uint8_t</name></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>+</operator> <name>buflen</name> <operator>+</operator> <name>kSlackForEightByteHashingEverywhere</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>BROTLI_IS_OOM</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>BROTLI_IS_NULL</name><argument_list>(<argument><expr><name>new_data</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>rb</name><operator>-&gt;</operator><name>data_</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>new_data</name></expr></argument>, <argument><expr><name><name>rb</name><operator>-&gt;</operator><name>data_</name></name></expr></argument>,
        <argument><expr><literal type="number">2</literal> <operator>+</operator> <name><name>rb</name><operator>-&gt;</operator><name>cur_size_</name></name> <operator>+</operator> <name>kSlackForEightByteHashingEverywhere</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BROTLI_FREE</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name><name>rb</name><operator>-&gt;</operator><name>data_</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>rb</name><operator>-&gt;</operator><name>data_</name></name> <operator>=</operator> <name>new_data</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>rb</name><operator>-&gt;</operator><name>cur_size_</name></name> <operator>=</operator> <name>buflen</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>rb</name><operator>-&gt;</operator><name>buffer_</name></name> <operator>=</operator> <name><name>rb</name><operator>-&gt;</operator><name>data_</name></name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>rb</name><operator>-&gt;</operator><name>buffer_</name><index>[<expr><operator>-</operator><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>rb</name><operator>-&gt;</operator><name>buffer_</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>kSlackForEightByteHashingEverywhere</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <expr_stmt><expr><name><name>rb</name><operator>-&gt;</operator><name>buffer_</name><index>[<expr><name><name>rb</name><operator>-&gt;</operator><name>cur_size_</name></name> <operator>+</operator> <name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BROTLI_INLINE</name> <name>void</name></type> <name>RingBufferWriteTail</name><parameter_list>(
    <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name><modifier>*</modifier></type> <name>bytes</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>RingBuffer</name><modifier>*</modifier></type> <name>rb</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>masked_pos</name> <init>= <expr><name><name>rb</name><operator>-&gt;</operator><name>pos_</name></name> <operator>&amp;</operator> <name><name>rb</name><operator>-&gt;</operator><name>mask_</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>BROTLI_PREDICT_FALSE</name><argument_list>(<argument><expr><name>masked_pos</name> <operator>&lt;</operator> <name><name>rb</name><operator>-&gt;</operator><name>tail_size_</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <comment type="block">/* Just fill the tail buffer with the beginning data. */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>p</name> <init>= <expr><name><name>rb</name><operator>-&gt;</operator><name>size_</name></name> <operator>+</operator> <name>masked_pos</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rb</name><operator>-&gt;</operator><name>buffer_</name><index>[<expr><name>p</name></expr>]</index></name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>,
        <argument><expr><call><name>BROTLI_MIN</name><argument_list>(<argument><expr><name>size_t</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name><name>rb</name><operator>-&gt;</operator><name>tail_size_</name></name> <operator>-</operator> <name>masked_pos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Push bytes into the ring buffer. */</comment>
<function><type><specifier>static</specifier> <name>BROTLI_INLINE</name> <name>void</name></type> <name>RingBufferWrite</name><parameter_list>(
    <parameter><decl><type><name>MemoryManager</name><modifier>*</modifier></type> <name>m</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name><modifier>*</modifier></type> <name>bytes</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>RingBuffer</name><modifier>*</modifier></type> <name>rb</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>rb</name><operator>-&gt;</operator><name>pos_</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>n</name> <operator>&lt;</operator> <name><name>rb</name><operator>-&gt;</operator><name>tail_size_</name></name></expr>)</condition> <block>{<block_content>
    <comment type="block">/* Special case for the first write: to process the first block, we don't
       need to allocate the whole ring-buffer and we don't need the tail
       either. However, we do this memory usage optimization only if the
       first write is less than the tail size, which is also the input block
       size, otherwise it is likely that other blocks will follow and we
       will need to reallocate to the full size anyway. */</comment>
    <expr_stmt><expr><name><name>rb</name><operator>-&gt;</operator><name>pos_</name></name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>n</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>RingBufferInitBuffer</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name><name>rb</name><operator>-&gt;</operator><name>pos_</name></name></expr></argument>, <argument><expr><name>rb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>BROTLI_IS_OOM</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>rb</name><operator>-&gt;</operator><name>buffer_</name></name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>rb</name><operator>-&gt;</operator><name>cur_size_</name></name> <operator>&lt;</operator> <name><name>rb</name><operator>-&gt;</operator><name>total_size_</name></name></expr>)</condition> <block>{<block_content>
    <comment type="block">/* Lazily allocate the full buffer. */</comment>
    <expr_stmt><expr><call><name>RingBufferInitBuffer</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name><name>rb</name><operator>-&gt;</operator><name>total_size_</name></name></expr></argument>, <argument><expr><name>rb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>BROTLI_IS_OOM</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <comment type="block">/* Initialize the last two bytes to zero, so that we don't have to worry
       later when we copy the last two bytes to the first two positions. */</comment>
    <expr_stmt><expr><name><name>rb</name><operator>-&gt;</operator><name>buffer_</name><index>[<expr><name><name>rb</name><operator>-&gt;</operator><name>size_</name></name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rb</name><operator>-&gt;</operator><name>buffer_</name><index>[<expr><name><name>rb</name><operator>-&gt;</operator><name>size_</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <comment type="block">/* Initialize tail; might be touched by "best_len++" optimization when
       ring buffer is "full". */</comment>
    <expr_stmt><expr><name><name>rb</name><operator>-&gt;</operator><name>buffer_</name><index>[<expr><name><name>rb</name><operator>-&gt;</operator><name>size_</name></name></expr>]</index></name> <operator>=</operator> <literal type="number">241</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>masked_pos</name> <init>= <expr><name><name>rb</name><operator>-&gt;</operator><name>pos_</name></name> <operator>&amp;</operator> <name><name>rb</name><operator>-&gt;</operator><name>mask_</name></name></expr></init></decl>;</decl_stmt>
    <comment type="block">/* The length of the writes is limited so that we do not need to worry
       about a write */</comment>
    <expr_stmt><expr><call><name>RingBufferWriteTail</name><argument_list>(<argument><expr><name>bytes</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>rb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>BROTLI_PREDICT_TRUE</name><argument_list>(<argument><expr><name>masked_pos</name> <operator>+</operator> <name>n</name> <operator>&lt;=</operator> <name><name>rb</name><operator>-&gt;</operator><name>size_</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <comment type="block">/* A single write fits. */</comment>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rb</name><operator>-&gt;</operator><name>buffer_</name><index>[<expr><name>masked_pos</name></expr>]</index></name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <comment type="block">/* Split into two writes.
         Copy into the end of the buffer, including the tail buffer. */</comment>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rb</name><operator>-&gt;</operator><name>buffer_</name><index>[<expr><name>masked_pos</name></expr>]</index></name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>,
             <argument><expr><call><name>BROTLI_MIN</name><argument_list>(<argument><expr><name>size_t</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name><name>rb</name><operator>-&gt;</operator><name>total_size_</name></name> <operator>-</operator> <name>masked_pos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* Copy into the beginning of the buffer */</comment>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rb</name><operator>-&gt;</operator><name>buffer_</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>bytes</name> <operator>+</operator> <operator>(</operator><name><name>rb</name><operator>-&gt;</operator><name>size_</name></name> <operator>-</operator> <name>masked_pos</name><operator>)</operator></expr></argument>,
             <argument><expr><name>n</name> <operator>-</operator> <operator>(</operator><name><name>rb</name><operator>-&gt;</operator><name>size_</name></name> <operator>-</operator> <name>masked_pos</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block>
  <block>{<block_content>
    <decl_stmt><decl><type><name>BROTLI_BOOL</name></type> <name>not_first_lap</name> <init>= <expr><operator>(</operator><name><name>rb</name><operator>-&gt;</operator><name>pos_</name></name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <literal type="number">31</literal><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>rb_pos_mask</name> <init>= <expr><operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <literal type="number">31</literal><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>rb</name><operator>-&gt;</operator><name>buffer_</name><index>[<expr><operator>-</operator><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>rb</name><operator>-&gt;</operator><name>buffer_</name><index>[<expr><name><name>rb</name><operator>-&gt;</operator><name>size_</name></name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rb</name><operator>-&gt;</operator><name>buffer_</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>rb</name><operator>-&gt;</operator><name>buffer_</name><index>[<expr><name><name>rb</name><operator>-&gt;</operator><name>size_</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rb</name><operator>-&gt;</operator><name>pos_</name></name> <operator>=</operator> <operator>(</operator><name><name>rb</name><operator>-&gt;</operator><name>pos_</name></name> <operator>&amp;</operator> <name>rb_pos_mask</name><operator>)</operator> <operator>+</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>n</name> <operator>&amp;</operator> <name>rb_pos_mask</name><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>not_first_lap</name></expr>)</condition> <block>{<block_content>
      <comment type="block">/* Wrap, but preserve not-a-first-lap feature. */</comment>
      <expr_stmt><expr><name><name>rb</name><operator>-&gt;</operator><name>pos_</name></name> <operator>|=</operator> <literal type="number">1u</literal> <operator>&lt;&lt;</operator> <literal type="number">31</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>c_plusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
</block_content>}</block></extern>  <comment type="block">/* extern "C" */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* BROTLI_ENC_RINGBUFFER_H_ */</comment>
</unit>
