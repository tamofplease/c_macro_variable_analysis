<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/workspace/age/src/backend/utils/cache/ag_cache.c"><comment type="block">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/attnum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/skey.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/stratnum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tupdesc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lockdefs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/catcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/hsearch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/inval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/ag_graph.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/ag_label.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ag_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/graphid.h"</cpp:file></cpp:include>

<typedef>typedef <type><struct>struct <name>graph_name_cache_entry</name>
<block>{
    <decl_stmt><decl><type><name>NameData</name></type> <name>name</name></decl>;</decl_stmt> <comment type="line">// hash key</comment>
    <decl_stmt><decl><type><name>graph_cache_data</name></type> <name>data</name></decl>;</decl_stmt>
}</block></struct></type> <name>graph_name_cache_entry</name>;</typedef>

<typedef>typedef <type><struct>struct <name>graph_namespace_cache_entry</name>
<block>{
    <decl_stmt><decl><type><name>Oid</name></type> <name>namespace</name></decl>;</decl_stmt> <comment type="line">// hash key</comment>
    <decl_stmt><decl><type><name>graph_cache_data</name></type> <name>data</name></decl>;</decl_stmt>
}</block></struct></type> <name>graph_namespace_cache_entry</name>;</typedef>

<typedef>typedef <type><struct>struct <name>label_name_graph_cache_key</name>
<block>{
    <decl_stmt><decl><type><name>NameData</name></type> <name>name</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type> <name>graph</name></decl>;</decl_stmt>
}</block></struct></type> <name>label_name_graph_cache_key</name>;</typedef>

<typedef>typedef <type><struct>struct <name>label_name_graph_cache_entry</name>
<block>{
    <decl_stmt><decl><type><name>label_name_graph_cache_key</name></type> <name>key</name></decl>;</decl_stmt> <comment type="line">// hash key</comment>
    <decl_stmt><decl><type><name>label_cache_data</name></type> <name>data</name></decl>;</decl_stmt>
}</block></struct></type> <name>label_name_graph_cache_entry</name>;</typedef>

<typedef>typedef <type><struct>struct <name>label_graph_id_cache_key</name>
<block>{
    <decl_stmt><decl><type><name>Oid</name></type> <name>graph</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type> <name>id</name></decl>;</decl_stmt>
}</block></struct></type> <name>label_graph_id_cache_key</name>;</typedef>

<typedef>typedef <type><struct>struct <name>label_graph_id_cache_entry</name>
<block>{
    <decl_stmt><decl><type><name>label_graph_id_cache_key</name></type> <name>key</name></decl>;</decl_stmt> <comment type="line">// hash key</comment>
    <decl_stmt><decl><type><name>label_cache_data</name></type> <name>data</name></decl>;</decl_stmt>
}</block></struct></type> <name>label_graph_id_cache_entry</name>;</typedef>

<typedef>typedef <type><struct>struct <name>label_relation_cache_entry</name>
<block>{
    <decl_stmt><decl><type><name>Oid</name></type> <name>relation</name></decl>;</decl_stmt> <comment type="line">// hash key</comment>
    <decl_stmt><decl><type><name>label_cache_data</name></type> <name>data</name></decl>;</decl_stmt>
}</block></struct></type> <name>label_relation_cache_entry</name>;</typedef>

<comment type="line">// ag_graph.name</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>graph_name_cache_hash</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ScanKeyData</name></type> <name><name>graph_name_scan_keys</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

<comment type="line">// ag_graph.namespace</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>graph_namespace_cache_hash</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ScanKeyData</name></type> <name><name>graph_namespace_scan_keys</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

<comment type="line">// ag_label.oid</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>label_oid_cache_hash</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ScanKeyData</name></type> <name><name>label_oid_scan_keys</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

<comment type="line">// ag_label.name, ag_label.graph</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>label_name_graph_cache_hash</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ScanKeyData</name></type> <name><name>label_name_graph_scan_keys</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<comment type="line">// ag_label.graph, ag_label.id</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>label_graph_id_cache_hash</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ScanKeyData</name></type> <name><name>label_graph_id_scan_keys</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<comment type="line">// ag_label.relation</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>label_relation_cache_hash</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ScanKeyData</name></type> <name><name>label_relation_scan_keys</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

<comment type="line">// initialize all caches</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>initialize_caches</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="line">// common</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ag_cache_scan_key_init</name><parameter_list>(<parameter><decl><type><name>ScanKey</name></type> <name>entry</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>attno</name></decl></parameter>,
                                   <parameter><decl><type><name>RegProcedure</name></type> <name>func</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>name_hash_compare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key2</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keysize</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="line">// ag_graph</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>initialize_graph_caches</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>create_graph_caches</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>create_graph_name_cache</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>create_graph_namespace_cache</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>invalidate_graph_caches</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cache_id</name></decl></parameter>,
                                    <parameter><decl><type><name>uint32</name></type> <name>hash_value</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>flush_graph_name_cache</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>flush_graph_namespace_cache</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>graph_cache_data</name> <modifier>*</modifier></type><name>search_graph_name_cache_miss</name><parameter_list>(<parameter><decl><type><name>Name</name></type> <name>name</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>graph_cache_data</name> <modifier>*</modifier></type><name>search_graph_namespace_cache_miss</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>namespace</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>fill_graph_cache_data</name><parameter_list>(<parameter><decl><type><name>graph_cache_data</name> <modifier>*</modifier></type><name>cache_data</name></decl></parameter>,
                                  <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tuple_desc</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="line">// ag_label</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>initialize_label_caches</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>create_label_caches</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>create_label_oid_cache</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>create_label_name_graph_cache</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>create_label_graph_id_cache</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>create_label_relation_cache</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>invalidate_label_caches</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>invalidate_label_oid_cache</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>flush_label_oid_cache</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>invalidate_label_name_graph_cache</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>flush_label_name_graph_cache</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>invalidate_label_graph_id_cache</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>flush_label_graph_id_cache</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>invalidate_label_relation_cache</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>flush_label_relation_cache</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>label_cache_data</name> <modifier>*</modifier></type><name>search_label_oid_cache_miss</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>label_cache_data</name> <modifier>*</modifier></type><name>search_label_name_graph_cache_miss</name><parameter_list>(<parameter><decl><type><name>Name</name></type> <name>name</name></decl></parameter>,
                                                            <parameter><decl><type><name>Oid</name></type> <name>graph</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>label_name_graph_cache_hash_search</name><parameter_list>(<parameter><decl><type><name>Name</name></type> <name>name</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>graph</name></decl></parameter>,
                                                <parameter><decl><type><name>HASHACTION</name></type> <name>action</name></decl></parameter>,
                                                <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>found</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>label_cache_data</name> <modifier>*</modifier></type><name>search_label_graph_id_cache_miss</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>graph</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>id</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>label_graph_id_cache_hash_search</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>graph</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>id</name></decl></parameter>,
                                              <parameter><decl><type><name>HASHACTION</name></type> <name>action</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>found</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>label_cache_data</name> <modifier>*</modifier></type><name>search_label_relation_cache_miss</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relation</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>fill_label_cache_data</name><parameter_list>(<parameter><decl><type><name>label_cache_data</name> <modifier>*</modifier></type><name>cache_data</name></decl></parameter>,
                                  <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tuple_desc</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>void</name></type> <name>initialize_caches</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>initialized</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>initialized</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>CacheMemoryContext</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>CreateCacheMemoryContext</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>initialize_graph_caches</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>initialize_label_caches</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>initialized</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>ag_cache_scan_key_init</name><parameter_list>(<parameter><decl><type><name>ScanKey</name></type> <name>entry</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>attno</name></decl></parameter>,
                                   <parameter><decl><type><name>RegProcedure</name></type> <name>func</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>sk_attno</name></name> <operator>=</operator> <name>attno</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>sk_strategy</name></name> <operator>=</operator> <name>BTEqualStrategyNumber</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>sk_subtype</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>sk_collation</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fmgr_info_cxt</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>sk_func</name></name></expr></argument>, <argument><expr><name>CacheMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>sk_argument</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator><literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>name_hash_compare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key2</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keysize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Name</name></type> <name>name1</name> <init>= <expr><operator>(</operator><name>Name</name><operator>)</operator><name>key1</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Name</name></type> <name>name2</name> <init>= <expr><operator>(</operator><name>Name</name><operator>)</operator><name>key2</name></expr></init></decl>;</decl_stmt>

    <comment type="line">// keysize parameter is superfluous here</comment>
    <expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>keysize</name> <operator>==</operator> <name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>strncmp</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>name1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>name2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>initialize_graph_caches</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="line">// ag_graph.name</comment>
    <expr_stmt><expr><call><name>ag_cache_scan_key_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>graph_name_scan_keys</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_ag_graph_name</name></expr></argument>,
                           <argument><expr><name>F_NAMEEQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// ag_graph.namespace</comment>
    <expr_stmt><expr><call><name>ag_cache_scan_key_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>graph_namespace_scan_keys</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                           <argument><expr><name>Anum_ag_graph_namespace</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>create_graph_caches</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * A graph is backed by the bound namespace. So, register the invalidation
     * logic of the graph caches for invalidation events of NAMESPACEOID cache.
     */</comment>
    <expr_stmt><expr><call><name>CacheRegisterSyscacheCallback</name><argument_list>(<argument><expr><name>NAMESPACEOID</name></expr></argument>, <argument><expr><name>invalidate_graph_caches</name></expr></argument>,
                                  <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>create_graph_caches</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * All the hash tables are created using their dedicated memory contexts
     * which are under TopMemoryContext.
     */</comment>
    <expr_stmt><expr><call><name>create_graph_name_cache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>create_graph_namespace_cache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>create_graph_name_cache</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HASHCTL</name></type> <name>hash_ctl</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hash_ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>NameData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>graph_name_cache_entry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>match</name></name> <operator>=</operator> <name>name_hash_compare</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Please see the comment of hash_create() for the nelem value 16 here.
     * HASH_BLOBS flag is set because the key for this hash is fixed-size.
     */</comment>
    <expr_stmt><expr><name>graph_name_cache_hash</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"ag_graph (name) cache"</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>,
                                        <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name> <operator>|</operator> <name>HASH_COMPARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>create_graph_namespace_cache</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HASHCTL</name></type> <name>hash_ctl</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hash_ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>graph_namespace_cache_entry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

    <comment type="block">/*
     * Please see the comment of hash_create() for the nelem value 16 here.
     * HASH_BLOBS flag is set because the size of the key is sizeof(uint32).
     */</comment>
    <expr_stmt><expr><name>graph_namespace_cache_hash</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"ag_graph (namespace) cache"</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>,
                                             <argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>,
                                             <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>invalidate_graph_caches</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cache_id</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>hash_value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>graph_name_cache_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Currently, all entries in the graph caches are flushed because
     * hash_value is for an entry in NAMESPACEOID cache. Since the caches
     * are not currently used in performance-critical paths, this seems OK.
     */</comment>
    <expr_stmt><expr><call><name>flush_graph_name_cache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>flush_graph_namespace_cache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>flush_graph_name_cache</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>hash_seq</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_seq</name></expr></argument>, <argument><expr><name>graph_name_cache_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>graph_name_cache_entry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>removed</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>entry</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>removed</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>graph_name_cache_hash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>HASH_REMOVE</name></expr></argument>,
                              <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>removed</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"graph (name) cache corrupted"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>flush_graph_namespace_cache</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>hash_seq</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_seq</name></expr></argument>, <argument><expr><name>graph_namespace_cache_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>graph_namespace_cache_entry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>removed</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>entry</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>removed</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>graph_namespace_cache_hash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>namespace</name></name></expr></argument>,
                              <argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>removed</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"graph (namespace) cache corrupted"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>graph_cache_data</name> <modifier>*</modifier></type><name>search_graph_name_cache</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>NameData</name></type> <name>name_key</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>graph_name_cache_entry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>initialize_caches</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>name_key</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>graph_name_cache_hash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name_key</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>entry</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>data</name></name></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><call><name>search_graph_name_cache_miss</name><argument_list>(<argument><expr><operator>&amp;</operator><name>name_key</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>graph_cache_data</name> <modifier>*</modifier></type><name>search_graph_name_cache_miss</name><parameter_list>(<parameter><decl><type><name>Name</name></type> <name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scan_keys</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type> <name>ag_graph</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan_desc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>found</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>graph_name_cache_entry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>scan_keys</name></expr></argument>, <argument><expr><name>graph_name_scan_keys</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>graph_name_scan_keys</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>scan_keys</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>sk_argument</name> <operator>=</operator> <call><name>NameGetDatum</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Calling heap_open() might call AcceptInvalidationMessage() and that
     * might flush the graph caches. This is OK because this function is called
     * when the desired entry is not in the cache.
     */</comment>
    <expr_stmt><expr><name>ag_graph</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><call><name>ag_graph_relation_id</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>scan_desc</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>ag_graph</name></expr></argument>, <argument><expr><call><name>ag_graph_name_index_id</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>,
                                   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>scan_keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// don't need to loop over scan_desc because ag_graph_name_index is UNIQUE</comment>
    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>ag_graph</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// get a new entry</comment>
    <expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>graph_name_cache_hash</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// no concurrent update on graph_name_cache_hash</comment>

    <comment type="line">// fill the new entry with the retrieved tuple</comment>
    <expr_stmt><expr><call><name>fill_graph_cache_data</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>ag_graph</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>ag_graph</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>graph_cache_data</name> <modifier>*</modifier></type><name>search_graph_namespace_cache</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>namespace</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>graph_namespace_cache_entry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>initialize_caches</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>graph_namespace_cache_hash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>namespace</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>,
                        <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>entry</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>data</name></name></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><call><name>search_graph_namespace_cache_miss</name><argument_list>(<argument><expr><name>namespace</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>graph_cache_data</name> <modifier>*</modifier></type><name>search_graph_namespace_cache_miss</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>namespace</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scan_keys</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type> <name>ag_graph</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan_desc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>found</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>graph_namespace_cache_entry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>scan_keys</name></expr></argument>, <argument><expr><name>graph_namespace_scan_keys</name></expr></argument>,
           <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>graph_namespace_scan_keys</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>scan_keys</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>sk_argument</name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>namespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Calling heap_open() might call AcceptInvalidationMessage() and that
     * might flush the graph caches. This is OK because this function is called
     * when the desired entry is not in the cache.
     */</comment>
    <expr_stmt><expr><name>ag_graph</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><call><name>ag_graph_relation_id</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>scan_desc</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>ag_graph</name></expr></argument>, <argument><expr><call><name>ag_graph_namespace_index_id</name><argument_list>()</argument_list></call></expr></argument>,
                                   <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>scan_keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// don't need to loop over scan_desc because ag_graph_namespace_index is</comment>
    <comment type="line">// UNIQUE</comment>
    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>ag_graph</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// get a new entry</comment>
    <expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>graph_namespace_cache_hash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>namespace</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>,
                        <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// no concurrent update on graph_namespace_cache_hash</comment>

    <comment type="line">// fill the new entry with the retrieved tuple</comment>
    <expr_stmt><expr><call><name>fill_graph_cache_data</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>ag_graph</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>ag_graph</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>fill_graph_cache_data</name><parameter_list>(<parameter><decl><type><name>graph_cache_data</name> <modifier>*</modifier></type><name>cache_data</name></decl></parameter>,
                                  <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tuple_desc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type> <name>is_null</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type> <name>value</name></decl>;</decl_stmt>

    <comment type="line">// ag_graph.oid</comment>
    <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>ObjectIdAttributeNumber</name></expr></argument>, <argument><expr><name>tuple_desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cache_data</name><operator>-&gt;</operator><name>oid</name></name> <operator>=</operator> <call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// ag_graph.name</comment>
    <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_ag_graph_name</name></expr></argument>, <argument><expr><name>tuple_desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>namecpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cache_data</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><call><name>DatumGetName</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// ag_graph.namespace</comment>
    <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_ag_graph_namespace</name></expr></argument>, <argument><expr><name>tuple_desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cache_data</name><operator>-&gt;</operator><name>namespace</name></name> <operator>=</operator> <call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>initialize_label_caches</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="line">// ag_label.oid</comment>
    <expr_stmt><expr><call><name>ag_cache_scan_key_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>label_oid_scan_keys</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>ObjectIdAttributeNumber</name></expr></argument>,
                           <argument><expr><name>F_OIDEQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// ag_label.name, ag_label.graph</comment>
    <expr_stmt><expr><call><name>ag_cache_scan_key_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>label_name_graph_scan_keys</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_ag_label_name</name></expr></argument>,
                           <argument><expr><name>F_NAMEEQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ag_cache_scan_key_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>label_name_graph_scan_keys</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_ag_label_graph</name></expr></argument>,
                           <argument><expr><name>F_OIDEQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// ag_label.graph, ag_label.id</comment>
    <expr_stmt><expr><call><name>ag_cache_scan_key_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>label_graph_id_scan_keys</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_ag_label_graph</name></expr></argument>,
                           <argument><expr><name>F_OIDEQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ag_cache_scan_key_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>label_graph_id_scan_keys</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_ag_label_id</name></expr></argument>,
                           <argument><expr><name>F_INT4EQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// ag_label.relation</comment>
    <expr_stmt><expr><call><name>ag_cache_scan_key_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>label_relation_scan_keys</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                           <argument><expr><name>Anum_ag_label_relation</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>create_label_caches</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * A label is backed by the bound relation. So, register the invalidation
     * logic of the label caches for invalidation events of relation cache.
     */</comment>
    <expr_stmt><expr><call><name>CacheRegisterRelcacheCallback</name><argument_list>(<argument><expr><name>invalidate_label_caches</name></expr></argument>, <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>create_label_caches</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * All the hash tables are created using their dedicated memory contexts
     * which are under TopMemoryContext.
     */</comment>
    <expr_stmt><expr><call><name>create_label_oid_cache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>create_label_name_graph_cache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>create_label_graph_id_cache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>create_label_relation_cache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>create_label_oid_cache</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HASHCTL</name></type> <name>hash_ctl</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Use label_cache_data itself since it has oid field as its first field
     * that is the key for this hash.
     */</comment>
    <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hash_ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>label_cache_data</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

    <comment type="block">/*
     * Please see the comment of hash_create() for the nelem value 16 here.
     * HASH_BLOBS flag is set because the size of the key is sizeof(uint32).
     */</comment>
    <expr_stmt><expr><name>label_oid_cache_hash</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"ag_label (oid) cache"</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>,
                                       <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>create_label_name_graph_cache</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HASHCTL</name></type> <name>hash_ctl</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hash_ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>label_name_graph_cache_key</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>label_name_graph_cache_entry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

    <comment type="block">/*
     * Please see the comment of hash_create() for the nelem value 16 here.
     * HASH_BLOBS flag is set because the key for this hash is fixed-size.
     */</comment>
    <expr_stmt><expr><name>label_name_graph_cache_hash</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"ag_label (name, graph) cache"</literal></expr></argument>,
                                              <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>,
                                              <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>create_label_graph_id_cache</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HASHCTL</name></type> <name>hash_ctl</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hash_ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>label_graph_id_cache_key</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>label_graph_id_cache_entry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

    <comment type="block">/*
     * Please see the comment of hash_create() for the nelem value 16 here.
     * HASH_BLOBS flag is set because the key for this hash is fixed-size.
     */</comment>
    <expr_stmt><expr><name>label_graph_id_cache_hash</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"ag_label (graph, id) cache"</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>,
                                              <argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>,
                                              <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>create_label_relation_cache</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HASHCTL</name></type> <name>hash_ctl</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hash_ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>label_relation_cache_entry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

    <comment type="block">/*
     * Please see the comment of hash_create() for the nelem value 16 here.
     * HASH_BLOBS flag is set because the size of the key is sizeof(uint32).
     */</comment>
    <expr_stmt><expr><name>label_relation_cache_hash</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"ag_label (relation) cache"</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>,
                                            <argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>, <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>invalidate_label_caches</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>label_name_graph_cache_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>invalidate_label_oid_cache</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>invalidate_label_name_graph_cache</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>invalidate_label_graph_id_cache</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>invalidate_label_relation_cache</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>flush_label_oid_cache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>flush_label_name_graph_cache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>flush_label_graph_id_cache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>flush_label_relation_cache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>invalidate_label_oid_cache</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>hash_seq</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_seq</name></expr></argument>, <argument><expr><name>label_oid_cache_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>label_cache_data</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>removed</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>entry</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>relation</name></name> <operator>!=</operator> <name>relid</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>removed</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>label_oid_cache_hash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><name>HASH_REMOVE</name></expr></argument>,
                              <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>hash_seq_term</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>removed</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"label (oid) cache corrupted"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <break>break;</break>
    </block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>flush_label_oid_cache</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>hash_seq</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_seq</name></expr></argument>, <argument><expr><name>label_name_graph_cache_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>label_cache_data</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>removed</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>entry</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>removed</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>label_oid_cache_hash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><name>HASH_REMOVE</name></expr></argument>,
                              <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>removed</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"label (oid) cache corrupted"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>invalidate_label_name_graph_cache</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>hash_seq</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_seq</name></expr></argument>, <argument><expr><name>label_name_graph_cache_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>label_name_graph_cache_entry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>removed</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>entry</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>relation</name></name> <operator>!=</operator> <name>relid</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>removed</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>label_name_graph_cache_hash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>key</name></name></expr></argument>,
                              <argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>hash_seq_term</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>removed</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"label (name, graph) cache corrupted"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <break>break;</break>
    </block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>flush_label_name_graph_cache</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>hash_seq</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_seq</name></expr></argument>, <argument><expr><name>label_name_graph_cache_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>label_name_graph_cache_entry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>removed</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>entry</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>removed</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>label_name_graph_cache_hash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>key</name></name></expr></argument>,
                              <argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>removed</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"label (name, graph) cache corrupted"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>invalidate_label_graph_id_cache</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>hash_seq</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_seq</name></expr></argument>, <argument><expr><name>label_graph_id_cache_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>label_graph_id_cache_entry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>removed</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>entry</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>relation</name></name> <operator>!=</operator> <name>relid</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>removed</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>label_graph_id_cache_hash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>key</name></name></expr></argument>,
                              <argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>hash_seq_term</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>removed</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"label (graph, id) cache corrupted"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <break>break;</break>
    </block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>flush_label_graph_id_cache</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>hash_seq</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_seq</name></expr></argument>, <argument><expr><name>label_graph_id_cache_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>label_graph_id_cache_entry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>removed</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>entry</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>removed</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>label_graph_id_cache_hash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>key</name></name></expr></argument>,
                              <argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>removed</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"label (graph, id) cache corrupted"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>invalidate_label_relation_cache</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>label_relation_cache_entry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>removed</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>label_relation_cache_hash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>relid</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>entry</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>removed</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>label_relation_cache_hash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>relid</name></expr></argument>, <argument><expr><name>HASH_REMOVE</name></expr></argument>,
                          <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>removed</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"label (namespace) cache corrupted"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>flush_label_relation_cache</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>hash_seq</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_seq</name></expr></argument>, <argument><expr><name>label_relation_cache_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>label_relation_cache_entry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>removed</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>entry</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>removed</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>label_relation_cache_hash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>,
                              <argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>removed</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"label (relation) cache corrupted"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>label_cache_data</name> <modifier>*</modifier></type><name>search_label_oid_cache</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>label_cache_data</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>initialize_caches</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>label_oid_cache_hash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>entry</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>entry</name></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><call><name>search_label_oid_cache_miss</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>label_cache_data</name> <modifier>*</modifier></type><name>search_label_oid_cache_miss</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scan_keys</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type> <name>ag_label</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan_desc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>found</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>label_cache_data</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>scan_keys</name></expr></argument>, <argument><expr><name>label_oid_scan_keys</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>label_oid_scan_keys</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>scan_keys</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>sk_argument</name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Calling heap_open() might call AcceptInvalidationMessage() and that
     * might invalidate the label caches. This is OK because this function is
     * called when the desired entry is not in the cache.
     */</comment>
    <expr_stmt><expr><name>ag_label</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><call><name>ag_label_relation_id</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>scan_desc</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>ag_label</name></expr></argument>, <argument><expr><call><name>ag_label_oid_index_id</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>,
                                   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>scan_keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// don't need to loop over scan_desc because ag_label_oid_index is UNIQUE</comment>
    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>ag_label</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// get a new entry</comment>
    <expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>label_oid_cache_hash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// no concurrent update on label_oid_cache_hash</comment>

    <comment type="line">// fill the new entry with the retrieved tuple</comment>
    <expr_stmt><expr><call><name>fill_label_cache_data</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>ag_label</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// make sure that the oid field is the same with the hash key(oid)</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>oid</name></name> <operator>==</operator> <name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>ag_label</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>entry</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>label_cache_data</name> <modifier>*</modifier></type><name>search_label_name_graph_cache</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>graph</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>NameData</name></type> <name>name_key</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>label_name_graph_cache_entry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>graph</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>initialize_caches</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>name_key</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>label_name_graph_cache_hash_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>name_key</name></expr></argument>, <argument><expr><name>graph</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>,
                                               <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>entry</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>data</name></name></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><call><name>search_label_name_graph_cache_miss</name><argument_list>(<argument><expr><operator>&amp;</operator><name>name_key</name></expr></argument>, <argument><expr><name>graph</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>label_cache_data</name> <modifier>*</modifier></type><name>search_label_name_graph_cache_miss</name><parameter_list>(<parameter><decl><type><name>Name</name></type> <name>name</name></decl></parameter>,
                                                            <parameter><decl><type><name>Oid</name></type> <name>graph</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scan_keys</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type> <name>ag_label</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan_desc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>found</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>label_name_graph_cache_entry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>scan_keys</name></expr></argument>, <argument><expr><name>label_name_graph_scan_keys</name></expr></argument>,
           <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>label_name_graph_scan_keys</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>scan_keys</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>sk_argument</name> <operator>=</operator> <call><name>NameGetDatum</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>scan_keys</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>sk_argument</name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>graph</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Calling heap_open() might call AcceptInvalidationMessage() and that
     * might invalidate the label caches. This is OK because this function is
     * called when the desired entry is not in the cache.
     */</comment>
    <expr_stmt><expr><name>ag_label</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><call><name>ag_label_relation_id</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>scan_desc</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>ag_label</name></expr></argument>, <argument><expr><call><name>ag_label_name_graph_index_id</name><argument_list>()</argument_list></call></expr></argument>,
                                   <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>scan_keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * don't need to loop over scan_desc because ag_label_name_graph_index is
     * UNIQUE
     */</comment>
    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>ag_label</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// get a new entry</comment>
    <expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>label_name_graph_cache_hash_search</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>graph</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>,
                                               <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// no concurrent update on label_name_graph_cache_hash</comment>

    <comment type="line">// fill the new entry with the retrieved tuple</comment>
    <expr_stmt><expr><call><name>fill_label_cache_data</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>ag_label</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>ag_label</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>label_name_graph_cache_hash_search</name><parameter_list>(<parameter><decl><type><name>Name</name></type> <name>name</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>graph</name></decl></parameter>,
                                                <parameter><decl><type><name>HASHACTION</name></type> <name>action</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>found</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>label_name_graph_cache_key</name></type> <name>key</name></decl>;</decl_stmt>

    <comment type="line">// initialize the hash key for label_name_graph_cache_hash</comment>
    <expr_stmt><expr><call><name>namecpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>key</name><operator>.</operator><name>graph</name></name> <operator>=</operator> <name>graph</name></expr>;</expr_stmt>

    <return>return <expr><call><name>hash_search</name><argument_list>(<argument><expr><name>label_name_graph_cache_hash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name>action</name></expr></argument>, <argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>label_cache_data</name> <modifier>*</modifier></type><name>search_label_graph_id_cache</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>graph</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>label_graph_id_cache_entry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>graph</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>label_id_is_valid</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>initialize_caches</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>label_graph_id_cache_hash_search</name><argument_list>(<argument><expr><name>graph</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>entry</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>data</name></name></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><call><name>search_label_graph_id_cache_miss</name><argument_list>(<argument><expr><name>graph</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>label_cache_data</name> <modifier>*</modifier></type><name>search_label_graph_id_cache_miss</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>graph</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scan_keys</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type> <name>ag_label</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan_desc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>found</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>label_graph_id_cache_entry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>scan_keys</name></expr></argument>, <argument><expr><name>label_graph_id_scan_keys</name></expr></argument>,
           <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>label_graph_id_scan_keys</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>scan_keys</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>sk_argument</name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>graph</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>scan_keys</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>sk_argument</name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Calling heap_open() might call AcceptInvalidationMessage() and that
     * might invalidate the label caches. This is OK because this function is
     * called when the desired entry is not in the cache.
     */</comment>
    <expr_stmt><expr><name>ag_label</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><call><name>ag_label_relation_id</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>scan_desc</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>ag_label</name></expr></argument>, <argument><expr><call><name>ag_label_graph_id_index_id</name><argument_list>()</argument_list></call></expr></argument>,
                                   <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>scan_keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * don't need to loop over scan_desc because ag_label_graph_id_index is
     * UNIQUE
     */</comment>
    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>ag_label</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// get a new entry</comment>
    <expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>label_graph_id_cache_hash_search</name><argument_list>(<argument><expr><name>graph</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// no concurrent update on label_graph_id_cache_hash</comment>

    <comment type="line">// fill the new entry with the retrieved tuple</comment>
    <expr_stmt><expr><call><name>fill_label_cache_data</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>ag_label</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>ag_label</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>label_graph_id_cache_hash_search</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>graph</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>id</name></decl></parameter>,
                                              <parameter><decl><type><name>HASHACTION</name></type> <name>action</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>found</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>label_graph_id_cache_key</name></type> <name>key</name></decl>;</decl_stmt>

    <comment type="line">// initialize the hash key for label_graph_id_cache_hash</comment>
    <expr_stmt><expr><name><name>key</name><operator>.</operator><name>graph</name></name> <operator>=</operator> <name>graph</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>key</name><operator>.</operator><name>id</name></name> <operator>=</operator> <name>id</name></expr>;</expr_stmt>

    <return>return <expr><call><name>hash_search</name><argument_list>(<argument><expr><name>label_graph_id_cache_hash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name>action</name></expr></argument>, <argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>label_cache_data</name> <modifier>*</modifier></type><name>search_label_relation_cache</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>label_relation_cache_entry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>initialize_caches</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>label_relation_cache_hash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>relation</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>entry</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>data</name></name></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><call><name>search_label_relation_cache_miss</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>label_cache_data</name> <modifier>*</modifier></type><name>search_label_relation_cache_miss</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scan_keys</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type> <name>ag_label</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan_desc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>found</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>label_cache_data</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>scan_keys</name></expr></argument>, <argument><expr><name>label_relation_scan_keys</name></expr></argument>,
           <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>label_relation_scan_keys</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>scan_keys</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>sk_argument</name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Calling heap_open() might call AcceptInvalidationMessage() and that
     * might invalidate the label caches. This is OK because this function is
     * called when the desired entry is not in the cache.
     */</comment>
    <expr_stmt><expr><name>ag_label</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><call><name>ag_label_relation_id</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>scan_desc</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>ag_label</name></expr></argument>, <argument><expr><call><name>ag_label_relation_index_id</name><argument_list>()</argument_list></call></expr></argument>,
                                   <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>scan_keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// don't need to loop over scan_desc because ag_label_relation_index is</comment>
    <comment type="line">// UNIQUE</comment>
    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>ag_label</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// get a new entry</comment>
    <expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>label_relation_cache_hash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>relation</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>,
                        <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// no concurrent update on label_relation_cache_hash</comment>

    <comment type="line">// fill the new entry with the retrieved tuple</comment>
    <expr_stmt><expr><call><name>fill_label_cache_data</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>ag_label</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>ag_label</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>entry</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>fill_label_cache_data</name><parameter_list>(<parameter><decl><type><name>label_cache_data</name> <modifier>*</modifier></type><name>cache_data</name></decl></parameter>,
                                  <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tuple_desc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type> <name>is_null</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type> <name>value</name></decl>;</decl_stmt>

    <comment type="line">// ag_label.oid</comment>
    <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>ObjectIdAttributeNumber</name></expr></argument>, <argument><expr><name>tuple_desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cache_data</name><operator>-&gt;</operator><name>oid</name></name> <operator>=</operator> <call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// ag_label.name</comment>
    <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_ag_label_name</name></expr></argument>, <argument><expr><name>tuple_desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>namecpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cache_data</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><call><name>DatumGetName</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// ag_label.graph</comment>
    <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_ag_label_graph</name></expr></argument>, <argument><expr><name>tuple_desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cache_data</name><operator>-&gt;</operator><name>graph</name></name> <operator>=</operator> <call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// ag_label.id</comment>
    <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_ag_label_id</name></expr></argument>, <argument><expr><name>tuple_desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cache_data</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// ag_label.kind</comment>
    <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_ag_label_kind</name></expr></argument>, <argument><expr><name>tuple_desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cache_data</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <call><name>DatumGetChar</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// ag_label.relation</comment>
    <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_ag_label_relation</name></expr></argument>, <argument><expr><name>tuple_desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cache_data</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
