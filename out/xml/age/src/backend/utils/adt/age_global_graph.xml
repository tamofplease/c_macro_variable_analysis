<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/workspace/age/src/backend/utils/adt/age_global_graph.c"><comment type="block">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/label_commands.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/age_global_graph.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/agtype.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/ag_graph.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/ag_label.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/graphid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/age_graphid_ds.h"</cpp:file></cpp:include>

<comment type="block">/* defines */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VERTEX_HTAB_NAME</name></cpp:macro> <cpp:value>"Vertex to edge lists "</cpp:value></cpp:define> <comment type="block">/* added a space at end for */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EDGE_HTAB_NAME</name></cpp:macro> <cpp:value>"Edge to vertex mapping "</cpp:value></cpp:define> <comment type="block">/* the graph name to follow */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VERTEX_HTAB_INITIAL_SIZE</name></cpp:macro> <cpp:value>1000000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EDGE_HTAB_INITIAL_SIZE</name></cpp:macro> <cpp:value>1000000</cpp:value></cpp:define>

<comment type="block">/* internal data structures implementation */</comment>

<comment type="block">/* vertex entry for the vertex_hastable */</comment>
<typedef>typedef <type><struct>struct <name>vertex_entry</name>
<block>{
    <decl_stmt><decl><type><name>graphid</name></type> <name>vertex_id</name></decl>;</decl_stmt>             <comment type="block">/* vertex id, it is also the hash key */</comment>
    <decl_stmt><decl><type><name>ListGraphId</name> <modifier>*</modifier></type><name>edges_in</name></decl>;</decl_stmt>         <comment type="block">/* List of entering edges graphids (int64) */</comment>
    <decl_stmt><decl><type><name>ListGraphId</name> <modifier>*</modifier></type><name>edges_out</name></decl>;</decl_stmt>        <comment type="block">/* List of exiting edges graphids (int64) */</comment>
    <decl_stmt><decl><type><name>ListGraphId</name> <modifier>*</modifier></type><name>edges_self</name></decl>;</decl_stmt>       <comment type="block">/* List of selfloop edges graphids (int64) */</comment>
    <decl_stmt><decl><type><name>Oid</name></type> <name>vertex_label_table_oid</name></decl>;</decl_stmt>    <comment type="block">/* the label table oid */</comment>
    <decl_stmt><decl><type><name>Datum</name></type> <name>vertex_properties</name></decl>;</decl_stmt>       <comment type="block">/* datum property value */</comment>
}</block></struct></type> <name>vertex_entry</name>;</typedef>

<comment type="block">/* edge entry for the edge_hashtable */</comment>
<typedef>typedef <type><struct>struct <name>edge_entry</name>
<block>{
    <decl_stmt><decl><type><name>graphid</name></type> <name>edge_id</name></decl>;</decl_stmt>               <comment type="block">/* edge id, it is also the hash key */</comment>
    <decl_stmt><decl><type><name>Oid</name></type> <name>edge_label_table_oid</name></decl>;</decl_stmt>      <comment type="block">/* the label table oid */</comment>
    <decl_stmt><decl><type><name>Datum</name></type> <name>edge_properties</name></decl>;</decl_stmt>         <comment type="block">/* datum property value */</comment>
    <decl_stmt><decl><type><name>graphid</name></type> <name>start_vertex_id</name></decl>;</decl_stmt>       <comment type="block">/* start vertex */</comment>
    <decl_stmt><decl><type><name>graphid</name></type> <name>end_vertex_id</name></decl>;</decl_stmt>         <comment type="block">/* end vertex */</comment>
}</block></struct></type> <name>edge_entry</name>;</typedef>

<comment type="block">/*
 * GRAPH global context per graph. They are chained together via next.
 * Be aware that the global pointer will point to the root BUT that
 * the root will change as new graphs are added to the top.
 */</comment>
<typedef>typedef <type><struct>struct <name>GRAPH_global_context</name>
<block>{
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>graph_name</name></decl>;</decl_stmt>              <comment type="block">/* graph name */</comment>
    <decl_stmt><decl><type><name>Oid</name></type> <name>graph_oid</name></decl>;</decl_stmt>                 <comment type="block">/* graph oid for searching */</comment>
    <decl_stmt><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>vertex_hashtable</name></decl>;</decl_stmt>        <comment type="block">/* hashtable to hold vertex edge lists */</comment>
    <decl_stmt><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>edge_hashtable</name></decl>;</decl_stmt>          <comment type="block">/* hashtable to hold edge to vertex map */</comment>
    <decl_stmt><decl><type><name>TransactionId</name></type> <name>xmin</name></decl>;</decl_stmt>            <comment type="block">/* transaction ids for this graph */</comment>
    <decl_stmt><decl><type><name>TransactionId</name></type> <name>xmax</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CommandId</name></type> <name>curcid</name></decl>;</decl_stmt>              <comment type="block">/* currentCommandId graph was created with */</comment>
    <decl_stmt><decl><type><name>int64</name></type> <name>num_loaded_vertices</name></decl>;</decl_stmt>     <comment type="block">/* number of loaded vertices in this graph */</comment>
    <decl_stmt><decl><type><name>int64</name></type> <name>num_loaded_edges</name></decl>;</decl_stmt>        <comment type="block">/* number of loaded edges in this graph */</comment>
    <decl_stmt><decl><type><name>ListGraphId</name> <modifier>*</modifier></type><name>vertices</name></decl>;</decl_stmt>         <comment type="block">/* vertices for vertex hashtable cleanup */</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>GRAPH_global_context</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt> <comment type="block">/* next graph */</comment>
}</block></struct></type> <name>GRAPH_global_context</name>;</typedef>

<comment type="block">/* global variable to hold the per process GRAPH global context */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>GRAPH_global_context</name> <modifier>*</modifier></type><name>global_graph_contexts</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* declarations */</comment>
<comment type="block">/* GRAPH global context functions */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>free_specific_GRAPH_global_context</name><parameter_list>(<parameter><decl><type><name>GRAPH_global_context</name> <modifier>*</modifier></type><name>ggctx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>delete_specific_GRAPH_global_contexts</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>graph_name</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>delete_GRAPH_global_contexts</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>create_GRAPH_global_hashtables</name><parameter_list>(<parameter><decl><type><name>GRAPH_global_context</name> <modifier>*</modifier></type><name>ggctx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>load_GRAPH_global_hashtables</name><parameter_list>(<parameter><decl><type><name>GRAPH_global_context</name> <modifier>*</modifier></type><name>ggctx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>load_vertex_hashtable</name><parameter_list>(<parameter><decl><type><name>GRAPH_global_context</name> <modifier>*</modifier></type><name>ggctx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>load_edge_hashtable</name><parameter_list>(<parameter><decl><type><name>GRAPH_global_context</name> <modifier>*</modifier></type><name>ggctx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>freeze_GRAPH_global_hashtables</name><parameter_list>(<parameter><decl><type><name>GRAPH_global_context</name> <modifier>*</modifier></type><name>ggctx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>get_ag_labels_names</name><parameter_list>(<parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>graph_oid</name></decl></parameter>,
                                 <parameter><decl><type><name>char</name></type> <name>label_type</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>insert_edge</name><parameter_list>(<parameter><decl><type><name>GRAPH_global_context</name> <modifier>*</modifier></type><name>ggctx</name></decl></parameter>, <parameter><decl><type><name>graphid</name></type> <name>edge_id</name></decl></parameter>,
                        <parameter><decl><type><name>Datum</name></type> <name>edge_properties</name></decl></parameter>, <parameter><decl><type><name>graphid</name></type> <name>start_vertex_id</name></decl></parameter>,
                        <parameter><decl><type><name>graphid</name></type> <name>end_vertex_id</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>edge_label_table_oid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>insert_vertex_edge</name><parameter_list>(<parameter><decl><type><name>GRAPH_global_context</name> <modifier>*</modifier></type><name>ggctx</name></decl></parameter>,
                               <parameter><decl><type><name>graphid</name></type> <name>start_vertex_id</name></decl></parameter>, <parameter><decl><type><name>graphid</name></type> <name>end_vertex_id</name></decl></parameter>,
                               <parameter><decl><type><name>graphid</name></type> <name>edge_id</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>insert_vertex_entry</name><parameter_list>(<parameter><decl><type><name>GRAPH_global_context</name> <modifier>*</modifier></type><name>ggctx</name></decl></parameter>, <parameter><decl><type><name>graphid</name></type> <name>vertex_id</name></decl></parameter>,
                                <parameter><decl><type><name>Oid</name></type> <name>vertex_label_table_oid</name></decl></parameter>,
                                <parameter><decl><type><name>Datum</name></type> <name>vertex_properties</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block">/* definitions */</comment>

<comment type="block">/*
 * Helper function to determine validity of the passed GRAPH_global_context.
 * This is based off of the current active snaphot, to see if the graph could
 * have been modified. Ideally, we should find a way to more accurately know
 * whether the particular graph was modified.
 */</comment>
<function><type><name>bool</name></type> <name>is_ggctx_invalid</name><parameter_list>(<parameter><decl><type><name>GRAPH_global_context</name> <modifier>*</modifier></type><name>ggctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Snapshot</name></type> <name>snap</name> <init>= <expr><call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * If the transaction ids (xmin or xmax) or currentCommandId (curcid) have
     * changed, then we have a graph that was updated. This means that the
     * global context for this graph is no longer valid.
     */</comment>
    <return>return <expr><operator>(</operator><name><name>ggctx</name><operator>-&gt;</operator><name>xmin</name></name> <operator>!=</operator> <name><name>snap</name><operator>-&gt;</operator><name>xmin</name></name> <operator>||</operator>
            <name><name>ggctx</name><operator>-&gt;</operator><name>xmax</name></name> <operator>!=</operator> <name><name>snap</name><operator>-&gt;</operator><name>xmax</name></name> <operator>||</operator>
            <name><name>ggctx</name><operator>-&gt;</operator><name>curcid</name></name> <operator>!=</operator> <name><name>snap</name><operator>-&gt;</operator><name>curcid</name></name><operator>)</operator></expr>;</return>

</block_content>}</block></function>
<comment type="block">/*
 * Helper function to create the global vertex and edge hashtables. One
 * hashtable will hold the vertex, its edges (both incoming and exiting) as a
 * list, and its properties datum. The other hashtable will hold the edge, its
 * properties datum, and its source and target vertex.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>create_GRAPH_global_hashtables</name><parameter_list>(<parameter><decl><type><name>GRAPH_global_context</name> <modifier>*</modifier></type><name>ggctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HASHCTL</name></type> <name>vertex_ctl</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HASHCTL</name></type> <name>edge_ctl</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>graph_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>vhn</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ehn</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>glen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>vlen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>elen</name></decl>;</decl_stmt>

    <comment type="block">/* get the graph name and length */</comment>
    <expr_stmt><expr><name>graph_name</name> <operator>=</operator> <name><name>ggctx</name><operator>-&gt;</operator><name>graph_name</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>glen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>graph_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* get the vertex htab name length */</comment>
    <expr_stmt><expr><name>vlen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>VERTEX_HTAB_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* get the edge htab name length */</comment>
    <expr_stmt><expr><name>elen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>EDGE_HTAB_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* allocate the space and build the names */</comment>
    <expr_stmt><expr><name>vhn</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>vlen</name> <operator>+</operator> <name>glen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ehn</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>elen</name> <operator>+</operator> <name>glen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* copy in the names */</comment>
    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>vhn</name></expr></argument>, <argument><expr><name>VERTEX_HTAB_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>ehn</name></expr></argument>, <argument><expr><name>EDGE_HTAB_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* add in the graph name */</comment>
    <expr_stmt><expr><name>vhn</name> <operator>=</operator> <call><name>strncat</name><argument_list>(<argument><expr><name>vhn</name></expr></argument>, <argument><expr><name>graph_name</name></expr></argument>, <argument><expr><name>glen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ehn</name> <operator>=</operator> <call><name>strncat</name><argument_list>(<argument><expr><name>ehn</name></expr></argument>, <argument><expr><name>graph_name</name></expr></argument>, <argument><expr><name>glen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* initialize the vertex hashtable */</comment>
    <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vertex_ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>vertex_ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>vertex_ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>vertex_ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>vertex_entry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>vertex_ctl</name><operator>.</operator><name>hash</name></name> <operator>=</operator> <name>tag_hash</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ggctx</name><operator>-&gt;</operator><name>vertex_hashtable</name></name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><name>vhn</name></expr></argument>, <argument><expr><name>VERTEX_HTAB_INITIAL_SIZE</name></expr></argument>,
                                          <argument><expr><operator>&amp;</operator><name>vertex_ctl</name></expr></argument>,
                                          <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_FUNCTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>vhn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* initialize the edge hashtable */</comment>
    <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>edge_ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>edge_ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>edge_ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>edge_ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>edge_entry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>edge_ctl</name><operator>.</operator><name>hash</name></name> <operator>=</operator> <name>tag_hash</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ggctx</name><operator>-&gt;</operator><name>edge_hashtable</name></name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><name>ehn</name></expr></argument>, <argument><expr><name>EDGE_HTAB_INITIAL_SIZE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>edge_ctl</name></expr></argument>,
                                        <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_FUNCTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>ehn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* helper function to get a List of all label names for the specified graph */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>get_ag_labels_names</name><parameter_list>(<parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>graph_oid</name></decl></parameter>,
                                 <parameter><decl><type><name>char</name></type> <name>label_type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>labels</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scan_keys</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type> <name>ag_label</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapScanDesc</name></type> <name>scan_desc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl>;</decl_stmt>

    <comment type="block">/* we need a valid snapshot */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>snapshot</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* setup scan keys to get all edges for the given graph oid */</comment>
    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scan_keys</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_ag_label_graph</name></expr></argument>, <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
                <argument><expr><name>F_OIDEQ</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>graph_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scan_keys</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_ag_label_kind</name></expr></argument>, <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
                <argument><expr><name>F_CHAREQ</name></expr></argument>, <argument><expr><call><name>CharGetDatum</name><argument_list>(<argument><expr><name>label_type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* setup the table to be scanned, ag_label in this case */</comment>
    <expr_stmt><expr><name>ag_label</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><call><name>ag_label_relation_id</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>scan_desc</name> <operator>=</operator> <call><name>heap_beginscan</name><argument_list>(<argument><expr><name>ag_label</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>scan_keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* get the tupdesc - we don't need to release this one */</comment>
    <expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>ag_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* bail if the number of columns differs - this table has 5 */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>==</operator> <name>Natts_ag_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* get all of the label names */</comment>
    <while>while<condition>(<expr><operator>(</operator><name>tuple</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan_desc</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Name</name></type> <name>label</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>is_null</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* something is wrong if this tuple isn't valid */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* get the label name */</comment>
        <expr_stmt><expr><name>label</name> <operator>=</operator> <call><name>DatumGetName</name><argument_list>(<argument><expr><call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_ag_label_name</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>,
                                          <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* add it to our list */</comment>
        <expr_stmt><expr><name>labels</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>labels</name></expr></argument>, <argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/* close up scan */</comment>
    <expr_stmt><expr><call><name>heap_endscan</name><argument_list>(<argument><expr><name>scan_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>ag_label</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>labels</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Helper function to insert one edge/edge-&gt;vertex, key/value pair, in the
 * current GRAPH global edge hashtable.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>insert_edge</name><parameter_list>(<parameter><decl><type><name>GRAPH_global_context</name> <modifier>*</modifier></type><name>ggctx</name></decl></parameter>, <parameter><decl><type><name>graphid</name></type> <name>edge_id</name></decl></parameter>,
                        <parameter><decl><type><name>Datum</name></type> <name>edge_properties</name></decl></parameter>, <parameter><decl><type><name>graphid</name></type> <name>start_vertex_id</name></decl></parameter>,
                        <parameter><decl><type><name>graphid</name></type> <name>end_vertex_id</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>edge_label_table_oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>edge_entry</name> <modifier>*</modifier></type><name>value</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* search for the edge */</comment>
    <expr_stmt><expr><name>value</name> <operator>=</operator> <operator>(</operator><name>edge_entry</name> <operator>*</operator><operator>)</operator><call><name>hash_search</name><argument_list>(<argument><expr><name><name>ggctx</name><operator>-&gt;</operator><name>edge_hashtable</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>edge_id</name></expr></argument>,
                                      <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/*
     * If we found the key, either we have a duplicate, or we made a mistake and
     * inserted it already. Either way, this isn't good so don't insert it and
     * return false. Likewise, if the value returned is NULL, don't do anything,
     * just return false. This way the caller can decide what to do.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>found</name> <operator>||</operator> <name>value</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* not sure if we really need to zero out the entry, as we set everything */</comment>
    <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>edge_entry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Set the edge id - this is important as this is the hash key value used
     * for hash function collisions.
     */</comment>
    <expr_stmt><expr><name><name>value</name><operator>-&gt;</operator><name>edge_id</name></name> <operator>=</operator> <name>edge_id</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>value</name><operator>-&gt;</operator><name>edge_properties</name></name> <operator>=</operator> <name>edge_properties</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>value</name><operator>-&gt;</operator><name>start_vertex_id</name></name> <operator>=</operator> <name>start_vertex_id</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>value</name><operator>-&gt;</operator><name>end_vertex_id</name></name> <operator>=</operator> <name>end_vertex_id</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>value</name><operator>-&gt;</operator><name>edge_label_table_oid</name></name> <operator>=</operator> <name>edge_label_table_oid</name></expr>;</expr_stmt>

    <comment type="block">/* increment the number of loaded edges */</comment>
    <expr_stmt><expr><name><name>ggctx</name><operator>-&gt;</operator><name>num_loaded_edges</name></name><operator>++</operator></expr>;</expr_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Helper function to insert an entire vertex into the current GRAPH global
 * vertex hashtable. It will return false if there is a duplicate.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>insert_vertex_entry</name><parameter_list>(<parameter><decl><type><name>GRAPH_global_context</name> <modifier>*</modifier></type><name>ggctx</name></decl></parameter>, <parameter><decl><type><name>graphid</name></type> <name>vertex_id</name></decl></parameter>,
                                <parameter><decl><type><name>Oid</name></type> <name>vertex_label_table_oid</name></decl></parameter>,
                                <parameter><decl><type><name>Datum</name></type> <name>vertex_properties</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>vertex_entry</name> <modifier>*</modifier></type><name>ve</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* search for the vertex */</comment>
    <expr_stmt><expr><name>ve</name> <operator>=</operator> <operator>(</operator><name>vertex_entry</name> <operator>*</operator><operator>)</operator><call><name>hash_search</name><argument_list>(<argument><expr><name><name>ggctx</name><operator>-&gt;</operator><name>vertex_hashtable</name></name></expr></argument>,
                                     <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>vertex_id</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* we should never have duplicates, return false */</comment>
    <if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* again, MemSet may not be needed here */</comment>
    <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>ve</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>vertex_entry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Set the vertex id - this is important as this is the hash key value
     * used for hash function collisions.
     */</comment>
    <expr_stmt><expr><name><name>ve</name><operator>-&gt;</operator><name>vertex_id</name></name> <operator>=</operator> <name>vertex_id</name></expr>;</expr_stmt>
    <comment type="block">/* set the label table oid for this vertex */</comment>
    <expr_stmt><expr><name><name>ve</name><operator>-&gt;</operator><name>vertex_label_table_oid</name></name> <operator>=</operator> <name>vertex_label_table_oid</name></expr>;</expr_stmt>
    <comment type="block">/* set the datum vertex properties */</comment>
    <expr_stmt><expr><name><name>ve</name><operator>-&gt;</operator><name>vertex_properties</name></name> <operator>=</operator> <name>vertex_properties</name></expr>;</expr_stmt>
    <comment type="block">/* set the NIL edge list */</comment>
    <expr_stmt><expr><name><name>ve</name><operator>-&gt;</operator><name>edges_in</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ve</name><operator>-&gt;</operator><name>edges_out</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ve</name><operator>-&gt;</operator><name>edges_self</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/* we also need to store the vertex id for clean up of vertex lists */</comment>
    <expr_stmt><expr><name><name>ggctx</name><operator>-&gt;</operator><name>vertices</name></name> <operator>=</operator> <call><name>append_graphid</name><argument_list>(<argument><expr><name><name>ggctx</name><operator>-&gt;</operator><name>vertices</name></name></expr></argument>, <argument><expr><name>vertex_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* increment the number of loaded vertices */</comment>
    <expr_stmt><expr><name><name>ggctx</name><operator>-&gt;</operator><name>num_loaded_vertices</name></name><operator>++</operator></expr>;</expr_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Helper function to append one edge to an existing vertex in the current
 * global vertex hashtable.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>insert_vertex_edge</name><parameter_list>(<parameter><decl><type><name>GRAPH_global_context</name> <modifier>*</modifier></type><name>ggctx</name></decl></parameter>,
                               <parameter><decl><type><name>graphid</name></type> <name>start_vertex_id</name></decl></parameter>, <parameter><decl><type><name>graphid</name></type> <name>end_vertex_id</name></decl></parameter>,
                               <parameter><decl><type><name>graphid</name></type> <name>edge_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>vertex_entry</name> <modifier>*</modifier></type><name>value</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>is_selfloop</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* is it a self loop */</comment>
    <expr_stmt><expr><name>is_selfloop</name> <operator>=</operator> <operator>(</operator><name>start_vertex_id</name> <operator>==</operator> <name>end_vertex_id</name><operator>)</operator></expr>;</expr_stmt>

    <comment type="block">/* search for the start vertex of the edge */</comment>
    <expr_stmt><expr><name>value</name> <operator>=</operator> <operator>(</operator><name>vertex_entry</name> <operator>*</operator><operator>)</operator><call><name>hash_search</name><argument_list>(<argument><expr><name><name>ggctx</name><operator>-&gt;</operator><name>vertex_hashtable</name></name></expr></argument>,
                                        <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>start_vertex_id</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>,
                                        <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* vertices were preloaded so it must be there */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>found</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* if it is a self loop, add the edge to edges_self and we're done */</comment>
    <if_stmt><if>if <condition>(<expr><name>is_selfloop</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>value</name><operator>-&gt;</operator><name>edges_self</name></name> <operator>=</operator> <call><name>append_graphid</name><argument_list>(<argument><expr><name><name>value</name><operator>-&gt;</operator><name>edges_self</name></name></expr></argument>, <argument><expr><name>edge_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>found</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* add the edge to the edges_out list of the start vertex */</comment>
    <expr_stmt><expr><name><name>value</name><operator>-&gt;</operator><name>edges_out</name></name> <operator>=</operator> <call><name>append_graphid</name><argument_list>(<argument><expr><name><name>value</name><operator>-&gt;</operator><name>edges_out</name></name></expr></argument>, <argument><expr><name>edge_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* search for the end vertex of the edge */</comment>
    <expr_stmt><expr><name>value</name> <operator>=</operator> <operator>(</operator><name>vertex_entry</name> <operator>*</operator><operator>)</operator><call><name>hash_search</name><argument_list>(<argument><expr><name><name>ggctx</name><operator>-&gt;</operator><name>vertex_hashtable</name></name></expr></argument>,
                                        <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>end_vertex_id</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>,
                                        <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* vertices were preloaded so it must be there */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>found</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* add the edge to the edges_in list of the end vertex */</comment>
    <expr_stmt><expr><name><name>value</name><operator>-&gt;</operator><name>edges_in</name></name> <operator>=</operator> <call><name>append_graphid</name><argument_list>(<argument><expr><name><name>value</name><operator>-&gt;</operator><name>edges_in</name></name></expr></argument>, <argument><expr><name>edge_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>found</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* helper routine to load all vertices into the GRAPH global vertex hashtable */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>load_vertex_hashtable</name><parameter_list>(<parameter><decl><type><name>GRAPH_global_context</name> <modifier>*</modifier></type><name>ggctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type> <name>graph_oid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type> <name>graph_namespace_oid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>vertex_label_names</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <comment type="block">/* get the specific graph OID and namespace (schema) OID */</comment>
    <expr_stmt><expr><name>graph_oid</name> <operator>=</operator> <name><name>ggctx</name><operator>-&gt;</operator><name>graph_oid</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>graph_namespace_oid</name> <operator>=</operator> <call><name>get_namespace_oid</name><argument_list>(<argument><expr><name><name>ggctx</name><operator>-&gt;</operator><name>graph_name</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* get the active snapshot */</comment>
    <expr_stmt><expr><name>snapshot</name> <operator>=</operator> <call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* get the names of all of the vertex label tables */</comment>
    <expr_stmt><expr><name>vertex_label_names</name> <operator>=</operator> <call><name>get_ag_labels_names</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>, <argument><expr><name>graph_oid</name></expr></argument>,
                                             <argument><expr><name>LABEL_TYPE_VERTEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* go through all vertex label tables in list */</comment>
    <macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>vertex_label_names</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Relation</name></type> <name>graph_vertex_label</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>HeapScanDesc</name></type> <name>scan_desc</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>vertex_label_name</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type> <name>vertex_label_table_oid</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl>;</decl_stmt>

        <comment type="block">/* get the vertex label name */</comment>
        <expr_stmt><expr><name>vertex_label_name</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* get the vertex label name's OID */</comment>
        <expr_stmt><expr><name>vertex_label_table_oid</name> <operator>=</operator> <call><name>get_relname_relid</name><argument_list>(<argument><expr><name>vertex_label_name</name></expr></argument>,
                                                   <argument><expr><name>graph_namespace_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* open the relation (table) and begin the scan */</comment>
        <expr_stmt><expr><name>graph_vertex_label</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>vertex_label_table_oid</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>scan_desc</name> <operator>=</operator> <call><name>heap_beginscan</name><argument_list>(<argument><expr><name>graph_vertex_label</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* get the tupdesc - we don't need to release this one */</comment>
        <expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>graph_vertex_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* bail if the number of columns differs */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Invalid number of attributes for %s.%s"</literal></expr></argument>,
                     <argument><expr><name><name>ggctx</name><operator>-&gt;</operator><name>graph_name</name></name></expr></argument>, <argument><expr><name>vertex_label_name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* get all tuples in table and insert them into graph hashtables */</comment>
        <while>while<condition>(<expr><operator>(</operator><name>tuple</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan_desc</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>graphid</name></type> <name>vertex_id</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Datum</name></type> <name>vertex_properties</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type> <name>inserted</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

            <comment type="block">/* something is wrong if this isn't true */</comment>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* get the vertex id */</comment>
            <expr_stmt><expr><name>vertex_id</name> <operator>=</operator> <call><name>DatumGetInt64</name><argument_list>(<argument><expr><call><name>column_get_datum</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"id"</literal></expr></argument>,
                                                       <argument><expr><name>GRAPHIDOID</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* get the vertex properties datum */</comment>
            <expr_stmt><expr><name>vertex_properties</name> <operator>=</operator> <call><name>column_get_datum</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
                                                 <argument><expr><literal type="string">"properties"</literal></expr></argument>, <argument><expr><name>AGTYPEOID</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* insert vertex into vertex hashtable */</comment>
            <expr_stmt><expr><name>inserted</name> <operator>=</operator> <call><name>insert_vertex_entry</name><argument_list>(<argument><expr><name>ggctx</name></expr></argument>, <argument><expr><name>vertex_id</name></expr></argument>,
                                           <argument><expr><name>vertex_label_table_oid</name></expr></argument>,
                                           <argument><expr><name>vertex_properties</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* this insert must not fail, it means there is a duplicate */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>inserted</name></expr>)</condition>
            <block>{<block_content>
                 <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"insert_vertex_entry: failed due to duplicate"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></while>

        <comment type="block">/* end the scan and close the relation */</comment>
        <expr_stmt><expr><call><name>heap_endscan</name><argument_list>(<argument><expr><name>scan_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>graph_vertex_label</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Helper function to load all of the GRAPH global hashtables (vertex &amp; edge)
 * for the current global context.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>load_GRAPH_global_hashtables</name><parameter_list>(<parameter><decl><type><name>GRAPH_global_context</name> <modifier>*</modifier></type><name>ggctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* initialize statistics */</comment>
    <expr_stmt><expr><name><name>ggctx</name><operator>-&gt;</operator><name>num_loaded_vertices</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ggctx</name><operator>-&gt;</operator><name>num_loaded_edges</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/* insert all of our vertices */</comment>
    <expr_stmt><expr><call><name>load_vertex_hashtable</name><argument_list>(<argument><expr><name>ggctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* insert all of our edges */</comment>
    <expr_stmt><expr><call><name>load_edge_hashtable</name><argument_list>(<argument><expr><name>ggctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Helper routine to load all edges into the GRAPH global edge and vertex
 * hashtables.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>load_edge_hashtable</name><parameter_list>(<parameter><decl><type><name>GRAPH_global_context</name> <modifier>*</modifier></type><name>ggctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type> <name>graph_oid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type> <name>graph_namespace_oid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>edge_label_names</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <comment type="block">/* get the specific graph OID and namespace (schema) OID */</comment>
    <expr_stmt><expr><name>graph_oid</name> <operator>=</operator> <name><name>ggctx</name><operator>-&gt;</operator><name>graph_oid</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>graph_namespace_oid</name> <operator>=</operator> <call><name>get_namespace_oid</name><argument_list>(<argument><expr><name><name>ggctx</name><operator>-&gt;</operator><name>graph_name</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* get the active snapshot */</comment>
    <expr_stmt><expr><name>snapshot</name> <operator>=</operator> <call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* get the names of all of the edge label tables */</comment>
    <expr_stmt><expr><name>edge_label_names</name> <operator>=</operator> <call><name>get_ag_labels_names</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>, <argument><expr><name>graph_oid</name></expr></argument>,
                                           <argument><expr><name>LABEL_TYPE_EDGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* go through all edge label tables in list */</comment>
    <macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>edge_label_names</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Relation</name></type> <name>graph_edge_label</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>HeapScanDesc</name></type> <name>scan_desc</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>edge_label_name</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type> <name>edge_label_table_oid</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl>;</decl_stmt>

        <comment type="block">/* get the edge label name */</comment>
        <expr_stmt><expr><name>edge_label_name</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* get the edge label name's OID */</comment>
        <expr_stmt><expr><name>edge_label_table_oid</name> <operator>=</operator> <call><name>get_relname_relid</name><argument_list>(<argument><expr><name>edge_label_name</name></expr></argument>,
                                                 <argument><expr><name>graph_namespace_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* open the relation (table) and begin the scan */</comment>
        <expr_stmt><expr><name>graph_edge_label</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>edge_label_table_oid</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>scan_desc</name> <operator>=</operator> <call><name>heap_beginscan</name><argument_list>(<argument><expr><name>graph_edge_label</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* get the tupdesc - we don't need to release this one */</comment>
        <expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>graph_edge_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* bail if the number of columns differs */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>!=</operator> <literal type="number">4</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Invalid number of attributes for %s.%s"</literal></expr></argument>,
                     <argument><expr><name><name>ggctx</name><operator>-&gt;</operator><name>graph_name</name></name></expr></argument>, <argument><expr><name>edge_label_name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* get all tuples in table and insert them into graph hashtables */</comment>
        <while>while<condition>(<expr><operator>(</operator><name>tuple</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan_desc</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>graphid</name></type> <name>edge_id</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>graphid</name></type> <name>edge_vertex_start_id</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>graphid</name></type> <name>edge_vertex_end_id</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Datum</name></type> <name>edge_properties</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type> <name>inserted</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

            <comment type="block">/* something is wrong if this isn't true */</comment>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* get the edge id */</comment>
            <expr_stmt><expr><name>edge_id</name> <operator>=</operator> <call><name>DatumGetInt64</name><argument_list>(<argument><expr><call><name>column_get_datum</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"id"</literal></expr></argument>,
                                                     <argument><expr><name>GRAPHIDOID</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* get the edge start_id (start vertex id) */</comment>
            <expr_stmt><expr><name>edge_vertex_start_id</name> <operator>=</operator> <call><name>DatumGetInt64</name><argument_list>(<argument><expr><call><name>column_get_datum</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>,
                                                                  <argument><expr><name>tuple</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
                                                                  <argument><expr><literal type="string">"start_id"</literal></expr></argument>,
                                                                  <argument><expr><name>GRAPHIDOID</name></expr></argument>,
                                                                  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* get the edge end_id (end vertex id)*/</comment>
            <expr_stmt><expr><name>edge_vertex_end_id</name> <operator>=</operator> <call><name>DatumGetInt64</name><argument_list>(<argument><expr><call><name>column_get_datum</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>,
                                                                <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"end_id"</literal></expr></argument>,
                                                                <argument><expr><name>GRAPHIDOID</name></expr></argument>,
                                                                <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* get the edge properties datum */</comment>
            <expr_stmt><expr><name>edge_properties</name> <operator>=</operator> <call><name>column_get_datum</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"properties"</literal></expr></argument>,
                                               <argument><expr><name>AGTYPEOID</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* insert edge into edge hashtable */</comment>
            <expr_stmt><expr><name>inserted</name> <operator>=</operator> <call><name>insert_edge</name><argument_list>(<argument><expr><name>ggctx</name></expr></argument>, <argument><expr><name>edge_id</name></expr></argument>, <argument><expr><name>edge_properties</name></expr></argument>,
                                   <argument><expr><name>edge_vertex_start_id</name></expr></argument>, <argument><expr><name>edge_vertex_end_id</name></expr></argument>,
                                   <argument><expr><name>edge_label_table_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* this insert must not fail */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>inserted</name></expr>)</condition>
            <block>{<block_content>
                 <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"insert_edge: failed to insert"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* insert the edge into the start and end vertices edge lists */</comment>
            <expr_stmt><expr><name>inserted</name> <operator>=</operator> <call><name>insert_vertex_edge</name><argument_list>(<argument><expr><name>ggctx</name></expr></argument>, <argument><expr><name>edge_vertex_start_id</name></expr></argument>,
                                          <argument><expr><name>edge_vertex_end_id</name></expr></argument>, <argument><expr><name>edge_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* this insert must not fail */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>inserted</name></expr>)</condition>
            <block>{<block_content>
                 <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"insert_vertex_edge: failed to insert"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></while>

        <comment type="block">/* end the scan and close the relation */</comment>
        <expr_stmt><expr><call><name>heap_endscan</name><argument_list>(<argument><expr><name>scan_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>graph_edge_label</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Helper function to freeze the GRAPH global hashtables from additional
 * inserts. This may, or may not, be useful. Currently, these hashtables are
 * only seen by the creating process and only for reading.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>freeze_GRAPH_global_hashtables</name><parameter_list>(<parameter><decl><type><name>GRAPH_global_context</name> <modifier>*</modifier></type><name>ggctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>hash_freeze</name><argument_list>(<argument><expr><name><name>ggctx</name><operator>-&gt;</operator><name>vertex_hashtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>hash_freeze</name><argument_list>(<argument><expr><name><name>ggctx</name><operator>-&gt;</operator><name>edge_hashtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Helper function to free the entire specified GRAPH global context. After
 * running this you should not use the pointer in ggctx.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>free_specific_GRAPH_global_context</name><parameter_list>(<parameter><decl><type><name>GRAPH_global_context</name> <modifier>*</modifier></type><name>ggctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GraphIdNode</name> <modifier>*</modifier></type><name>curr_vertex</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* don't do anything if NULL */</comment>
    <if_stmt><if>if <condition>(<expr><name>ggctx</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* free the graph name */</comment>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>ggctx</name><operator>-&gt;</operator><name>graph_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ggctx</name><operator>-&gt;</operator><name>graph_name</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>ggctx</name><operator>-&gt;</operator><name>graph_oid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ggctx</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/* free the vertex edge lists, starting with the head */</comment>
    <expr_stmt><expr><name>curr_vertex</name> <operator>=</operator> <call><name>peek_stack_head</name><argument_list>(<argument><expr><name><name>ggctx</name><operator>-&gt;</operator><name>vertices</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>curr_vertex</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>GraphIdNode</name> <modifier>*</modifier></type><name>next_vertex</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>vertex_entry</name> <modifier>*</modifier></type><name>value</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>graphid</name></type> <name>vertex_id</name></decl>;</decl_stmt>

        <comment type="block">/* get the next vertex in the list, if any */</comment>
        <expr_stmt><expr><name>next_vertex</name> <operator>=</operator> <call><name>next_GraphIdNode</name><argument_list>(<argument><expr><name>curr_vertex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* get the current vertex id */</comment>
        <expr_stmt><expr><name>vertex_id</name> <operator>=</operator> <call><name>get_graphid</name><argument_list>(<argument><expr><name>curr_vertex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* retrieve the vertex entry */</comment>
        <expr_stmt><expr><name>value</name> <operator>=</operator> <operator>(</operator><name>vertex_entry</name> <operator>*</operator><operator>)</operator><call><name>hash_search</name><argument_list>(<argument><expr><name><name>ggctx</name><operator>-&gt;</operator><name>vertex_hashtable</name></name></expr></argument>,
                                            <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>vertex_id</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>,
                                            <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* this is bad if it isn't found */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* free the edge list associated with this vertex */</comment>
        <expr_stmt><expr><call><name>free_ListGraphId</name><argument_list>(<argument><expr><name><name>value</name><operator>-&gt;</operator><name>edges_in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free_ListGraphId</name><argument_list>(<argument><expr><name><name>value</name><operator>-&gt;</operator><name>edges_out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free_ListGraphId</name><argument_list>(<argument><expr><name><name>value</name><operator>-&gt;</operator><name>edges_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>value</name><operator>-&gt;</operator><name>edges_in</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>value</name><operator>-&gt;</operator><name>edges_out</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>value</name><operator>-&gt;</operator><name>edges_self</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

        <comment type="block">/* move to the next vertex */</comment>
        <expr_stmt><expr><name>curr_vertex</name> <operator>=</operator> <name>next_vertex</name></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/* free the vertices list */</comment>
    <expr_stmt><expr><call><name>free_ListGraphId</name><argument_list>(<argument><expr><name><name>ggctx</name><operator>-&gt;</operator><name>vertices</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ggctx</name><operator>-&gt;</operator><name>vertices</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/* free the hashtables */</comment>
    <expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name><name>ggctx</name><operator>-&gt;</operator><name>vertex_hashtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name><name>ggctx</name><operator>-&gt;</operator><name>edge_hashtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>ggctx</name><operator>-&gt;</operator><name>vertex_hashtable</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ggctx</name><operator>-&gt;</operator><name>edge_hashtable</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/* free the context */</comment>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>ggctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ggctx</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Helper function to manage the GRAPH global contexts. It will create the
 * context for the graph specified, provided it isn't already built and valid.
 * During processing it will free (delete) all invalid GRAPH contexts. It
 * returns the GRAPH global context for the specified graph.
 */</comment>
<function><type><name>GRAPH_global_context</name> <modifier>*</modifier></type><name>manage_GRAPH_global_contexts</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>graph_name</name></decl></parameter>,
                                                   <parameter><decl><type><name>Oid</name></type> <name>graph_oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GRAPH_global_context</name> <modifier>*</modifier></type><name>new_ggctx</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GRAPH_global_context</name> <modifier>*</modifier></type><name>curr_ggctx</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GRAPH_global_context</name> <modifier>*</modifier></type><name>prev_ggctx</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldctx</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* we need a higher context, or one that isn't destroyed by SRF exit */</comment>
    <expr_stmt><expr><name>oldctx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We need to see if any GRAPH global contexts already exist and if any do
     * for this particular graph. There are 5 possibilities -
     *
     *     1) There are no global contexts.
     *     2) One does exist for this graph but, is invalid.
     *     3) One does exist for this graph and is valid.
     *     4) One or more other contexts do exist and all are valid.
     *     5) One or more other contexts do exist but, one or more are invalid.
     */</comment>

    <comment type="block">/* free the invalidated GRAPH global contexts first */</comment>
    <expr_stmt><expr><name>prev_ggctx</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>curr_ggctx</name> <operator>=</operator> <name>global_graph_contexts</name></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>curr_ggctx</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>GRAPH_global_context</name> <modifier>*</modifier></type><name>next_ggctx</name> <init>= <expr><name><name>curr_ggctx</name><operator>-&gt;</operator><name>next</name></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* if the transaction ids have changed, we have an invalid graph */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>is_ggctx_invalid</name><argument_list>(<argument><expr><name>curr_ggctx</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * If prev_ggctx is NULL then we are freeing the top of the
             * contexts. So, we need to point the global variable to the
             * new (next) top context, if there is one.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>prev_ggctx</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>global_graph_contexts</name> <operator>=</operator> <name>next_ggctx</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name><name>prev_ggctx</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>curr_ggctx</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <comment type="block">/* free the current graph context */</comment>
            <expr_stmt><expr><call><name>free_specific_GRAPH_global_context</name><argument_list>(<argument><expr><name>curr_ggctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>prev_ggctx</name> <operator>=</operator> <name>curr_ggctx</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* advance to the next context */</comment>
        <expr_stmt><expr><name>curr_ggctx</name> <operator>=</operator> <name>next_ggctx</name></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/* find our graph's context. if it exists, we are done */</comment>
    <expr_stmt><expr><name>curr_ggctx</name> <operator>=</operator> <name>global_graph_contexts</name></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>curr_ggctx</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>curr_ggctx</name><operator>-&gt;</operator><name>graph_oid</name></name> <operator>==</operator> <name>graph_oid</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* switch our context back */</comment>
            <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* we are done */</comment>
            <return>return <expr><name>curr_ggctx</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>curr_ggctx</name> <operator>=</operator> <name><name>curr_ggctx</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/* otherwise, we need to create one and possibly attach it */</comment>
    <expr_stmt><expr><name>new_ggctx</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GRAPH_global_context</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>global_graph_contexts</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>new_ggctx</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>global_graph_contexts</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>new_ggctx</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* set the global context variable */</comment>
    <expr_stmt><expr><name>global_graph_contexts</name> <operator>=</operator> <name>new_ggctx</name></expr>;</expr_stmt>

    <comment type="block">/* set the graph name and oid */</comment>
    <expr_stmt><expr><name><name>new_ggctx</name><operator>-&gt;</operator><name>graph_name</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>graph_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new_ggctx</name><operator>-&gt;</operator><name>graph_oid</name></name> <operator>=</operator> <name>graph_oid</name></expr>;</expr_stmt>

    <comment type="block">/* set the transaction ids */</comment>
    <expr_stmt><expr><name><name>new_ggctx</name><operator>-&gt;</operator><name>xmin</name></name> <operator>=</operator> <call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>xmin</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new_ggctx</name><operator>-&gt;</operator><name>xmax</name></name> <operator>=</operator> <call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>xmax</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new_ggctx</name><operator>-&gt;</operator><name>curcid</name></name> <operator>=</operator> <call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>curcid</name></expr>;</expr_stmt>

    <comment type="block">/* initialize our vertices list */</comment>
    <expr_stmt><expr><name><name>new_ggctx</name><operator>-&gt;</operator><name>vertices</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/* build the hashtables for this graph */</comment>
    <expr_stmt><expr><call><name>create_GRAPH_global_hashtables</name><argument_list>(<argument><expr><name>new_ggctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>load_GRAPH_global_hashtables</name><argument_list>(<argument><expr><name>new_ggctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>freeze_GRAPH_global_hashtables</name><argument_list>(<argument><expr><name>new_ggctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* switch back to the previous memory context */</comment>
    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>new_ggctx</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Helper function to delete all of the global graph contexts used by the
 * process. When done the global global_graph_contexts will be NULL.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>delete_GRAPH_global_contexts</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GRAPH_global_context</name> <modifier>*</modifier></type><name>curr_ggctx</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>retval</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* get the first context, if any */</comment>
    <expr_stmt><expr><name>curr_ggctx</name> <operator>=</operator> <name>global_graph_contexts</name></expr>;</expr_stmt>

    <comment type="block">/* free all GRAPH global contexts */</comment>
    <while>while <condition>(<expr><name>curr_ggctx</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>GRAPH_global_context</name> <modifier>*</modifier></type><name>next_ggctx</name> <init>= <expr><name><name>curr_ggctx</name><operator>-&gt;</operator><name>next</name></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* free the current graph context */</comment>
        <expr_stmt><expr><call><name>free_specific_GRAPH_global_context</name><argument_list>(<argument><expr><name>curr_ggctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* advance to the next context */</comment>
        <expr_stmt><expr><name>curr_ggctx</name> <operator>=</operator> <name>next_ggctx</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>retval</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/* clear the global variable */</comment>
    <expr_stmt><expr><name>global_graph_contexts</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Helper function to delete a specific global graph context used by the
 * process.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>delete_specific_GRAPH_global_contexts</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>graph_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GRAPH_global_context</name> <modifier>*</modifier></type><name>prev_ggctx</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GRAPH_global_context</name> <modifier>*</modifier></type><name>curr_ggctx</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type> <name>graph_oid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>graph_name</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* get the graph oid */</comment>
    <expr_stmt><expr><name>graph_oid</name> <operator>=</operator> <call><name>get_graph_oid</name><argument_list>(<argument><expr><name>graph_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* get the first context, if any */</comment>
    <expr_stmt><expr><name>curr_ggctx</name> <operator>=</operator> <name>global_graph_contexts</name></expr>;</expr_stmt>

    <comment type="block">/* find the specified GRAPH global context */</comment>
    <while>while <condition>(<expr><name>curr_ggctx</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>GRAPH_global_context</name> <modifier>*</modifier></type><name>next_ggctx</name> <init>= <expr><name><name>curr_ggctx</name><operator>-&gt;</operator><name>next</name></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>curr_ggctx</name><operator>-&gt;</operator><name>graph_oid</name></name> <operator>==</operator> <name>graph_oid</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * If prev_ggctx is NULL then we are freeing the top of the
             * contexts. So, we need to point the global variable to the
             * new (next) top context, if there is one.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>prev_ggctx</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>global_graph_contexts</name> <operator>=</operator> <name>next_ggctx</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name><name>prev_ggctx</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>curr_ggctx</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <comment type="block">/* free the current graph context */</comment>
            <expr_stmt><expr><call><name>free_specific_GRAPH_global_context</name><argument_list>(<argument><expr><name>curr_ggctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* we found and freed it, return true */</comment>
            <return>return <expr><name>true</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* save the current as previous and advance to the next one */</comment>
        <expr_stmt><expr><name>prev_ggctx</name> <operator>=</operator> <name>curr_ggctx</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>curr_ggctx</name> <operator>=</operator> <name>next_ggctx</name></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/* we didn't find it, return false */</comment>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Helper function to retrieve a vertex_entry from the graph's vertex hash
 * table. If there isn't one, it returns a NULL. The latter is necessary for
 * checking if the vsid and veid entries exist.
 */</comment>
<function><type><name>vertex_entry</name> <modifier>*</modifier></type><name>get_vertex_entry</name><parameter_list>(<parameter><decl><type><name>GRAPH_global_context</name> <modifier>*</modifier></type><name>ggctx</name></decl></parameter>, <parameter><decl><type><name>graphid</name></type> <name>vertex_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>vertex_entry</name> <modifier>*</modifier></type><name>ve</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* retrieve the current vertex entry */</comment>
    <expr_stmt><expr><name>ve</name> <operator>=</operator> <operator>(</operator><name>vertex_entry</name> <operator>*</operator><operator>)</operator><call><name>hash_search</name><argument_list>(<argument><expr><name><name>ggctx</name><operator>-&gt;</operator><name>vertex_hashtable</name></name></expr></argument>,
                                     <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>vertex_id</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ve</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* helper function to retrieve an edge_entry from the graph's edge hash table */</comment>
<function><type><name>edge_entry</name> <modifier>*</modifier></type><name>get_edge_entry</name><parameter_list>(<parameter><decl><type><name>GRAPH_global_context</name> <modifier>*</modifier></type><name>ggctx</name></decl></parameter>, <parameter><decl><type><name>graphid</name></type> <name>edge_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>edge_entry</name> <modifier>*</modifier></type><name>ee</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* retrieve the current edge entry */</comment>
    <expr_stmt><expr><name>ee</name> <operator>=</operator> <operator>(</operator><name>edge_entry</name> <operator>*</operator><operator>)</operator><call><name>hash_search</name><argument_list>(<argument><expr><name><name>ggctx</name><operator>-&gt;</operator><name>edge_hashtable</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>edge_id</name></expr></argument>,
                                   <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* it should be found, otherwise we have problems */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>ee</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Helper function to find the GRAPH_global_context used by the specified
 * graph_oid. If not found, it returns NULL.
 */</comment>
<function><type><name>GRAPH_global_context</name> <modifier>*</modifier></type><name>find_GRAPH_global_context</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>graph_oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GRAPH_global_context</name> <modifier>*</modifier></type><name>ggctx</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* get the root */</comment>
    <expr_stmt><expr><name>ggctx</name> <operator>=</operator> <name>global_graph_contexts</name></expr>;</expr_stmt>

    <while>while<condition>(<expr><name>ggctx</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* if we found it return it */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>ggctx</name><operator>-&gt;</operator><name>graph_oid</name></name> <operator>==</operator> <name>graph_oid</name></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><name>ggctx</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* advance to the next context */</comment>
        <expr_stmt><expr><name>ggctx</name> <operator>=</operator> <name><name>ggctx</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/* we did not find it so return NULL */</comment>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* graph vertices accessor */</comment>
<function><type><name>ListGraphId</name> <modifier>*</modifier></type><name>get_graph_vertices</name><parameter_list>(<parameter><decl><type><name>GRAPH_global_context</name> <modifier>*</modifier></type><name>ggctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name><name>ggctx</name><operator>-&gt;</operator><name>vertices</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* vertex_entry accessor functions */</comment>
<function><type><name>graphid</name></type> <name>get_vertex_entry_id</name><parameter_list>(<parameter><decl><type><name>vertex_entry</name> <modifier>*</modifier></type><name>ve</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name><name>ve</name><operator>-&gt;</operator><name>vertex_id</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>ListGraphId</name> <modifier>*</modifier></type><name>get_vertex_entry_edges_in</name><parameter_list>(<parameter><decl><type><name>vertex_entry</name> <modifier>*</modifier></type><name>ve</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name><name>ve</name><operator>-&gt;</operator><name>edges_in</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>ListGraphId</name> <modifier>*</modifier></type><name>get_vertex_entry_edges_out</name><parameter_list>(<parameter><decl><type><name>vertex_entry</name> <modifier>*</modifier></type><name>ve</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name><name>ve</name><operator>-&gt;</operator><name>edges_out</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>ListGraphId</name> <modifier>*</modifier></type><name>get_vertex_entry_edges_self</name><parameter_list>(<parameter><decl><type><name>vertex_entry</name> <modifier>*</modifier></type><name>ve</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name><name>ve</name><operator>-&gt;</operator><name>edges_self</name></name></expr>;</return>
</block_content>}</block></function>


<function><type><name>Oid</name></type> <name>get_vertex_entry_label_table_oid</name><parameter_list>(<parameter><decl><type><name>vertex_entry</name> <modifier>*</modifier></type><name>ve</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name><name>ve</name><operator>-&gt;</operator><name>vertex_label_table_oid</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type> <name>get_vertex_entry_properties</name><parameter_list>(<parameter><decl><type><name>vertex_entry</name> <modifier>*</modifier></type><name>ve</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name><name>ve</name><operator>-&gt;</operator><name>vertex_properties</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* edge_entry accessor functions */</comment>
<function><type><name>graphid</name></type> <name>get_edge_entry_id</name><parameter_list>(<parameter><decl><type><name>edge_entry</name> <modifier>*</modifier></type><name>ee</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name><name>ee</name><operator>-&gt;</operator><name>edge_id</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Oid</name></type> <name>get_edge_entry_label_table_oid</name><parameter_list>(<parameter><decl><type><name>edge_entry</name> <modifier>*</modifier></type><name>ee</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name><name>ee</name><operator>-&gt;</operator><name>edge_label_table_oid</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type> <name>get_edge_entry_properties</name><parameter_list>(<parameter><decl><type><name>edge_entry</name> <modifier>*</modifier></type><name>ee</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name><name>ee</name><operator>-&gt;</operator><name>edge_properties</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>graphid</name></type> <name>get_edge_entry_start_vertex_id</name><parameter_list>(<parameter><decl><type><name>edge_entry</name> <modifier>*</modifier></type><name>ee</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name><name>ee</name><operator>-&gt;</operator><name>start_vertex_id</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>graphid</name></type> <name>get_edge_entry_end_vertex_id</name><parameter_list>(<parameter><decl><type><name>edge_entry</name> <modifier>*</modifier></type><name>ee</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name><name>ee</name><operator>-&gt;</operator><name>end_vertex_id</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* PostgreSQL SQL facing functions */</comment>

<comment type="block">/* PG wrapper function for age_delete_global_graphs */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_delete_global_graphs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_delete_global_graphs</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_temp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>success</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* get the graph name if supplied */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>agtv_temp</name> <operator>=</operator> <call><name>get_agtype_value</name><argument_list>(<argument><expr><literal type="string">"delete_global_graphs"</literal></expr></argument>,
                                     <argument><expr><call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
                                     <argument><expr><name>AGTV_STRING</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>agtv_temp</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>agtv_temp</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>delete_GRAPH_global_contexts</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>agtv_temp</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_STRING</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>graph_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>graph_name</name> <operator>=</operator> <name><name>agtv_temp</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>delete_specific_GRAPH_global_contexts</name><argument_list>(<argument><expr><name>graph_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"delete_global_graphs: invalid graph name type"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>success</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* PG wrapper function for age_vertex_degree */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_vertex_stats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_vertex_stats</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GRAPH_global_context</name> <modifier>*</modifier></type><name>ggctx</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>vertex_entry</name> <modifier>*</modifier></type><name>ve</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListGraphId</name> <modifier>*</modifier></type><name>edges</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_vertex</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_temp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>agtv_integer</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_in_state</name></type> <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>graph_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type> <name>graph_oid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>graphid</name></type> <name>vid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type> <name>self_loops</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type> <name>degree</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* the graph name is required, but this generally isn't user supplied */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"vertex_stats: graph name cannot be NULL"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* get the graph name */</comment>
    <expr_stmt><expr><name>agtv_temp</name> <operator>=</operator> <call><name>get_agtype_value</name><argument_list>(<argument><expr><literal type="string">"vertex_stats"</literal></expr></argument>, <argument><expr><call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><name>AGTV_STRING</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* we need the vertex */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"vertex_stats: vertex cannot be NULL"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* get the vertex */</comment>
    <expr_stmt><expr><name>agtv_vertex</name> <operator>=</operator> <call><name>get_agtype_value</name><argument_list>(<argument><expr><literal type="string">"vertex_stats"</literal></expr></argument>, <argument><expr><call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><name>AGTV_VERTEX</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>graph_name</name> <operator>=</operator> <call><name>pnstrdup</name><argument_list>(<argument><expr><name><name>agtv_temp</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>,
                          <argument><expr><name><name>agtv_temp</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* get the graph oid */</comment>
    <expr_stmt><expr><name>graph_oid</name> <operator>=</operator> <call><name>get_graph_oid</name><argument_list>(<argument><expr><name>graph_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Create or retrieve the GRAPH global context for this graph. This function
     * will also purge off invalidated contexts.
     */</comment>
    <expr_stmt><expr><name>ggctx</name> <operator>=</operator> <call><name>manage_GRAPH_global_contexts</name><argument_list>(<argument><expr><name>graph_name</name></expr></argument>, <argument><expr><name>graph_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* free the graph name */</comment>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>graph_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* get the id */</comment>
    <expr_stmt><expr><name>agtv_temp</name> <operator>=</operator> <call><name>GET_AGTYPE_VALUE_OBJECT_VALUE</name><argument_list>(<argument><expr><name>agtv_vertex</name></expr></argument>, <argument><expr><literal type="string">"id"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>vid</name> <operator>=</operator> <name><name>agtv_temp</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>int_value</name></name></expr>;</expr_stmt>

    <comment type="block">/* get the vertex entry */</comment>
    <expr_stmt><expr><name>ve</name> <operator>=</operator> <call><name>get_vertex_entry</name><argument_list>(<argument><expr><name>ggctx</name></expr></argument>, <argument><expr><name>vid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* zero the state */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>agtype_in_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* start the object */</comment>
    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_BEGIN_OBJECT</name></expr></argument>,
                                   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* store the id */</comment>
    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_KEY</name></expr></argument>,
                                   <argument><expr><call><name>string_to_agtype_value</name><argument_list>(<argument><expr><literal type="string">"id"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_VALUE</name></expr></argument>, <argument><expr><name>agtv_temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* store the label */</comment>
    <expr_stmt><expr><name>agtv_temp</name> <operator>=</operator> <call><name>GET_AGTYPE_VALUE_OBJECT_VALUE</name><argument_list>(<argument><expr><name>agtv_vertex</name></expr></argument>, <argument><expr><literal type="string">"label"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_KEY</name></expr></argument>,
                                   <argument><expr><call><name>string_to_agtype_value</name><argument_list>(<argument><expr><literal type="string">"label"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_VALUE</name></expr></argument>, <argument><expr><name>agtv_temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* set up an integer for returning values */</comment>
    <expr_stmt><expr><name>agtv_temp</name> <operator>=</operator> <operator>&amp;</operator><name>agtv_integer</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_temp</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>AGTV_INTEGER</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_temp</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>int_value</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/* get and store the self_loops */</comment>
    <expr_stmt><expr><name>edges</name> <operator>=</operator> <call><name>get_vertex_entry_edges_self</name><argument_list>(<argument><expr><name>ve</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>self_loops</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>edges</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>get_list_size</name><argument_list>(<argument><expr><name>edges</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_temp</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>int_value</name></name> <operator>=</operator> <name>self_loops</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_KEY</name></expr></argument>,
                                   <argument><expr><call><name>string_to_agtype_value</name><argument_list>(<argument><expr><literal type="string">"self_loops"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_VALUE</name></expr></argument>, <argument><expr><name>agtv_temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* get and store the in_degree */</comment>
    <expr_stmt><expr><name>edges</name> <operator>=</operator> <call><name>get_vertex_entry_edges_in</name><argument_list>(<argument><expr><name>ve</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>degree</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>edges</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>get_list_size</name><argument_list>(<argument><expr><name>edges</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_temp</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>int_value</name></name> <operator>=</operator> <name>degree</name> <operator>+</operator> <name>self_loops</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_KEY</name></expr></argument>,
                                   <argument><expr><call><name>string_to_agtype_value</name><argument_list>(<argument><expr><literal type="string">"in_degree"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_VALUE</name></expr></argument>, <argument><expr><name>agtv_temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* get and store the out_degree */</comment>
    <expr_stmt><expr><name>edges</name> <operator>=</operator> <call><name>get_vertex_entry_edges_out</name><argument_list>(<argument><expr><name>ve</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>degree</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>edges</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>get_list_size</name><argument_list>(<argument><expr><name>edges</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_temp</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>int_value</name></name> <operator>=</operator> <name>degree</name> <operator>+</operator> <name>self_loops</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_KEY</name></expr></argument>,
                                   <argument><expr><call><name>string_to_agtype_value</name><argument_list>(<argument><expr><literal type="string">"out_degree"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_VALUE</name></expr></argument>, <argument><expr><name>agtv_temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* close the object */</comment>
    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_END_OBJECT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>AGTV_OBJECT</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><name><name>result</name><operator>.</operator><name>res</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
